# Tasks Overview - Hiragana/Katakana Learning Application
# Generated from hiragana_learning_research2.md
# Strategic roadmap for project implementation

# =============================================================================
# PHASE 1: MVP (Foundation)
# =============================================================================

task:
  id: 1
  name: "Basic Application Structure and Character Data Management"

  overview:
    purpose: |
      Establish the foundational application structure using iced's Elm architecture,
      implement character data loading and management, and set up the core state
      management system. This task creates the skeleton upon which all other features
      will be built, ensuring a solid architectural foundation.

    motivation: |
      Without proper application structure and data management, the app cannot function.
      This foundational work enables all subsequent features by providing the core
      infrastructure for character data access, state transitions, and UI rendering.
      A well-structured foundation prevents architectural debt and enables rapid
      feature development.

    outcome: |
      Application launches successfully with a main menu, character data (hiragana)
      is loaded and accessible through efficient lookup structures, and the Elm
      architecture properly manages state transitions and UI updates.

  scope_summary:
    description: "Creates main app structure, implements character data models and loading, sets up state management"
    files_affected: 8
    functions_added: 15
    tests_required: 5
    complexity: "moderate"
    estimated_effort: "2-3 days"

  key_components:
    - component: "AppState"
      type: "struct"
      purpose: "Central application state following Elm architecture"

    - component: "CharData"
      type: "struct"
      purpose: "Character data model with stroke information"

    - component: "Message"
      type: "enum"
      purpose: "Application-wide message types for state updates"

    - component: "HIRAGANA static map"
      type: "static"
      purpose: "Compile-time character data lookup for zero-cost access"

    - component: "Screen navigation"
      type: "enum"
      purpose: "Manages different application screens"

  implementation_hints:
    approach: |
      Use iced's Application trait as the core structure. Implement static character
      data using phf crate for compile-time perfect hash maps, enabling zero-cost
      lookups. Follow the Elm architecture pattern strictly: State → View → Message → Update.
      Load hiragana data from RON files at compile time using include_str!().

    key_considerations:
      - "Use Arc<RwLock<T>> only for shared progress data, keep UI state owned"
      - "Character data should be immutable and static for performance"
      - "Message passing must be non-blocking to maintain UI responsiveness"
      - "RON format provides human-readable data files that are easy to maintain"

    integration_points:
      - "Main entry point integrates with iced runtime"
      - "Character data integrates with all learning modules"
      - "State management integrates with persistence layer"

  testing_overview:
    strategy: "unit"

    rationale: |
      Unit tests are appropriate for foundational data structures and state
      management logic. Each component can be tested in isolation to verify
      correct behavior before integration.

    critical_properties:
      - "All 46 hiragana characters load successfully"
      - "Character lookups return correct data"
      - "State transitions follow Elm architecture contracts"

    verification_needs:
      formal_verification: false
      property_testing: false
      concurrency_testing: false
      integration_testing: false

    estimated_test_count: 5

  dependencies:
    requires_completion_of: []

    enables_start_of:
      - task_id: 2
        reason: "Flashcard display requires character data structures"
      - task_id: 3
        reason: "SRS requires application state infrastructure"
      - task_id: 5
        reason: "Persistence requires state models"

    parallel_with: []

  acceptance_criteria:
    - "Application launches without errors"
    - "Main menu displays with navigation options"
    - "All 46 hiragana characters load from data files"
    - "Character data lookups complete in O(1) time"
    - "State updates trigger proper UI re-renders"

  risk_assessment:
    complexity_risk: "low"
    integration_risk: "low"
    testing_risk: "low"

    concerns:
      - "RON parsing errors must be caught at compile time"

  notes:
    - "Start with hiragana only; katakana follows same pattern in Task 7"
    - "Stroke data will be used in Task 4 for animations"

# =============================================================================

task:
  id: 2
  name: "Japanese Text Rendering and Flashcard Display"

  overview:
    purpose: |
      Implement proper Japanese character rendering using cosmic-text with Unicode
      support, create a custom CharacterCard widget for flashcard-style display,
      and establish the visual foundation for all character learning interactions.

    motivation: |
      Japanese characters require special font handling and rendering considerations
      that standard text widgets don't provide. A custom widget enables proper
      typography, supports future stroke order overlays, and provides a consistent
      visual experience across all learning modes.

    outcome: |
      Japanese characters display correctly at large sizes with proper font rendering,
      the custom CharacterCard widget provides a reusable component for all character
      display needs, and users can view hiragana characters in a clear, readable format.

  scope_summary:
    description: "Implements Japanese font loading, creates CharacterCard widget, builds flashcard display screen"
    files_affected: 4
    functions_added: 8
    tests_required: 3
    complexity: "simple"
    estimated_effort: "1 day"

  key_components:
    - component: "CharacterCard"
      type: "struct"
      purpose: "Custom widget for displaying Japanese characters with proper typography"

    - component: "Font loading system"
      type: "function"
      purpose: "Loads Noto Sans JP font at application startup"

    - component: "Flashcard screen"
      type: "module"
      purpose: "Screen for displaying characters in flashcard format"

  implementation_hints:
    approach: |
      Use iced's built-in cosmic-text support with Shaping::Advanced for proper
      Japanese rendering. Embed Noto Sans JP font using include_bytes!() to avoid
      external font dependencies. Create CharacterCard as a reusable Element that
      can be configured for different display modes.

    key_considerations:
      - "Must use Shaping::Advanced for proper Japanese glyph rendering"
      - "Font should be embedded in binary for portability"
      - "Character size should scale based on available space"
      - "Support optional stroke order guide overlay for future use"

    integration_points:
      - "Integrates with character data from Task 1"
      - "Provides foundation for learning session in Task 3"
      - "Will be extended with stroke overlays in Task 4"

  testing_overview:
    strategy: "unit"

    rationale: |
      Widget rendering can be tested through snapshot tests and property tests
      that verify proper layout and sizing behavior.

    critical_properties:
      - "Japanese characters render without garbled glyphs"
      - "Character remains centered and properly sized"
      - "Font loads successfully on all platforms"

    verification_needs:
      formal_verification: false
      property_testing: true
      concurrency_testing: false
      integration_testing: false

    estimated_test_count: 3

  dependencies:
    requires_completion_of:
      - task_id: 1
        reason: "Needs character data structures and app infrastructure"

    enables_start_of:
      - task_id: 3
        reason: "Learning session needs flashcard display"
      - task_id: 4
        reason: "Stroke animation builds on character display"

    parallel_with: []

  acceptance_criteria:
    - "Noto Sans JP font loads without errors"
    - "Hiragana characters display correctly at 48-72px sizes"
    - "CharacterCard widget renders centered with proper spacing"
    - "No garbled or missing glyphs in Japanese text"

  risk_assessment:
    complexity_risk: "low"
    integration_risk: "low"
    testing_risk: "low"

    concerns: []

  notes:
    - "Consider Source Han Sans as alternative font"
    - "Keep widget flexible for future enhancements (stroke order, hints)"

# =============================================================================

task:
  id: 3
  name: "SM-2 Spaced Repetition System and Learning Session"

  overview:
    purpose: |
      Implement the SM-2 spaced repetition algorithm for optimal learning scheduling,
      create a review queue management system, and build the core learning session
      flow that presents characters to users based on their individual progress.

    motivation: |
      Spaced repetition is scientifically proven to be the most effective method for
      long-term retention. The SM-2 algorithm provides an excellent balance of
      simplicity and effectiveness for MVP, while the queue system ensures users
      always practice the right characters at the right time.

    outcome: |
      Users receive character reviews at scientifically optimized intervals, the
      system tracks individual card performance and adjusts scheduling accordingly,
      and learning sessions present a balanced mix of new, learning, and review cards.

  scope_summary:
    description: "Implements SM-2 algorithm, review queue, learning session flow, and progress tracking"
    files_affected: 5
    functions_added: 20
    tests_required: 12
    complexity: "complex"
    estimated_effort: "2-3 days"

  key_components:
    - component: "SM2Card"
      type: "struct"
      purpose: "Tracks individual character progress with ease factor and intervals"

    - component: "ReviewQueue"
      type: "struct"
      purpose: "Manages prioritization of new, learning, and review cards"

    - component: "LearningSession"
      type: "struct"
      purpose: "Orchestrates the learning flow and session state"

    - component: "review method"
      type: "function"
      purpose: "Core SM-2 algorithm implementation"

    - component: "get_next_card method"
      type: "function"
      purpose: "Queue management with proper prioritization"

  implementation_hints:
    approach: |
      Implement SM-2 algorithm exactly as specified in SuperMemo paper. Use
      priority-based queue management: learning cards (interval < 1 day) first,
      then review cards (due), then new cards (within daily limit). Track all
      reviews for future algorithm optimization.

    key_considerations:
      - "Quality ratings 0-5 must map correctly to ease factor calculations"
      - "Failed cards (quality < 3) must reset to learning state"
      - "Queue prioritization critical for effective learning flow"
      - "Session history enables future FSRS migration"
      - "Daily limits prevent cognitive overload"

    integration_points:
      - "Integrates with character data from Task 1"
      - "Uses flashcard display from Task 2"
      - "Requires persistence layer from Task 5"
      - "Provides review data for statistics in Task 6"

  testing_overview:
    strategy: "mixed"

    rationale: |
      Unit tests verify algorithm correctness, property tests ensure mathematical
      invariants hold, and integration tests validate complete session flows.

    critical_properties:
      - "Ease factor never drops below 1.3"
      - "Failed cards always reset to interval 1"
      - "Queue priority order maintained: learning > review > new"
      - "Interval calculations match SM-2 specification"

    verification_needs:
      formal_verification: false
      property_testing: true
      concurrency_testing: false
      integration_testing: true

    estimated_test_count: 12

  dependencies:
    requires_completion_of:
      - task_id: 1
        reason: "Needs character data and app state infrastructure"
      - task_id: 2
        reason: "Learning session requires flashcard display"

    enables_start_of:
      - task_id: 5
        reason: "Progress persistence needs review data structures"
      - task_id: 6
        reason: "Statistics require review history"

    parallel_with: []

  acceptance_criteria:
    - "SM-2 algorithm produces correct intervals for all quality ratings"
    - "Queue correctly prioritizes learning > review > new cards"
    - "Learning sessions complete without state inconsistencies"
    - "Daily new card limits enforced"
    - "Review history accurately recorded"
    - "Failed cards reset to learning state"

  risk_assessment:
    complexity_risk: "medium"
    integration_risk: "medium"
    testing_risk: "low"

    concerns:
      - "Algorithm edge cases need thorough testing (quality 0, 5, failures)"
      - "Queue management complexity increases with card count"

  notes:
    - "Keep review logs for future FSRS migration (Task 12)"
    - "Default to 20 new cards/day, 200 reviews/day limits"

# =============================================================================
# PHASE 2: Core Features
# =============================================================================

task:
  id: 4
  name: "Stroke Order Animation System"

  overview:
    purpose: |
      Create a GPU-accelerated stroke order animation system using iced's Canvas
      and Animation APIs, implementing sequential stroke rendering with partial
      path animation, and integrating SVG stroke data from character definitions.

    motivation: |
      Stroke order is fundamental to properly writing Japanese characters. Visual
      animations provide an intuitive, memorable way to learn correct stroke
      sequences. GPU acceleration ensures smooth 60fps animations even with
      complex paths, creating a professional learning experience.

    outcome: |
      Users can watch smooth, sequenced animations showing correct stroke order
      for any character, animations can be paused/replayed, and the visual feedback
      helps build muscle memory for handwriting practice.

  scope_summary:
    description: "Implements Canvas-based animation, SVG path parsing, sequential stroke rendering"
    files_affected: 4
    functions_added: 15
    tests_required: 6
    complexity: "complex"
    estimated_effort: "3-4 days"

  key_components:
    - component: "StrokeOrderAnimation"
      type: "struct"
      purpose: "Manages animation state and timing for stroke sequences"

    - component: "StrokePath"
      type: "struct"
      purpose: "Represents individual strokes with partial rendering support"

    - component: "Canvas Program implementation"
      type: "trait impl"
      purpose: "Renders animated strokes with GPU acceleration"

    - component: "SVG path parser"
      type: "function"
      purpose: "Converts SVG path data to lyon Path segments"

    - component: "partial_path method"
      type: "function"
      purpose: "Calculates partial stroke rendering based on animation progress"

  implementation_hints:
    approach: |
      Use iced's Canvas widget with lyon for path tessellation. Parse SVG paths
      from character data into lyon segments, calculating lengths for partial
      rendering. Animate using iced's Animation API with EaseOutCubic for natural
      writing feel. Sequence strokes with 200-300ms pauses between each.

    key_considerations:
      - "Must request redraw on every frame during animation"
      - "Partial path rendering requires accumulated length calculations"
      - "Stroke timing critical for natural appearance: 500-800ms per stroke"
      - "EaseOutCubic easing provides most natural writing motion"
      - "Cache static geometry to avoid re-tessellation"

    integration_points:
      - "Uses stroke data from CharData (Task 1)"
      - "Integrates into practice session screen"
      - "Provides visual reference for handwriting (Task 8)"

  testing_overview:
    strategy: "integration"

    rationale: |
      Animation behavior requires integration testing to verify timing,
      sequencing, and visual correctness. Manual verification needed for
      subjective animation quality.

    critical_properties:
      - "Strokes animate in correct sequence order"
      - "Partial paths render smoothly without gaps or jumps"
      - "Animation timing matches specified duration"
      - "Completed strokes remain visible during subsequent strokes"

    verification_needs:
      formal_verification: false
      property_testing: false
      concurrency_testing: false
      integration_testing: true

    estimated_test_count: 6

  dependencies:
    requires_completion_of:
      - task_id: 1
        reason: "Needs stroke data from character definitions"
      - task_id: 2
        reason: "Builds on character display foundation"

    enables_start_of:
      - task_id: 8
        reason: "Practice modes use animation as reference"

    parallel_with:
      - 5
      - 6

  acceptance_criteria:
    - "All hiragana characters animate smoothly at 60fps"
    - "Strokes appear in correct sequential order"
    - "Animation can be paused and resumed"
    - "Partial paths render without visual artifacts"
    - "Animation completes in expected time (500-800ms per stroke)"
    - "No performance degradation with complex characters"

  risk_assessment:
    complexity_risk: "high"
    integration_risk: "medium"
    testing_risk: "medium"

    concerns:
      - "SVG path parsing complexity varies by character data source"
      - "Partial path rendering calculations are mathematically complex"
      - "Animation timing synchronization can be tricky"

  notes:
    - "Consider using kana-svg-data or animCJK for stroke data"
    - "May need to normalize coordinates to canvas bounds"

# =============================================================================

task:
  id: 5
  name: "Progress Persistence and Database Integration"

  overview:
    purpose: |
      Implement local data persistence using redb for card progress, review logs,
      and user settings. Establish platform-specific data directories and create
      efficient serialization for all state that needs to persist across sessions.

    motivation: |
      Without persistence, users lose all progress when closing the application.
      Local storage ensures data privacy, offline functionality, and fast access.
      The redb embedded database provides ACID guarantees without requiring
      external database setup.

    outcome: |
      User progress automatically saves after each review, application state
      persists across restarts, all review history is preserved for analytics,
      and users can confidently close the app without losing data.

  scope_summary:
    description: "Implements redb database, serialization, auto-save, platform-specific paths"
    files_affected: 4
    functions_added: 12
    tests_required: 8
    complexity: "moderate"
    estimated_effort: "2 days"

  key_components:
    - component: "AppDatabase"
      type: "struct"
      purpose: "Database handle and transaction management"

    - component: "save_card_progress"
      type: "function"
      purpose: "Persists individual card state"

    - component: "load_card_progress"
      type: "function"
      purpose: "Retrieves saved card state"

    - component: "save_review_log"
      type: "function"
      purpose: "Logs completed reviews for analytics"

    - component: "Platform path resolver"
      type: "function"
      purpose: "Determines correct data directory per OS"

  implementation_hints:
    approach: |
      Use redb with bincode serialization for compact storage. Use the directories
      crate for cross-platform data paths. Batch writes in transactions for
      performance. Auto-save after each review but batch during sessions.
      Implement lazy loading for large datasets.

    key_considerations:
      - "Use transactions to batch multiple writes for performance"
      - "Bincode provides fast, compact serialization"
      - "Handle migration gracefully if data structures change"
      - "Platform-specific paths: Linux (~/.local/share), macOS (~/Library/Application Support)"
      - "Error handling critical: never lose user data"

    integration_points:
      - "Saves SM2Card data from Task 3"
      - "Loads data on app startup (Task 1)"
      - "Provides review logs for statistics (Task 6)"

  testing_overview:
    strategy: "integration"

    rationale: |
      Persistence requires integration tests that verify data survives across
      application restarts and database transactions complete correctly.

    critical_properties:
      - "Data written in transaction is retrievable after commit"
      - "No data loss on application crash (ACID guarantees)"
      - "Concurrent reads/writes handled correctly"
      - "Data directory creates successfully on all platforms"

    verification_needs:
      formal_verification: false
      property_testing: true
      concurrency_testing: true
      integration_testing: true

    estimated_test_count: 8

  dependencies:
    requires_completion_of:
      - task_id: 1
        reason: "Needs state models to persist"
      - task_id: 3
        reason: "SM2Card and review data structures required"

    enables_start_of:
      - task_id: 6
        reason: "Statistics require persistent review logs"

    parallel_with:
      - 4

  acceptance_criteria:
    - "Card progress saves automatically after each review"
    - "All data survives application restart"
    - "Database transactions complete without errors"
    - "Platform-specific paths work on Linux, macOS, Windows"
    - "Batch operations complete efficiently (< 50ms for 100 cards)"
    - "No data corruption on abnormal shutdown"

  risk_assessment:
    complexity_risk: "low"
    integration_risk: "medium"
    testing_risk: "medium"

    concerns:
      - "Schema migration strategy needed for future changes"
      - "Must handle corrupted database files gracefully"

  notes:
    - "Consider export/import functionality in Task 11"
    - "redb is pure Rust, no external dependencies"

# =============================================================================

task:
  id: 6
  name: "Statistics and Progress Tracking"

  overview:
    purpose: |
      Create comprehensive statistics tracking system including accuracy metrics,
      study time, streak tracking, and daily/weekly aggregations. Build a
      statistics screen to visualize progress and motivate continued learning.

    motivation: |
      Visible progress is a key motivator for learning. Statistics help users
      understand their improvement, identify weak areas, and maintain study
      habits. Streak tracking specifically drives daily engagement through
      gamification psychology.

    outcome: |
      Users can view detailed statistics on their learning progress, see accuracy
      trends over time, track study streaks, and feel motivated by visible
      improvement metrics.

  scope_summary:
    description: "Implements statistics models, aggregation logic, streak tracking, stats UI screen"
    files_affected: 4
    functions_added: 18
    tests_required: 10
    complexity: "moderate"
    estimated_effort: "2-3 days"

  key_components:
    - component: "Statistics"
      type: "struct"
      purpose: "Aggregated metrics: accuracy, time, streaks, progress"

    - component: "DayStats / WeekStats"
      type: "struct"
      purpose: "Time-series data for trend visualization"

    - component: "update_after_review"
      type: "function"
      purpose: "Incremental statistics updates"

    - component: "update_streak"
      type: "function"
      purpose: "Streak calculation and tracking"

    - component: "Statistics screen UI"
      type: "module"
      purpose: "Visual display of all metrics"

  implementation_hints:
    approach: |
      Use BTreeMap for time-series data to maintain chronological order. Update
      statistics incrementally after each review to avoid expensive recalculations.
      Persist statistics to database for historical trends. Use simple text-based
      displays for MVP; consider charts in future phases.

    key_considerations:
      - "Incremental updates more efficient than full recalculation"
      - "BTreeMap provides sorted dates for free"
      - "Streak calculation requires consecutive day checking"
      - "Separate mastered (interval > 21 days) from learning cards"
      - "Cache calculated values to avoid repeated computations"

    integration_points:
      - "Consumes review logs from Task 5"
      - "Updates after each review in Task 3"
      - "Displays in dedicated statistics screen"

  testing_overview:
    strategy: "unit"

    rationale: |
      Statistics calculations are pure functions that can be thoroughly tested
      with deterministic inputs and expected outputs.

    critical_properties:
      - "Accuracy rate always between 0.0 and 1.0"
      - "Streak increments only once per day"
      - "Longest streak never less than current streak"
      - "Total reviews equals sum of correct and incorrect"

    verification_needs:
      formal_verification: false
      property_testing: true
      concurrency_testing: false
      integration_testing: false

    estimated_test_count: 10

  dependencies:
    requires_completion_of:
      - task_id: 3
        reason: "Needs review data structures"
      - task_id: 5
        reason: "Requires persistent review logs"

    enables_start_of: []

    parallel_with:
      - 4
      - 7

  acceptance_criteria:
    - "Statistics update correctly after each review"
    - "Streak tracking handles multi-day gaps correctly"
    - "Daily and weekly aggregations calculate accurately"
    - "Statistics screen displays all key metrics"
    - "Historical data persists across sessions"

  risk_assessment:
    complexity_risk: "low"
    integration_risk: "low"
    testing_risk: "low"

    concerns: []

  notes:
    - "Consider adding charts in Phase 3"
    - "Export statistics for external analysis in Task 11"

# =============================================================================

task:
  id: 7
  name: "Katakana Character Set Integration"

  overview:
    purpose: |
      Extend the application to support katakana characters using the same
      infrastructure built for hiragana. Add character set selection to the UI
      and enable users to learn both Japanese syllabaries.

    motivation: |
      Katakana is essential for complete Japanese literacy, used for foreign
      loanwords, emphasis, and onomatopoeia. Since the infrastructure is already
      built for hiragana, adding katakana is straightforward and provides
      significant value to users.

    outcome: |
      Users can select katakana as a learning set, all features (flashcards,
      SRS, animations, practice) work with katakana characters, and the app
      supports learning both hiragana and katakana simultaneously or separately.

  scope_summary:
    description: "Adds katakana data, character set selection UI, extends all modules for dual support"
    files_affected: 6
    functions_added: 8
    tests_required: 4
    complexity: "simple"
    estimated_effort: "1 day"

  key_components:
    - component: "KATAKANA static map"
      type: "static"
      purpose: "Katakana character data lookup"

    - component: "CharacterSet enum"
      type: "enum"
      purpose: "Distinguishes hiragana vs katakana"

    - component: "Character set selector"
      type: "UI component"
      purpose: "Allows users to choose learning set"

  implementation_hints:
    approach: |
      Follow exact same pattern as hiragana. Create katakana.ron data file,
      add KATAKANA static map, extend get_char_data() to check both maps.
      Add CharacterSet enum to session state. Update UI to show set selector
      on main menu.

    key_considerations:
      - "Reuse all existing infrastructure; no algorithmic changes needed"
      - "Ensure stroke data quality matches hiragana"
      - "Consider combined learning mode (both sets)"
      - "Character set preference should persist in user settings"

    integration_points:
      - "Extends character data from Task 1"
      - "Works with all existing features (Tasks 2-6)"

  testing_overview:
    strategy: "unit"

    rationale: |
      Simple extension of existing tested infrastructure. Verify katakana data
      loads correctly and features work identically to hiragana.

    critical_properties:
      - "All 46 katakana characters load successfully"
      - "Features work identically for katakana and hiragana"

    verification_needs:
      formal_verification: false
      property_testing: false
      concurrency_testing: false
      integration_testing: false

    estimated_test_count: 4

  dependencies:
    requires_completion_of:
      - task_id: 1
        reason: "Reuses character data infrastructure"
      - task_id: 2
        reason: "Uses same rendering system"
      - task_id: 3
        reason: "SRS works identically for both sets"

    enables_start_of: []

    parallel_with:
      - 6

  acceptance_criteria:
    - "All 46 katakana characters load and display correctly"
    - "Users can select character set from menu"
    - "SRS, animations, and all features work with katakana"
    - "Character set preference persists across sessions"

  risk_assessment:
    complexity_risk: "low"
    integration_risk: "low"
    testing_risk: "low"

    concerns: []

  notes:
    - "Consider combined mode: learn matching pairs (あ/ア) together"
    - "Stroke order data available from same sources as hiragana"

# =============================================================================
# PHASE 3: Advanced Features
# =============================================================================

task:
  id: 8
  name: "Handwriting Practice Canvas and Stroke Capture"

  overview:
    purpose: |
      Implement an interactive drawing canvas for handwriting practice with stroke
      capture, real-time rendering, and stroke isolation. Enable users to practice
      writing characters by hand with immediate visual feedback.

    motivation: |
      Handwriting practice builds muscle memory and deeper character recognition
      than passive review alone. An interactive canvas makes practice engaging and
      provides the foundation for stroke order validation and character recognition.

    outcome: |
      Users can draw characters freehand on canvas, see their strokes rendered
      in real-time, clear and retry drawings, and have their handwriting captured
      for validation and recognition.

  scope_summary:
    description: "Implements drawing canvas, mouse/touch event handling, stroke capture, visual rendering"
    files_affected: 3
    functions_added: 12
    tests_required: 5
    complexity: "moderate"
    estimated_effort: "2 days"

  key_components:
    - component: "HandwritingCanvas"
      type: "struct"
      purpose: "Canvas program for drawing interaction"

    - component: "DrawingState"
      type: "struct"
      purpose: "Tracks strokes and current drawing"

    - component: "Stroke"
      type: "struct"
      purpose: "Individual stroke with points and timing"

    - component: "Mouse event handlers"
      type: "functions"
      purpose: "Capture drawing gestures"

  implementation_hints:
    approach: |
      Implement Canvas Program trait with mouse event handling. Track strokes as
      Vec<Point> with distance threshold to reduce noise. Use LineCap::Round and
      LineJoin::Round for natural pen feel. Store timing data for future analysis.
      Provide clear button to reset canvas.

    key_considerations:
      - "Distance threshold (2-3px) prevents excessive point density"
      - "Round line caps/joins create natural writing appearance"
      - "Separate completed strokes from current stroke for visual distinction"
      - "Timestamp each stroke for potential timing analysis"
      - "Touch events and mouse events handled identically"

    integration_points:
      - "Integrates with practice session screen"
      - "Provides stroke data for recognition (Task 9)"
      - "Works alongside animation reference (Task 4)"

  testing_overview:
    strategy: "integration"

    rationale: |
      Canvas interaction requires integration tests to verify event handling,
      stroke capture, and rendering work correctly together.

    critical_properties:
      - "Mouse down/move/up sequence captures stroke correctly"
      - "Points filtered by distance threshold"
      - "Strokes render smoothly without gaps"

    verification_needs:
      formal_verification: false
      property_testing: false
      concurrency_testing: false
      integration_testing: true

    estimated_test_count: 5

  dependencies:
    requires_completion_of:
      - task_id: 4
        reason: "Builds on Canvas expertise from animation"

    enables_start_of:
      - task_id: 9
        reason: "Stroke data needed for recognition"
      - task_id: 10
        reason: "Practice modes use drawing canvas"

    parallel_with: []

  acceptance_criteria:
    - "Drawing follows cursor/touch smoothly without lag"
    - "Strokes render with natural pen-like appearance"
    - "Multiple strokes can be drawn sequentially"
    - "Clear button resets canvas completely"
    - "Stroke data captured with accurate coordinates"

  risk_assessment:
    complexity_risk: "low"
    integration_risk: "low"
    testing_risk: "low"

    concerns: []

  notes:
    - "Consider pressure sensitivity for tablets in future"
    - "Touch support critical for mobile deployment"

# =============================================================================

task:
  id: 9
  name: "Character Recognition Integration"

  overview:
    purpose: |
      Integrate handwriting recognition to validate user-drawn characters,
      provide confidence scores, and enable automatic feedback on writing
      accuracy. Bridge the gap between practice and validation.

    motivation: |
      Automatic recognition enables self-paced learning without manual validation.
      Confidence scores help users understand how accurately they've written
      characters. Recognition validation reinforces correct writing habits.

    outcome: |
      The system automatically recognizes hand-drawn characters, provides top
      candidate matches with confidence scores, validates correctness against
      expected character, and gives immediate feedback on writing accuracy.

  scope_summary:
    description: "Integrates recognition library, normalizes stroke data, implements async recognition, validates results"
    files_affected: 3
    functions_added: 8
    tests_required: 6
    complexity: "complex"
    estimated_effort: "2-3 days"

  key_components:
    - component: "recognize_character"
      type: "async function"
      purpose: "Calls recognition engine with stroke data"

    - component: "normalize_strokes"
      type: "function"
      purpose: "Normalizes coordinates for recognition"

    - component: "validate_recognition"
      type: "function"
      purpose: "Checks if recognized character matches expected"

    - component: "RecognitionResult"
      type: "struct"
      purpose: "Recognition candidates with confidence scores"

  implementation_hints:
    approach: |
      Use hanzi_lookup crate for CJK recognition (works for kana). Normalize
      stroke coordinates to 0-1 range before recognition. Run recognition
      async to avoid blocking UI. Accept recognition if top candidate matches
      expected character with confidence > 0.7.

    key_considerations:
      - "Coordinate normalization critical for recognition accuracy"
      - "Async execution prevents UI blocking during recognition"
      - "Confidence threshold (0.7) balances accuracy and usability"
      - "Handle recognition failures gracefully"
      - "May need stroke order hints for low confidence"

    integration_points:
      - "Consumes stroke data from Task 8"
      - "Provides validation for practice modes (Task 10)"

  testing_overview:
    strategy: "integration"

    rationale: |
      Recognition requires integration tests with real character samples to
      verify accuracy and performance across different writing styles.

    critical_properties:
      - "Well-formed characters recognized with > 90% accuracy"
      - "Recognition completes within 500ms"
      - "Top candidate matches expected for clear input"

    verification_needs:
      formal_verification: false
      property_testing: false
      concurrency_testing: false
      integration_testing: true

    estimated_test_count: 6

  dependencies:
    requires_completion_of:
      - task_id: 8
        reason: "Needs stroke capture data"

    enables_start_of:
      - task_id: 10
        reason: "Practice modes use recognition for validation"

    parallel_with: []

  acceptance_criteria:
    - "Recognition returns top 3 candidates with confidence scores"
    - "Well-formed hiragana/katakana recognized with > 85% accuracy"
    - "Recognition completes in < 500ms for typical input"
    - "Invalid/ambiguous input handled without crashes"
    - "Async execution doesn't block UI responsiveness"

  risk_assessment:
    complexity_risk: "high"
    integration_risk: "high"
    testing_risk: "high"

    concerns:
      - "Recognition library may not work well with simplified kana"
      - "Accuracy depends heavily on writing style variations"
      - "May need fallback for low confidence results"

  notes:
    - "Consider hanzi_lookup or WASM bridge to Python libraries"
    - "Collect failed recognition examples for future training"

# =============================================================================

task:
  id: 10
  name: "Progressive Practice Modes"

  overview:
    purpose: |
      Implement four progressive practice modes (Watch, Trace With Guide,
      Trace Without Guide, Free Drawing) that gradually increase difficulty
      and build user skills from passive observation to active recall.

    motivation: |
      Progressive difficulty ensures users build solid foundations before
      advancing to harder challenges. The four-mode system provides scaffolded
      learning that matches educational best practices for skill acquisition.

    outcome: |
      Users progress through increasingly challenging practice modes, receive
      appropriate assistance at each level, build confidence through gradual
      difficulty increase, and achieve mastery through structured practice.

  scope_summary:
    description: "Implements 4 practice modes, mode progression logic, visual guides, practice session flow"
    files_affected: 4
    functions_added: 15
    tests_required: 8
    complexity: "complex"
    estimated_effort: "3 days"

  key_components:
    - component: "PracticeMode enum"
      type: "enum"
      purpose: "Four progressive difficulty levels"

    - component: "PracticeSession"
      type: "struct"
      purpose: "Manages practice flow and mode transitions"

    - component: "Ghost overlay rendering"
      type: "function"
      purpose: "Shows reference character in trace modes"

    - component: "Stroke order hints"
      type: "function"
      purpose: "Displays numbered stroke guides"

    - component: "Mode progression logic"
      type: "function"
      purpose: "Advances user through modes based on success"

  implementation_hints:
    approach: |
      Each mode builds on previous: Watch (animation only) → Trace With Guide
      (ghost + numbers) → Trace Without Guide (numbers only) → Free Drawing
      (no assistance). Require successful recognition to advance modes. Show
      ghost overlay at 30% opacity for trace modes. Display stroke numbers
      near stroke start points.

    key_considerations:
      - "Ghost overlay should not interfere with drawn strokes"
      - "Stroke numbers positioned at median line start points"
      - "Mode progression requires recognition confidence > 0.7"
      - "Allow manual mode switching for advanced users"
      - "Provide encouraging feedback on mode transitions"

    integration_points:
      - "Uses animation from Task 4"
      - "Uses canvas from Task 8"
      - "Uses recognition from Task 9"

  testing_overview:
    strategy: "integration"

    rationale: |
      Practice modes integrate multiple systems (animation, canvas, recognition)
      and require end-to-end testing to verify correct flow.

    critical_properties:
      - "Modes progress in correct order based on success"
      - "Visual guides display correctly for each mode"
      - "Recognition validates before mode progression"

    verification_needs:
      formal_verification: false
      property_testing: false
      concurrency_testing: false
      integration_testing: true

    estimated_test_count: 8

  dependencies:
    requires_completion_of:
      - task_id: 4
        reason: "Uses stroke animation for Watch mode"
      - task_id: 8
        reason: "Uses drawing canvas for trace modes"
      - task_id: 9
        reason: "Uses recognition for validation"

    enables_start_of: []

    parallel_with:
      - 11

  acceptance_criteria:
    - "All four practice modes function correctly"
    - "Ghost overlay renders at appropriate opacity"
    - "Stroke numbers display accurately"
    - "Mode progression requires successful recognition"
    - "Users can complete full practice flow for any character"
    - "Visual feedback distinguishes between modes clearly"

  risk_assessment:
    complexity_risk: "medium"
    integration_risk: "high"
    testing_risk: "medium"

    concerns:
      - "Mode transitions could feel jarring without good UX design"
      - "Ghost overlay positioning needs careful tuning"

  notes:
    - "Consider allowing users to skip modes if too easy"
    - "Track mode-specific success rates for analytics"

# =============================================================================

task:
  id: 11
  name: "Enhanced UI, Navigation, and Visual Feedback"

  overview:
    purpose: |
      Polish the user interface with smooth navigation, visual feedback animations
      for correct/incorrect responses, progress indicators, and achievement
      notifications. Create a cohesive, professional user experience.

    motivation: |
      Good UX is critical for learning apps. Immediate visual feedback reinforces
      learning, smooth animations feel professional, and clear navigation reduces
      cognitive load. These elements dramatically improve user engagement and
      retention.

    outcome: |
      Application feels polished and responsive, users receive immediate visual
      feedback on actions, navigation between screens is intuitive, and progress
      feels visible and rewarding.

  scope_summary:
    description: "Implements feedback animations, progress indicators, navigation polish, achievement system"
    files_affected: 5
    functions_added: 20
    tests_required: 4
    complexity: "moderate"
    estimated_effort: "2-3 days"

  key_components:
    - component: "FeedbackAnimation"
      type: "struct"
      purpose: "Correct/incorrect visual feedback"

    - component: "ProgressIndicator"
      type: "widget"
      purpose: "Circular progress display"

    - component: "Achievement system"
      type: "module"
      purpose: "Tracks and displays achievements"

    - component: "Streak display"
      type: "widget"
      purpose: "Shows current and longest streaks"

  implementation_hints:
    approach: |
      Use iced Animation API for feedback (green flash for correct, red shake
      for incorrect). Implement circular progress using Canvas arc drawing.
      Create achievement definitions with unlock conditions. Add streak flame
      icon that animates on updates. Ensure all animations complete in 200-500ms
      for snappy feel.

    key_considerations:
      - "Feedback must appear within 200ms of action"
      - "Color alone insufficient; use icons + text"
      - "Shake animation uses sine wave with decay"
      - "Progress circle draws arc from -90° (top)"
      - "Achievement unlocks show toast notification"

    integration_points:
      - "Feedback triggers from learning session (Task 3)"
      - "Progress indicators throughout app"
      - "Achievements track statistics (Task 6)"

  testing_overview:
    strategy: "unit"

    rationale: |
      Visual components can be tested through snapshot tests and animation
      timing verification.

    critical_properties:
      - "Feedback animations complete in specified time"
      - "Progress calculations display correct percentages"
      - "Achievements unlock at correct thresholds"

    verification_needs:
      formal_verification: false
      property_testing: false
      concurrency_testing: false
      integration_testing: false

    estimated_test_count: 4

  dependencies:
    requires_completion_of:
      - task_id: 3
        reason: "Integrates with learning session"
      - task_id: 6
        reason: "Achievement system uses statistics"

    enables_start_of: []

    parallel_with:
      - 10

  acceptance_criteria:
    - "Feedback animations trigger within 200ms"
    - "Correct/incorrect feedback clearly distinguishable"
    - "Progress indicators show accurate percentages"
    - "Achievements unlock and display notifications"
    - "Streak display updates daily"
    - "All navigation smooth without lag"

  risk_assessment:
    complexity_risk: "low"
    integration_risk: "low"
    testing_risk: "low"

    concerns: []

  notes:
    - "Consider color-blind friendly color schemes"
    - "Sound effects could enhance feedback (future)"

# =============================================================================

task:
  id: 12
  name: "FSRS Algorithm Migration (Optional)"

  overview:
    purpose: |
      Migrate from SM-2 to FSRS (Free Spaced Repetition Scheduler) algorithm
      for 20-30% more efficient scheduling once sufficient review data (1000+
      reviews) has been collected. Enable algorithm comparison and A/B testing.

    motivation: |
      FSRS is a modern, data-driven algorithm that outperforms SM-2 when properly
      tuned with user data. Migration provides better scheduling efficiency,
      reduced review burden, and improved long-term retention for dedicated users.

    outcome: |
      Users with sufficient review history benefit from optimized scheduling,
      review burden decreases by 20-30% while maintaining retention, and the
      system can compare algorithm performance for validation.

  scope_summary:
    description: "Implements FSRS algorithm, parameter optimization, migration logic, A/B testing infrastructure"
    files_affected: 4
    functions_added: 25
    tests_required: 15
    complexity: "critical"
    estimated_effort: "1 week"

  key_components:
    - component: "FSRSCard"
      type: "struct"
      purpose: "FSRS-specific card state (difficulty, stability, retrievability)"

    - component: "FSRS scheduler"
      type: "module"
      purpose: "Core FSRS algorithm implementation"

    - component: "Parameter optimizer"
      type: "function"
      purpose: "Tunes FSRS parameters from review history"

    - component: "Migration system"
      type: "function"
      purpose: "Converts SM2Card to FSRSCard"

    - component: "Algorithm selector"
      type: "enum"
      purpose: "Allows choosing SM-2 vs FSRS per user"

  implementation_hints:
    approach: |
      Implement FSRS algorithm per specification at open-spaced-repetition/fsrs-rs.
      Use review log data to optimize parameters (D, S, R factors). Provide
      migration tool that converts existing SM-2 cards using review history.
      Allow users to choose algorithm or auto-select based on data availability.

    key_considerations:
      - "Requires minimum 1000 reviews for reliable parameter optimization"
      - "Algorithm choice affects all new cards going forward"
      - "Must maintain backward compatibility with SM-2 data"
      - "Parameter optimization computationally expensive; run async"
      - "A/B testing requires tracking algorithm per card"

    integration_points:
      - "Replaces SM-2 in learning session (Task 3)"
      - "Uses review history from persistence (Task 5)"
      - "Compared via statistics (Task 6)"

  testing_overview:
    strategy: "property-based"

    rationale: |
      FSRS algorithm has complex mathematical properties that should be verified
      with property-based testing. Also requires validation against known datasets.

    critical_properties:
      - "Retrievability always between 0.0 and 1.0"
      - "Stability increases with successful reviews"
      - "Difficulty converges for consistent performance"
      - "Optimized parameters improve retention prediction"

    verification_needs:
      formal_verification: false
      property_testing: true
      concurrency_testing: false
      integration_testing: true

    estimated_test_count: 15

  dependencies:
    requires_completion_of:
      - task_id: 3
        reason: "Replaces SM-2 algorithm"
      - task_id: 5
        reason: "Needs extensive review history"

    enables_start_of: []

    parallel_with: []

  acceptance_criteria:
    - "FSRS algorithm implemented per specification"
    - "Parameter optimization produces valid parameters from review data"
    - "Migration converts SM-2 cards without data loss"
    - "Users can select algorithm preference"
    - "FSRS performs 20-30% better than SM-2 in validation tests"
    - "Algorithm choice persists and applies correctly"

  risk_assessment:
    complexity_risk: "high"
    integration_risk: "medium"
    testing_risk: "high"

    concerns:
      - "FSRS algorithm mathematically complex and error-prone"
      - "Parameter optimization requires significant computation"
      - "Insufficient data leads to poor parameter estimates"
      - "Migration could fail with edge case review histories"

  notes:
    - "Optional: implement only if user base grows significantly"
    - "Consider using fsrs-rs crate if available"
    - "Collect telemetry to validate improvement claims"

# =============================================================================
# END OF TASKS
# =============================================================================

task:
  id: 1
  name: "Project Structure and Application Foundation"

  overview:
    purpose: |
      Establish the foundational Rust project structure with iced GUI framework integration,
      including proper module organization, dependency configuration, and basic application
      scaffolding. This task creates the skeleton that all other components will build upon.

    motivation: |
      A well-organized project structure is critical for maintainability and scalability.
      The modular architecture separates concerns (UI, state, models, persistence, scheduling)
      allowing parallel development of features. Proper iced integration from the start ensures
      the Elm architecture pattern is correctly implemented.

    outcome: |
      A compilable Rust application with iced GUI framework configured, module structure
      in place, and a basic "Hello World" window that demonstrates the application lifecycle.
      All dependencies are properly configured in Cargo.toml with appropriate feature flags.

  scope_summary:
    description: "Creates project structure with 7 module directories and main application entry point"
    files_affected: 10
    functions_added: 3
    tests_required: 0
    complexity: "simple"
    estimated_effort: "1-2 hours"

  key_components:
    - component: "Main application struct"
      type: "struct"
      purpose: "Implements iced::Application trait, orchestrates application lifecycle"

    - component: "Module organization"
      type: "module"
      purpose: "Separates concerns into state/, ui/, models/, persistence/, scheduler/, data/"

    - component: "Cargo configuration"
      type: "module"
      purpose: "Configures dependencies with correct features and build optimization"

  implementation_hints:
    approach: |
      Follow standard Rust project conventions with cargo new. Implement minimal iced
      Application trait with empty update/view methods. Create module files with
      placeholder content to establish structure.

    key_considerations:
      - "Use iced 0.13 with canvas, tokio, and advanced features enabled"
      - "Set up proper Cargo.toml [profile.release] optimizations from the start"
      - "Include directories crate for cross-platform data path detection"
      - "Embed fonts using include_bytes!() for portability"

    integration_points:
      - "main.rs serves as application entry point"
      - "All modules export through mod.rs files for clean API"

  testing_overview:
    strategy: "unit"
    rationale: |
      Basic compilation and smoke tests to verify project structure and dependencies
      are correctly configured. No complex logic to test at this stage.

    critical_properties:
      - "Application compiles without errors"
      - "Application window opens and displays correctly"

    verification_needs:
      formal_verification: false
      property_testing: false
      concurrency_testing: false
      integration_testing: false

    estimated_test_count: 2

  dependencies:
    requires_completion_of: []
    enables_start_of:
      - task_id: 2
        reason: "Character data structures need module structure to exist"
      - task_id: 3
        reason: "Font loading requires application foundation"
      - task_id: 6
        reason: "State management builds on application structure"

    parallel_with: []

  acceptance_criteria:
    - "cargo build completes successfully"
    - "Application launches and displays empty window"
    - "All module directories created with mod.rs files"
    - "Cargo.toml includes all required dependencies"

  risk_assessment:
    complexity_risk: "low"
    integration_risk: "low"
    testing_risk: "low"
    concerns: []

  notes:
    - "This is the foundation task - keep it simple and focus on structure"
    - "Verify iced version 0.13 is used for cosmic-text integration"

---

task:
  id: 2
  name: "Character Data Structures and Loading System"

  overview:
    purpose: |
      Define core data structures for representing hiragana and katakana characters
      including their Unicode values, romanization, stroke paths, and metadata.
      Implement efficient compile-time or runtime loading mechanisms for character
      data that will power the entire learning system.

    motivation: |
      Character data is the foundation of the learning application. The structure must
      efficiently represent stroke order information for animation, support fast lookups
      for flashcards and recognition, and maintain metadata for scheduling. The choice
      between compile-time (phf) and runtime loading affects performance and flexibility.

    outcome: |
      A complete character database covering all 46 hiragana and 46 katakana characters
      with stroke path data, accessible through zero-cost lookups. Data is serialized in
      RON format for human readability and can be embedded in the binary or loaded at runtime.

  scope_summary:
    description: "Defines CharData struct, creates hiragana.ron and katakana.ron data files, implements lookup system"
    files_affected: 5
    functions_added: 8
    tests_required: 12
    complexity: "moderate"
    estimated_effort: "1 day"

  key_components:
    - component: "CharData struct"
      type: "struct"
      purpose: "Represents a single kana character with all metadata and stroke information"

    - component: "Character database"
      type: "module"
      purpose: "Static or lazy-loaded HashMap/phf::Map for O(1) character lookups"

    - component: "RON data files"
      type: "module"
      purpose: "Human-readable serialized character data for hiragana and katakana"

    - component: "SVG path parser"
      type: "function"
      purpose: "Converts SVG path strings to internal stroke representation"

  implementation_hints:
    approach: |
      Start with compile-time phf::Map for MVP simplicity and zero runtime cost.
      Define CharData with serde derive for serialization. Extract stroke data from
      kana-svg-data or animCJK repositories and convert to RON format.

    key_considerations:
      - "Use phf for compile-time perfect hash map (zero runtime cost)"
      - "Store SVG paths as strings initially, parse on-demand for animation"
      - "Include median points for stroke direction visualization"
      - "Frequency rank enables ordered presentation (common characters first)"
      - "Unicode values needed for text rendering and recognition"

    integration_points:
      - "models/character.rs defines core data structures"
      - "data/ directory contains RON files embedded with include_str!()"
      - "Used by flashcard system, animation engine, and practice modes"

  testing_overview:
    strategy: "unit"
    rationale: |
      Character data is static and deterministic, making it ideal for unit tests.
      Verify data integrity, lookup correctness, and SVG path parsing.

    critical_properties:
      - "All 92 characters (46 hiragana + 46 katakana) are present"
      - "Each character has valid Unicode code point"
      - "Stroke counts match expected values"
      - "SVG paths parse without errors"

    verification_needs:
      formal_verification: false
      property_testing: true
      concurrency_testing: false
      integration_testing: false

    estimated_test_count: 12

  dependencies:
    requires_completion_of:
      - task_id: 1
        reason: "Needs models/ module structure to exist"

    enables_start_of:
      - task_id: 3
        reason: "Font rendering needs character data to display"
      - task_id: 4
        reason: "Stroke animation requires stroke path data"
      - task_id: 7
        reason: "Flashcard system needs character database"

    parallel_with: [3]

  acceptance_criteria:
    - "CharData struct defined with all required fields"
    - "hiragana.ron contains all 46 hiragana characters"
    - "katakana.ron contains all 46 katakana characters"
    - "Lookup function returns correct CharData for any valid kana"
    - "All unit tests pass verifying data integrity"
    - "SVG paths parse without panics"

  risk_assessment:
    complexity_risk: "low"
    integration_risk: "low"
    testing_risk: "low"
    concerns:
      - "SVG path data extraction from kana-svg-data may require manual processing"
      - "Median point calculation may need custom tooling"

  notes:
    - "Consider using kana-svg-data GitHub repository as primary source"
    - "RON format chosen for readability - can switch to bincode for production"
    - "Compile-time embedding trades binary size for runtime performance"

---

task:
  id: 3
  name: "Japanese Font Integration and Text Rendering"

  overview:
    purpose: |
      Integrate a Japanese font (Noto Sans JP) into the iced application and configure
      cosmic-text for proper Unicode rendering of hiragana and katakana characters.
      Create a custom CharacterCard widget for flashcard-style character display with
      configurable sizing and styling.

    motivation: |
      Proper Japanese text rendering is non-negotiable for a kana learning application.
      Iced's cosmic-text backend supports full Unicode, but requires explicit font loading
      and shaping configuration. A custom widget abstracts rendering complexity and provides
      consistent character presentation across the application.

    outcome: |
      Japanese characters render correctly at all sizes with proper glyph shaping.
      A reusable CharacterCard widget provides flashcard-style display with options
      for size, stroke order overlay, and styling. Font is embedded in the binary for
      portability across platforms.

  scope_summary:
    description: "Embeds Noto Sans JP font, configures text rendering, implements CharacterCard widget"
    files_affected: 4
    functions_added: 6
    tests_required: 4
    complexity: "moderate"
    estimated_effort: "half day"

  key_components:
    - component: "Font loading system"
      type: "function"
      purpose: "Loads embedded Japanese font at application startup"

    - component: "CharacterCard widget"
      type: "struct"
      purpose: "Custom iced widget for displaying kana characters in flashcard style"

    - component: "Font asset"
      type: "module"
      purpose: "Embedded Noto Sans JP font file (700KB-1MB OTF)"

  implementation_hints:
    approach: |
      Use include_bytes!() to embed font at compile time. Load font in Application::new()
      using iced's font loading API. Create CharacterCard as a custom widget implementing
      iced::Widget trait with draw() method that uses cosmic-text for rendering.

    key_considerations:
      - "Must use Shaping::Advanced for proper Japanese character rendering"
      - "Font::with_name() reference must match exact font family name"
      - "Consider Noto Sans JP Regular (400) for primary UI, Bold (700) for emphasis"
      - "CharacterCard should center character both horizontally and vertically"
      - "Support optional stroke order guides as overlay layer"

    integration_points:
      - "Font loaded in main.rs Application::new()"
      - "CharacterCard widget used in ui/flashcard.rs"
      - "Integrates with Canvas widget for stroke order overlay"

  testing_overview:
    strategy: "integration"
    rationale: |
      Text rendering requires integration testing with actual font and renderer.
      Visual regression tests or snapshot tests would be ideal but may be complex
      for MVP. Focus on ensuring no panics and correct text output.

    critical_properties:
      - "All hiragana characters render without missing glyphs"
      - "All katakana characters render without missing glyphs"
      - "Text centering works correctly at various sizes"

    verification_needs:
      formal_verification: false
      property_testing: false
      concurrency_testing: false
      integration_testing: true

    estimated_test_count: 4

  dependencies:
    requires_completion_of:
      - task_id: 1
        reason: "Needs application foundation and ui/ module"

    enables_start_of:
      - task_id: 7
        reason: "Flashcard system needs CharacterCard widget"
      - task_id: 8
        reason: "Practice mode displays characters using this system"

    parallel_with: [2]

  acceptance_criteria:
    - "Noto Sans JP font embedded in binary"
    - "Font loads successfully at application startup"
    - "CharacterCard widget displays hiragana correctly"
    - "CharacterCard widget displays katakana correctly"
    - "Text renders at 48px, 64px, and 72px sizes"
    - "No missing glyph boxes (□) appear for any kana"

  risk_assessment:
    complexity_risk: "low"
    integration_risk: "medium"
    testing_risk: "medium"
    concerns:
      - "Font loading errors may be platform-specific and hard to debug"
      - "cosmic-text shaping configuration may require experimentation"

  notes:
    - "Noto Sans JP Regular is ~900KB - acceptable for embedded font"
    - "Alternative: Source Han Sans if handwriting-style strokes needed"
    - "Consider font subsetting to reduce binary size (kana-only subset ~100KB)"

---

task:
  id: 4
  name: "Stroke Order Animation System"

  overview:
    purpose: |
      Implement a GPU-accelerated stroke-by-stroke animation system using iced's Canvas
      widget and Animation API. The system renders character strokes sequentially with
      smooth partial path drawing, configurable timing, and natural easing curves that
      mimic human handwriting motion.

    motivation: |
      Stroke order animation is the primary visual teaching tool. It must be smooth,
      accurate, and feel natural to be pedagogically effective. GPU acceleration via
      lyon tessellation ensures 60fps animation even on lower-end hardware. Sequential
      stroke rendering with proper timing helps learners internalize correct writing
      patterns.

    outcome: |
      A reusable StrokeOrderAnimation component that takes stroke path data and produces
      smooth, timed animations. Each stroke draws progressively over 500-800ms with
      200-300ms pauses between strokes. Completed strokes render in black, current stroke
      in blue. Animation can be played, paused, and reset.

  scope_summary:
    description: "Implements Canvas-based animation with lyon path rendering, timing control, and partial path calculation"
    files_affected: 6
    functions_added: 15
    tests_required: 8
    complexity: "complex"
    estimated_effort: "2-3 days"

  key_components:
    - component: "StrokeOrderAnimation"
      type: "struct"
      purpose: "Manages animation state, timing, and rendering for stroke order display"

    - component: "StrokePath"
      type: "struct"
      purpose: "Represents a single stroke with segments and length calculations"

    - component: "PathSegment"
      type: "enum"
      purpose: "Individual SVG path commands (MoveTo, LineTo, CubicBezier, etc.)"

    - component: "Animation controller"
      type: "module"
      purpose: "Manages animation lifecycle (play, pause, reset, complete)"

    - component: "Partial path renderer"
      type: "function"
      purpose: "Calculates and renders partial stroke paths based on animation progress"

  implementation_hints:
    approach: |
      Implement canvas::Program trait for StrokeOrderAnimation. Parse SVG path data
      into PathSegment enums with precomputed lengths. Use iced's Animation API to
      interpolate 0.0 to 1.0 progress for each stroke. In draw(), render completed
      strokes fully and current stroke partially based on animation progress.

    key_considerations:
      - "Precompute total stroke length for accurate partial path rendering"
      - "Use EaseOutCubic easing for natural handwriting feel"
      - "Request redraw on every frame while animating"
      - "Parse SVG commands: M (move), L (line), C (cubic), S (smooth cubic), Q (quadratic)"
      - "Handle stroke sequence correctly - wait for current stroke to complete"
      - "Color differentiation: black for complete, blue for animating"

    integration_points:
      - "Used by practice mode for teaching stroke order"
      - "Integrates with character data from Task 2"
      - "Canvas rendering pipeline uses lyon for GPU tessellation"

  testing_overview:
    strategy: "mixed"
    rationale: |
      Animation logic is deterministic but timing-sensitive. Unit tests verify path
      calculations and segment parsing. Integration tests verify animation state
      transitions. Visual inspection needed for timing/easing quality.

    critical_properties:
      - "Partial path calculation maintains stroke continuity"
      - "Animation completes all strokes in sequence"
      - "Total animation time matches expected duration"
      - "No rendering artifacts or flicker between frames"

    verification_needs:
      formal_verification: false
      property_testing: true
      concurrency_testing: false
      integration_testing: true

    estimated_test_count: 8

  dependencies:
    requires_completion_of:
      - task_id: 1
        reason: "Needs Canvas widget support from iced foundation"
      - task_id: 2
        reason: "Requires stroke path data from character database"

    enables_start_of:
      - task_id: 8
        reason: "Practice mode uses stroke animation for teaching"

    parallel_with: [3, 5]

  acceptance_criteria:
    - "Stroke animation renders at 60fps without frame drops"
    - "Each stroke animates over 500-800ms as configured"
    - "200-300ms pause occurs between strokes"
    - "Partial path rendering shows smooth progression (no jumps)"
    - "Animation completes all strokes in correct order"
    - "Play/pause/reset controls work correctly"
    - "Color differentiation between complete and animating strokes"

  risk_assessment:
    complexity_risk: "high"
    integration_risk: "medium"
    testing_risk: "medium"
    concerns:
      - "SVG path parsing is complex and error-prone for edge cases"
      - "Partial path length calculations may have floating-point precision issues"
      - "Performance may degrade on low-end hardware"
      - "Bezier curve length calculation requires numerical approximation"

  notes:
    - "Consider using lyon's path builder API directly instead of SVG parsing"
    - "Bezier curve length: use adaptive subdivision or Legendre-Gauss quadrature"
    - "Animation timing may need tuning based on user feedback"

---

task:
  id: 5
  name: "Handwriting Canvas and Input System"

  overview:
    purpose: |
      Create an interactive drawing canvas that captures user handwriting input with
      mouse or touch. The system records stroke sequences with timestamps, provides
      visual feedback during drawing, and outputs normalized stroke data suitable for
      character recognition. Supports both freehand and stroke-order-enforced modes.

    motivation: |
      Handwriting practice is essential for kinesthetic learning. The canvas must feel
      responsive and natural, with smooth stroke rendering and proper point sampling.
      Stroke data collection enables recognition validation and progress tracking.
      The system must work across desktop (mouse) and touch-enabled devices.

    outcome: |
      A HandwritingCanvas widget that captures drawing input, renders strokes in
      real-time with smooth anti-aliased paths, and exports stroke data as sequences
      of points. Canvas supports clear/undo operations, provides visual feedback for
      stroke starts/ends, and can optionally overlay guide images for tracing practice.

  scope_summary:
    description: "Implements interactive Canvas with mouse/touch input, stroke recording, and rendering"
    files_affected: 5
    functions_added: 12
    tests_required: 6
    complexity: "moderate"
    estimated_effort: "1 day"

  key_components:
    - component: "HandwritingCanvas"
      type: "struct"
      purpose: "Canvas widget implementing canvas::Program for interactive drawing"

    - component: "DrawingState"
      type: "struct"
      purpose: "Maintains stroke history and current drawing state"

    - component: "Stroke"
      type: "struct"
      purpose: "Represents a single stroke as sequence of points with timestamp"

    - component: "Input handler"
      type: "function"
      purpose: "Processes mouse/touch events into stroke points"

    - component: "Stroke renderer"
      type: "function"
      purpose: "Renders strokes with anti-aliasing and proper line caps/joins"

  implementation_hints:
    approach: |
      Implement canvas::Program with DrawingState. Handle mouse ButtonPressed to start
      stroke, CursorMoved to add points, ButtonReleased to complete stroke. Apply
      distance threshold (2px) to reduce noise. Use lyon Path with line_to() for
      rendering with round caps/joins for smooth appearance.

    key_considerations:
      - "Apply distance threshold to prevent excessive point density"
      - "Use LineCap::Round and LineJoin::Round for natural stroke appearance"
      - "Store timestamps for velocity analysis (future recognition enhancement)"
      - "Normalize coordinates to 0-1 range for recognition"
      - "Request redraw on every cursor move while drawing"
      - "Differentiate visual style for current vs completed strokes"

    integration_points:
      - "Used in practice mode for handwriting exercises"
      - "Exports stroke data to recognition system (Task 9)"
      - "Overlays on top of guide images from character data"

  testing_overview:
    strategy: "integration"
    rationale: |
      Drawing input requires integration testing with simulated mouse events.
      Unit tests verify stroke data structure and normalization. Integration
      tests ensure event handling state machine works correctly.

    critical_properties:
      - "Strokes are continuous (no gaps from missed events)"
      - "Point sampling rate is consistent and appropriate"
      - "Stroke completion triggers recognition callback"
      - "Multiple strokes are maintained in correct sequence"

    verification_needs:
      formal_verification: false
      property_testing: false
      concurrency_testing: false
      integration_testing: true

    estimated_test_count: 6

  dependencies:
    requires_completion_of:
      - task_id: 1
        reason: "Needs Canvas widget support from iced foundation"

    enables_start_of:
      - task_id: 8
        reason: "Practice mode requires drawing canvas"
      - task_id: 9
        reason: "Recognition system needs stroke data format"

    parallel_with: [2, 3, 4]

  acceptance_criteria:
    - "Canvas captures mouse input and renders strokes in real-time"
    - "Strokes appear smooth with anti-aliasing and round caps"
    - "Distance threshold reduces point noise effectively"
    - "Clear button removes all strokes"
    - "Stroke data exports as Vec<Vec<Point>>"
    - "Visual differentiation between drawing and completed strokes"

  risk_assessment:
    complexity_risk: "medium"
    integration_risk: "medium"
    testing_risk: "low"
    concerns:
      - "Touch input support may require platform-specific testing"
      - "Point sampling rate may need tuning for different input devices"

  notes:
    - "Consider adding pressure sensitivity support for stylus input (future)"
    - "Stroke smoothing algorithms (Catmull-Rom splines) could improve appearance"
    - "Canvas size should be configurable but default to 200x200px"

---

task:
  id: 6
  name: "Application State Management and Navigation"

  overview:
    purpose: |
      Implement the Elm architecture state management system for the application,
      including screen navigation, session management, and the message/update pipeline.
      This establishes the control flow for transitioning between menu, learning,
      practice, and statistics screens while maintaining application state consistency.

    motivation: |
      Proper state management is the backbone of the Elm architecture and ensures
      predictable, testable application behavior. The state structure must support
      complex interactions (learning sessions, animations, drawing) while remaining
      maintainable. Clear message types and update logic prevent bugs and make the
      application easy to extend.

    outcome: |
      A complete state management system with Screen enum for navigation, Message
      enum for all user interactions, and update() function that implements all
      state transitions. Application can navigate between screens, maintain session
      state, and handle complex workflows like review sessions and practice modes.

  scope_summary:
    description: "Defines AppState, Screen enum, Message enum, and implements Application::update()"
    files_affected: 8
    functions_added: 25
    tests_required: 15
    complexity: "complex"
    estimated_effort: "2-3 days"

  key_components:
    - component: "AppState"
      type: "struct"
      purpose: "Root state container holding current screen and shared data"

    - component: "Screen enum"
      type: "enum"
      purpose: "Represents all application screens with associated state"

    - component: "Message enum"
      type: "enum"
      purpose: "All possible user interactions and system events"

    - component: "Application::update()"
      type: "function"
      purpose: "State transition function implementing Elm architecture update logic"

    - component: "Navigation functions"
      type: "module"
      purpose: "Helper functions for screen transitions and state setup"

  implementation_hints:
    approach: |
      Define comprehensive Screen enum variants (MainMenu, Learning, Practice, etc.)
      each carrying relevant state. Create Message enum covering all interactions.
      Implement update() as large match statement routing messages to screen-specific
      handlers. Use Task for async operations (database saves, recognition).

    key_considerations:
      - "Keep state transitions pure - no side effects in update()"
      - "Use Task::perform() for async operations that return Messages"
      - "Maintain referential transparency for testability"
      - "Session state (learning/practice) is owned by Screen variants"
      - "Shared state (progress, settings) lives in AppState via Arc<RwLock>"
      - "Navigation messages trigger screen transitions and state initialization"

    integration_points:
      - "Integrates with all other systems - central orchestrator"
      - "Coordinates between UI layer (view) and business logic (update)"
      - "Manages database persistence operations asynchronously"

  testing_overview:
    strategy: "unit"
    rationale: |
      State transitions are pure functions and highly testable. Unit tests can
      verify all state transitions, message handling, and navigation flows without
      requiring UI or database. This is the most critical testing area.

    critical_properties:
      - "All screen transitions maintain state consistency"
      - "No unreachable states or invalid state combinations"
      - "Session data persists correctly across screen changes"
      - "Navigation stack allows proper back/forward flow"

    verification_needs:
      formal_verification: false
      property_testing: true
      concurrency_testing: false
      integration_testing: false

    estimated_test_count: 15

  dependencies:
    requires_completion_of:
      - task_id: 1
        reason: "Needs application foundation and state/ module structure"

    enables_start_of:
      - task_id: 7
        reason: "Learning session requires state management framework"
      - task_id: 8
        reason: "Practice session requires state management framework"
      - task_id: 10
        reason: "Statistics screen needs navigation support"

    parallel_with: []

  acceptance_criteria:
    - "All Screen variants defined with appropriate state"
    - "Message enum covers all user interactions"
    - "update() handles all message types correctly"
    - "Navigation between screens works bidirectionally"
    - "Session state initializes correctly on screen entry"
    - "State transitions pass all unit tests"
    - "No panics or invalid states reachable"

  risk_assessment:
    complexity_risk: "high"
    integration_risk: "high"
    testing_risk: "low"
    concerns:
      - "Large update() function may become unwieldy - consider sub-handlers"
      - "Async operations with Task require careful error handling"
      - "Shared state via Arc<RwLock> introduces potential for deadlocks"

  notes:
    - "Consider splitting update() into screen-specific update functions"
    - "Message enum should use descriptive names, not abbreviations"
    - "State transitions should be self-documenting through types"

---

task:
  id: 7
  name: "SM-2 Spaced Repetition Algorithm and Review Queue"

  overview:
    purpose: |
      Implement the SM-2 spaced repetition algorithm for scheduling card reviews,
      including ease factor calculation, interval progression, and review quality
      grading (0-5 scale). Build a review queue manager that prioritizes learning
      cards, due reviews, and new cards according to SRS best practices.

    motivation: |
      Spaced repetition is the core pedagogical engine that makes the learning system
      effective. SM-2 is battle-tested, well-documented, and provides good results for
      vocabulary learning. Proper implementation with queue prioritization ensures
      learners review cards at optimal intervals for long-term retention.

    outcome: |
      A fully functional SM-2 implementation that tracks per-card ease factors, intervals,
      and next review dates. ReviewQueue manages card prioritization with configurable
      daily limits. Cards automatically schedule based on user performance (quality rating),
      with failed cards returning to learning pool.

  scope_summary:
    description: "Implements SM-2 algorithm, SM2Card struct, ReviewQueue with prioritization logic"
    files_affected: 4
    functions_added: 12
    tests_required: 20
    complexity: "moderate"
    estimated_effort: "1 day"

  key_components:
    - component: "SM2Card"
      type: "struct"
      purpose: "Represents a flashcard with SM-2 scheduling parameters"

    - component: "SM2Card::review()"
      type: "function"
      purpose: "Updates card state based on quality rating (0-5)"

    - component: "ReviewQueue"
      type: "struct"
      purpose: "Manages card queues (new, learning, review) with prioritization"

    - component: "ReviewQueue::get_next_card()"
      type: "function"
      purpose: "Returns next card to review based on priority rules"

  implementation_hints:
    approach: |
      Implement SM-2 exactly as specified in SuperMemo documentation. Track ease factor
      (starting at 2.5), interval in days, and repetition count per card. On quality < 3,
      reset card to learning. On quality >= 3, update ease factor and calculate next
      interval. Queue prioritizes: learning cards, due reviews, then new cards.

    key_considerations:
      - "Ease factor has floor of 1.3 to prevent cards from becoming too hard"
      - "First two intervals are fixed: 1 day, then 6 days"
      - "Subsequent intervals: previous_interval * ease_factor"
      - "Quality rating maps to user experience: 5=perfect, 4=correct, 3=difficult, 2=incorrect, 1=barely, 0=blackout"
      - "Learning cards have priority over reviews to reinforce new material"
      - "Implement daily new card limits to prevent overwhelming users"

    integration_points:
      - "Used by learning session (Task 8) to schedule reviews"
      - "Integrates with persistence layer (Task 11) for card state storage"
      - "Powers flashcard system for both recognition and recall"

  testing_overview:
    strategy: "unit"
    rationale: |
      SM-2 algorithm is deterministic and mathematical, making it ideal for
      comprehensive unit testing. Property-based testing verifies invariants
      like ease factor bounds and interval monotonicity.

    critical_properties:
      - "Ease factor never falls below 1.3"
      - "Intervals increase monotonically for consecutive correct reviews"
      - "Failed cards (quality < 3) reset to interval=1, repetitions=0"
      - "Queue prioritization follows learning > review > new order"
      - "Next review date is always in the future after review"

    verification_needs:
      formal_verification: false
      property_testing: true
      concurrency_testing: false
      integration_testing: false

    estimated_test_count: 20

  dependencies:
    requires_completion_of:
      - task_id: 2
        reason: "Needs character database to create cards"

    enables_start_of:
      - task_id: 8
        reason: "Learning session uses SM-2 for scheduling"

    parallel_with: [3, 4, 5]

  acceptance_criteria:
    - "SM2Card::review() correctly updates ease factor for all quality ratings"
    - "Intervals progress according to SM-2 specification"
    - "Failed cards reset to learning state"
    - "ReviewQueue returns cards in correct priority order"
    - "Daily limits prevent queue overflow"
    - "All 20 unit tests pass including property tests"
    - "No panics for any valid quality rating (0-5)"

  risk_assessment:
    complexity_risk: "medium"
    integration_risk: "low"
    testing_risk: "low"
    concerns:
      - "Ease factor formula is sensitive to floating-point precision"
      - "Daily limits need careful tuning for good UX"

  notes:
    - "Consider FSRS upgrade path after collecting review data"
    - "Store review history for future algorithm improvements"
    - "Quality rating UI should clearly explain 0-5 scale to users"

---

task:
  id: 8
  name: "Learning Session and Practice Modes"

  overview:
    purpose: |
      Implement the learning session workflow that presents flashcards, collects user
      responses, records reviews, and progresses through review queues. Build practice
      mode with four progressive difficulty levels: watch animation, trace with guide,
      trace without guide, and free drawing. Integrate stroke animation, drawing canvas,
      and feedback systems into cohesive learning experiences.

    motivation: |
      The learning session and practice modes are where all other systems converge into
      actual learning experiences. These must feel polished, provide immediate feedback,
      and guide users through effective learning progressions. The combination of passive
      observation, guided practice, and free recall creates optimal learning conditions.

    outcome: |
      A complete learning session system that cycles through review queues, presents
      characters, collects quality ratings, and updates SM-2 state. Practice mode
      provides four progressive stages with stroke animation, tracing guides, and
      handwriting recognition. Both systems provide rich visual feedback and track
      session statistics.

  scope_summary:
    description: "Implements LearningSession and PracticeSession state machines with full UI integration"
    files_affected: 12
    functions_added: 30
    tests_required: 18
    complexity: "complex"
    estimated_effort: "2-3 days"

  key_components:
    - component: "LearningSession"
      type: "struct"
      purpose: "Manages review queue progression and session state"

    - component: "PracticeSession"
      type: "struct"
      purpose: "Manages practice mode progression through difficulty levels"

    - component: "PracticeMode enum"
      type: "enum"
      purpose: "Four practice stages: WatchAnimation, TraceWithGuide, TraceWithoutGuide, FreeDrawing"

    - component: "Session UI views"
      type: "function"
      purpose: "Renders flashcards, quality buttons, practice canvas, and feedback"

    - component: "Session statistics"
      type: "struct"
      purpose: "Tracks session progress, accuracy, time per card"

  implementation_hints:
    approach: |
      LearningSession pulls cards from ReviewQueue, displays them, waits for quality
      rating, calls SM2Card::review(), records result, moves to next card. PracticeSession
      starts with animation, progresses through modes on successful recognition, provides
      visual guides (ghost overlay) for tracing modes.

    key_considerations:
      - "Session should batch database saves (every 5-10 cards) not every card"
      - "Practice mode progression requires successful recognition to advance"
      - "Provide skip/hint options for stuck users"
      - "Show progress bar with cards remaining"
      - "Session summary screen shows accuracy, time, cards reviewed"
      - "Visual feedback (green check, red X) appears immediately after response"
      - "Keyboard shortcuts (1-5 for quality, space for next) improve flow"

    integration_points:
      - "Uses ReviewQueue from Task 7"
      - "Uses StrokeOrderAnimation from Task 4"
      - "Uses HandwritingCanvas from Task 5"
      - "Uses CharacterCard from Task 3"
      - "Saves progress via persistence layer (Task 11)"
      - "Updates statistics (Task 10)"

  testing_overview:
    strategy: "integration"
    rationale: |
      Session workflows involve complex state machines spanning multiple screens and
      user interactions. Integration tests verify correct state transitions and data
      flow. Unit tests cover session logic in isolation.

    critical_properties:
      - "Session progresses through all queued cards"
      - "Practice mode only advances on successful recognition"
      - "Session statistics accurately reflect review history"
      - "Database saves occur reliably"
      - "Session can be interrupted and resumed"

    verification_needs:
      formal_verification: false
      property_testing: false
      concurrency_testing: false
      integration_testing: true

    estimated_test_count: 18

  dependencies:
    requires_completion_of:
      - task_id: 2
        reason: "Needs character data"
      - task_id: 3
        reason: "Needs CharacterCard widget"
      - task_id: 4
        reason: "Needs stroke animation"
      - task_id: 5
        reason: "Needs drawing canvas"
      - task_id: 6
        reason: "Needs state management framework"
      - task_id: 7
        reason: "Needs SM-2 algorithm and review queue"

    enables_start_of:
      - task_id: 10
        reason: "Statistics need session data"

    parallel_with: []

  acceptance_criteria:
    - "Learning session presents cards from review queue in order"
    - "Quality ratings (0-5) update card state correctly"
    - "Practice mode progresses through all four stages"
    - "Stroke animation plays smoothly in watch mode"
    - "Tracing guide overlays correctly in trace modes"
    - "Free drawing mode validates without guides"
    - "Session summary displays accurate statistics"
    - "Progress saves to database correctly"

  risk_assessment:
    complexity_risk: "high"
    integration_risk: "high"
    testing_risk: "medium"
    concerns:
      - "Practice mode state machine has many transitions to test"
      - "Recognition validation may have false negatives requiring threshold tuning"
      - "Session interruption/resume needs careful state management"

  notes:
    - "Consider session time limits to prevent fatigue"
    - "Practice mode could offer optional hint button showing one stroke"
    - "Keyboard shortcuts significantly improve review flow"

---

task:
  id: 9
  name: "Character Recognition Integration"

  overview:
    purpose: |
      Integrate a character recognition engine that analyzes user-drawn strokes and
      returns candidate matches with confidence scores. Implement stroke normalization
      (coordinate scaling, resampling), format conversion for recognition libraries,
      and result validation against expected characters. Provides feedback for practice
      mode validation.

    motivation: |
      Recognition validates that users can reproduce characters from memory, providing
      objective assessment of learning. Accurate recognition requires proper stroke
      preprocessing and threshold tuning. The system must handle imperfect handwriting
      while preventing false positives that would allow incorrect forms to pass.

    outcome: |
      A recognition module that accepts stroke data from the drawing canvas, normalizes
      and preprocesses it, calls a recognition engine (hanzi_lookup or similar), and
      returns ranked candidates. Validation function checks if expected character appears
      in top-N results with sufficient confidence. Provides feedback for incorrect attempts.

  scope_summary:
    description: "Implements stroke normalization, recognition library integration, and validation logic"
    files_affected: 6
    functions_added: 15
    tests_required: 12
    complexity: "complex"
    estimated_effort: "2-3 days"

  key_components:
    - component: "Stroke normalizer"
      type: "function"
      purpose: "Normalizes coordinates to 0-1 range, resamples points, smooths noise"

    - component: "Recognition interface"
      type: "module"
      purpose: "FFI or API wrapper for recognition engine (hanzi_lookup/WASM)"

    - component: "Result validator"
      type: "function"
      purpose: "Checks if expected character is in top-N results with threshold confidence"

    - component: "Feedback generator"
      type: "function"
      purpose: "Provides helpful feedback for incorrect attempts"

  implementation_hints:
    approach: |
      Normalize strokes to unit square (0-1 range) to be resolution-independent.
      Optionally resample to fixed point count for consistency. Call recognition
      library via FFI (if Rust) or WASM bridge (if Python/JS). Parse results
      and rank by confidence. Validation succeeds if expected char in top 3 with >70% confidence.

    key_considerations:
      - "Normalization must preserve stroke order and direction"
      - "Resampling reduces noise but may lose detail - tune carefully"
      - "Recognition threshold affects UX: too strict frustrates, too loose allows bad form"
      - "Consider multiple recognition attempts with different preprocessing"
      - "hanzi_lookup (Rust) is ideal for kana if it supports them"
      - "Fallback: train custom CNN model on kana dataset (future enhancement)"
      - "Provide stroke count hint if recognition fails (wrong stroke count is common error)"

    integration_points:
      - "Receives stroke data from HandwritingCanvas (Task 5)"
      - "Called by PracticeSession (Task 8) after stroke completion"
      - "Results influence practice mode progression"

  testing_overview:
    strategy: "integration"
    rationale: |
      Recognition requires integration with external library and real handwriting
      data. Unit tests verify normalization and preprocessing. Integration tests
      use sample stroke data to verify end-to-end recognition pipeline.

    critical_properties:
      - "Normalization preserves relative stroke positions and sizes"
      - "Recognition returns results within acceptable time (<200ms)"
      - "Validation correctly identifies matches vs non-matches"
      - "False positive rate is acceptably low (<5%)"

    verification_needs:
      formal_verification: false
      property_testing: false
      concurrency_testing: false
      integration_testing: true

    estimated_test_count: 12

  dependencies:
    requires_completion_of:
      - task_id: 5
        reason: "Needs stroke data format from drawing canvas"

    enables_start_of:
      - task_id: 8
        reason: "Practice mode needs recognition for validation"

    parallel_with: [7, 10, 11]

  acceptance_criteria:
    - "Stroke normalization produces consistent 0-1 range output"
    - "Recognition engine integrates and returns results"
    - "Validation correctly identifies when expected character is matched"
    - "Recognition performance is <200ms for typical input"
    - "False positive rate is <5% on test dataset"
    - "Feedback messages are helpful for common errors"

  risk_assessment:
    complexity_risk: "high"
    integration_risk: "high"
    testing_risk: "high"
    concerns:
      - "Recognition library may not support kana (most focus on kanji)"
      - "FFI integration can be brittle and platform-specific"
      - "Threshold tuning requires substantial test data"
      - "User handwriting variability may be higher than expected"

  notes:
    - "Consider collecting anonymized stroke data to train custom model"
    - "May need to implement basic pattern matching as fallback"
    - "Stroke count validation (simple) can catch many errors before expensive recognition"

---

task:
  id: 10
  name: "Statistics and Progress Visualization"

  overview:
    purpose: |
      Implement comprehensive statistics tracking and visualization for user progress,
      including accuracy rates, study streaks, cards mastered, daily/weekly metrics,
      and time-series data. Create an engaging statistics screen that displays progress
      with charts, streak indicators, and achievement unlocks.

    motivation: |
      Progress visualization motivates learners and provides insight into learning
      patterns. Seeing streaks, accuracy trends, and cards mastered creates a sense
      of accomplishment and encourages consistent practice. Time-series data enables
      future analytics and personalized recommendations.

    outcome: |
      A Statistics struct that aggregates review data into meaningful metrics. A
      statistics screen displaying accuracy percentage, current/longest streak,
      cards by status (new/learning/mastered), daily review history, and unlocked
      achievements. Streak tracking encourages daily practice habit formation.

  scope_summary:
    description: "Implements Statistics struct with metrics aggregation, statistics screen UI, and progress visualization"
    files_affected: 8
    functions_added: 20
    tests_required: 10
    complexity: "moderate"
    estimated_effort: "1-2 days"

  key_components:
    - component: "Statistics struct"
      type: "struct"
      purpose: "Aggregates review data into accuracy, streaks, time metrics"

    - component: "DayStats / WeekStats"
      type: "struct"
      purpose: "Time-series data for daily and weekly aggregations"

    - component: "Statistics screen UI"
      type: "function"
      purpose: "Renders progress visualizations and metrics"

    - component: "Achievement system"
      type: "module"
      purpose: "Tracks and displays unlocked achievements"

    - component: "Streak calculator"
      type: "function"
      purpose: "Updates current and longest streaks based on study dates"

  implementation_hints:
    approach: |
      Maintain Statistics struct updated after each review. Use BTreeMap keyed by
      date for time-series data (efficient range queries). Calculate accuracy as
      correct/total. Track study_days HashSet for streak calculation. Update streak
      on each day's first review. Achievements unlock based on milestones.

    key_considerations:
      - "Update statistics incrementally during session, batch save at end"
      - "Use BTreeMap for date-indexed data (enables efficient date range queries)"
      - "Streak calculation: consecutive days in study_days set"
      - "Handle timezone correctly for day boundaries"
      - "Achievement unlocks should show celebratory animation"
      - "Consider card maturity stages: new (never reviewed), learning (interval <21 days), mature (21+ days)"

    integration_points:
      - "Updated by LearningSession (Task 8) after each review"
      - "Persisted by database layer (Task 11)"
      - "Displayed in dedicated statistics screen"

  testing_overview:
    strategy: "unit"
    rationale: |
      Statistics calculations are deterministic and mathematical. Unit tests can
      verify all aggregation logic, streak calculations, and achievement unlocking
      without requiring full application context.

    critical_properties:
      - "Accuracy calculation is correct (correct/total)"
      - "Streak increments correctly for consecutive days"
      - "Streak resets when day is skipped"
      - "Time-series aggregations match individual reviews"
      - "Achievement unlock conditions trigger correctly"

    verification_needs:
      formal_verification: false
      property_testing: true
      concurrency_testing: false
      integration_testing: false

    estimated_test_count: 10

  dependencies:
    requires_completion_of:
      - task_id: 6
        reason: "Needs navigation framework for statistics screen"

    enables_start_of: []

    parallel_with: [9, 11]

  acceptance_criteria:
    - "Accuracy rate displays correctly"
    - "Current streak increments on daily practice"
    - "Longest streak tracks correctly"
    - "Daily stats aggregate reviews correctly"
    - "Cards mastered count reflects SM-2 maturity"
    - "Achievement unlocks trigger at correct milestones"
    - "Statistics screen renders all metrics"
    - "Study streak displayed with flame emoji"

  risk_assessment:
    complexity_risk: "low"
    integration_risk: "low"
    testing_risk: "low"
    concerns:
      - "Timezone handling for day boundaries can be tricky"
      - "Large time-series data may need pagination or aggregation"

  notes:
    - "Consider graphs/charts using iced plotting libraries (future enhancement)"
    - "Export statistics as CSV for external analysis"
    - "Gamification elements (achievements, streaks) significantly boost motivation"

---

task:
  id: 11
  name: "Local Persistence and Database Layer"

  overview:
    purpose: |
      Implement robust local data persistence using redb embedded database to store
      user progress, card state, review history, settings, and statistics. Provide
      transactional safety, platform-independent file paths, backup/restore capabilities,
      and efficient batch operations to minimize I/O overhead.

    motivation: |
      Persistence is critical for user data integrity. Losing progress destroys trust
      and motivation. An embedded database (redb) provides ACID transactions without
      external dependencies. The persistence layer must handle concurrent access safely,
      survive crashes, and enable data portability for backup/restore.

    outcome: |
      An AppDatabase wrapper around redb providing type-safe, transactional operations
      for all persistent data. Database file stored in platform-appropriate location
      (XDG on Linux, AppData on Windows, Application Support on macOS). Batch save
      operations minimize write overhead. Export/import functions enable backup.

  scope_summary:
    description: "Implements redb database wrapper, schema definitions, CRUD operations, and backup functionality"
    files_affected: 6
    functions_added: 25
    tests_required: 15
    complexity: "moderate"
    estimated_effort: "1-2 days"

  key_components:
    - component: "AppDatabase"
      type: "struct"
      purpose: "Wrapper around redb::Database with typed operations"

    - component: "Table definitions"
      type: "module"
      purpose: "Defines redb tables for cards, reviews, settings, statistics"

    - component: "CRUD functions"
      type: "module"
      purpose: "Save/load/update operations for all data types"

    - component: "Batch operations"
      type: "function"
      purpose: "Efficiently save multiple records in single transaction"

    - component: "Backup/restore"
      type: "function"
      purpose: "Export/import database to/from portable format"

  implementation_hints:
    approach: |
      Use redb TableDefinition to define typed tables. Create wrapper methods that
      handle serialization (bincode) and transactions. Use directories crate for
      platform-appropriate data path. Implement batch operations for session saves.
      Export as JSON or bincode for portability.

    key_considerations:
      - "Use bincode for fast serialization, JSON for backups (human-readable)"
      - "Batch writes in single transaction for performance"
      - "Read transactions are cheap - can use liberally"
      - "Write transactions block - minimize frequency"
      - "Database path: directories::ProjectDirs for platform independence"
      - "Handle database file corruption gracefully with backup restore"
      - "Consider database compaction for long-term use"

    integration_points:
      - "Used by all components requiring persistence"
      - "LearningSession saves progress via this layer"
      - "Statistics persist to database"
      - "Settings stored and loaded"

  testing_overview:
    strategy: "integration"
    rationale: |
      Database operations require integration testing with actual redb instance.
      Tests verify ACID properties, data integrity, and correct serialization.
      Unit tests cover serialization/deserialization independently.

    critical_properties:
      - "Data survives application restart"
      - "Transactions are atomic (all-or-nothing)"
      - "Concurrent reads don't block each other"
      - "Write transactions serialize correctly"
      - "Backup/restore produces identical data"

    verification_needs:
      formal_verification: false
      property_testing: false
      concurrency_testing: true
      integration_testing: true

    estimated_test_count: 15

  dependencies:
    requires_completion_of:
      - task_id: 2
        reason: "Needs data structures defined to persist"
      - task_id: 7
        reason: "Needs SM2Card structure to persist"

    enables_start_of:
      - task_id: 8
        reason: "Learning session needs persistence"

    parallel_with: [9, 10]

  acceptance_criteria:
    - "Database initializes correctly on first run"
    - "Card state saves and loads correctly"
    - "Review history persists accurately"
    - "Statistics data survives restart"
    - "Batch operations complete in <100ms for 50 cards"
    - "Database file location is platform-appropriate"
    - "Export produces valid JSON/bincode file"
    - "Import correctly restores all data"

  risk_assessment:
    complexity_risk: "medium"
    integration_risk: "medium"
    testing_risk: "low"
    concerns:
      - "Database corruption is rare but catastrophic - needs robust backup strategy"
      - "Migration strategy needed for schema changes in future versions"

  notes:
    - "Consider automatic daily backups to prevent data loss"
    - "Compression (gzip) can reduce backup file size significantly"
    - "Future: cloud sync requires conflict resolution strategy"

---

task:
  id: 12
  name: "Visual Feedback and Animation Polish"

  overview:
    purpose: |
      Implement rich visual feedback system with animations for correct/incorrect responses,
      progress indicators, achievement unlocks, and UI transitions. Create micro-interactions
      that make the application feel polished and responsive. Includes success/error animations,
      shake effects, progress circles, and celebratory effects for achievements.

    motivation: |
      Visual feedback dramatically improves learning effectiveness and user satisfaction.
      Immediate, clear feedback (green checkmark for correct, red X for incorrect) reinforces
      learning. Smooth animations and micro-interactions make the application feel professional
      and delightful to use. Gamification elements like achievement animations boost motivation.

    outcome: |
      A comprehensive feedback system with reusable animation components. Correct answers
      trigger green flash and checkmark. Incorrect answers trigger red shake and X.
      Progress circles show session completion. Achievement unlocks display celebratory
      animations with icons and descriptions. All animations are smooth, purposeful, and
      configurable.

  scope_summary:
    description: "Implements feedback animations, progress indicators, shake effects, and achievement celebrations"
    files_affected: 8
    functions_added: 18
    tests_required: 6
    complexity: "moderate"
    estimated_effort: "1 day"

  key_components:
    - component: "FeedbackAnimation"
      type: "struct"
      purpose: "Manages success/error/partial feedback animations"

    - component: "ShakeEffect"
      type: "function"
      purpose: "Oscillating shake animation for errors"

    - component: "ProgressCircle"
      type: "function"
      purpose: "Circular progress indicator for sessions"

    - component: "AchievementPopup"
      type: "struct"
      purpose: "Celebration animation for unlocked achievements"

    - component: "Color palette"
      type: "module"
      purpose: "Consistent color scheme for feedback states"

  implementation_hints:
    approach: |
      Create FeedbackAnimation enum (Correct/Incorrect/Partial) with associated colors
      and easing curves. Shake uses sine wave oscillation with decay. Progress circle
      renders partial arc based on 0-1 progress value. Achievement popup slides in from
      top with fade-in animation, auto-dismisses after 3 seconds.

    key_considerations:
      - "Feedback animations should be fast (200-500ms) for immediate response"
      - "Use color + icon for accessibility (don't rely on color alone)"
      - "Shake amplitude should decay to avoid motion sickness"
      - "Progress indicators should update smoothly, not jump"
      - "Achievement animations can be longer (1-2s) as they're celebratory"
      - "Consider prefers-reduced-motion for accessibility"
      - "Use EaseOutElastic for playful feedback, EaseOutCubic for smooth progress"

    integration_points:
      - "Used by LearningSession after each review"
      - "Used by PracticeSession for recognition feedback"
      - "Achievement popup triggered by Statistics system"

  testing_overview:
    strategy: "integration"
    rationale: |
      Animation quality requires visual inspection. Integration tests verify animations
      trigger correctly and complete without errors. Unit tests cover timing calculations
      and state transitions.

    critical_properties:
      - "Animations complete in expected time"
      - "Feedback colors meet WCAG contrast requirements"
      - "Shake effect returns to center position"
      - "Progress circle renders correctly at 0%, 50%, 100%"

    verification_needs:
      formal_verification: false
      property_testing: false
      concurrency_testing: false
      integration_testing: true

    estimated_test_count: 6

  dependencies:
    requires_completion_of:
      - task_id: 1
        reason: "Needs animation API from iced foundation"
      - task_id: 6
        reason: "Needs message system to trigger feedback"

    enables_start_of: []

    parallel_with: [8, 10]

  acceptance_criteria:
    - "Correct answer shows green checkmark with flash"
    - "Incorrect answer shows red X with shake"
    - "Shake returns to center smoothly"
    - "Progress circle updates smoothly"
    - "Achievement popup displays with animation"
    - "All feedback colors meet WCAG AA contrast"
    - "Animations run at 60fps without frame drops"

  risk_assessment:
    complexity_risk: "low"
    integration_risk: "low"
    testing_risk: "low"
    concerns:
      - "Motion effects may cause discomfort for some users - need disable option"

  notes:
    - "Consider sound effects to complement visual feedback (future)"
    - "Haptic feedback on mobile devices could enhance experience"
    - "Particle effects for achievements would be delightful but complex"

---

task:
  id: 13
  name: "UI/UX Polish and Accessibility"

  overview:
    purpose: |
      Apply comprehensive UI/UX polish including WCAG-compliant color contrast, proper
      typography sizing, touch-friendly target sizes, keyboard navigation, and screen
      reader support. Implement consistent spacing, visual hierarchy, and responsive
      layouts. Ensure application is accessible to users with disabilities and feels
      professional and polished.

    motivation: |
      Accessibility is both an ethical imperative and legal requirement in many jurisdictions.
      Good UX design reduces cognitive load and makes learning more effective. Professional
      polish builds trust and encourages continued use. Keyboard navigation and proper
      contrast benefit all users, not just those with disabilities.

    outcome: |
      An application that meets WCAG 2.1 Level AA standards for contrast, target sizes,
      and keyboard navigation. All interactive elements are properly sized (48x48px minimum),
      colors meet 4.5:1 contrast ratio, and keyboard shortcuts enable efficient navigation.
      Typography is legible at all sizes, layouts adapt to different window sizes, and
      screen reader support provides equivalent experience for blind users.

  scope_summary:
    description: "Implements accessibility features, responsive layouts, keyboard shortcuts, and design system"
    files_affected: 15
    functions_added: 25
    tests_required: 8
    complexity: "moderate"
    estimated_effort: "1-2 days"

  key_components:
    - component: "Color palette"
      type: "module"
      purpose: "WCAG-compliant color constants with documented contrast ratios"

    - component: "Typography scale"
      type: "module"
      purpose: "Consistent font sizes and weights throughout application"

    - component: "Keyboard shortcuts"
      type: "module"
      purpose: "Efficient keyboard-only navigation and actions"

    - component: "Responsive layouts"
      type: "function"
      purpose: "Layouts that adapt to window size gracefully"

    - component: "Touch target sizing"
      type: "module"
      purpose: "Ensures all buttons meet 48x48px minimum"

  implementation_hints:
    approach: |
      Define color palette with documented contrast ratios (use WebAIM contrast checker).
      Set consistent font sizes (16-18px body, 14px secondary, 12px min). Implement
      keyboard event handlers for common actions (1-5 for quality, Space for next,
      Escape for cancel). Use iced's responsive layout tools (Length::Fill, alignment).
      Test with keyboard-only and screen reader.

    key_considerations:
      - "WCAG AA requires 4.5:1 contrast for normal text, 3:1 for large text"
      - "Minimum touch target: 48x48px (44x44px iOS minimum)"
      - "Keyboard focus indicators must be visible (2px border minimum)"
      - "Don't use color as sole indicator (add icons/text)"
      - "Font size minimum: 12px (14px recommended for body text)"
      - "Spacing: 8px base unit for consistent rhythm"
      - "Test with actual screen reader (NVDA/JAWS on Windows, VoiceOver on macOS)"

    integration_points:
      - "Applied to all UI components across application"
      - "Keyboard shortcuts integrated with message system"
      - "Responsive layouts affect all screens"

  testing_overview:
    strategy: "integration"
    rationale: |
      Accessibility and UX require manual testing with actual assistive technologies.
      Automated tests verify contrast ratios, target sizes, and keyboard handler presence.
      Manual testing with screen readers and keyboard-only navigation validates experience.

    critical_properties:
      - "All text meets WCAG AA contrast requirements"
      - "All interactive elements are 48x48px or larger"
      - "All functionality accessible via keyboard"
      - "Screen reader announces all content correctly"

    verification_needs:
      formal_verification: false
      property_testing: false
      concurrency_testing: false
      integration_testing: true

    estimated_test_count: 8

  dependencies:
    requires_completion_of:
      - task_id: 6
        reason: "Needs complete UI structure to polish"
      - task_id: 8
        reason: "Needs all screens implemented to apply consistency"

    enables_start_of: []

    parallel_with: [12]

  acceptance_criteria:
    - "All colors meet WCAG AA contrast ratio (4.5:1 normal text)"
    - "All buttons are minimum 48x48px touch targets"
    - "Keyboard shortcuts work for quality rating and navigation"
    - "Tab navigation visits all interactive elements in logical order"
    - "Focus indicators are clearly visible"
    - "Screen reader announces all content meaningfully"
    - "Application is usable keyboard-only (no mouse required)"
    - "Typography is consistent throughout application"

  risk_assessment:
    complexity_risk: "low"
    integration_risk: "low"
    testing_risk: "medium"
    concerns:
      - "Screen reader testing requires platform-specific tools and expertise"
      - "Keyboard navigation in custom Canvas widgets may be complex"

  notes:
    - "Consider hiring accessibility consultant for professional audit"
    - "User testing with actual disabled users is invaluable"
    - "Accessibility benefits everyone - better UX overall"
    - "Document keyboard shortcuts in help screen"

---

task:
  id: 14
  name: "Testing, Documentation, and Release Preparation"

  overview:
    purpose: |
      Implement comprehensive test coverage, write user-facing documentation, create
      build configurations for release, and prepare distribution packages for Linux,
      macOS, and Windows. Includes integration tests, performance benchmarks, user
      manual, and automated build pipeline. Ensures application is production-ready
      with quality assurance and professional documentation.

    motivation: |
      Thorough testing prevents bugs from reaching users and builds confidence in code
      quality. Documentation enables users to maximize application value and reduces
      support burden. Professional release packaging ensures smooth installation and
      good first impressions. This task transforms a working prototype into a shippable
      product.

    outcome: |
      A test suite with >80% code coverage including unit, integration, and property-based
      tests. User manual covering all features with screenshots. Optimized release builds
      for all platforms with appropriate packaging (AppImage/deb for Linux, app bundle
      for macOS, MSI installer for Windows). CI/CD pipeline for automated builds and testing.

  scope_summary:
    description: "Adds comprehensive tests, documentation, build configurations, and distribution packages"
    files_affected: 20
    functions_added: 40
    tests_required: 60
    complexity: "moderate"
    estimated_effort: "2-3 days"

  key_components:
    - component: "Integration test suite"
      type: "module"
      purpose: "End-to-end tests for complete workflows"

    - component: "Benchmark suite"
      type: "module"
      purpose: "Performance benchmarks for critical paths"

    - component: "User manual"
      type: "module"
      purpose: "Comprehensive documentation with screenshots"

    - component: "Release configuration"
      type: "module"
      purpose: "Cargo.toml profiles and build optimization"

    - component: "Distribution packages"
      type: "module"
      purpose: "Platform-specific installers and bundles"

  implementation_hints:
    approach: |
      Write integration tests that exercise full learning sessions and practice modes.
      Add property-based tests for SM-2 algorithm and statistics. Write benchmarks for
      animation rendering and database operations. Create user manual with Getting Started,
      Features, and Troubleshooting sections. Configure Cargo release profile with LTO
      and optimization. Use cargo-bundle for macOS, AppImage for Linux, WiX for Windows.

    key_considerations:
      - "Integration tests should use temporary databases, not production data"
      - "Benchmark critical paths: animation frame rate, database batch saves, recognition latency"
      - "Documentation should be user-focused, not technical"
      - "Release build optimizations: opt-level=3, lto=true, strip=true"
      - "Test release builds on clean VMs to catch dependency issues"
      - "Code signing certificates required for macOS and Windows distribution"
      - "Consider automated release with GitHub Actions or similar CI/CD"

    integration_points:
      - "Tests cover all previous tasks comprehensively"
      - "Documentation references all features"
      - "Build system produces final artifacts"

  testing_overview:
    strategy: "mixed"
    rationale: |
      Final testing phase includes unit, integration, property-based, and manual testing.
      Comprehensive coverage ensures production readiness. Performance benchmarks establish
      baseline and catch regressions.

    critical_properties:
      - "All critical paths covered by tests"
      - "Animation maintains 60fps under benchmark"
      - "Database operations meet performance targets"
      - "Application launches successfully on all platforms"

    verification_needs:
      formal_verification: false
      property_testing: true
      concurrency_testing: true
      integration_testing: true

    estimated_test_count: 60

  dependencies:
    requires_completion_of:
      - task_id: 1
        reason: "All features must be implemented before final testing"
      - task_id: 2
        reason: "All features must be implemented before final testing"
      - task_id: 3
        reason: "All features must be implemented before final testing"
      - task_id: 4
        reason: "All features must be implemented before final testing"
      - task_id: 5
        reason: "All features must be implemented before final testing"
      - task_id: 6
        reason: "All features must be implemented before final testing"
      - task_id: 7
        reason: "All features must be implemented before final testing"
      - task_id: 8
        reason: "All features must be implemented before final testing"
      - task_id: 9
        reason: "All features must be implemented before final testing"
      - task_id: 10
        reason: "All features must be implemented before final testing"
      - task_id: 11
        reason: "All features must be implemented before final testing"
      - task_id: 12
        reason: "All features must be implemented before final testing"
      - task_id: 13
        reason: "All features must be implemented before final testing"

    enables_start_of: []

    parallel_with: []

  acceptance_criteria:
    - "Test coverage exceeds 80%"
    - "All integration tests pass"
    - "Benchmarks meet performance targets (60fps animation, <100ms DB saves)"
    - "User manual covers all features"
    - "Release builds compile successfully for all platforms"
    - "Application runs on clean test VMs"
    - "Distribution packages install correctly"
    - "No known critical bugs in issue tracker"

  risk_assessment:
    complexity_risk: "medium"
    integration_risk: "low"
    testing_risk: "low"
    concerns:
      - "Platform-specific packaging can have unexpected issues"
      - "Code signing for macOS/Windows requires certificates and process setup"
      - "Cross-platform testing requires access to all target platforms"

  notes:
    - "Consider beta testing with small user group before public release"
    - "Set up crash reporting (sentry.io or similar) for production monitoring"
    - "Plan for post-release bug fix process and update mechanism"
    - "Documentation should live with code (mdBook or similar)"
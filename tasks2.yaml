task:
  id: 1
  name: "Project Structure and Application Foundation"

context:
  description: |
    This task establishes the foundational Rust project structure with iced GUI framework
    integration, including proper module organization, dependency configuration, and basic
    application scaffolding. This creates the skeleton that all other components will build upon.
    
    A well-organized project structure is critical for maintainability and scalability.
    The modular architecture separates concerns (UI, state, models, persistence, scheduling)
    allowing parallel development of features. Proper iced integration from the start ensures
    the Elm architecture pattern is correctly implemented.
    
    The outcome is a compilable Rust application with iced GUI framework configured, module
    structure in place, and a basic "Hello World" window that demonstrates the application
    lifecycle. All dependencies are properly configured in Cargo.toml with appropriate feature
    flags.

  key_points:
    - "Use iced 0.13 with canvas, tokio, and advanced features enabled for cosmic-text compatibility"
    - "Follow Elm architecture pattern with Application trait implementing new, title, update, and view methods"
    - "Set up proper Cargo.toml [profile.release] optimizations from the start for production builds"
    - "Include directories crate for cross-platform data path detection"
    - "Embed fonts using include_bytes!() for portability"
    - "Create module structure separating state/, ui/, models/, persistence/, scheduler/, data/ concerns"
    - "All modules export through mod.rs files for clean API boundaries"

files:
  - path: "Cargo.toml"
    description: "Project manifest with dependency configurations, feature flags, and build profiles"
  - path: "src/main.rs"
    description: "Application entry point implementing the iced::Application trait and main function"
  - path: "src/lib.rs"
    description: "Library root module declaring and exporting all submodules"
  - path: "src/state/mod.rs"
    description: "State management module placeholder for application state"
  - path: "src/ui/mod.rs"
    description: "UI components and view logic module placeholder"
  - path: "src/models/mod.rs"
    description: "Data models and domain types module placeholder"
  - path: "src/persistence/mod.rs"
    description: "Data persistence and storage module placeholder"
  - path: "src/scheduler/mod.rs"
    description: "Scheduling logic and algorithms module placeholder"
  - path: "src/data/mod.rs"
    description: "Data utilities and cross-platform path handling module placeholder"
  - path: ".gitignore"
    description: "Git ignore file for Rust projects excluding target/ and build artifacts"

functions:
  - file: "src/main.rs"
    items:
      - type: "function"
        name: "main"
        description: "Application entry point that initializes and runs the iced application with configured settings"
        preconditions: "iced dependencies are properly configured in Cargo.toml"
        postconditions: "Application window is created and event loop is started, or error is returned"
        invariants: "Must call iced::application() to create application runner"
      
      - type: "struct"
        name: "App"
        description: "Main application structure that implements iced::Application trait, managing application state and lifecycle"
        invariants: "Implements Application trait with Message, Theme, and Executor associated types"
      
      - type: "trait_impl"
        name: "iced::Application for App"
        description: "Implementation of iced's Application trait providing core application behavior following Elm architecture"
        invariants: "Must implement all required methods: new, title, update, view"
      
      - type: "method"
        name: "App::new"
        description: "Constructor method required by iced::Application trait, creates initial application state"
        postconditions: "Returns initialized App instance with default state"
      
      - type: "method"
        name: "App::title"
        description: "Provides window title string for the application"
        postconditions: "Returns string slice containing application title"
        invariants: "Returns consistent title throughout application lifecycle"
      
      - type: "method"
        name: "App::update"
        description: "Handles state transitions in response to messages following Elm architecture update pattern"
        preconditions: "Valid Message is provided"
        postconditions: "Application state is updated according to message, Command is returned for side effects"
      
      - type: "method"
        name: "App::view"
        description: "Renders current application state into iced UI elements"
        preconditions: "Application state is valid"
        postconditions: "Returns Element containing UI representation of current state"
        invariants: "Pure function with no side effects, deterministic output for given state"
      
      - type: "enum_variant"
        name: "Message"
        description: "Message type representing all possible user interactions and system events in the application"
        invariants: "Used as associated type in Application trait implementation"

  - file: "src/state/mod.rs"
    items:
      - type: "module_declaration"
        name: "state"
        description: "Module declaration for state management components, organizing application state structures"

  - file: "src/ui/mod.rs"
    items:
      - type: "module_declaration"
        name: "ui"
        description: "Module declaration for user interface components and view rendering logic"

  - file: "src/models/mod.rs"
    items:
      - type: "module_declaration"
        name: "models"
        description: "Module declaration for data models representing domain entities like Character, Attribute, etc."

  - file: "src/persistence/mod.rs"
    items:
      - type: "module_declaration"
        name: "persistence"
        description: "Module declaration for data persistence layer handling save/load operations"

  - file: "src/scheduler/mod.rs"
    items:
      - type: "module_declaration"
        name: "scheduler"
        description: "Module declaration for quest scheduling and temporal tracking components"

  - file: "src/data/mod.rs"
    items:
      - type: "module_declaration"
        name: "data"
        description: "Module declaration for embedded data resources like fonts and default templates"

  - file: "Cargo.toml"
    items:
      - type: "constant"
        name: "dependencies.iced"
        description: "iced GUI framework dependency with version 0.13, enabling canvas, tokio, and advanced features"
        invariants: "Version locked to 0.13.x for cosmic-text compatibility"
      
      - type: "constant"
        name: "dependencies.serde"
        description: "Serialization framework with derive feature for data persistence"
        invariants: "Must include derive feature for automatic Serialize/Deserialize implementation"
      
      - type: "constant"
        name: "dependencies.serde_json"
        description: "JSON serialization backend for character sheet persistence"
      
      - type: "constant"
        name: "dependencies.directories"
        description: "Cross-platform user data directory detection for save file location"
      
      - type: "constant"
        name: "dependencies.chrono"
        description: "Date and time handling for quest scheduling and temporal tracking"
        invariants: "Must include serde feature for date serialization"
      
      - type: "constant"
        name: "profile.release"
        description: "Release build optimization profile configuration"
        postconditions: "Binary is optimized for size and performance with LTO enabled"

formal_verification:
  needed: false
  level: "None"
  explanation: |
    Formal verification is not needed for this task because it establishes basic project
    scaffolding with no complex logic, algorithms, or critical safety properties to verify.
    
    The task involves:
    1. Creating directory structure and module files (file system operations)
    2. Configuring dependencies in Cargo.toml (build configuration)
    3. Implementing minimal iced::Application trait with placeholder methods
    4. Opening a basic "Hello World" window
    
    These operations are:
    - Deterministic and straightforward (no complex state transitions)
    - Validated by the Rust compiler (type safety, borrow checker)
    - Verified through compilation success and basic smoke tests
    - Non-critical foundation code with no data integrity, security, or correctness concerns
    
    The acceptance criteria (successful compilation and window display) provide sufficient
    validation that the structure is correctly established. Any structural issues will be
    caught immediately by compilation errors or runtime failures during smoke testing.
    
    Future tasks building on this foundation may require verification if they implement
    complex algorithms, handle critical data operations, or manage concurrent state, but
    the foundational scaffolding itself does not warrant formal verification effort.

tests:
  strategy:
    approach: "unit tests with basic integration smoke tests"
    rationale:
      - "At this foundational stage, we need to verify project structure integrity and dependency resolution"
      - "Unit tests confirm module organization and accessibility"
      - "Integration smoke tests verify iced Application trait implementation compiles and basic window lifecycle works"
      - "No complex logic exists yet, so focus on structural validation and build system verification"
      - "Tests should run quickly and catch configuration/dependency issues early"

  implementation:
    file: "src/main.rs"
    location: "in existing test module at end of file"
    code: |
      #[cfg(test)]
      mod tests {
          use super::*;

          #[test]
          fn test_application_compiles() {
              // Verify that the main application struct exists and implements required traits
              // This is a compile-time test - if it compiles, the structure is correct
              fn assert_implements_application<T: iced::Application>() {}
              assert_implements_application::<HabitTrackerApp>();
          }

          #[test]
          fn test_module_structure_exists() {
              // Verify all core modules are accessible
              // These should compile if modules are properly declared
              
              // State module
              let _ = std::any::type_name::<crate::state::AppState>();
              
              // Models module
              let _ = std::any::type_name::<crate::models::Character>();
              
              // UI module structure should be accessible
              // (specific types will be added in later tasks)
              
              // This test passing means mod.rs files are correctly set up
              assert!(true, "Module structure is accessible");
          }

          #[test]
          fn test_dependency_versions() {
              // Verify key dependency features are available at compile time
              // This ensures Cargo.toml is correctly configured
              
              // iced with required features
              let _ = iced::Application::run;
              
              // directories crate for data paths
              let _ = directories::ProjectDirs::from;
              
              assert!(true, "All required dependencies are accessible");
          }

          #[test]
          fn test_application_messages_defined() {
              // Verify Message enum exists and is usable
              // The actual variants will be tested in later tasks
              fn assert_message_type<T: Clone + std::fmt::Debug>() {}
              assert_message_type::<Message>();
          }
      }

      // Separate integration test module for runtime behavior
      #[cfg(test)]
      mod integration_tests {
          use super::*;

          #[test]
          fn test_application_settings_valid() {
              // Test that application settings can be created without panic
              let settings = HabitTrackerApp::settings();
              
              // Verify window settings are configured
              assert!(settings.window.size.width > 0.0);
              assert!(settings.window.size.height > 0.0);
          }

          #[test]
          fn test_application_new_initializes() {
              // Test that application can be instantiated
              let app = HabitTrackerApp::new();
              
              // Verify basic initialization (specific fields depend on implementation)
              // At minimum, this should not panic
              assert!(std::mem::size_of_val(&app) > 0);
          }

          #[test]
          fn test_update_handles_empty_message_queue() {
              // Test that update method handles basic message processing
              let mut app = HabitTrackerApp::new();
              
              // This is a placeholder - actual messages will be tested in later tasks
              // For now, verify the method exists and can be called
              // Specific message handling will be tested when messages are implemented
          }

          #[test]
          fn test_view_returns_valid_element() {
              // Test that view method returns a valid iced Element
              let app = HabitTrackerApp::new();
              let _element = app.view();
              
              // If this compiles and runs, the view method is correctly implemented
              assert!(true, "View method returns valid Element");
          }

          #[test]
          fn test_project_directories_accessible() {
              // Verify that project directories can be determined
              // This tests cross-platform data path detection
              let proj_dirs = directories::ProjectDirs::from("com", "habittracker", "HabitTracker");
              
              assert!(proj_dirs.is_some(), "Project directories should be determinable on this platform");
              
              if let Some(dirs) = proj_dirs {
                  let data_dir = dirs.data_dir();
                  assert!(data_dir.to_str().is_some(), "Data directory path should be valid UTF-8");
              }
          }

          #[test]
          fn test_embedded_fonts_accessible() {
              // Verify that font embedding works (if fonts are embedded in this task)
              // This ensures include_bytes!() macro is correctly used
              // Note: This test should be uncommented once fonts are actually embedded
              
              // Example when fonts are added:
              // const FONT_DATA: &[u8] = include_bytes!("../assets/font.ttf");
              // assert!(FONT_DATA.len() > 0, "Embedded font data should be non-empty");
              
              // For now, just verify the pattern works with a dummy file
              assert!(true, "Font embedding pattern verified");
          }
      }

      // Build-time verification tests
      #[cfg(test)]
      mod build_tests {
          #[test]
          fn test_cargo_configuration() {
              // Verify this is being compiled with expected Rust edition
              // This is a compile-time assertion
              
              #[cfg(not(any(edition2021, edition2024)))]
              compile_error!("Project should use Rust edition 2021 or later");
              
              assert!(true, "Cargo edition configuration verified");
          }

          #[test]
          fn test_required_features_enabled() {
              // Verify iced features are enabled at compile time
              
              #[cfg(not(feature = "canvas"))]
              compile_error!("iced canvas feature must be enabled");
              
              #[cfg(not(feature = "tokio"))]
              compile_error!("iced tokio feature must be enabled");
              
              // Note: These compile_error! macros should only trigger if features are missing
              // For standard builds, this test just passes
              assert!(true, "Required features verified");
          }
      }

  coverage:
    - "Application struct implements iced::Application trait"
    - "Message enum is properly defined with required traits (Clone, Debug)"
    - "All core module declarations exist and are accessible (state, models, ui, persistence, scheduler, data)"
    - "Module structure allows imports from submodules"
    - "Application settings can be created with valid window configuration"
    - "Application can be instantiated without panicking"
    - "Update method exists and can process messages"
    - "View method returns valid iced Element"
    - "Project directories can be determined cross-platform using directories crate"
    - "Data directory paths are valid UTF-8 strings"
    - "Embedded font pattern is correctly set up (verification for include_bytes!)"
    - "Cargo.toml uses Rust edition 2021 or later"
    - "Required iced features (canvas, tokio, advanced) are enabled"
    - "All required dependencies are accessible and resolve correctly"
    - "Project compiles successfully without errors"

dependencies:
  depends_on: []

  depended_upon_by:
    - task_id: 2
      reason: "Character data structures need module structure to exist"
    - task_id: 3
      reason: "Font loading requires application foundation"
    - task_id: 6
      reason: "State management builds on application structure"

  external:
    - name: "iced"
      type: "crate"
      status: "to be imported"
    - name: "iced::Application"
      type: "trait"
      status: "to be imported"
    - name: "serde"
      type: "crate"
      status: "to be imported"
    - name: "serde_json"
      type: "crate"
      status: "to be imported"
    - name: "directories"
      type: "crate"
      status: "to be imported"
    - name: "chrono"
      type: "crate"
      status: "to be imported"
---
task:
  id: 2
  name: "Character Data Structures and Loading System"

context:
  description: |
    This task establishes the foundational character database for the hiragana/katakana learning
    application. It defines core data structures (CharData, StrokeData) that represent individual
    kana characters with all necessary metadata including Unicode values, romanization mappings,
    SVG stroke paths, and frequency rankings. The implementation uses compile-time perfect hash
    maps (phf) for zero-cost O(1) character lookups, with data serialized in human-readable RON
    format for maintainability.
    
    Character data is the cornerstone of the entire learning system - flashcards need character
    metadata for presentation, the stroke animation engine requires path data to render writing
    sequences, and the spaced repetition scheduler uses frequency rankings for optimal learning
    order. The choice of compile-time embedding via phf::Map trades binary size for runtime
    performance, eliminating initialization overhead and ensuring deterministic lookup latency.
    
    The task involves extracting stroke path data from existing SVG sources (kana-svg-data or
    animCJK repositories), converting it to RON format with calculated median points for stroke
    direction visualization, and building a compile-time database covering all 92 basic kana
    characters (46 hiragana + 46 katakana).

  key_points:
    - "Uses phf (perfect hash function) for compile-time hash map generation with zero runtime cost"
    - "RON (Rusty Object Notation) chosen for human-readable, version-controllable character data"
    - "Stroke paths stored as SVG path strings, parsed on-demand for animation rendering"
    - "Median points pre-calculated for each stroke to enable direction arrow visualization"
    - "Frequency rank metadata enables presentation of common characters first for efficient learning"
    - "Dual lookup capability: by Unicode character and by romanization string"
    - "Data embedded at compile-time using include_str!() macro to avoid runtime I/O"
    - "Separate hiragana.ron and katakana.ron files for modular data management"

files:
  - path: "src/models/character.rs"
    description: "Defines the CharData struct representing a kana character with Unicode, romanization, stroke paths, and metadata"
  
  - path: "src/models/mod.rs"
    description: "Module declaration file that exports the character module"
  
  - path: "src/data/hiragana.ron"
    description: "RON-formatted data file containing all 46 hiragana characters with stroke information"
  
  - path: "src/data/katakana.ron"
    description: "RON-formatted data file containing all 46 katakana characters with stroke information"
  
  - path: "src/db/character_db.rs"
    description: "Character database implementation with phf-based lookup for O(1) character retrieval"
  
  - path: "src/db/mod.rs"
    description: "Module declaration file that exports the character_db module"
  
  - path: "build.rs"
    description: "Build script that generates perfect hash map from RON data files at compile time"

functions:
  - file: "src/models/character.rs"
    items:
      - type: "struct"
        name: "CharData"
        description: "Core data structure representing a kana character with metadata, stroke paths, and romanization"
        invariants: "unicode field contains valid Unicode scalar value; strokes.len() matches stroke_count; romanization is non-empty ASCII string"
      
      - type: "struct"
        name: "StrokeData"
        description: "Represents a single stroke with SVG path and optional median points for direction visualization"
        invariants: "svg_path is valid SVG path syntax; median_points contains normalized coordinates in [0,1] range"
      
      - type: "enum"
        name: "CharacterSet"
        description: "Distinguishes between hiragana and katakana character sets"
      
      - type: "function"
        name: "get_character"
        description: "Looks up character data by Unicode character, returning Option<&CharData>"
        preconditions: "Character database is initialized"
        postconditions: "Returns Some(&CharData) if character exists in hiragana or katakana sets, None otherwise"
      
      - type: "function"
        name: "get_character_by_romanization"
        description: "Looks up character data by romanization string (e.g. 'ka'), returning Option<&CharData>"
        preconditions: "Character database is initialized; input is ASCII lowercase"
        postconditions: "Returns Some(&CharData) if romanization matches, None otherwise"
      
      - type: "function"
        name: "get_all_hiragana"
        description: "Returns iterator over all hiragana CharData entries"
        postconditions: "Returns iterator yielding exactly 46 hiragana characters"
      
      - type: "function"
        name: "get_all_katakana"
        description: "Returns iterator over all katakana CharData entries"
        postconditions: "Returns iterator yielding exactly 46 katakana characters"

  - file: "src/db/character_db.rs"
    items:
      - type: "constant"
        name: "HIRAGANA_DATA"
        description: "Compile-time embedded string containing hiragana.ron file contents"
      
      - type: "constant"
        name: "KATAKANA_DATA"
        description: "Compile-time embedded string containing katakana.ron file contents"
      
      - type: "function"
        name: "init_character_database"
        description: "Initializes the character database by parsing RON data and building lookup structures"
        preconditions: "Called before any character lookups"
        postconditions: "Global character database is populated with all 92 kana characters"
      
      - type: "function"
        name: "build_phf_map"
        description: "Constructs perfect hash map from parsed character data for O(1) lookups"
        preconditions: "Character data has been deserialized from RON"
        postconditions: "Returns phf::Map<char, CharData> with all characters indexed by Unicode value"
      
      - type: "function"
        name: "build_romanization_map"
        description: "Constructs secondary index mapping romanization strings to character data"
        preconditions: "Character data has been deserialized from RON"
        postconditions: "Returns phf::Map<&str, CharData> with all characters indexed by romanization"

  - file: "src/models/svg_parser.rs"
    items:
      - type: "function"
        name: "parse_svg_path"
        description: "Parses SVG path string into internal stroke representation for animation"
        preconditions: "Input is valid SVG path syntax (M, L, C, Q, Z commands)"
        postconditions: "Returns Result<Vec<PathSegment>, ParseError> with parsed segments or error"
      
      - type: "function"
        name: "calculate_median_point"
        description: "Computes median point along stroke path for direction arrow visualization"
        preconditions: "Path contains at least 2 points"
        postconditions: "Returns (x, y) normalized coordinates in [0,1] range representing path midpoint"
      
      - type: "enum"
        name: "PathSegment"
        description: "Represents SVG path commands (MoveTo, LineTo, CurveTo, etc.)"
      
      - type: "struct"
        name: "ParseError"
        description: "Error type for SVG path parsing failures with diagnostic information"

  - file: "src/data/hiragana.ron"
    items:
      - type: "constant"
        name: "hiragana_data_structure"
        description: "RON-serialized array of 46 hiragana CharData entries with Unicode values, romanization, stroke paths, and metadata"

  - file: "src/data/katakana.ron"
    items:
      - type: "constant"
        name: "katakana_data_structure"
        description: "RON-serialized array of 46 katakana CharData entries with Unicode values, romanization, stroke paths, and metadata"

  - file: "tests/character_data_tests.rs"
    items:
      - type: "function"
        name: "test_all_hiragana_present"
        description: "Verifies all 46 hiragana characters are loadable from database"
        postconditions: "Asserts 46 unique hiragana characters with correct Unicode ranges"
      
      - type: "function"
        name: "test_all_katakana_present"
        description: "Verifies all 46 katakana characters are loadable from database"
        postconditions: "Asserts 46 unique katakana characters with correct Unicode ranges"
      
      - type: "function"
        name: "test_character_lookup_by_unicode"
        description: "Tests get_character function with known hiragana and katakana characters"
        postconditions: "Asserts correct CharData returned for valid characters, None for invalid"
      
      - type: "function"
        name: "test_character_lookup_by_romanization"
        description: "Tests get_character_by_romanization with common romanizations"
        postconditions: "Asserts correct CharData returned for 'a', 'ka', 'shi', etc."
      
      - type: "function"
        name: "test_stroke_count_validity"
        description: "Verifies stroke_count field matches actual strokes array length for all characters"
        postconditions: "Asserts strokes.len() == stroke_count for all 92 characters"
      
      - type: "function"
        name: "test_unicode_validity"
        description: "Validates Unicode code points are in correct ranges for hiragana/katakana"
        postconditions: "Asserts hiragana in U+3040-U+309F, katakana in U+30A0-U+30FF"
      
      - type: "function"
        name: "test_svg_path_parsing"
        description: "Tests parse_svg_path with sample stroke data from character database"
        postconditions: "Asserts all stroke paths parse without errors"
      
      - type: "function"
        name: "test_median_point_calculation"
        description: "Tests calculate_median_point with simple line and curve paths"
        postconditions: "Asserts median points are within [0,1] normalized coordinate space"
      
      - type: "function"
        name: "test_ron_deserialization"
        description: "Tests RON parsing of hiragana.ron and katakana.ron files"
        postconditions: "Asserts both files deserialize successfully to Vec<CharData>"
      
      - type: "function"
        name: "test_frequency_rank_ordering"
        description: "Verifies frequency_rank values enable proper ordering of character presentation"
        postconditions: "Asserts frequency_rank values are unique and cover expected range"
      
      - type: "function"
        name: "test_romanization_uniqueness"
        description: "Ensures no duplicate romanization values within same character set"
        postconditions: "Asserts all romanizations are unique within hiragana and katakana separately"
      
      - type: "function"
        name: "prop_all_characters_roundtrip"
        description: "Property test verifying character lookup and serialization roundtrip"
        postconditions: "For all characters: get_character(c.unicode).unwrap() == c"

formal_verification:
  needed: false
  level: "None"
  explanation: |
    Formal verification is not needed for this task because:
    
    1. **Static, Deterministic Data**: The character database consists of static, 
       predetermined data (92 kana characters with fixed Unicode values, stroke counts, 
       and SVG paths). There are no complex algorithms or state transitions to verify.
    
    2. **Data Integrity Through Testing**: The correctness of this system can be fully 
       validated through comprehensive unit and property-based tests that verify:
       - All 92 characters are present
       - Unicode values are valid
       - Stroke counts match expected values
       - SVG paths parse without errors
       - Lookup operations return correct results
    
    3. **No Safety-Critical Logic**: This task implements data structures and lookup 
       mechanisms without complex invariants, concurrency, or safety-critical properties 
       that would benefit from formal proof. The primary concern is data completeness 
       and correctness, not algorithmic correctness.
    
    4. **Simple Lookup Semantics**: The phf::Map provides O(1) lookup with well-understood 
       properties. The lookup function's behavior is straightforward: return Some(CharData) 
       if the character exists, None otherwise. This doesn't require formal verification.
    
    5. **Cost-Benefit Analysis**: The effort required for formal verification would 
       outweigh the benefits. Standard testing practices (unit tests for data integrity, 
       property-based tests for lookup correctness) provide sufficient confidence for 
       this foundational but non-critical component.
    
    Property-based testing will be more valuable here to verify that all characters 
    meet expected constraints (valid Unicode ranges, non-empty stroke data, etc.) 
    without the overhead of formal methods.

tests:
  strategy:
    approach: "mixed (unit tests + property-based testing)"
    rationale:
      - "Unit tests verify data integrity for all 92 characters (46 hiragana + 46 katakana)"
      - "Property-based tests ensure SVG path parsing robustness and handle edge cases"
      - "Static data validation ensures compile-time or load-time correctness"
      - "Lookup performance tests verify O(1) access pattern with phf::Map"
      - "Data completeness tests prevent missing or malformed character entries"
      - "SVG path validation ensures stroke animation compatibility"

  implementation:
    file: "tests/character_data_tests.rs"
    location: "create new"
    code: |
      #[cfg(test)]
      mod tests {
          use crate::models::character::*;
          use crate::db::character_db::*;
          
          #[test]
          fn test_char_data_struct_creation() {
              let char_data = CharData {
                  character: 'あ',
                  unicode: 0x3042,
                  romanization: "a".to_string(),
                  stroke_count: 3,
                  stroke_paths: vec![
                      "M10,10 L20,20".to_string(),
                      "M15,15 L25,25".to_string(),
                      "M5,5 L30,30".to_string(),
                  ],
                  median_points: vec![
                      (15.0, 15.0),
                      (20.0, 20.0),
                      (17.5, 17.5),
                  ],
                  frequency_rank: 1,
              };
              
              assert_eq!(char_data.character, 'あ');
              assert_eq!(char_data.unicode, 0x3042);
              assert_eq!(char_data.stroke_count, 3);
              assert_eq!(char_data.stroke_paths.len(), 3);
          }
          
          #[test]
          fn test_hiragana_database_completeness() {
              let hiragana_chars = vec![
                  'あ', 'い', 'う', 'え', 'お',
                  'か', 'き', 'く', 'け', 'こ',
                  'さ', 'し', 'す', 'せ', 'そ',
                  'た', 'ち', 'つ', 'て', 'と',
                  'な', 'に', 'ぬ', 'ね', 'の',
                  'は', 'ひ', 'ふ', 'へ', 'ほ',
                  'ま', 'み', 'む', 'め', 'も',
                  'や', 'ゆ', 'よ',
                  'ら', 'り', 'る', 'れ', 'ろ',
                  'わ', 'を', 'ん',
              ];
              
              for ch in hiragana_chars {
                  let result = get_character(ch);
                  assert!(result.is_some(), "Missing hiragana character: {}", ch);
                  assert_eq!(result.unwrap().character, ch);
              }
          }
          
          #[test]
          fn test_katakana_database_completeness() {
              let katakana_chars = vec![
                  'ア', 'イ', 'ウ', 'エ', 'オ',
                  'カ', 'キ', 'ク', 'ケ', 'コ',
                  'サ', 'シ', 'ス', 'セ', 'ソ',
                  'タ', 'チ', 'ツ', 'テ', 'ト',
                  'ナ', 'ニ', 'ヌ', 'ネ', 'ノ',
                  'ハ', 'ヒ', 'フ', 'ヘ', 'ホ',
                  'マ', 'ミ', 'ム', 'メ', 'モ',
                  'ヤ', 'ユ', 'ヨ',
                  'ラ', 'リ', 'ル', 'レ', 'ロ',
                  'ワ', 'ヲ', 'ン',
              ];
              
              for ch in katakana_chars {
                  let result = get_character(ch);
                  assert!(result.is_some(), "Missing katakana character: {}", ch);
                  assert_eq!(result.unwrap().character, ch);
              }
          }
          
          #[test]
          fn test_unicode_values_valid() {
              let hiragana = get_character('あ').unwrap();
              assert!(hiragana.unicode >= 0x3040 && hiragana.unicode <= 0x309F,
                      "Hiragana unicode out of range: {:x}", hiragana.unicode);
              
              let katakana = get_character('ア').unwrap();
              assert!(katakana.unicode >= 0x30A0 && katakana.unicode <= 0x30FF,
                      "Katakana unicode out of range: {:x}", katakana.unicode);
          }
          
          #[test]
          fn test_stroke_count_validity() {
              let char_data = get_character('あ').unwrap();
              assert!(char_data.stroke_count > 0, "Stroke count must be positive");
              assert!(char_data.stroke_count <= 10, "Stroke count unreasonably high");
              assert_eq!(
                  char_data.stroke_count,
                  char_data.stroke_paths.len(),
                  "Stroke count doesn't match paths length"
              );
          }
          
          #[test]
          fn test_stroke_paths_match_count() {
              for ch in get_all_hiragana() {
                  let data = get_character(ch).unwrap();
                  assert_eq!(
                      data.stroke_count,
                      data.stroke_paths.len(),
                      "Stroke count mismatch for '{}'", ch
                  );
              }
              
              for ch in get_all_katakana() {
                  let data = get_character(ch).unwrap();
                  assert_eq!(
                      data.stroke_count,
                      data.stroke_paths.len(),
                      "Stroke count mismatch for '{}'", ch
                  );
              }
          }
          
          #[test]
          fn test_median_points_match_strokes() {
              let char_data = get_character('あ').unwrap();
              assert_eq!(
                  char_data.median_points.len(),
                  char_data.stroke_count,
                  "Median points count doesn't match stroke count"
              );
          }
          
          #[test]
          fn test_romanization_not_empty() {
              for ch in get_all_hiragana() {
                  let data = get_character(ch).unwrap();
                  assert!(!data.romanization.is_empty(),
                          "Empty romanization for '{}'", ch);
              }
              
              for ch in get_all_katakana() {
                  let data = get_character(ch).unwrap();
                  assert!(!data.romanization.is_empty(),
                          "Empty romanization for '{}'", ch);
              }
          }
          
          #[test]
          fn test_frequency_rank_uniqueness() {
              use std::collections::HashSet;
              
              let mut hiragana_ranks = HashSet::new();
              for ch in get_all_hiragana() {
                  let data = get_character(ch).unwrap();
                  assert!(hiragana_ranks.insert(data.frequency_rank),
                          "Duplicate frequency rank: {}", data.frequency_rank);
              }
              
              let mut katakana_ranks = HashSet::new();
              for ch in get_all_katakana() {
                  let data = get_character(ch).unwrap();
                  assert!(katakana_ranks.insert(data.frequency_rank),
                          "Duplicate frequency rank: {}", data.frequency_rank);
              }
          }
          
          #[test]
          fn test_lookup_performance() {
              use std::time::Instant;
              
              let start = Instant::now();
              for _ in 0..10000 {
                  let _ = get_character('あ');
              }
              let duration = start.elapsed();
              
              assert!(duration.as_millis() < 10,
                      "Lookup too slow: {:?}", duration);
          }
          
          #[test]
          fn test_invalid_character_lookup() {
              assert!(get_character('A').is_none());
              assert!(get_character('漢').is_none());
          }
          
          #[test]
          fn test_svg_path_basic_parsing() {
              let char_data = get_character('あ').unwrap();
              
              for (i, path) in char_data.stroke_paths.iter().enumerate() {
                  assert!(!path.is_empty(), "Empty SVG path at stroke {}", i);
                  assert!(path.chars().next().unwrap().is_ascii_alphabetic(),
                          "Invalid SVG path start: {}", path);
              }
          }
      }
      
      #[cfg(test)]
      mod property_tests {
          use crate::models::character::*;
          use crate::db::character_db::*;
          use proptest::prelude::*;
          
          proptest! {
              #[test]
              fn prop_all_hiragana_lookups_succeed(ch in "[あ-ん]") {
                  let result = get_character(ch.chars().next().unwrap());
                  prop_assert!(result.is_some());
              }
              
              #[test]
              fn prop_all_katakana_lookups_succeed(ch in "[ア-ン]") {
                  let result = get_character(ch.chars().next().unwrap());
                  prop_assert!(result.is_some());
              }
              
              #[test]
              fn prop_stroke_paths_non_empty(idx in 0..46usize) {
                  let chars = get_all_hiragana();
                  if idx < chars.len() {
                      let ch = chars[idx];
                      let data = get_character(ch).unwrap();
                      for path in &data.stroke_paths {
                          prop_assert!(!path.is_empty());
                      }
                  }
              }
              
              #[test]
              fn prop_median_points_in_reasonable_range(idx in 0..46usize) {
                  let chars = get_all_hiragana();
                  if idx < chars.len() {
                      let ch = chars[idx];
                      let data = get_character(ch).unwrap();
                      for (x, y) in &data.median_points {
                          prop_assert!(*x >= -10.0 && *x <= 120.0,
                                      "X coordinate out of range: {}", x);
                          prop_assert!(*y >= -10.0 && *y <= 120.0,
                                      "Y coordinate out of range: {}", y);
                      }
                  }
              }
          }
      }

  coverage:
    - "CharData struct creation with all required fields"
    - "Hiragana database contains all 46 characters"
    - "Katakana database contains all 46 characters"
    - "Unicode values are in correct ranges (Hiragana: U+3040-U+309F, Katakana: U+30A0-U+30FF)"
    - "Stroke counts are positive and reasonable (1-10)"
    - "Stroke count matches stroke_paths array length for all characters"
    - "Median points count matches stroke count for all characters"
    - "Romanization strings are non-empty for all characters"
    - "Frequency ranks are unique within each character set"
    - "Lookup performance is O(1) (phf::Map verification)"
    - "Invalid character lookups return None"
    - "SVG paths have valid basic format (non-empty, start with command)"
    - "Property: All valid hiragana characters have database entries"
    - "Property: All valid katakana characters have database entries"
    - "Property: All stroke paths are non-empty strings"
    - "Property: Median points are within reasonable SVG coordinate ranges"

dependencies:
  depends_on:
    - task_id: 1
      reason: "Needs models/ module structure to exist before defining character.rs"

  depended_upon_by:
    - task_id: 3
      reason: "Font rendering needs character data to display kana correctly"
    - task_id: 4
      reason: "Stroke animation requires stroke path data from CharData"
    - task_id: 7
      reason: "Flashcard system needs character database for card generation"

  external:
    - name: "phf"
      type: "crate"
      status: "to be imported"
    - name: "serde"
      type: "crate"
      status: "to be imported"
    - name: "ron"
      type: "crate"
      status: "to be imported"
    - name: "proptest"
      type: "crate"
      status: "to be imported"
---
task:
  id: 3
  name: "Japanese Font Integration and Text Rendering"

context:
  description: |
    Integrate a Japanese font (Noto Sans JP) into the iced application and configure
    cosmic-text for proper Unicode rendering of hiragana and katakana characters.
    Create a custom CharacterCard widget for flashcard-style character display with
    configurable sizing and styling.
    
    Proper Japanese text rendering is non-negotiable for a kana learning application.
    Iced's cosmic-text backend supports full Unicode, but requires explicit font loading
    and shaping configuration. A custom widget abstracts rendering complexity and provides
    consistent character presentation across the application.
    
    The implementation embeds Noto Sans JP font using include_bytes!() for portability,
    loads it during application initialization, and provides a reusable CharacterCard
    widget that leverages cosmic-text's advanced shaping capabilities to ensure correct
    glyph rendering for all kana characters.

  key_points:
    - "Font is embedded at compile time using include_bytes!() for cross-platform portability"
    - "Must use Shaping::Advanced in cosmic-text for proper Japanese character rendering"
    - "CharacterCard widget abstracts rendering complexity and provides consistent flashcard-style display"
    - "Noto Sans JP Regular (~900KB) provides comprehensive kana coverage with clean, readable glyphs"
    - "Font loading happens once at application startup in Application::new()"
    - "Widget implements iced::Widget trait for full integration with iced's layout and rendering pipeline"
    - "Text centering (both horizontal and vertical) is critical for flashcard aesthetic"
    - "Consider font subsetting in future to reduce binary size to ~100KB for kana-only subset"

files:
  - path: "assets/fonts/NotoSansJP-Regular.otf"
    description: "Embedded Noto Sans JP Regular font file for Japanese character rendering"
  - path: "src/main.rs"
    description: "Application entry point - modified to load Japanese font at startup"
  - path: "src/ui/mod.rs"
    description: "UI module declaration - modified to include character_card submodule"
  - path: "src/ui/character_card.rs"
    description: "Custom CharacterCard widget implementation for flashcard-style kana display"

functions:
  - file: "src/main.rs"
    items:
      - type: "constant"
        name: "NOTO_SANS_JP_BYTES"
        description: "Embedded Noto Sans JP font file loaded at compile time using include_bytes!()"
        invariants: "Contains valid OTF/TTF font data that can be parsed by cosmic-text"
      
      - type: "method"
        name: "Application::new"
        description: "Modified to load the embedded Japanese font into iced's font system during application initialization"
        preconditions: "NOTO_SANS_JP_BYTES contains valid font data"
        postconditions: "Font is registered with iced and available for text rendering; returns error if font loading fails"

  - file: "src/ui/mod.rs"
    items:
      - type: "module_declaration"
        name: "character_card"
        description: "Module containing the CharacterCard widget implementation"

  - file: "src/ui/character_card.rs"
    items:
      - type: "struct"
        name: "CharacterCard"
        description: "Custom iced widget for displaying a single kana character in flashcard style with configurable size and styling"
        invariants: "Character must be valid Unicode; size must be positive"
      
      - type: "struct"
        name: "CharacterCardStyle"
        description: "Configuration struct for CharacterCard appearance including font size, colors, padding, and optional stroke order overlay settings"
        invariants: "Font size >= 12.0; colors are valid; padding >= 0.0"
      
      - type: "method"
        name: "CharacterCard::new"
        description: "Creates a new CharacterCard widget with specified character and default styling"
        preconditions: "Character is a valid Unicode string (ideally single kana character)"
        postconditions: "Returns CharacterCard instance with character stored and default style applied"
      
      - type: "method"
        name: "CharacterCard::with_style"
        description: "Builder method to customize the CharacterCard's appearance"
        preconditions: "CharacterCard instance exists; style contains valid values"
        postconditions: "Returns CharacterCard with updated style settings"
      
      - type: "method"
        name: "CharacterCard::size"
        description: "Builder method to set the font size for character display"
        preconditions: "Size is positive (size > 0.0)"
        postconditions: "Returns CharacterCard with updated font size"
      
      - type: "trait_impl"
        name: "Widget<Message> for CharacterCard"
        description: "Implementation of iced::Widget trait for CharacterCard to integrate with iced's rendering system"
        invariants: "Rendering uses Shaping::Advanced for proper Japanese glyph shaping"
      
      - type: "method"
        name: "CharacterCard::width"
        description: "Widget trait method returning the width requirement for layout calculation"
        postconditions: "Returns Length::Shrink or calculated width based on font metrics"
      
      - type: "method"
        name: "CharacterCard::height"
        description: "Widget trait method returning the height requirement for layout calculation"
        postconditions: "Returns Length::Shrink or calculated height based on font metrics"
      
      - type: "method"
        name: "CharacterCard::layout"
        description: "Widget trait method calculating layout bounds for the character card"
        preconditions: "Renderer is initialized; font is loaded"
        postconditions: "Returns layout node with properly calculated bounds for character rendering"
      
      - type: "method"
        name: "CharacterCard::draw"
        description: "Widget trait method rendering the character using cosmic-text with proper Unicode shaping"
        preconditions: "Font is loaded; layout has been calculated; renderer is in valid state"
        postconditions: "Character is rendered centered in the widget bounds with correct glyph shaping; no missing glyph boxes appear"
        invariants: "Uses Shaping::Advanced; text is horizontally and vertically centered"
      
      - type: "function"
        name: "center_text"
        description: "Helper function to calculate text position for centering within given bounds"
        preconditions: "Bounds are valid; text metrics are available"
        postconditions: "Returns Point coordinates for centered text rendering"

  - file: "assets/fonts/README.md"
    items:
      - type: "constant"
        name: "FONT_SOURCE"
        description: "Documentation of Noto Sans JP font source URL and license information (SIL Open Font License)"

  - file: "src/config.rs"
    items:
      - type: "constant"
        name: "DEFAULT_CHARACTER_SIZE"
        description: "Default font size for character display (64.0px)"
        invariants: "Value is 64.0"
      
      - type: "constant"
        name: "SMALL_CHARACTER_SIZE"
        description: "Small font size for compact character display (48.0px)"
        invariants: "Value is 48.0"
      
      - type: "constant"
        name: "LARGE_CHARACTER_SIZE"
        description: "Large font size for emphasis character display (72.0px)"
        invariants: "Value is 72.0"
      
      - type: "constant"
        name: "FONT_FAMILY_NAME"
        description: "Exact font family name string for Noto Sans JP to use with Font::with_name()"
        invariants: "Matches the internal font family name in the embedded font file"

formal_verification:
  needed: false
  level: "None"
  explanation: |
    Formal verification is not needed for this task because:
    
    1. Font loading and text rendering are handled by mature, well-tested libraries
       (iced's font system and cosmic-text). The correctness of glyph shaping and
       rendering is the responsibility of these battle-tested dependencies, not our
       application code.
    
    2. The CharacterCard widget is primarily a presentation component with no complex
       state management, critical algorithms, or safety-critical behavior. Its core
       responsibility is visual layout and rendering delegation to the graphics backend.
    
    3. Failure modes are benign and easily observable: missing glyphs, incorrect sizing,
       or layout issues are immediately visible during development and testing. These
       are quality-of-implementation issues rather than correctness-critical bugs.
    
    4. The embedded font data is static (loaded via include_bytes!()) with no runtime
       modification, eliminating concerns about data corruption or state inconsistency.
    
    5. Integration testing with visual inspection and automated glyph presence checks
       provides sufficient confidence that the system works correctly. The properties
       we care about (correct rendering, no missing glyphs, proper sizing) are effectively
       verified through integration tests that exercise the full rendering pipeline.
    
    6. This is a UI/presentation layer component in an educational application, not a
       safety-critical system, cryptographic implementation, or concurrent data structure
       where formal verification would provide substantial value.
    
    Integration testing with actual font files and visual verification is the appropriate
    validation strategy for text rendering components.

tests:
  strategy:
    approach: "integration with unit components"
    rationale:
      - "Font rendering requires integration with iced's rendering pipeline and cosmic-text, making pure unit tests insufficient"
      - "Individual components (font loading, widget construction) can be unit tested for correctness"
      - "Critical visual properties (glyph presence, sizing) need integration-level verification"
      - "Platform-specific font loading behavior requires runtime validation"
      - "Character coverage testing ensures all required kana render without missing glyphs"

  implementation:
    file: "src/ui/widgets/character_card.rs"
    location: "in existing test module"
    code: |
      #[cfg(test)]
      mod tests {
          use super::*;
          use iced::widget::Text;
          use iced::{Font, Element, Length};

          /// Test that CharacterCard can be constructed with valid parameters
          #[test]
          fn test_character_card_construction() {
              let card = CharacterCard::new('あ')
                  .size(64.0)
                  .font(Font::default());
              
              assert_eq!(card.character(), 'あ');
              assert_eq!(card.size(), 64.0);
          }

          /// Test CharacterCard with various size configurations
          #[test]
          fn test_character_card_sizes() {
              let sizes = [48.0, 64.0, 72.0, 96.0, 128.0];
              
              for size in sizes {
                  let card = CharacterCard::new('あ').size(size);
                  assert_eq!(card.size(), size);
                  assert!(card.size() > 0.0, "Size must be positive");
              }
          }

          /// Test that CharacterCard accepts all hiragana characters
          #[test]
          fn test_character_card_hiragana_characters() {
              let hiragana_chars = [
                  'あ', 'い', 'う', 'え', 'お',
                  'か', 'き', 'く', 'け', 'こ',
                  'さ', 'し', 'す', 'せ', 'そ',
                  'た', 'ち', 'つ', 'て', 'と',
                  'な', 'に', 'ぬ', 'ね', 'の',
                  'は', 'ひ', 'ふ', 'へ', 'ほ',
                  'ま', 'み', 'む', 'め', 'も',
                  'や', 'ゆ', 'よ',
                  'ら', 'り', 'る', 'れ', 'ろ',
                  'わ', 'を', 'ん',
                  'が', 'ぎ', 'ぐ', 'げ', 'ご',
                  'ざ', 'じ', 'ず', 'ぜ', 'ぞ',
                  'だ', 'ぢ', 'づ', 'で', 'ど',
                  'ば', 'び', 'ぶ', 'べ', 'ぼ',
                  'ぱ', 'ぴ', 'ぷ', 'ぺ', 'ぽ',
                  'きゃ', 'きゅ', 'きょ',
              ];

              for &ch in &hiragana_chars {
                  let card = CharacterCard::new(ch);
                  assert_eq!(card.character(), ch);
              }
          }

          /// Test that CharacterCard accepts all katakana characters
          #[test]
          fn test_character_card_katakana_characters() {
              let katakana_chars = [
                  'ア', 'イ', 'ウ', 'エ', 'オ',
                  'カ', 'キ', 'ク', 'ケ', 'コ',
                  'サ', 'シ', 'ス', 'セ', 'ソ',
                  'タ', 'チ', 'ツ', 'テ', 'ト',
                  'ナ', 'ニ', 'ヌ', 'ネ', 'ノ',
                  'ハ', 'ヒ', 'フ', 'ヘ', 'ホ',
                  'マ', 'ミ', 'ム', 'メ', 'モ',
                  'ヤ', 'ユ', 'ヨ',
                  'ラ', 'リ', 'ル', 'レ', 'ロ',
                  'ワ', 'ヲ', 'ン',
                  'ガ', 'ギ', 'グ', 'ゲ', 'ゴ',
                  'ザ', 'ジ', 'ズ', 'ゼ', 'ゾ',
                  'ダ', 'ヂ', 'ヅ', 'デ', 'ド',
                  'バ', 'ビ', 'ブ', 'ベ', 'ボ',
                  'パ', 'ピ', 'プ', 'ペ', 'ポ',
              ];

              for &ch in &katakana_chars {
                  let card = CharacterCard::new(ch);
                  assert_eq!(card.character(), ch);
              }
          }

          /// Test CharacterCard with optional stroke order overlay
          #[test]
          fn test_character_card_stroke_order_toggle() {
              let mut card = CharacterCard::new('あ');
              
              // Default should have no stroke order
              assert!(!card.show_stroke_order());
              
              // Enable stroke order
              card = card.show_stroke_order(true);
              assert!(card.show_stroke_order());
              
              // Disable stroke order
              card = card.show_stroke_order(false);
              assert!(!card.show_stroke_order());
          }

          /// Test CharacterCard styling options
          #[test]
          fn test_character_card_styling() {
              use iced::Color;
              
              let card = CharacterCard::new('あ')
                  .color(Color::from_rgb(0.2, 0.3, 0.4))
                  .background(Color::WHITE)
                  .border_radius(8.0);
              
              assert_eq!(card.color(), Color::from_rgb(0.2, 0.3, 0.4));
              assert_eq!(card.background(), Color::WHITE);
              assert_eq!(card.border_radius(), 8.0);
          }
      }

      #[cfg(test)]
      mod integration_tests {
          use super::*;

          /// Integration test: Font loading in application context
          /// Note: This test requires the application runtime
          #[test]
          #[ignore]
          fn test_font_loading_integration() {
              use crate::NOTO_SANS_JP;
              
              // Verify font bytes are embedded
              assert!(!NOTO_SANS_JP.is_empty(), "Font data should be embedded");
              assert!(NOTO_SANS_JP.len() > 100_000, "Font should be substantial size");
              
              // Verify font has correct magic bytes for OTF/TTF
              let magic = &NOTO_SANS_JP[0..4];
              assert!(
magic == b"OTTO" || magic == b"\x00\x01\x00\x00" || magic == b"ttcf",
                  "Font should have valid OpenType/TrueType magic bytes"
              );
          }

          /// Integration test: Verify Text widget can render Japanese with custom font
          #[test]
          #[ignore]
          fn test_japanese_text_rendering() {
              use iced::widget::text;
              use iced::Font;
              
              let japanese_font = Font::with_name("Noto Sans JP");
              
              // Test hiragana rendering
              let hiragana_text = text("あいうえお").font(japanese_font);
              
              // Test katakana rendering
              let katakana_text = text("アイウエオ").font(japanese_font);
              
              // Test mixed content
              let mixed_text = text("ひらがな カタカナ").font(japanese_font);
          }

          /// Integration test: CharacterCard rendering at multiple sizes
          #[test]
          #[ignore]
          fn test_character_card_rendering_sizes() {
              let test_char = 'あ';
              let sizes = [48.0, 64.0, 72.0];
              
              for size in sizes {
                  let card = CharacterCard::new(test_char).size(size);
                  assert_eq!(card.size(), size);
              }
          }

          /// Integration test: Verify all kana characters render without missing glyphs
          #[test]
          #[ignore]
          fn test_complete_kana_coverage() {
              use crate::data::HIRAGANA_CHARACTERS;
              use crate::data::KATAKANA_CHARACTERS;
              
              for ch in HIRAGANA_CHARACTERS.chars() {
                  let card = CharacterCard::new(ch).size(64.0);
              }
              
              for ch in KATAKANA_CHARACTERS.chars() {
                  let card = CharacterCard::new(ch).size(64.0);
              }
          }
      }

  coverage:
    - "CharacterCard construction with valid parameters"
    - "CharacterCard size configuration (48px, 64px, 72px, 96px, 128px)"
    - "CharacterCard accepts all basic hiragana characters (a-n)"
    - "CharacterCard accepts all dakuten hiragana (ga, za, da, ba series)"
    - "CharacterCard accepts all handakuten hiragana (pa series)"
    - "CharacterCard accepts all basic katakana characters (a-n)"
    - "CharacterCard accepts all dakuten katakana (ga, za, da, ba series)"
    - "CharacterCard accepts all handakuten katakana (pa series)"
    - "Stroke order overlay toggle functionality"
    - "CharacterCard color styling configuration"
    - "CharacterCard background color configuration"
    - "CharacterCard border radius styling"
    - "Font data is embedded in binary at compile time"
    - "Font data has valid OpenType/TrueType format"
    - "Font data is substantial size (>100KB)"
    - "Japanese text renders without panic in Text widget"
    - "Hiragana renders correctly with custom font"
    - "Katakana renders correctly with custom font"
    - "Mixed hiragana/katakana content renders properly"
    - "CharacterCard renders at all required sizes without error"
    - "Character centering works correctly"
    - "No missing glyph boxes (□) for any hiragana character"
    - "No missing glyph boxes (□) for any katakana character"

dependencies:
  depends_on:
    - task_id: 1
      reason: "Needs application foundation and ui/ module structure"

  depended_upon_by:
    - task_id: 7
      reason: "Flashcard system needs CharacterCard widget for displaying kana characters"
    - task_id: 8
      reason: "Practice mode displays characters using CharacterCard widget"

  external:
    - name: "iced::Font"
      type: "struct"
      status: "already exists"
    - name: "iced::widget::Text"
      type: "struct"
      status: "already exists"
    - name: "iced::Widget"
      type: "trait"
      status: "already exists"
    - name: "cosmic_text"
      type: "crate"
      status: "already exists"
    - name: "Noto Sans JP"
      type: "font"
      status: "needs download"
---
task:
  id: 4
  name: "Stroke Order Animation System"

context:
  description: |
    Implement a GPU-accelerated stroke-by-stroke animation system using iced's Canvas
    widget and Animation API. The system renders character strokes sequentially with
    smooth partial path drawing, configurable timing, and natural easing curves that
    mimic human handwriting motion.
    
    Stroke order animation is the primary visual teaching tool for Chinese character
    learning. It must be smooth, accurate, and feel natural to be pedagogically effective.
    GPU acceleration via lyon tessellation ensures 60fps animation even on lower-end
    hardware. Sequential stroke rendering with proper timing helps learners internalize
    correct writing patterns.
    
    The system takes stroke path data from the character database (Task 2) and produces
    smooth, timed animations. Each stroke draws progressively over 500-800ms with
    200-300ms pauses between strokes. Completed strokes render in black, current stroke
    in blue. Animation can be played, paused, and reset.

  key_points:
    - "Canvas-based rendering using iced's canvas::Program trait for custom drawing logic"
    - "Lyon tessellation provides GPU-accelerated path rendering for smooth 60fps animation"
    - "SVG path parsing converts database stroke data into renderable PathSegment enums"
    - "Partial path rendering requires precomputed stroke lengths and progressive segment calculation"
    - "EaseOutCubic easing creates natural handwriting feel with smooth deceleration"
    - "Animation state machine manages play/pause/reset/complete lifecycle"
    - "Color differentiation (black complete, blue animating) provides visual learning cues"
    - "Bezier curve length calculation uses numerical approximation via adaptive subdivision"
    - "Timing system coordinates stroke duration, pause intervals, and total animation length"
    - "Reusable component integrates with practice mode for interactive stroke order teaching"

files:
  - path: "src/animation/stroke_order.rs"
    description: "Core StrokeOrderAnimation struct implementing canvas::Program trait with animation state management and rendering logic"
  
  - path: "src/animation/path.rs"
    description: "StrokePath and PathSegment definitions with SVG path parsing and length calculation utilities"
  
  - path: "src/animation/mod.rs"
    description: "Animation module declaration exporting stroke_order and path submodules"
  
  - path: "src/animation/controller.rs"
    description: "Animation lifecycle controller managing play, pause, reset, and complete operations with timing state"
  
  - path: "src/animation/renderer.rs"
    description: "Partial path rendering implementation with lyon tessellation integration for GPU-accelerated stroke drawing"
  
  - path: "tests/animation/stroke_order_tests.rs"
    description: "Unit and integration tests for stroke order animation including path parsing, timing, and state transitions"

functions:
  - file: "src/animation/stroke_order.rs"
    items:
      - type: "struct"
        name: "StrokeOrderAnimation"
        description: "Main animation component managing stroke-by-stroke rendering state, timing, and progress tracking"
        invariants: "current_stroke_index <= strokes.len(); animation_progress in [0.0, 1.0]"
      
      - type: "struct"
        name: "StrokePath"
        description: "Represents a single stroke with path segments and precomputed length for partial rendering"
        invariants: "total_length >= 0.0; segments is non-empty"
      
      - type: "enum"
        name: "PathSegment"
        description: "Individual SVG path commands (MoveTo, LineTo, CubicBezier, QuadraticBezier, SmoothCubic)"
      
      - type: "enum_variant"
        name: "PathSegment::MoveTo"
        description: "Move pen to absolute position without drawing"
      
      - type: "enum_variant"
        name: "PathSegment::LineTo"
        description: "Draw straight line to absolute position"
      
      - type: "enum_variant"
        name: "PathSegment::CubicBezier"
        description: "Draw cubic Bezier curve with two control points"
      
      - type: "enum_variant"
        name: "PathSegment::QuadraticBezier"
        description: "Draw quadratic Bezier curve with one control point"
      
      - type: "enum_variant"
        name: "PathSegment::SmoothCubic"
        description: "Draw smooth cubic Bezier curve with reflected first control point"
      
      - type: "struct"
        name: "AnimationConfig"
        description: "Configuration for stroke animation timing and visual properties"
      
      - type: "enum"
        name: "AnimationState"
        description: "Current state of animation (Idle, Playing, Paused, Complete)"
      
      - type: "method"
        name: "StrokeOrderAnimation::new"
        description: "Creates new animation instance from stroke path data and configuration"
        preconditions: "strokes is non-empty vector of valid stroke paths"
        postconditions: "Returns animation in Idle state with current_stroke_index = 0"
      
      - type: "method"
        name: "StrokeOrderAnimation::play"
        description: "Starts or resumes animation playback"
        preconditions: "Animation state is Idle or Paused"
        postconditions: "Animation state becomes Playing"
      
      - type: "method"
        name: "StrokeOrderAnimation::pause"
        description: "Pauses animation at current position"
        preconditions: "Animation state is Playing"
        postconditions: "Animation state becomes Paused; progress preserved"
      
      - type: "method"
        name: "StrokeOrderAnimation::reset"
        description: "Resets animation to initial state"
        postconditions: "current_stroke_index = 0; animation_progress = 0.0; state = Idle"
      
      - type: "method"
        name: "StrokeOrderAnimation::update"
        description: "Updates animation state based on elapsed time delta"
        preconditions: "delta_time >= 0.0"
        postconditions: "Advances animation progress; transitions strokes when complete"
      
      - type: "method"
        name: "StrokePath::from_svg_path"
        description: "Parses SVG path data string into StrokePath with segments"
        preconditions: "svg_path is valid SVG path data string"
        postconditions: "Returns StrokePath with parsed segments and computed total_length"
      
      - type: "method"
        name: "StrokePath::calculate_total_length"
        description: "Computes total length of stroke by summing segment lengths"
        postconditions: "Returns non-negative length value"
        invariants: "Result equals sum of all segment lengths"
      
      - type: "method"
        name: "StrokePath::get_partial_path"
        description: "Calculates partial stroke path up to specified progress ratio"
        preconditions: "progress in [0.0, 1.0]"
        postconditions: "Returns path segments representing partial stroke from start to progress point"
      
      - type: "method"
        name: "PathSegment::calculate_length"
        description: "Computes length of individual path segment"
        postconditions: "Returns non-negative length; uses numerical approximation for curves"
      
      - type: "method"
        name: "PathSegment::split_at_length"
        description: "Splits segment at specified length along path, returning partial segment"
        preconditions: "length >= 0.0 and length <= segment.calculate_length()"
        postconditions: "Returns new PathSegment representing portion from start to length"
      
      - type: "trait_impl"
        name: "canvas::Program for StrokeOrderAnimation"
        description: "Implements iced canvas::Program trait for rendering and event handling"
      
      - type: "method"
        name: "<StrokeOrderAnimation as canvas::Program>::update"
        description: "Handles animation frame updates and state transitions"
        postconditions: "Returns appropriate Action (request redraw if animating)"
      
      - type: "method"
        name: "<StrokeOrderAnimation as canvas::Program>::draw"
        description: "Renders stroke animation frame to canvas using lyon tessellation"
        postconditions: "Completed strokes rendered in black; current stroke in blue with partial progress"
      
      - type: "function"
        name: "parse_svg_path_data"
        description: "Parses SVG path data string into vector of PathSegment enums"
        preconditions: "input is valid SVG path syntax"
        postconditions: "Returns Result<Vec<PathSegment>> with parsed commands"
      
      - type: "function"
        name: "calculate_bezier_length"
        description: "Approximates cubic Bezier curve length using adaptive subdivision"
        preconditions: "Control points form valid Bezier curve"
        postconditions: "Returns length approximation with configurable precision tolerance"
      
      - type: "function"
        name: "calculate_quadratic_bezier_length"
        description: "Approximates quadratic Bezier curve length using subdivision"
        preconditions: "Control points form valid quadratic Bezier curve"
        postconditions: "Returns length approximation within tolerance"
      
      - type: "function"
        name: "ease_out_cubic"
        description: "Applies ease-out cubic easing function for natural animation timing"
        preconditions: "t in [0.0, 1.0]"
        postconditions: "Returns eased value in [0.0, 1.0] with smooth deceleration"
        invariants: "f(0.0) = 0.0; f(1.0) = 1.0; monotonically increasing"
      
      - type: "function"
        name: "tessellate_stroke_path"
        description: "Converts PathSegment vector to lyon tessellation for GPU rendering"
        preconditions: "segments is non-empty valid path"
        postconditions: "Returns lyon::path::Path ready for rendering"
      
      - type: "constant"
        name: "DEFAULT_STROKE_DURATION_MS"
        description: "Default duration for single stroke animation (650ms)"
      
      - type: "constant"
        name: "DEFAULT_PAUSE_DURATION_MS"
        description: "Default pause between strokes (250ms)"
      
      - type: "constant"
        name: "COMPLETE_STROKE_COLOR"
        description: "Color for completed strokes (black)"
      
      - type: "constant"
        name: "ANIMATING_STROKE_COLOR"
        description: "Color for currently animating stroke (blue)"
      
      - type: "constant"
        name: "BEZIER_SUBDIVISION_TOLERANCE"
        description: "Tolerance for Bezier curve length approximation (0.01)"

  - file: "src/animation/mod.rs"
    items:
      - type: "module_declaration"
        name: "stroke_order"
        description: "Public module declaration exposing stroke order animation system"
      
      - type: "function"
        name: "create_stroke_animation"
        description: "Convenience function to create configured stroke animation from character data"
        preconditions: "character_id exists in database with valid stroke path data"
        postconditions: "Returns configured StrokeOrderAnimation ready for display"

  - file: "tests/animation/stroke_order_tests.rs"
    items:
      - type: "function"
        name: "test_parse_simple_line_path"
        description: "Tests parsing of simple SVG path with MoveTo and LineTo commands"
      
      - type: "function"
        name: "test_parse_cubic_bezier_path"
        description: "Tests parsing of SVG path with cubic Bezier curves"
      
      - type: "function"
        name: "test_stroke_length_calculation"
        description: "Verifies total stroke length calculation for known paths"
      
      - type: "function"
        name: "test_partial_path_at_zero"
        description: "Tests partial path rendering at 0% progress returns empty path"
      
      - type: "function"
        name: "test_partial_path_at_full"
        description: "Tests partial path rendering at 100% progress returns complete path"
      
      - type: "function"
        name: "test_partial_path_midpoint"
        description: "Tests partial path rendering at 50% progress returns accurate half-path"
      
      - type: "function"
        name: "test_animation_state_transitions"
        description: "Tests play/pause/reset state machine transitions"
      
      - type: "function"
        name: "test_animation_timing_sequence"
        description: "Tests stroke sequence timing with configured durations and pauses"
      
      - type: "function"
        name: "test_animation_completion"
        description: "Verifies animation completes all strokes and enters Complete state"
      
      - type: "function"
        name: "test_bezier_length_approximation"
        description: "Tests Bezier curve length calculation accuracy against known curves"
      
      - type: "function"
        name: "test_ease_out_cubic_function"
        description: "Tests easing function properties (endpoints, monotonicity)"
      
      - type: "function"
        name: "prop_partial_path_length_bounds"
        description: "Property test verifying partial path length <= total length for all progress values"
      
      - type: "function"
        name: "prop_segment_split_preserves_length"
        description: "Property test verifying split segments sum to original length"

  - file: "src/widgets/stroke_animation_widget.rs"
    items:
      - type: "struct"
        name: "StrokeAnimationWidget"
        description: "Iced widget wrapper for StrokeOrderAnimation providing UI controls"
      
      - type: "method"
        name: "StrokeAnimationWidget::new"
        description: "Creates widget instance with animation and control buttons"
      
      - type: "method"
        name: "StrokeAnimationWidget::view"
        description: "Builds iced Element tree with canvas and control buttons"
      
      - type: "enum"
        name: "StrokeAnimationMessage"
        description: "Message types for animation widget interactions (Play, Pause, Reset)"
      
      - type: "method"
        name: "StrokeAnimationWidget::update"
        description: "Handles widget messages and updates animation state"

  - file: "src/data/stroke_data.rs"
    items:
      - type: "function"
        name: "load_stroke_paths_for_character"
        description: "Loads SVG stroke path data for specified character from database"
        preconditions: "character_id is valid; database connection available"
        postconditions: "Returns Vec<String> of SVG path data strings in correct stroke order"
      
      - type: "struct"
        name: "StrokeData"
        description: "Container for stroke metadata including path, order number, and timing hints"

  - file: "src/utils/bezier.rs"
    items:
      - type: "struct"
        name: "CubicBezier"
        description: "Cubic Bezier curve with four control points and length calculation"
      
      - type: "method"
        name: "CubicBezier::point_at"
        description: "Evaluates Bezier curve at parameter t in [0,1]"
        preconditions: "t in [0.0, 1.0]"
        postconditions: "Returns point on curve"
      
      - type: "method"
        name: "CubicBezier::split_at"
        description: "Splits Bezier curve at parameter t using de Casteljau algorithm"
        preconditions: "t in [0.0, 1.0]"
        postconditions: "Returns two CubicBezier curves representing left and right portions"
      
      - type: "method"
        name: "CubicBezier::approximate_length"
        description: "Computes curve length using adaptive subdivision to tolerance"
        postconditions: "Returns length approximation accurate to BEZIER_SUBDIVISION_TOLERANCE"
      
      - type: "struct"
        name: "QuadraticBezier"
        description: "Quadratic Bezier curve with three control points"
      
      - type: "method"
        name: "QuadraticBezier::point_at"
        description: "Evaluates quadratic Bezier curve at parameter t"
        preconditions: "t in [0.0, 1.0]"
      
      - type: "method"
        name: "QuadraticBezier::approximate_length"
        description: "Computes quadratic curve length using subdivision"

formal_verification:
  needed: true
  level: "Basic"
  explanation: |
    Basic formal verification is recommended for critical mathematical properties
    in the animation system, though full formal verification is not necessary.
    
    The stroke order animation system involves several areas where formal properties
    should be verified:
    
    1. Path length calculations: Partial path rendering depends on accurate length
       computations. Errors accumulate through Bezier curve approximations and can
       cause visual discontinuities or incorrect stroke progression.
    
    2. Animation progress monotonicity: The animation progress must be strictly
       non-decreasing to prevent visual artifacts like strokes moving backward.
    
    3. Segment boundary correctness: When rendering partial paths, segment transitions
       must maintain continuity without gaps or overlaps.
    
    4. Timing invariants: Total animation duration must equal sum of stroke durations
       plus pause intervals, ensuring predictable completion times.
    
    However, full Critical-level verification is not warranted because:
    - No safety-critical consequences from rendering errors
    - Visual bugs are easily caught through integration testing
    - Performance issues detectable through benchmarking
    - User interaction is forgiving of minor timing variations
    
    Basic verification focuses on mathematical correctness of core algorithms while
    relying on property-based testing for edge cases and integration tests for
    user-facing behavior. This balanced approach catches logic errors without
    over-investing in formal methods for a UI animation feature.

  properties:
    - name: "Path Length Non-Negativity"
      formal_statement: "∀ stroke ∈ strokes: compute_length(stroke) ≥ 0"
    
    - name: "Partial Path Continuity"
      formal_statement: "∀ t₁, t₂ where 0 ≤ t₁ < t₂ ≤ 1: end_point(partial_path(t₁)) is continuous with start of remaining path to partial_path(t₂)"
    
    - name: "Progress Monotonicity"
      formal_statement: "∀ t₁ < t₂: animation_progress(t₁) ≤ animation_progress(t₂)"
    
    - name: "Total Duration Correctness"
      formal_statement: "total_duration = Σ(stroke_duration[i] + pause_duration[i]) for i in 0..n-1, where n = stroke_count"
    
    - name: "Segment Coverage Completeness"
      formal_statement: "partial_path(1.0) = full_path ∧ partial_path(0.0) = empty_path"
    
    - name: "Animation State Consistency"
      formal_statement: "current_stroke_index ≤ total_strokes ∧ (is_complete ⟹ current_stroke_index = total_strokes)"

  strategy:
    - "Use property-based testing (proptest) to verify mathematical properties across random inputs"
    - "Implement unit tests with symbolic values to verify boundary conditions (t=0.0, t=0.5, t=1.0)"
    - "Add assertions in code for runtime invariant checking during development"
    - "Use typed state machines to enforce valid animation state transitions"
    - "Implement QuickCheck-style tests for path length calculations with known geometric shapes"
    - "Validate Bezier length approximation error bounds remain within acceptable threshold (< 0.1% relative error)"

tests:
  strategy:
    approach: "mixed"
    rationale:
      - "Path parsing and segment creation are deterministic units requiring unit tests"
      - "Path length calculations involve numerical precision - property-based testing ensures correctness across various inputs"
      - "Animation timing and state transitions are stateful - integration tests verify correct sequencing"
      - "Partial path rendering requires visual validation but logic can be unit tested"
      - "Canvas integration and GPU rendering need integration testing with iced framework"
      - "Performance characteristics (60fps) require benchmarking but frame timing logic needs unit coverage"

  implementation:
    file: "tests/animation/stroke_order_tests.rs"
    location: "separate test file"
    code: |
      #[cfg(test)]
      mod tests {
          use super::*;
          use iced::advanced::graphics::geometry::Path as IcedPath;
          use std::time::Duration;

          // ==================== Unit Tests: Path Segment Parsing ====================

          #[test]
          fn test_parse_move_to_command() {
              let svg = "M 10 20";
              let segments = PathSegment::parse_svg_path(svg).unwrap();
              
              assert_eq!(segments.len(), 1);
              match segments[0] {
                  PathSegment::MoveTo { x, y } => {
                      assert_eq!(x, 10.0);
                      assert_eq!(y, 20.0);
                  }
                  _ => panic!("Expected MoveTo segment"),
              }
          }

          #[test]
          fn test_parse_line_to_command() {
              let svg = "M 0 0 L 100 50";
              let segments = PathSegment::parse_svg_path(svg).unwrap();
              
              assert_eq!(segments.len(), 2);
              match segments[1] {
                  PathSegment::LineTo { x, y } => {
                      assert_eq!(x, 100.0);
                      assert_eq!(y, 50.0);
                  }
                  _ => panic!("Expected LineTo segment"),
              }
          }

          #[test]
          fn test_parse_cubic_bezier_command() {
              let svg = "M 0 0 C 10 20 30 40 50 60";
              let segments = PathSegment::parse_svg_path(svg).unwrap();
              
              assert_eq!(segments.len(), 2);
              match segments[1] {
                  PathSegment::CubicBezier { cx1, cy1, cx2, cy2, x, y } => {
                      assert_eq!(cx1, 10.0);
                      assert_eq!(cy1, 20.0);
                      assert_eq!(cx2, 30.0);
                      assert_eq!(cy2, 40.0);
                      assert_eq!(x, 50.0);
                      assert_eq!(y, 60.0);
                  }
                  _ => panic!("Expected CubicBezier segment"),
              }
          }

          #[test]
          fn test_parse_quadratic_bezier_command() {
              let svg = "M 0 0 Q 25 50 50 0";
              let segments = PathSegment::parse_svg_path(svg).unwrap();
              
              assert_eq!(segments.len(), 2);
              match segments[1] {
                  PathSegment::QuadraticBezier { cx, cy, x, y } => {
                      assert_eq!(cx, 25.0);
                      assert_eq!(cy, 50.0);
                      assert_eq!(x, 50.0);
                      assert_eq!(y, 0.0);
                  }
                  _ => panic!("Expected QuadraticBezier segment"),
              }
          }

          #[test]
          fn test_parse_smooth_cubic_bezier_command() {
              let svg = "M 0 0 C 10 20 30 40 50 60 S 90 80 110 100";
              let segments = PathSegment::parse_svg_path(svg).unwrap();
              
              assert_eq!(segments.len(), 3);
              match segments[2] {
                  PathSegment::SmoothCubicBezier { cx2, cy2, x, y } => {
                      assert_eq!(cx2, 90.0);
                      assert_eq!(cy2, 80.0);
                      assert_eq!(x, 110.0);
                      assert_eq!(y, 100.0);
                  }
                  _ => panic!("Expected SmoothCubicBezier segment"),
              }
          }

          #[test]
          fn test_parse_complex_path() {
              let svg = "M 0 0 L 50 50 Q 75 0 100 50 C 120 70 140 70 160 50";
              let segments = PathSegment::parse_svg_path(svg).unwrap();
              
              assert_eq!(segments.len(), 4);
              assert!(matches!(segments[0], PathSegment::MoveTo { .. }));
              assert!(matches!(segments[1], PathSegment::LineTo { .. }));
              assert!(matches!(segments[2], PathSegment::QuadraticBezier { .. }));
              assert!(matches!(segments[3], PathSegment::CubicBezier { .. }));
          }

          #[test]
          fn test_parse_invalid_svg_path() {
              let svg = "X 10 20";
              let result = PathSegment::parse_svg_path(svg);
              
              assert!(result.is_err());
          }

          #[test]
          fn test_parse_empty_svg_path() {
              let svg = "";
              let result = PathSegment::parse_svg_path(svg);
              
              assert!(result.is_err());
          }

          // ==================== Unit Tests: Path Length Calculation ====================

          #[test]
          fn test_line_segment_length() {
              let segment = PathSegment::LineTo { x: 100.0, y: 0.0 };
              let length = segment.calculate_length((0.0, 0.0));
              
              assert!((length - 100.0).abs() < 0.01);
          }

          #[test]
          fn test_diagonal_line_segment_length() {
              let segment = PathSegment::LineTo { x: 3.0, y: 4.0 };
              let length = segment.calculate_length((0.0, 0.0));
              
              // 3-4-5 triangle
              assert!((length - 5.0).abs() < 0.01);
          }

          #[test]
          fn test_stroke_path_total_length() {
              let segments = vec![
                  PathSegment::MoveTo { x: 0.0, y: 0.0 },
                  PathSegment::LineTo { x: 30.0, y: 0.0 },
                  PathSegment::LineTo { x: 30.0, y: 40.0 },
              ];
              
              let stroke = StrokePath::new(segments);
              
              // MoveTo contributes 0, first line is 30, second line is 40
              assert!((stroke.total_length() - 70.0).abs() < 0.01);
          }

          #[test]
          fn test_bezier_curve_length_approximation() {
              // Simple quadratic Bezier curve
              let segment = PathSegment::QuadraticBezier {
                  cx: 50.0,
                  cy: 50.0,
                  x: 100.0,
                  y: 0.0,
              };
              
              let length = segment.calculate_length((0.0, 0.0));
              
              // Should be greater than straight line distance (100) but reasonable
              assert!(length > 100.0);
              assert!(length < 150.0);
          }

          // ==================== Unit Tests: Partial Path Calculation ====================

          #[test]
          fn test_partial_path_at_zero_progress() {
              let segments = vec![
                  PathSegment::MoveTo { x: 0.0, y: 0.0 },
                  PathSegment::LineTo { x: 100.0, y: 0.0 },
              ];
              
              let stroke = StrokePath::new(segments);
              let partial = stroke.calculate_partial_path(0.0);
              
              assert_eq!(partial.len(), 1);
              assert!(matches!(partial[0], PathSegment::MoveTo { .. }));
          }

          #[test]
          fn test_partial_path_at_full_progress() {
              let segments = vec![
                  PathSegment::MoveTo { x: 0.0, y: 0.0 },
                  PathSegment::LineTo { x: 100.0, y: 0.0 },
                  PathSegment::LineTo { x: 100.0, y: 100.0 },
              ];
              
              let stroke = StrokePath::new(segments.clone());
              let partial = stroke.calculate_partial_path(1.0);
              
              assert_eq!(partial.len(), segments.len());
          }

          #[test]
          fn test_partial_path_midway_progress() {
              let segments = vec![
                  PathSegment::MoveTo { x: 0.0, y: 0.0 },
                  PathSegment::LineTo { x: 100.0, y: 0.0 },
              ];
              
              let stroke = StrokePath::new(segments);
              let partial = stroke.calculate_partial_path(0.5);
              
              // Should have MoveTo and partial LineTo
              assert_eq!(partial.len(), 2);
              match partial[1] {
                  PathSegment::LineTo { x, y } => {
                      assert!((x - 50.0).abs() < 0.1);
                      assert!((y - 0.0).abs() < 0.1);
                  }
                  _ => panic!("Expected partial LineTo"),
              }
          }

          #[test]
          fn test_partial_path_multiple_segments() {
              let segments = vec![
                  PathSegment::MoveTo { x: 0.0, y: 0.0 },
                  PathSegment::LineTo { x: 50.0, y: 0.0 },
                  PathSegment::LineTo { x: 50.0, y: 50.0 },
              ];
              
              let stroke = StrokePath::new(segments);
              // Progress that should complete first line and start second
              let partial = stroke.calculate_partial_path(0.6);
              
              assert!(partial.len() >= 2);
              // First LineTo should be complete
              match partial[1] {
                  PathSegment::LineTo { x, y } => {
                      assert_eq!(x, 50.0);
                      assert_eq!(y, 0.0);
                  }
                  _ => panic!("Expected complete first LineTo"),
              }
          }

          // ==================== Unit Tests: Animation State Management ====================

          #[test]
          fn test_animation_initial_state() {
              let strokes = vec![
                  StrokePath::new(vec![
                      PathSegment::MoveTo { x: 0.0, y: 0.0 },
                      PathSegment::LineTo { x: 100.0, y: 0.0 },
                  ]),
              ];
              
              let animation = StrokeOrderAnimation::new(strokes, Duration::from_millis(600));
              
              assert_eq!(animation.current_stroke_index(), 0);
              assert_eq!(animation.current_progress(), 0.0);
              assert!(!animation.is_playing());
              assert!(!animation.is_complete());
          }

          #[test]
          fn test_animation_play_state() {
              let strokes = vec![
                  StrokePath::new(vec![
                      PathSegment::MoveTo { x: 0.0, y: 0.0 },
                      PathSegment::LineTo { x: 100.0, y: 0.0 },
                  ]),
              ];
              
              let mut animation = StrokeOrderAnimation::new(strokes, Duration::from_millis(600));
              animation.play();
              
              assert!(animation.is_playing());
              assert!(!animation.is_complete());
          }

          #[test]
          fn test_animation_pause_state() {
              let strokes = vec![
                  StrokePath::new(vec![
                      PathSegment::MoveTo { x: 0.0, y: 0.0 },
                      PathSegment::LineTo { x: 100.0, y: 0.0 },
                  ]),
              ];
              
              let mut animation = StrokeOrderAnimation::new(strokes, Duration::from_millis(600));
              animation.play();
              animation.pause();
              
              assert!(!animation.is_playing());
          }

          #[test]
          fn test_animation_reset_state() {
              let strokes = vec![
                  StrokePath::new(vec![
                      PathSegment::MoveTo { x: 0.0, y: 0.0 },
                      PathSegment::LineTo { x: 100.0, y: 0.0 },
                  ]),
              ];
              
              let mut animation = StrokeOrderAnimation::new(strokes, Duration::from_millis(600));
              animation.play();
              animation.update(Duration::from_millis(300));
              animation.reset();
              
              assert_eq!(animation.current_stroke_index(), 0);
              assert_eq!(animation.current_progress(), 0.0);
              assert!(!animation.is_playing());
              assert!(!animation.is_complete());
          }

          #[test]
          fn test_animation_progress_update() {
              let strokes = vec![
                  StrokePath::new(vec![
                      PathSegment::MoveTo { x: 0.0, y: 0.0 },
                      PathSegment::LineTo { x: 100.0, y: 0.0 },
                  ]),
              ];
              
              let mut animation = StrokeOrderAnimation::new(strokes, Duration::from_millis(600));
              animation.play();
              animation.update(Duration::from_millis(300));
              
              let progress = animation.current_progress();
              assert!(progress > 0.4 && progress < 0.6);
          }

          #[test]
          fn test_animation_stroke_transition() {
              let strokes = vec![
                  StrokePath::new(vec![
                      PathSegment::MoveTo { x: 0.0, y: 0.0 },
                      PathSegment::LineTo { x: 100.0, y: 0.0 },
                  ]),
                  StrokePath::new(vec![
                      PathSegment::MoveTo { x: 100.0, y: 0.0 },
                      PathSegment::LineTo { x: 100.0, y: 100.0 },
                  ]),
              ];
              
              let mut animation = StrokeOrderAnimation::new(strokes, Duration::from_millis(600));
              animation.play();
              
              // Complete first stroke and pause period
              animation.update(Duration::from_millis(600));
              animation.update(Duration::from_millis(250));
              
              assert_eq!(animation.current_stroke_index(), 1);
              assert!(animation.current_progress() < 0.1);
          }

          #[test]
          fn test_animation_completion() {
              let strokes = vec![
                  StrokePath::new(vec![
                      PathSegment::MoveTo { x: 0.0, y: 0.0 },
                      PathSegment::LineTo { x: 100.0, y: 0.0 },
                  ]),
              ];
              
              let mut animation = StrokeOrderAnimation::new(strokes, Duration::from_millis(600));
              animation.play();
              animation.update(Duration::from_millis(600));
              
              assert!(animation.is_complete());
              assert!(!animation.is_playing());
          }

          #[test]
          fn test_animation_multi_stroke_completion() {
              let strokes = vec![
                  StrokePath::new(vec![
                      PathSegment::MoveTo { x: 0.0, y: 0.0 },
                      PathSegment::LineTo { x: 50.0, y: 0.0 },
                  ]),
                  StrokePath::new(vec![
                      PathSegment::MoveTo { x: 50.0, y: 0.0 },
                      PathSegment::LineTo { x: 50.0, y: 50.0 },
                  ]),
              ];
              
              let mut animation = StrokeOrderAnimation::new(strokes, Duration::from_millis(600));
              animation.play();

              // Complete both strokes with pause in between
              animation.update(Duration::from_millis(600));
              animation.update(Duration::from_millis(250));
              animation.update(Duration::from_millis(600));
              
              assert!(animation.is_complete());
              assert_eq!(animation.current_stroke_index(), 1);
          }

          // ==================== Unit Tests: Easing Functions ====================

          #[test]
          fn test_ease_out_cubic_boundaries() {
              assert_eq!(ease_out_cubic(0.0), 0.0);
              assert_eq!(ease_out_cubic(1.0), 1.0);
          }

          #[test]
          fn test_ease_out_cubic_midpoint() {
              let mid = ease_out_cubic(0.5);
              // EaseOutCubic should be > 0.5 at t=0.5 (accelerated early, slower late)
              assert!(mid > 0.5);
              assert!(mid < 1.0);
          }

          #[test]
          fn test_ease_out_cubic_progression() {
              let t1 = ease_out_cubic(0.25);
              let t2 = ease_out_cubic(0.5);
              let t3 = ease_out_cubic(0.75);
              
              // Should be monotonically increasing
              assert!(t1 < t2);
              assert!(t2 < t3);
              
              // Early progression should be larger than late progression
              let early_delta = t2 - t1;
              let late_delta = t3 - t2;
              assert!(early_delta > late_delta);
          }

          // ==================== Unit Tests: Timing Configuration ====================

          #[test]
          fn test_custom_stroke_duration() {
              let strokes = vec![
                  StrokePath::new(vec![
                      PathSegment::MoveTo { x: 0.0, y: 0.0 },
                      PathSegment::LineTo { x: 100.0, y: 0.0 },
                  ]),
              ];
              
              let animation = StrokeOrderAnimation::new(strokes, Duration::from_millis(800));
              assert_eq!(animation.stroke_duration(), Duration::from_millis(800));
          }

          #[test]
          fn test_custom_pause_duration() {
              let strokes = vec![
                  StrokePath::new(vec![
                      PathSegment::MoveTo { x: 0.0, y: 0.0 },
                      PathSegment::LineTo { x: 100.0, y: 0.0 },
                  ]),
              ];
              
              let mut animation = StrokeOrderAnimation::new(strokes, Duration::from_millis(600));
              animation.set_pause_duration(Duration::from_millis(400));
              
              assert_eq!(animation.pause_duration(), Duration::from_millis(400));
          }

          #[test]
          fn test_total_animation_duration() {
              let strokes = vec![
                  StrokePath::new(vec![
                      PathSegment::MoveTo { x: 0.0, y: 0.0 },
                      PathSegment::LineTo { x: 100.0, y: 0.0 },
                  ]),
                  StrokePath::new(vec![
                      PathSegment::MoveTo { x: 100.0, y: 0.0 },
                      PathSegment::LineTo { x: 100.0, y: 100.0 },
                  ]),
              ];
              
              let animation = StrokeOrderAnimation::new(strokes, Duration::from_millis(600));
              // 2 strokes * 600ms + 1 pause * 250ms = 1450ms
              let total = animation.total_duration();
              
              assert_eq!(total, Duration::from_millis(1450));
          }
      }

      // ==================== Property-Based Tests ====================

      #[cfg(test)]
      mod property_tests {
          use super::*;
          use proptest::prelude::*;

          proptest! {
              #[test]
              fn prop_line_length_non_negative(x in -1000.0f32..1000.0, y in -1000.0f32..1000.0) {
                  let segment = PathSegment::LineTo { x, y };
                  let length = segment.calculate_length((0.0, 0.0));
                  
                  assert!(length >= 0.0);
              }

              #[test]
              fn prop_partial_path_progress_bounds(progress in 0.0f32..1.0) {
                  let segments = vec![
                      PathSegment::MoveTo { x: 0.0, y: 0.0 },
                      PathSegment::LineTo { x: 100.0, y: 0.0 },
                  ];
                  
                  let stroke = StrokePath::new(segments);
                  let partial = stroke.calculate_partial_path(progress);
                  
                  // Should always have at least MoveTo
                  assert!(partial.len() >= 1);
                  // Should never exceed original length
                  assert!(partial.len() <= 2);
              }

              #[test]
              fn prop_animation_progress_monotonic(
                  dt1 in 0u64..1000,
                  dt2 in 0u64..1000,
              ) {
                  let strokes = vec![
                      StrokePath::new(vec![
                          PathSegment::MoveTo { x: 0.0, y: 0.0 },
                          PathSegment::LineTo { x: 100.0, y: 0.0 },
                      ]),
                  ];
                  
                  let mut animation = StrokeOrderAnimation::new(strokes, Duration::from_millis(600));
                  animation.play();
                  
                  animation.update(Duration::from_millis(dt1));
                  let p1 = animation.current_progress();
                  
                  animation.update(Duration::from_millis(dt2));
                  let p2 = animation.current_progress();
                  
                  // Progress should never decrease while playing
                  assert!(p2 >= p1 || animation.is_complete());
              }

              #[test]
              fn prop_easing_function_bounds(t in 0.0f32..1.0) {
                  let eased = ease_out_cubic(t);
                  
                  assert!(eased >= 0.0);
                  assert!(eased <= 1.0);
              }

              #[test]
              fn prop_stroke_path_length_positive(
                  x1 in -1000.0f32..1000.0,
                  y1 in -1000.0f32..1000.0,
                  x2 in -1000.0f32..1000.0,
                  y2 in -1000.0f32..1000.0,
              ) {
                  let segments = vec![
                      PathSegment::MoveTo { x: x1, y: y1 },
                      PathSegment::LineTo { x: x2, y: y2 },
                  ];
                  
                  let stroke = StrokePath::new(segments);
                  let length = stroke.total_length();
                  
                  assert!(length >= 0.0);
              }

              #[test]
              fn prop_bezier_length_greater_than_chord(
                  cx in 0.0f32..100.0,
                  cy in 0.0f32..100.0,
              ) {
                  let segment = PathSegment::QuadraticBezier {
                      cx,
                      cy,
                      x: 100.0,
                      y: 0.0,
                  };
                  
                  let curve_length = segment.calculate_length((0.0, 0.0));
                  let chord_length = 100.0; // Distance from (0,0) to (100,0)
                  
                  // Curve should be at least as long as chord
                  assert!(curve_length >= chord_length - 0.1);
              }

              #[test]
              fn prop_partial_path_at_extremes_consistent(
                  x in -1000.0f32..1000.0,
                  y in -1000.0f32..1000.0,
              ) {
                  let segments = vec![
                      PathSegment::MoveTo { x: 0.0, y: 0.0 },
                      PathSegment::LineTo { x, y },
                  ];
                  
                  let stroke = StrokePath::new(segments.clone());
                  
                  let at_zero = stroke.calculate_partial_path(0.0);
                  assert_eq!(at_zero.len(), 1);
                  
                  let at_one = stroke.calculate_partial_path(1.0);
                  assert_eq!(at_one.len(), segments.len());
              }
          }
      }

      // ==================== Integration Tests ====================

      #[cfg(test)]
      mod integration_tests {
          use super::*;
          use iced::advanced::graphics::geometry::Frame;

          #[test]
          fn test_full_animation_cycle() {
              let strokes = vec![
                  StrokePath::new(vec![
                      PathSegment::MoveTo { x: 0.0, y: 0.0 },
                      PathSegment::LineTo { x: 100.0, y: 0.0 },
                  ]),
                  StrokePath::new(vec![
                      PathSegment::MoveTo { x: 100.0, y: 0.0 },
                      PathSegment::LineTo { x: 100.0, y: 100.0 },
                  ]),
              ];
              
              let mut animation = StrokeOrderAnimation::new(strokes, Duration::from_millis(600));
              
              // Initial state
              assert_eq!(animation.current_stroke_index(), 0);
              assert!(!animation.is_playing());
              
              // Play and progress through first stroke
              animation.play();
              animation.update(Duration::from_millis(300));
              assert_eq!(animation.current_stroke_index(), 0);
              assert!(animation.current_progress() > 0.0);
              
              // Complete first stroke
              animation.update(Duration::from_millis(300));
              
              // Wait through pause
              animation.update(Duration::from_millis(250));
              
              // Now on second stroke
              assert_eq!(animation.current_stroke_index(), 1);
              
              // Complete second stroke
              animation.update(Duration::from_millis(600));
              assert!(animation.is_complete());
              
              // Reset
              animation.reset();
              assert_eq!(animation.current_stroke_index(), 0);
              assert_eq!(animation.current_progress(), 0.0);
          }

          #[test]
          fn test_pause_resume_preserves_state() {
              let strokes = vec![
                  StrokePath::new(vec![
                      PathSegment::MoveTo { x: 0.0, y: 0.0 },
                      PathSegment::LineTo { x: 100.0, y: 0.0 },
                  ]),
              ];
              
              let mut animation = StrokeOrderAnimation::new(strokes, Duration::from_millis(600));
              animation.play();
              animation.update(Duration::from_millis(300));
              
              let progress_before = animation.current_progress();
              let stroke_before = animation.current_stroke_index();
              
              animation.pause();
              animation.update(Duration::from_millis(100)); // Should not advance
              
              assert_eq!(animation.current_progress(), progress_before);
              assert_eq!(animation.current_stroke_index(), stroke_before);
              
              animation.play();
              animation.update(Duration::from_millis(100));
              
              assert!(animation.current_progress() > progress_before);
          }

          #[test]
          fn test_render_state_transitions() {
              let strokes = vec![
                  StrokePath::new(vec![
                      PathSegment::MoveTo { x: 0.0, y: 0.0 },
                      PathSegment::LineTo { x: 100.0, y: 0.0 },
                  ]),
                  StrokePath::new(vec![
                      PathSegment::MoveTo { x: 100.0, y: 0.0 },
                      PathSegment::LineTo { x: 100.0, y: 100.0 },
                  ]),
              ];
              
              let mut animation = StrokeOrderAnimation::new(strokes, Duration::from_millis(600));
              animation.play();
              
              // At start: stroke 0 animating, stroke 1 not rendered
              let render_state = animation.get_render_state();
              assert_eq!(render_state.completed_strokes.len(), 0);
              assert_eq!(render_state.current_stroke_index, 0);
              
              // Mid first stroke: stroke 0 partial, stroke 1 not rendered
              animation.update(Duration::from_millis(300));
              let render_state = animation.get_render_state();
              assert_eq!(render_state.completed_strokes.len(), 0);
              assert!(render_state.current_stroke_progress > 0.0);
              
              // Complete first stroke and pause
              animation.update(Duration::from_millis(300));
              animation.update(Duration::from_millis(250));
              
              // On second stroke: stroke 0 complete (black), stroke 1 animating (blue)
              let render_state = animation.get_render_state();
              assert_eq!(render_state.completed_strokes.len(), 1);
              assert_eq!(render_state.current_stroke_index, 1);
          }

          #[test]
          fn test_complex_character_animation() {
              // Simulate a complex character with multiple strokes
              let strokes = vec![
                  StrokePath::new(vec![
                      PathSegment::MoveTo { x: 10.0, y: 10.0 },
                      PathSegment::LineTo { x: 50.0, y: 10.0 },
                  ]),
                  StrokePath::new(vec![
                      PathSegment::MoveTo { x: 30.0, y: 10.0 },
                      PathSegment::LineTo { x: 30.0, y: 50.0 },
                  ]),
                  StrokePath::new(vec![
                      PathSegment::MoveTo { x: 10.0, y: 30.0 },
                      PathSegment::LineTo { x: 50.0, y: 30.0 },
                  ]),
              ];
              
              let mut animation = StrokeOrderAnimation::new(strokes.clone(), Duration::from_millis(600));
              animation.play();
              
              // Animate through all strokes
              for i in 0..strokes.len() {
                  assert_eq!(animation.current_stroke_index(), i);
                  animation.update(Duration::from_millis(600));
                  if i < strokes.len() - 1 {
                      animation.update(Duration::from_millis(250));
                  }
              }
              
              assert!(animation.is_complete());
          }

          #[test]
          fn test_animation_timing_accuracy() {
              let strokes = vec![
                  StrokePath::new(vec![
                      PathSegment::MoveTo { x: 0.0, y: 0.0 },
                      PathSegment::LineTo { x: 100.0, y: 0.0 },
                  ]),
              ];
              
              let mut animation = StrokeOrderAnimation::new(strokes, Duration::from_millis(600));
              animation.play();
              
              // Test progress at specific time points
              animation.update(Duration::from_millis(150)); // 25% through
              let p1 = animation.current_progress();
              assert!(p1 > 0.2 && p1 < 0.3);
              
              animation.update(Duration::from_millis(150)); // 50% through
              let p2 = animation.current_progress();
              assert!(p2 > 0.4 && p2 < 0.6);
              
              animation.update(Duration::from_millis(300)); // 100% through
              assert!(animation.current_progress() >= 0.99);
          }
      }

  coverage:
    - "SVG path parsing for MoveTo commands"
    - "SVG path parsing for LineTo commands"
    - "SVG path parsing for CubicBezier commands"
    - "SVG path parsing for QuadraticBezier commands"
    - "SVG path parsing for SmoothCubicBezier commands"
    - "SVG path parsing for complex multi-command paths"
    - "SVG path parsing error handling for invalid commands"
    - "SVG path parsing error handling for empty paths"
    - "Line segment length calculation accuracy"
    - "Diagonal line segment length calculation (Pythagorean theorem)"
    - "Total stroke path length calculation across multiple segments"
    - "Bezier curve length approximation within reasonable bounds"
    - "Partial path calculation at zero progress (initial state)"
    - "Partial path calculation at full progress (complete path)"
    - "Partial path calculation at midway progress (50%)"
    - "Partial path calculation across multiple segments"
    - "Animation initial state (not playing, zero progress)"
    - "Animation play state transition"
    - "Animation pause state transition"
    - "Animation reset functionality restores initial state"
    - "Animation progress updates correctly over time"
    - "Animation stroke-to-stroke transition with pause period"
    - "Animation completion detection for single stroke"
    - "Animation completion detection for multiple strokes"
    - "EaseOutCubic function boundary values (0.0 and 1.0)"
    - "EaseOutCubic function midpoint behavior"
    - "EaseOutCubic function monotonic progression and curve shape"
    - "Custom stroke duration configuration"
    - "Custom pause duration configuration"
    - "Total animation duration calculation with multiple strokes"
    - "Property: Line length is always non-negative"
    - "Property: Partial path progress stays within bounds [0.0, 1.0]"
    - "Property: Animation progress is monotonically increasing"
    - "Property: Easing function output stays within bounds [0.0, 1.0]"
    - "Property: Stroke path length is always positive or zero"
    - "Property: Bezier curve length is at least equal to chord length"
    - "Property: Partial path at 0.0 and 1.0 is consistent"
    - "Integration: Full animation cycle through multiple strokes"
    - "Integration: Pause and resume preserves animation state"
    - "Integration: Render state transitions (completed vs animating strokes)"
    - "Integration: Complex character animation with multiple strokes"
    - "Integration: Animation timing accuracy at specific time points"

dependencies:
  depends_on:
    - task_id: 1
      reason: "Needs Canvas widget support from iced foundation"
    - task_id: 2
      reason: "Requires stroke path data from character database"

  depended_upon_by:
    - task_id: 8
      reason: "Practice mode uses stroke animation for teaching"

  external:
    - name: "iced::canvas::Program"
      type: "trait"
      status: "already exists"
    - name: "iced::canvas::Frame"
      type: "struct"
      status: "already exists"
    - name: "iced::Animation"
      type: "module"
      status: "already exists"
    - name: "lyon::path::Path"
      type: "struct"
      status: "to be imported"
    - name: "lyon::tessellation"
      type: "module"
      status: "to be imported"
    - name: "std::time::Duration"
      type: "struct"
      status: "already exists"
    - name: "proptest"
      type: "crate"
      status: "to be imported"
---
task:
  id: 5
  name: "Handwriting Canvas and Input System"

context:
  description: |
    This task implements an interactive drawing canvas that captures handwriting input
    through mouse or touch interactions. The system records stroke sequences with
    timestamps, provides real-time visual feedback during drawing, and outputs
    normalized stroke data suitable for character recognition processing.
    
    The canvas serves as the primary input mechanism for the handwriting practice system,
    enabling users to write characters freehand while the application tracks their
    strokes for validation and recognition. The implementation uses iced's canvas::Program
    trait to handle low-level drawing events and render smooth, anti-aliased strokes.
    
    Stroke data is captured as sequences of timestamped points, with intelligent filtering
    to prevent noise from excessive point density. The system maintains a clear separation
    between active (currently being drawn) and completed strokes, supporting operations
    like clear and undo for a natural drawing experience.
    
    The normalized stroke output format (coordinates in 0-1 range) provides a
    device-independent representation suitable for machine learning-based character
    recognition, enabling the practice mode to validate user input against expected
    character forms.

  key_points:
    - "Implements canvas::Program trait for event-driven drawing interaction"
    - "Applies 2px distance threshold to reduce point density and noise"
    - "Uses lyon path rendering with round caps/joins for smooth stroke appearance"
    - "Maintains stroke history with timestamps for potential velocity analysis"
    - "Normalizes coordinates to 0-1 range for recognition system compatibility"
    - "Differentiates visual style between active and completed strokes"
    - "Supports both desktop (mouse) and touch-enabled device input"
    - "Provides clear separation between drawing state and rendering logic"

files:
  - path: "src/ui/handwriting_canvas.rs"
    description: "Main HandwritingCanvas widget implementing canvas::Program for interactive drawing and stroke capture"
  
  - path: "src/ui/drawing_state.rs"
    description: "DrawingState struct managing stroke history, current drawing state, and canvas operations"
  
  - path: "src/ui/stroke.rs"
    description: "Stroke data structure representing individual strokes as point sequences with timestamps"
  
  - path: "src/ui/mod.rs"
    description: "UI module declaration file - add handwriting_canvas, drawing_state, and stroke submodules"
  
  - path: "tests/handwriting_canvas_tests.rs"
    description: "Integration tests for canvas input handling, stroke recording, and rendering behavior"

functions:
  - file: "src/ui/handwriting_canvas.rs"
    items:
      - type: "module_declaration"
        name: "handwriting_canvas"
        description: "Module containing the interactive drawing canvas implementation for handwriting input"
      
      - type: "struct"
        name: "HandwritingCanvas"
        description: "Main canvas widget implementing canvas::Program for capturing and rendering handwriting strokes"
        invariants: "Canvas dimensions remain positive and non-zero throughout lifecycle"
      
      - type: "struct"
        name: "DrawingState"
        description: "Maintains the current drawing state including stroke history, active stroke, and canvas dimensions"
        invariants: "Completed strokes remain immutable once added to history; current stroke exists only during active drawing"
      
      - type: "struct"
        name: "Stroke"
        description: "Represents a single handwriting stroke as a sequence of timestamped points"
        postconditions: "All points in sequence maintain temporal ordering by timestamp"
        invariants: "Contains at least one point; timestamps are monotonically increasing"
      
      - type: "struct"
        name: "Point"
        description: "Individual point in a stroke containing x, y coordinates and timestamp"
        invariants: "Coordinates are non-negative; timestamp is valid"
      
      - type: "struct"
        name: "NormalizedPoint"
        description: "Point with coordinates normalized to 0-1 range for recognition processing"
        invariants: "Both x and y coordinates are in range [0.0, 1.0]"
      
      - type: "enum"
        name: "Message"
        description: "Events generated by canvas interactions"
      
      - type: "enum_variant"
        name: "Message::StartStroke"
        description: "Indicates beginning of new stroke at given position"
      
      - type: "enum_variant"
        name: "Message::AddPoint"
        description: "Adds point to current stroke during drawing"
      
      - type: "enum_variant"
        name: "Message::EndStroke"
        description: "Completes current stroke and adds to history"
      
      - type: "enum_variant"
        name: "Message::Clear"
        description: "Removes all strokes from canvas"
      
      - type: "enum_variant"
        name: "Message::Undo"
        description: "Removes the most recently completed stroke"
      
      - type: "trait_impl"
        name: "canvas::Program for HandwritingCanvas"
        description: "Implements iced canvas::Program trait for interactive drawing behavior"
      
      - type: "method"
        name: "HandwritingCanvas::new"
        description: "Creates new HandwritingCanvas with specified dimensions"
        postconditions: "Canvas initialized with empty stroke history and no active stroke"
      
      - type: "method"
        name: "HandwritingCanvas::view"
        description: "Returns iced Element for displaying the canvas widget"
      
      - type: "method"
        name: "HandwritingCanvas::get_strokes"
        description: "Exports all completed strokes as vector of point sequences"
        postconditions: "Returns deep copy of stroke data; original data unchanged"
      
      - type: "method"
        name: "HandwritingCanvas::get_normalized_strokes"
        description: "Exports strokes with coordinates normalized to 0-1 range"
        postconditions: "All returned points have coordinates in [0.0, 1.0] range"
      
      - type: "method"
        name: "HandwritingCanvas::clear"
        description: "Removes all strokes from canvas"
        postconditions: "Stroke history is empty; no active stroke"
      
      - type: "method"
        name: "HandwritingCanvas::update (canvas::Program)"
        description: "Processes canvas events and updates drawing state"
        preconditions: "Event is valid Message variant"
        postconditions: "State updated according to event type; redraw requested if visual change occurred"
      
      - type: "method"
        name: "HandwritingCanvas::draw (canvas::Program)"
        description: "Renders all strokes and current drawing to canvas frame"
        postconditions: "All completed strokes rendered with standard style; active stroke rendered with distinct style"
      
      - type: "method"
        name: "HandwritingCanvas::mouse_interaction (canvas::Program)"
        description: "Determines mouse cursor appearance based on canvas state"
      
      - type: "method"
        name: "DrawingState::new"
        description: "Creates new DrawingState with specified canvas dimensions"
        postconditions: "Empty stroke history; no active stroke; dimensions set"
      
      - type: "method"
        name: "DrawingState::start_stroke"
        description: "Begins new stroke at given position with current timestamp"
        preconditions: "No active stroke exists"
        postconditions: "Active stroke created with single initial point"
      
      - type: "method"
        name: "DrawingState::add_point"
        description: "Adds point to current stroke if distance threshold met"
        preconditions: "Active stroke exists"
        postconditions: "Point added to active stroke if distance from last point >= threshold; otherwise no change"
      
      - type: "method"
        name: "DrawingState::end_stroke"
        description: "Completes current stroke and adds to history"
        preconditions: "Active stroke exists"
        postconditions: "Active stroke moved to completed history; no active stroke remains"
      
      - type: "method"
        name: "DrawingState::clear_all"
        description: "Removes all completed strokes and cancels active stroke"
        postconditions: "Empty stroke history; no active stroke"
      
      - type: "method"
        name: "DrawingState::undo_last"
        description: "Removes most recent completed stroke from history"
        postconditions: "Last stroke removed if history non-empty; otherwise no change"
      
      - type: "method"
        name: "DrawingState::get_all_strokes"
        description: "Returns reference to completed stroke history"
      
      - type: "method"
        name: "DrawingState::normalize_strokes"
        description: "Converts all strokes to normalized coordinate space (0-1)"
        postconditions: "Returns new stroke collection with coordinates scaled by canvas dimensions"
      
      - type: "function"
        name: "should_add_point"
        description: "Determines if new point is sufficiently distant from last point to record"
        preconditions: "Previous point exists in stroke"
        postconditions: "Returns true if Euclidean distance >= DISTANCE_THRESHOLD"
      
      - type: "function"
        name: "calculate_distance"
        description: "Computes Euclidean distance between two points"
        postconditions: "Returns non-negative distance value"
      
      - type: "function"
        name: "render_stroke"
        description: "Renders single stroke as anti-aliased path with round caps and joins"
        preconditions: "Stroke contains at least 2 points for visible rendering"
        postconditions: "Stroke drawn to frame with specified color and stroke width"
      
      - type: "function"
        name: "stroke_to_path"
        description: "Converts stroke point sequence to lyon Path for rendering"
        preconditions: "Stroke contains at least one point"
        postconditions: "Returns Path with line segments connecting all points"
      
      - type: "constant"
        name: "DISTANCE_THRESHOLD"
        description: "Minimum pixel distance between consecutive points (2.0px)"
        invariants: "Value remains 2.0; prevents excessive point density"
      
      - type: "constant"
        name: "STROKE_WIDTH"
        description: "Width of rendered stroke lines in pixels (3.0px)"
        invariants: "Positive value for visible strokes"
      
      - type: "constant"
        name: "ACTIVE_STROKE_COLOR"
        description: "Color for stroke currently being drawn (blue)"
      
      - type: "constant"
        name: "COMPLETED_STROKE_COLOR"
        description: "Color for completed strokes in history (black)"
      
      - type: "constant"
        name: "DEFAULT_CANVAS_SIZE"
        description: "Default canvas dimensions in pixels (200x200)"

  - file: "src/ui/mod.rs"
    items:
      - type: "module_declaration"
        name: "handwriting_canvas"
        description: "Public module declaration exposing handwriting canvas functionality"

  - file: "tests/canvas_tests.rs"
    items:
      - type: "function"
        name: "test_stroke_creation"
        description: "Verifies Stroke can be created with points and maintains ordering"
        postconditions: "Stroke contains all added points in correct sequence"
      
      - type: "function"
        name: "test_distance_threshold"
        description: "Validates that points closer than threshold are filtered out"
        postconditions: "Only points meeting distance requirement are added"
      
      - type: "function"
        name: "test_stroke_normalization"
        description: "Ensures stroke coordinates normalize correctly to 0-1 range"
        postconditions: "All normalized points have coordinates in [0.0, 1.0]"
      
      - type: "function"
        name: "test_drawing_state_lifecycle"
        description: "Tests complete stroke drawing cycle: start, add points, end"
        postconditions: "Completed stroke appears in history with all recorded points"
      
      - type: "function"
        name: "test_clear_and_undo"
        description: "Validates clear removes all strokes and undo removes last stroke"
        postconditions: "Clear results in empty canvas; undo removes only most recent stroke"
      
      - type: "function"
        name: "test_multiple_strokes"
        description: "Verifies multiple sequential strokes are maintained in correct order"
        postconditions: "All strokes preserved in chronological order with correct point sequences"

formal_verification:
  needed: false
  level: "None"
  explanation: |
    Formal verification is not required for the handwriting canvas input system.
    
    This task deals with UI event handling and graphical rendering, which are
    inherently difficult to verify formally. The core logic involves:
    1. Capturing mouse/touch events (external input)
    2. Recording point sequences in a straightforward data structure
    3. Rendering strokes using the iced/lyon graphics library
    
    The critical correctness properties (stroke continuity, proper point sampling,
    coordinate normalization) are better validated through integration testing with
    simulated input events and visual regression testing. The state machine for
    drawing (start stroke → add points → end stroke) is simple enough that
    conventional testing provides adequate confidence.
    
    The distance threshold logic (filtering points < 2px apart) is a simple
    mathematical operation that doesn't warrant formal verification. Coordinate
    normalization to 0-1 range is a straightforward linear transformation.
    
    The risk level is moderate primarily due to integration complexity with the
    iced framework, not algorithmic complexity that would benefit from formal
    methods. Property-based testing could validate the normalization function,
    but full formal verification would be excessive for a UI input component.
    
    Future recognition systems (Task 9) that consume this stroke data may have
    higher verification needs, but the canvas itself is appropriately validated
    through integration and property-based testing as outlined in the task spec.

tests:
  strategy:
    approach: "mixed (unit + integration)"
    rationale:
      - "Unit tests verify stroke data structures, point normalization, and distance threshold filtering"
      - "Integration tests simulate mouse/touch event sequences to validate state machine behavior"
      - "Stroke rendering quality and continuity require event-driven testing"
      - "Canvas Program trait implementation needs integration testing with simulated user interactions"

  implementation:
    file: "src/ui/canvas.rs"
    location: "in existing test module"
    code: |
      #[cfg(test)]
      mod tests {
          use super::*;
          use iced::Point;
          
          // ============================================================================
          // Unit Tests - Stroke Data Structures
          // ============================================================================
          
          #[test]
          fn test_stroke_creation() {
              // Verify stroke can be created with points and timestamp
              let points = vec![
                  Point::new(10.0, 20.0),
                  Point::new(15.0, 25.0),
                  Point::new(20.0, 30.0),
              ];
              let timestamp = std::time::SystemTime::now();
              
              let stroke = Stroke::new(points.clone(), timestamp);
              
              assert_eq!(stroke.points.len(), 3);
              assert_eq!(stroke.points[0], Point::new(10.0, 20.0));
              assert_eq!(stroke.timestamp, timestamp);
          }
          
          #[test]
          fn test_stroke_normalization() {
              // Verify stroke coordinates are normalized to 0-1 range
              let points = vec![
                  Point::new(50.0, 100.0),
                  Point::new(150.0, 150.0),
                  Point::new(200.0, 50.0),
              ];
              let canvas_size = iced::Size::new(200.0, 200.0);
              let stroke = Stroke::new(points, std::time::SystemTime::now());
              
              let normalized = stroke.normalize(canvas_size);
              
              assert_eq!(normalized[0], Point::new(0.25, 0.5));
              assert_eq!(normalized[1], Point::new(0.75, 0.75));
              assert_eq!(normalized[2], Point::new(1.0, 0.25));
          }
          
          #[test]
          fn test_distance_threshold_filtering() {
              // Verify points below distance threshold are filtered out
              let mut drawing_state = DrawingState::new();
              let threshold = 2.0;
              
              drawing_state.add_point(Point::new(10.0, 10.0), threshold);
              drawing_state.add_point(Point::new(10.5, 10.5), threshold); // Too close, should be filtered
              drawing_state.add_point(Point::new(13.0, 13.0), threshold); // Far enough, should be kept
              
              assert_eq!(drawing_state.current_stroke_points().len(), 2);
              assert_eq!(drawing_state.current_stroke_points()[0], Point::new(10.0, 10.0));
              assert_eq!(drawing_state.current_stroke_points()[1], Point::new(13.0, 13.0));
          }
          
          #[test]
          fn test_drawing_state_initialization() {
              // Verify DrawingState initializes with empty stroke history
              let state = DrawingState::new();
              
              assert_eq!(state.completed_strokes().len(), 0);
              assert_eq!(state.current_stroke_points().len(), 0);
              assert!(!state.is_drawing());
          }
          
          #[test]
          fn test_stroke_completion() {
              // Verify stroke completion moves current stroke to completed strokes
              let mut state = DrawingState::new();
              
              state.start_stroke(Point::new(10.0, 10.0));
              state.add_point(Point::new(20.0, 20.0), 2.0);
              state.add_point(Point::new(30.0, 30.0), 2.0);
              state.complete_stroke();
              
              assert_eq!(state.completed_strokes().len(), 1);
              assert_eq!(state.completed_strokes()[0].points.len(), 3);
              assert_eq!(state.current_stroke_points().len(), 0);
              assert!(!state.is_drawing());
          }
          
          #[test]
          fn test_clear_all_strokes() {
              // Verify clear operation removes all strokes
              let mut state = DrawingState::new();
              
              state.start_stroke(Point::new(10.0, 10.0));
              state.add_point(Point::new(20.0, 20.0), 2.0);
              state.complete_stroke();
              
              state.start_stroke(Point::new(30.0, 30.0));
              state.add_point(Point::new(40.0, 40.0), 2.0);
              state.complete_stroke();
              
              state.clear();
              
              assert_eq!(state.completed_strokes().len(), 0);
              assert_eq!(state.current_stroke_points().len(), 0);
              assert!(!state.is_drawing());
          }
          
          #[test]
          fn test_undo_last_stroke() {
              // Verify undo removes only the last completed stroke
              let mut state = DrawingState::new();
              
              state.start_stroke(Point::new(10.0, 10.0));
              state.add_point(Point::new(20.0, 20.0), 2.0);
              state.complete_stroke();
              
              state.start_stroke(Point::new(30.0, 30.0));
              state.add_point(Point::new(40.0, 40.0), 2.0);
              state.complete_stroke();
              
              state.undo();
              
              assert_eq!(state.completed_strokes().len(), 1);
              assert_eq!(state.completed_strokes()[0].points[0], Point::new(10.0, 10.0));
          }
          
          #[test]
          fn test_undo_with_no_strokes() {
              // Verify undo operation is safe when no strokes exist
              let mut state = DrawingState::new();
              
              state.undo(); // Should not panic
              
              assert_eq!(state.completed_strokes().len(), 0);
          }
          
          // ============================================================================
          // Integration Tests - Event Handling State Machine
          // ============================================================================
          
          #[test]
          fn test_mouse_button_pressed_starts_stroke() {
              // Verify MouseButtonPressed event initiates stroke capture
              let mut canvas = HandwritingCanvas::new();
              let cursor = iced::mouse::Cursor::Available(Point::new(50.0, 50.0));
              
              let event = canvas::Event::Mouse(iced::mouse::Event::ButtonPressed(
                  iced::mouse::Button::Left,
              ));
              
              let (_status, _message) = canvas.update(event, cursor);
              
              assert!(canvas.state.is_drawing());
              assert_eq!(canvas.state.current_stroke_points().len(), 1);
              assert_eq!(canvas.state.current_stroke_points()[0], Point::new(50.0, 50.0));
          }
          
          #[test]
          fn test_cursor_moved_adds_points_while_drawing() {
              // Verify CursorMoved events add points to current stroke
              let mut canvas = HandwritingCanvas::new();
              
              // Start stroke
              let cursor_start = iced::mouse::Cursor::Available(Point::new(10.0, 10.0));
              let press_event = canvas::Event::Mouse(iced::mouse::Event::ButtonPressed(
                  iced::mouse::Button::Left,
              ));
              canvas.update(press_event, cursor_start);
              
              // Move cursor
              let cursor_move1 = iced::mouse::Cursor::Available(Point::new(20.0, 20.0));
              let move_event1 = canvas::Event::Mouse(iced::mouse::Event::CursorMoved {
                  position: Point::new(20.0, 20.0),
              });
              canvas.update(move_event1, cursor_move1);
              
              let cursor_move2 = iced::mouse::Cursor::Available(Point::new(30.0, 30.0));
              let move_event2 = canvas::Event::Mouse(iced::mouse::Event::CursorMoved {
                  position: Point::new(30.0, 30.0),
              });
              canvas.update(move_event2, cursor_move2);
              
              assert!(canvas.state.is_drawing());
              assert_eq!(canvas.state.current_stroke_points().len(), 3);
          }
          
          #[test]
          fn test_cursor_moved_ignored_when_not_drawing() {
              // Verify CursorMoved events are ignored when not actively drawing
              let mut canvas = HandwritingCanvas::new();
              
              let cursor = iced::mouse::Cursor::Available(Point::new(20.0, 20.0));
              let move_event = canvas::Event::Mouse(iced::mouse::Event::CursorMoved {
                  position: Point::new(20.0, 20.0),
              });
              
              canvas.update(move_event, cursor);
              
              assert!(!canvas.state.is_drawing());
              assert_eq!(canvas.state.current_stroke_points().len(), 0);
          }
          
          #[test]
          fn test_mouse_button_released_completes_stroke() {
              // Verify MouseButtonReleased event finalizes stroke
              let mut canvas = HandwritingCanvas::new();
              
              // Start and draw
              let cursor_start = iced::mouse::Cursor::Available(Point::new(10.0, 10.0));
              let press_event = canvas::Event::Mouse(iced::mouse::Event::ButtonPressed(
                  iced::mouse::Button::Left,
              ));
              canvas.update(press_event, cursor_start);
              
              let cursor_move = iced::mouse::Cursor::Available(Point::new(50.0, 50.0));
              let move_event = canvas::Event::Mouse(iced::mouse::Event::CursorMoved {
                  position: Point::new(50.0, 50.0),
              });
              canvas.update(move_event, cursor_move);
              
              // Release
              let cursor_release = iced::mouse::Cursor::Available(Point::new(50.0, 50.0));
              let release_event = canvas::Event::Mouse(iced::mouse::Event::ButtonReleased(
                  iced::mouse::Button::Left,
              ));
              canvas.update(release_event, cursor_release);
              
              assert!(!canvas.state.is_drawing());
              assert_eq!(canvas.state.completed_strokes().len(), 1);
              assert_eq!(canvas.state.current_stroke_points().len(), 0);
          }
          
          #[test]
          fn test_multiple_stroke_sequence() {
              // Verify multiple strokes are captured and maintained in sequence
              let mut canvas = HandwritingCanvas::new();
              
              // First stroke
              canvas.simulate_stroke(vec![
                  Point::new(10.0, 10.0),
                  Point::new(20.0, 20.0),
                  Point::new(30.0, 30.0),
              ]);
              
              // Second stroke
              canvas.simulate_stroke(vec![
                  Point::new(40.0, 40.0),
                  Point::new(50.0, 50.0),
              ]);
              
              // Third stroke
              canvas.simulate_stroke(vec![
                  Point::new(60.0, 60.0),
                  Point::new(70.0, 70.0),
                  Point::new(80.0, 80.0),
                  Point::new(90.0, 90.0),
              ]);
              
              assert_eq!(canvas.state.completed_strokes().len(), 3);
              assert_eq!(canvas.state.completed_strokes()[0].points.len(), 3);
              assert_eq!(canvas.state.completed_strokes()[1].points.len(), 2);
              assert_eq!(canvas.state.completed_strokes()[2].points.len(), 4);
          }
          
          #[test]
          fn test_stroke_data_export() {
              // Verify stroke data exports as Vec<Vec<Point>>
              let mut canvas = HandwritingCanvas::new();
              
              canvas.simulate_stroke(vec![
                  Point::new(10.0, 10.0),
                  Point::new(20.0, 20.0),
              ]);
              
              canvas.simulate_stroke(vec![
                  Point::new(30.0, 30.0),
                  Point::new(40.0, 40.0),
                  Point::new(50.0, 50.0),
              ]);
              
              let exported = canvas.export_strokes();
              
              assert_eq!(exported.len(), 2);
              assert_eq!(exported[0].len(), 2);
              assert_eq!(exported[1].len(), 3);
              assert_eq!(exported[0][0], Point::new(10.0, 10.0));
              assert_eq!(exported[1][2], Point::new(50.0, 50.0));
          }
          
          #[test]
          fn test_stroke_continuity_no_gaps() {
              // Verify strokes are continuous with no gaps from missed events
              let mut canvas = HandwritingCanvas::new();
              
              // Simulate rapid cursor movements
              let cursor_start = iced::mouse::Cursor::Available(Point::new(0.0, 0.0));
              let press_event = canvas::Event::Mouse(iced::mouse::Event::ButtonPressed(
                  iced::mouse::Button::Left,
              ));
              canvas.update(press_event, cursor_start);
              
              // Rapid sequence of movements
              for i in 1..=20 {
                  let x = i as f32 * 10.0;
                  let cursor = iced::mouse::Cursor::Available(Point::new(x, x));
                  let move_event = canvas::Event::Mouse(iced::mouse::Event::CursorMoved {
                      position: Point::new(x, x),
                  });
                  canvas.update(move_event, cursor);
              }
              
              let cursor_release = iced::mouse::Cursor::Available(Point::new(200.0, 200.0));
              let release_event = canvas::Event::Mouse(iced::mouse::Event::ButtonReleased(
                  iced::mouse::Button::Left,
              ));
              canvas.update(release_event, cursor_release);
              
              // Verify all points captured (accounting for distance threshold)
              let stroke = &canvas.state.completed_strokes()[0];
              assert!(stroke.points.len() > 10); // Should capture most points
              
              // Verify continuity - each point should be reasonably close to the next
              for i in 0..stroke.points.len() - 1 {
                  let dist = distance(stroke.points[i], stroke.points[i + 1]);
                  assert!(dist < 20.0, "Gap detected between points");
              }
          }
          
          // ============================================================================
          // Helper Functions for Testing
          // ============================================================================
          
          impl HandwritingCanvas {
              /// Helper method to simulate a complete stroke for testing
              fn simulate_stroke(&mut self, points: Vec<Point>) {
                  if points.is_empty() {
                      return;
                  }
                  
                  // Start stroke
                  let cursor = iced::mouse::Cursor::Available(points[0]);
                  let press_event = canvas::Event::Mouse(iced::mouse::Event::ButtonPressed(
                      iced::mouse::Button::Left,
                  ));
                  self.update(press_event, cursor);
                  
                  // Add intermediate points
                  for point in points.iter().skip(1) {
                      let cursor = iced::mouse::Cursor::Available(*point);
                      let move_event = canvas::Event::Mouse(iced::mouse::Event::CursorMoved {
                          position: *point,
                      });
                      self.update(move_event, cursor);
                  }
                  
                  // Complete stroke
                  let cursor = iced::mouse::Cursor::Available(*points.last().unwrap());
                  let release_event = canvas::Event::Mouse(iced::mouse::Event::ButtonReleased(
                      iced::mouse::Button::Left,
                  ));
                  self.update(release_event, cursor);
              }
          }
          
          fn distance(p1: Point, p2: Point) -> f32 {
              let dx = p2.x - p1.x;
              let dy = p2.y - p1.y;
              (dx * dx + dy * dy).sqrt()
          }
      }

  coverage:
    - "Stroke creation with points and timestamp"
    - "Stroke coordinate normalization to 0-1 range"
    - "Distance threshold filtering removes points below 2px threshold"
    - "DrawingState initialization with empty stroke history"
    - "Stroke completion moves current stroke to completed strokes list"
    - "Clear operation removes all strokes from canvas"
    - "Undo operation removes only the last completed stroke"
    - "Undo operation safety when no strokes exist"
    - "Mouse ButtonPressed event initiates stroke capture"
    - "CursorMoved events add points to current stroke while drawing"
    - "CursorMoved events ignored when not actively drawing"
    - "Mouse ButtonReleased event finalizes stroke"
    - "Multiple strokes captured and maintained in correct sequence"
    - "Stroke data exports as Vec<Vec<Point>> format"
    - "Stroke continuity verified with no gaps from missed events"
    - "Point sampling consistency during rapid cursor movements"

dependencies:
  depends_on:
    - task_id: 1
      reason: "Needs Canvas widget support from iced foundation"

  depended_upon_by:
    - task_id: 8
      reason: "Practice mode requires drawing canvas for handwriting exercises"
    - task_id: 9
      reason: "Recognition system needs stroke data format exported by canvas"

  external:
    - name: "iced::canvas::Program"
      type: "trait"
      status: "already exists"
    - name: "iced::Point"
      type: "struct"
      status: "already exists"
    - name: "iced::Size"
      type: "struct"
      status: "already exists"
    - name: "lyon::path::Path"
      type: "struct"
      status: "already exists"
    - name: "std::time::SystemTime"
      type: "struct"
      status: "already exists"
---
task:
  id: 6
  name: "Application State Management and Navigation"

context:
  description: |
    This task implements the core Elm architecture state management system for the
    kanji learning application. It establishes the foundational control flow that
    orchestrates all user interactions, screen transitions, and application state
    consistency. The implementation creates a predictable, testable architecture
    where all state changes flow through a single update function, ensuring referential
    transparency and making the application behavior easy to reason about.
    
    The state management system serves as the central nervous system of the application,
    coordinating between the UI layer (view functions) and business logic (update handlers).
    It manages complex workflows including learning sessions with spaced repetition,
    practice modes with performance tracking, and navigation between multiple screens
    while maintaining session continuity.
    
    This architecture follows the Elm pattern where state transitions are pure functions,
    side effects are isolated to Task/Command structures, and all possible application
    states are represented explicitly in the type system. This design prevents entire
    classes of bugs related to invalid states and makes the application highly testable
    without requiring UI or database integration during unit testing.

  key_points:
    - "Implements pure functional state transitions following Elm architecture principles"
    - "Screen enum with variants carrying screen-specific state enables type-safe navigation"
    - "Message enum comprehensively captures all user interactions and system events"
    - "Central update() function routes messages to screen-specific handlers maintaining referential transparency"
    - "Async operations (database, recognition) handled via Task without breaking purity"
    - "Shared state (progress, settings) managed through Arc<RwLock> for cross-screen access"
    - "Session state (learning/practice) owned by Screen variants ensuring encapsulation"
    - "Navigation helpers initialize screen state correctly on transitions"
    - "High testability due to pure functions and explicit state representation"
    - "Serves as integration point for all other application subsystems"

files:
  - path: "src/state/mod.rs"
    description: "Module declaration file for state management, exports AppState, Screen, Message, and navigation functions"
  
  - path: "src/state/app_state.rs"
    description: "Defines the AppState struct that holds the current screen and shared application data (progress, settings, database connection)"
  
  - path: "src/state/screen.rs"
    description: "Defines the Screen enum with variants for each application screen (MainMenu, Learning, Practice, Statistics, Settings) and their associated state"
  
  - path: "src/state/message.rs"
    description: "Defines the comprehensive Message enum containing all possible user interactions, navigation events, and system events"
  
  - path: "src/state/update.rs"
    description: "Implements the Application::update() function that handles all state transitions and message routing"
  
  - path: "src/state/navigation.rs"
    description: "Helper functions for screen transitions, state initialization, and navigation stack management"
  
  - path: "src/state/session_state.rs"
    description: "Defines state structures for learning and practice sessions (current character, queue, timing, results)"
  
  - path: "src/state/shared.rs"
    description: "Defines SharedState struct for application data accessible across all screens"
  
  - path: "src/lib.rs"
    description: "Updated to include the state module declaration and re-export key state types"
  
  - path: "tests/state_tests.rs"
    description: "Unit tests for state transitions, message handling, navigation flows, and session state management"

functions:
  - file: "src/state/mod.rs"
    items:
      - type: "module_declaration"
        name: "pub mod app_state;"
        description: "Module containing AppState root state container"
      
      - type: "module_declaration"
        name: "pub mod screen;"
        description: "Module containing Screen enum and screen-specific state types"
      
      - type: "module_declaration"
        name: "pub mod message;"
        description: "Module containing Message enum and message-related types"
      
      - type: "module_declaration"
        name: "pub mod navigation;"
        description: "Module containing navigation helper functions"
      
      - type: "module_declaration"
        name: "pub mod session_state;"
        description: "Module containing learning and practice session state structures"
      
      - type: "module_declaration"
        name: "pub mod shared;"
        description: "Module containing SharedState for cross-screen data"

  - file: "src/state/app_state.rs"
    items:
      - type: "struct"
        name: "AppState"
        description: "Root state container holding current screen, shared data, and session state"
        invariants: "Always contains a valid Screen variant; shared data accessible via Arc<RwLock>"
      
      - type: "method"
        name: "AppState::new"
        description: "Creates initial AppState with MainMenu screen and default shared data"
        postconditions: "Returns AppState in MainMenu screen with initialized database connection"
      
      - type: "method"
        name: "AppState::current_screen"
        description: "Returns immutable reference to current Screen"
        preconditions: "AppState is initialized"
      
      - type: "method"
        name: "AppState::current_screen_mut"
        description: "Returns mutable reference to current Screen"
        preconditions: "AppState is initialized"

  - file: "src/state/screen.rs"
    items:
      - type: "enum"
        name: "Screen"
        description: "Represents all application screens with associated state data"
        invariants: "Each variant contains valid state for that screen; no orphaned data"
      
      - type: "enum_variant"
        name: "Screen::MainMenu"
        description: "Main menu screen with no additional state"
      
      - type: "enum_variant"
        name: "Screen::Learning(LearningSessionState)"
        description: "Active learning session screen with session-specific state"
      
      - type: "enum_variant"
        name: "Screen::Practice(PracticeSessionState)"
        description: "Practice mode screen with practice session state"
      
      - type: "enum_variant"
        name: "Screen::Statistics(StatisticsState)"
        description: "Statistics and progress viewing screen"
      
      - type: "enum_variant"
        name: "Screen::Settings(SettingsState)"
        description: "Settings configuration screen"
      
      - type: "enum_variant"
        name: "Screen::CharacterDetail(CharacterDetailState)"
        description: "Individual character detail and history screen"
      
      - type: "struct"
        name: "LearningSessionState"
        description: "State for an active learning session including current character, review queue, and session progress"
        invariants: "current_character_index < characters.len(); review_queue is properly ordered"
      
      - type: "struct"
        name: "PracticeSessionState"
        description: "State for practice mode including practice set, current character, and performance metrics"
        invariants: "current_index < practice_set.len()"
      
      - type: "struct"
        name: "StatisticsState"
        description: "State for statistics screen including time range filters and cached statistics data"
      
      - type: "struct"
        name: "SettingsState"
        description: "State for settings screen including temporary/unsaved setting values"
      
      - type: "struct"
        name: "CharacterDetailState"
        description: "State for character detail view including character ID and historical performance data"

  - file: "src/state/message.rs"
    items:
      - type: "enum"
        name: "Message"
        description: "All possible user interactions and system events in the application"
      
      - type: "enum_variant"
        name: "Message::NavigateToMainMenu"
        description: "Navigate to main menu screen"
      
      - type: "enum_variant"
        name: "Message::StartLearningSession"
        description: "Initialize and navigate to learning session"
      
      - type: "enum_variant"
        name: "Message::StartPracticeSession(PracticeMode)"
        description: "Initialize practice session with specified mode (all characters, weakest, etc.)"
      
      - type: "enum_variant"
        name: "Message::ViewStatistics"
        description: "Navigate to statistics screen"
      
      - type: "enum_variant"
        name: "Message::ViewSettings"
        description: "Navigate to settings screen"
      
      - type: "enum_variant"
        name: "Message::ViewCharacterDetail(CharacterId)"
        description: "Navigate to character detail screen for specified character"
      
      - type: "enum_variant"
        name: "Message::DrawingStarted"
        description: "User began drawing stroke on canvas"
      
      - type: "enum_variant"
        name: "Message::DrawingContinued(Point)"
        description: "User continued drawing with stroke point"
      
      - type: "enum_variant"
        name: "Message::DrawingEnded"
        description: "User completed current stroke"
      
      - type: "enum_variant"
        name: "Message::SubmitDrawing"
        description: "User submitted complete drawing for recognition"
      
      - type: "enum_variant"
        name: "Message::ClearDrawing"
        description: "Clear current drawing canvas"
      
      - type: "enum_variant"
        name: "Message::UndoStroke"
        description: "Undo last drawn stroke"
      
      - type: "enum_variant"
        name: "Message::RecognitionComplete(RecognitionResult)"
        description: "Recognition engine completed processing drawing"
      
      - type: "enum_variant"
        name: "Message::AnswerRevealed"
        description: "User requested to reveal correct answer"
      
      - type: "enum_variant"
        name: "Message::RateResponse(ResponseRating)"
        description: "User rated their recall quality (SRS rating)"
      
      - type: "enum_variant"
        name: "Message::NextCharacter"
        description: "Advance to next character in session"
      
      - type: "enum_variant"
        name: "Message::SessionComplete"
        description: "Learning or practice session completed"
      
      - type: "enum_variant"
        name: "Message::UpdateSetting(SettingKey, SettingValue)"
        description: "Update application setting value"
      
      - type: "enum_variant"
        name: "Message::SaveSettings"
        description: "Persist setting changes to database"
      
      - type: "enum_variant"
        name: "Message::FilterStatistics(TimeRange)"
        description: "Update statistics display for time range"
      
      - type: "enum_variant"
        name: "Message::DatabaseOperationComplete(DbResult)"
        description: "Async database operation completed with result"
      
      - type: "enum_variant"
        name: "Message::ErrorOccurred(AppError)"
        description: "Error occurred during operation"
      
      - type: "enum"
        name: "PracticeMode"
        description: "Different practice session modes"
      
      - type: "enum_variant"
        name: "PracticeMode::AllCharacters"
        description: "Practice all learned characters"
      
      - type: "enum_variant"
        name: "PracticeMode::WeakestCharacters(usize)"
        description: "Practice N weakest characters by accuracy"
      
      - type: "enum_variant"
        name: "PracticeMode::DueForReview"
        description: "Practice characters due for SRS review"
      
      - type: "enum_variant"
        name: "PracticeMode::Custom(Vec<CharacterId>)"
        description: "Practice specific character set"
      
      - type: "enum"
        name: "ResponseRating"
        description: "SRS quality rating for recall"
      
      - type: "enum_variant"
        name: "ResponseRating::Again"
        description: "Complete failure to recall"
      
      - type: "enum_variant"
        name: "ResponseRating::Hard"
        description: "Recalled with significant difficulty"
      
      - type: "enum_variant"
        name: "ResponseRating::Good"
        description: "Recalled with some effort"
      
      - type: "enum_variant"
        name: "ResponseRating::Easy"
        description: "Recalled easily and confidently"
      
      - type: "struct"
        name: "RecognitionResult"
        description: "Result from character recognition engine"
        invariants: "candidates are sorted by confidence descending; confidence values in [0.0, 1.0]"
      
      - type: "struct"
        name: "DbResult"
        description: "Result wrapper for async database operations"

  - file: "src/application.rs"
    items:
      - type: "method"
        name: "Application::update"
        description: "Main state transition function implementing Elm architecture update logic"
        preconditions: "message is valid; state is consistent"
        postconditions: "Returns updated state and optional Task for async operations; state remains consistent"
        invariants: "Pure function - no side effects; all state changes captured in return value"
      
      - type: "method"
        name: "Application::update_main_menu"
        description: "Handle messages specific to main menu screen"
        preconditions: "Current screen is MainMenu"
        postconditions: "Returns updated state or initiates screen transition"
      
      - type: "method"
        name: "Application::update_learning_session"
        description: "Handle messages during active learning session"
        preconditions: "Current screen is Learning with valid session state"
        postconditions: "Updates session state or transitions to next character/session end"
      
      - type: "method"
        name: "Application::update_practice_session"
        description: "Handle messages during practice session"
        preconditions: "Current screen is Practice with valid session state"
        postconditions: "Updates practice state or transitions to next character/session end"
      
      - type: "method"
        name: "Application::update_statistics"
        description: "Handle messages in statistics screen"
        preconditions: "Current screen is Statistics"
        postconditions: "Updates statistics filters or cached data"
      
      - type: "method"
        name: "Application::update_settings"
        description: "Handle messages in settings screen"
        preconditions: "Current screen is Settings"
        postconditions: "Updates temporary settings or persistschanges"
      
      - type: "method"
        name: "Application::update_character_detail"
        description: "Handle messages in character detail screen"
        preconditions: "Current screen is CharacterDetail"
        postconditions: "Updates detail view state"

  - file: "src/state/navigation.rs"
    items:
      - type: "function"
        name: "navigate_to_learning_session"
        description: "Initialize learning session state and create Learning screen"
        preconditions: "Database contains characters for learning"
        postconditions: "Returns Screen::Learning with initialized session or error"
      
      - type: "function"
        name: "navigate_to_practice_session"
        description: "Initialize practice session state for given mode and create Practice screen"
        preconditions: "Database contains characters matching practice mode criteria"
        postconditions: "Returns Screen::Practice with initialized session or error"
      
      - type: "function"
        name: "navigate_to_statistics"
        description: "Initialize statistics screen with default time range"
        postconditions: "Returns Screen::Statistics with default filters"
      
      - type: "function"
        name: "navigate_to_settings"
        description: "Load current settings and create Settings screen"
        preconditions: "Database contains settings data"
        postconditions: "Returns Screen::Settings with current setting values"
      
      - type: "function"
        name: "navigate_to_character_detail"
        description: "Load character detail data and create CharacterDetail screen"
        preconditions: "Character ID exists in database"
        postconditions: "Returns Screen::CharacterDetail with loaded data or error"
      
      - type: "function"
        name: "navigate_to_main_menu"
        description: "Create main menu screen and clear session state"
        postconditions: "Returns Screen::MainMenu"
      
      - type: "function"
        name: "initialize_learning_queue"
        description: "Build initial learning queue using SRS algorithm"
        preconditions: "Database contains character review data"
        postconditions: "Returns ordered queue of characters for learning session"
        invariants: "Queue follows SRS priority ordering"
      
      - type: "function"
        name: "initialize_practice_set"
        description: "Build practice character set based on practice mode"
        preconditions: "Practice mode is valid; database contains matching characters"
        postconditions: "Returns character set matching mode criteria"

  - file: "src/state/shared.rs"
    items:
      - type: "struct"
        name: "SharedState"
        description: "Shared application state accessible across all screens"
        invariants: "Database connection is valid; settings are internally consistent"
      
      - type: "method"
        name: "SharedState::new"
        description: "Create shared state with database connection and loaded settings"
        postconditions: "Returns SharedState with open database connection and loaded settings"
      
      - type: "method"
        name: "SharedState::get_setting"
        description: "Retrieve current value of application setting"
        preconditions: "Setting key is valid"
      
      - type: "method"
        name: "SharedState::update_setting"
        description: "Update setting value in shared state (not persisted)"
        preconditions: "Setting key and value are valid and compatible"
      
      - type: "method"
        name: "SharedState::persist_settings"
        description: "Save current settings to database"
        postconditions: "Returns Task that persists settings and returns result message"

  - file: "src/types/mod.rs"
    items:
      - type: "type"
        name: "CharacterId"
        description: "Unique identifier for a character (type alias for i64 or custom type)"
      
      - type: "type"
        name: "SettingKey"
        description: "Enumeration of all application setting keys"
      
      - type: "type"
        name: "SettingValue"
        description: "Variant type for setting values (String, Int, Bool, etc.)"
      
      - type: "struct"
        name: "Point"
        description: "2D point coordinate for drawing strokes"
        invariants: "x and y coordinates are finite numbers"
      
      - type: "enum"
        name: "AppError"
        description: "Application-level error types"
      
      - type: "enum_variant"
        name: "AppError::Database(DbError)"
        description: "Database operation error"
      
      - type: "enum_variant"
        name: "AppError::Recognition(RecognitionError)"
        description: "Character recognition error"
      
      - type: "enum_variant"
        name: "AppError::InvalidState(String)"
        description: "Invalid state transition or state inconsistency"
      
      - type: "enum_variant"
        name: "AppError::Navigation(String)"
        description: "Navigation error (missing data, invalid transition)"

formal_verification:
  needed: true
  level: "Basic"
  explanation: |
    State management in the Elm architecture is the critical orchestration layer
    that controls all application behavior. While full formal verification may be
    impractical for the entire state machine, basic verification of key invariants
    is essential to prevent invalid states, ensure state transition correctness,
    and guarantee that no screen transitions lead to undefined behavior.
    
    The high complexity and integration risk noted in the task assessment, combined
    with the fact that this is the "central orchestrator" touching all other systems,
    makes verification valuable. However, the pure functional nature of update()
    and the comprehensive unit testing strategy provide strong guarantees, so we
    recommend Basic level verification focused on critical invariants rather than
    exhaustive state space exploration.
    
    Critical concerns requiring verification:
    1. No unreachable or invalid states (as mentioned in critical properties)
    2. State transition completeness (all Message variants handled)
    3. Navigation stack integrity (proper back/forward flow)
    4. Session state consistency across screen transitions
    5. Absence of panic paths in update()
    
    The shared state via Arc<RwLock> introduces potential deadlocks (noted in risks),
    but this is a runtime concurrency concern better addressed through runtime testing
    and careful design patterns rather than formal verification.

  properties:
    - name: "State Transition Completeness"
      formal_statement: |
        ∀ state : AppState, ∀ msg : Message,
        ∃ state' : AppState such that update(state, msg) → state'
        (No message/state combination results in panic or undefined behavior)

    - name: "Screen Variant Exhaustiveness"
      formal_statement: |
        ∀ screen : Screen, screen matches exactly one variant ∈ 
        {MainMenu, Learning, Practice, Statistics, Settings, CharacterDetail}
        (Rust's enum exhaustiveness provides this, verify no wildcard catches)

    - name: "Navigation Stack Validity"
      formal_statement: |
        ∀ navigation_stack : Vec<Screen>,
        navigation_stack.len() ≥ 1 ∧ 
        navigation_stack[0] = MainMenu ∧
        (∀ i : 0 ≤ i < len, screen_reachable(navigation_stack[i], navigation_stack[i+1]))
        (Navigation stack always contains at least MainMenu and follows valid transitions)

    - name: "Session State Preservation"
      formal_statement: |
        ∀ state : AppState with Screen::Learning(session_data),
        ∀ msg : Message where msg ≠ NavigateBack ∧ msg ≠ NavigateToScreen(_),
        update(state, msg) = state' ⟹ 
        state'.current_screen preserves session_data or session_data is persisted
        (Session data is not lost during non-navigation updates)

    - name: "State Consistency After Async Operations"
      formal_statement: |
        ∀ state : AppState, ∀ async_msg : Message::AsyncResult(_),
        update(state, async_msg) = state' ⟹
        state'.is_consistent() = true
        (Async operation results maintain AppState invariants)

    - name: "No Shared State Mutation During Pure Updates"
      formal_statement: |
        ∀ state : AppState, ∀ msg : Message,
        update(state, msg) does not directly mutate Arc<RwLock<T>> contents
        (All shared state updates occur through Task/Command, not in pure update())

  strategy:
    - "Use Rust's type system exhaustiveness checking for enum variants (Message and Screen)"
    - "Implement compile-time assertions using const fn where possible for invariants"
    - "Apply property-based testing (PropTest) to verify state transition properties hold for arbitrary valid inputs"
    - "Create state machine model checker using quickcheck or similar to explore state space for small configurations"
    - "Implement runtime assertions in debug builds to verify invariants (using debug_assert!)"
    - "Use static analysis tools (clippy with custom lints) to detect pattern match non-exhaustiveness and potential panics"
    - "Document and manually verify that all async Task operations return Messages that are handled in update()"
    - "Create invariant checking functions (is_valid_state(), is_consistent()) called in tests and debug assertions"

tests:
  strategy:
    approach: "unit tests with property-based testing"
    rationale:
      - "State transitions are pure functions making them highly testable with unit tests"
      - "Message handling and navigation flows can be verified without UI or database dependencies"
      - "Property-based tests ensure state consistency across all possible transitions"
      - "Screen transitions and state initialization are deterministic and isolated"
      - "Critical path for application correctness - comprehensive coverage is essential"
      - "Low cost to test since update() is pure and stateless operations are easily mockable"

  implementation:
    file: "tests/state_tests.rs"
    location: "create new"
    code: |
      #[cfg(test)]
      mod app_state_tests {
          use super::*;
          use crate::models::{Character, CharacterProgress, LearningSession, PracticeSession};
          use crate::state::{AppState, Screen, Message};
          use std::sync::{Arc, RwLock};

          fn create_test_app_state() -> AppState {
              AppState {
                  current_screen: Screen::MainMenu,
                  characters: Arc::new(RwLock::new(vec![])),
                  progress: Arc::new(RwLock::new(vec![])),
                  settings: Arc::new(RwLock::new(Default::default())),
              }
          }

          fn create_test_character(id: u32, kanji: &str) -> Character {
              Character {
                  id,
                  kanji: kanji.to_string(),
                  readings: vec!["test".to_string()],
                  meanings: vec!["test meaning".to_string()],
                  stroke_count: 5,
                  grade: 1,
                  frequency: Some(100),
              }
          }

          #[test]
          fn test_initial_state_is_main_menu() {
              let state = create_test_app_state();
              assert!(matches!(state.current_screen, Screen::MainMenu));
          }

          #[test]
          fn test_navigate_to_learning_screen() {
              let mut state = create_test_app_state();
              let characters = vec![create_test_character(1, "一")];
              
              let msg = Message::StartLearningSession(characters.clone());
              state.update(msg);
              
              match &state.current_screen {
                  Screen::Learning(session) => {
                      assert_eq!(session.characters.len(), 1);
                      assert_eq!(session.current_index, 0);
                      assert!(!session.is_complete);
                  }
                  _ => panic!("Expected Learning screen"),
              }
          }

          #[test]
          fn test_navigate_to_practice_screen() {
              let mut state = create_test_app_state();
              let characters = vec![create_test_character(1, "一")];
              
              let msg = Message::StartPracticeSession {
                  characters: characters.clone(),
                  mode: crate::models::PracticeMode::Recognition,
              };
              state.update(msg);
              
              match &state.current_screen {
                  Screen::Practice(session) => {
                      assert_eq!(session.characters.len(), 1);
                      assert_eq!(session.current_index, 0);
                      assert!(!session.is_complete);
                  }
                  _ => panic!("Expected Practice screen"),
              }
          }

          #[test]
          fn test_navigate_to_statistics_screen() {
              let mut state = create_test_app_state();
              
              let msg = Message::NavigateToStatistics;
              state.update(msg);
              
              assert!(matches!(state.current_screen, Screen::Statistics(_)));
          }

          #[test]
          fn test_return_to_main_menu_from_learning() {
              let mut state = create_test_app_state();
              state.current_screen = Screen::Learning(LearningSession {
                  characters: vec![create_test_character(1, "一")],
                  current_index: 0,
                  is_complete: false,
                  learned_characters: vec![],
              });
              
              let msg = Message::ReturnToMainMenu;
              state.update(msg);
              
              assert!(matches!(state.current_screen, Screen::MainMenu));
          }

          #[test]
          fn test_return_to_main_menu_from_practice() {
              let mut state = create_test_app_state();
              state.current_screen = Screen::Practice(PracticeSession {
                  characters: vec![create_test_character(1, "一")],
                  current_index: 0,
                  is_complete: false,
                  mode: crate::models::PracticeMode::Recognition,
                  results: vec![],
              });
              
              let msg = Message::ReturnToMainMenu;
              state.update(msg);
              
              assert!(matches!(state.current_screen, Screen::MainMenu));
          }

          #[test]
          fn test_learning_session_advance_character() {
              let mut state = create_test_app_state();
              let characters = vec![
                  create_test_character(1, "一"),
                  create_test_character(2, "二"),
              ];
              
              state.current_screen = Screen::Learning(LearningSession {
                  characters: characters.clone(),
                  current_index: 0,
                  is_complete: false,
                  learned_characters: vec![],
              });
              
              let msg = Message::AdvanceToNextCharacter;
              state.update(msg);
              
              match &state.current_screen {
                  Screen::Learning(session) => {
                      assert_eq!(session.current_index, 1);
                      assert!(!session.is_complete);
                  }
                  _ => panic!("Expected Learning screen"),
              }
          }

          #[test]
          fn test_learning_session_complete_on_last_character() {
              let mut state = create_test_app_state();
              let characters = vec![create_test_character(1, "一")];
              
              state.current_screen = Screen::Learning(LearningSession {
                  characters: characters.clone(),
                  current_index: 0,
                  is_complete: false,
                  learned_characters: vec![],
              });
              
              let msg = Message::AdvanceToNextCharacter;
              state.update(msg);
              
              match &state.current_screen {
                  Screen::Learning(session) => {
                      assert!(session.is_complete);
                  }
                  _ => panic!("Expected Learning screen"),
              }
          }

          #[test]
          fn test_practice_session_advance_character() {
              let mut state = create_test_app_state();
              let characters = vec![
                  create_test_character(1, "一"),
                  create_test_character(2, "二"),
              ];
              
              state.current_screen = Screen::Practice(PracticeSession {
                  characters: characters.clone(),
                  current_index: 0,
                  is_complete: false,
                  mode: crate::models::PracticeMode::Recognition,
                  results: vec![],
              });
              
              let msg = Message::SubmitPracticeAnswer {
                  character_id: 1,
                  correct: true,
                  time_taken_ms: 1500,
              };
              state.update(msg);
              
              match &state.current_screen {
                  Screen::Practice(session) => {
                      assert_eq!(session.current_index, 1);
                      assert_eq!(session.results.len(), 1);
                      assert!(!session.is_complete);
                  }
                  _ => panic!("Expected Practice screen"),
              }
          }

          #[test]
          fn test_practice_session_records_results() {
              let mut state = create_test_app_state();
              let characters = vec![create_test_character(1, "一")];
              
              state.current_screen = Screen::Practice(PracticeSession {
                  characters: characters.clone(),
                  current_index: 0,
                  is_complete: false,
                  mode: crate::models::PracticeMode::Recognition,
                  results: vec![],
              });
              
              let msg = Message::SubmitPracticeAnswer {
                  character_id: 1,
                  correct: true,
                  time_taken_ms: 2000,
              };
              state.update(msg);
              
              match &state.current_screen {
                  Screen::Practice(session) => {
                      assert_eq!(session.results.len(), 1);
                      assert!(session.results[0].correct);
                      assert_eq!(session.results[0].time_taken_ms, 2000);
                  }
                  _ => panic!("Expected Practice screen"),
              }
          }

          #[test]
          fn test_practice_session_complete_on_last_character() {
              let mut state = create_test_app_state();
              let characters = vec![create_test_character(1, "一")];
              
              state.current_screen = Screen::Practice(PracticeSession {
                  characters: characters.clone(),
                  current_index: 0,
                  is_complete: false,
                  mode: crate::models::PracticeMode::Recognition,
                  results: vec![],
              });
              
              let msg = Message::SubmitPracticeAnswer {
                  character_id: 1,
                  correct: true,
                  time_taken_ms: 1500,
              };
              state.update(msg);
              
              match &state.current_screen {
                  Screen::Practice(session) => {
                      assert!(session.is_complete);
                  }
                  _ => panic!("Expected Practice screen"),
              }
          }

          #[test]
          fn test_learning_session_go_back_character() {
              let mut state = create_test_app_state();
              let characters = vec![
                  create_test_character(1, "一"),
                  create_test_character(2, "二"),
              ];
              
              state.current_screen = Screen::Learning(LearningSession {
                  characters: characters.clone(),
                  current_index: 1,
                  is_complete: false,
                  learned_characters: vec![],
              });
              
              let msg = Message::GoToPreviousCharacter;
              state.update(msg);
              
              match &state.current_screen {
                  Screen::Learning(session) => {
                      assert_eq!(session.current_index, 0);
                  }
                  _ => panic!("Expected Learning screen"),
              }
          }

          #[test]
          fn test_learning_session_cannot_go_back_from_first() {
              let mut state = create_test_app_state();
              let characters = vec![create_test_character(1, "一")];
              
              state.current_screen = Screen::Learning(LearningSession {
                  characters: characters.clone(),
                  current_index: 0,
                  is_complete: false,
                  learned_characters: vec![],
              });
              
              let msg = Message::GoToPreviousCharacter;
              state.update(msg);
              
              match &state.current_screen {
                  Screen::Learning(session) => {
                      assert_eq!(session.current_index, 0);
                  }
                  _ => panic!("Expected Learning screen"),
              }
          }

          #[test]
          fn test_empty_character_list_creates_complete_session() {
              let mut state = create_test_app_state();
              
              let msg = Message::StartLearningSession(vec![]);
              state.update(msg);
              
              match &state.current_screen {
                  Screen::Learning(session) => {
                      assert_eq!(session.characters.len(), 0);
                      assert!(session.is_complete);
                  }
                  _ => panic!("Expected Learning screen"),
              }
          }

          #[test]
          fn test_message_noop_on_wrong_screen() {
              let mut state = create_test_app_state();
              state.current_screen = Screen::MainMenu;
              
              let msg = Message::SubmitPracticeAnswer {
                  character_id: 1,
                  correct: true,
                  time_taken_ms: 1500,
              };
              state.update(msg);
              
              assert!(matches!(state.current_screen, Screen::MainMenu));
          }

          #[test]
          fn test_session_state_preserved_on_navigation() {
              let mut state = create_test_app_state();
              let characters = vec![create_test_character(1, "一")];
              
              state.current_screen = Screen::Learning(LearningSession {
                  characters: characters.clone(),
                  current_index: 0,
                  is_complete: false,
                  learned_characters: vec![],
              });
              
              let msg = Message::NavigateToStatistics;
              state.update(msg);
              
              assert!(matches!(state.current_screen, Screen::Statistics(_)));
          }
      }

      #[cfg(test)]
      mod screen_enum_tests {
          use super::*;
          use crate::state::Screen;

          #[test]
          fn test_screen_variants_exist() {
              let _main_menu = Screen::MainMenu;
              let _learning = Screen::Learning(Default::default());
              let _practice = Screen::Practice(Default::default());
              let _statistics = Screen::Statistics(Default::default());
          }

          #[test]
          fn test_screen_debug_representation() {
              let main_menu = Screen::MainMenu;
              let debug_str = format!("{:?}", main_menu);
              assert!(debug_str.contains("MainMenu"));
          }
      }

      #[cfg(test)]
      mod message_enum_tests {
          use super::*;
          use crate::state::Message;

          #[test]
          fn test_message_variants_exist() {
              let _start_learning = Message::StartLearningSession(vec![]);
              let _return = Message::ReturnToMainMenu;
              let _advance = Message::AdvanceToNextCharacter;
              let _previous = Message::GoToPreviousCharacter;
              let _navigate_stats = Message::NavigateToStatistics;
          }

          #[test]
          fn test_message_clone() {
              let msg = Message::ReturnToMainMenu;
              let cloned = msg.clone();
              assert!(matches!(cloned, Message::ReturnToMainMenu));
          }
      }

      #[cfg(test)]
      mod navigation_tests {
          use super::*;

          fn create_test_app_state() -> AppState {
              AppState {
                  current_screen: Screen::MainMenu,
                  characters: Arc::new(RwLock::new(vec![])),
                  progress: Arc::new(RwLock::new(vec![])),
                  settings: Arc::new(RwLock::new(Default::default())),
              }
          }

          fn create_test_character(id: u32, kanji: &str) -> Character {
              Character {
                  id,
                  kanji: kanji.to_string(),
                  readings: vec!["test".to_string()],
                  meanings: vec!["test meaning".to_string()],
                  stroke_count: 5,
                  grade: 1,
                  frequency: Some(100),
              }
          }

          #[test]
          fn test_circular_navigation_main_to_learning_to_main() {
              let mut state = create_test_app_state();
              let characters = vec![create_test_character(1, "一")];
              
              state.update(Message::StartLearningSession(characters.clone()));
              assert!(matches!(state.current_screen, Screen::Learning(_)));
              
              state.update(Message::ReturnToMainMenu);
              assert!(matches!(state.current_screen, Screen::MainMenu));
          }

          #[test]
          fn test_circular_navigation_main_to_practice_to_main() {
              let mut state = create_test_app_state();
              let characters = vec![create_test_character(1, "一")];
              
              state.update(Message::StartPracticeSession {
                  characters: characters.clone(),
                  mode: crate::models::PracticeMode::Recognition,
              });
              assert!(matches!(state.current_screen, Screen::Practice(_)));
              
              state.update(Message::ReturnToMainMenu);
              assert!(matches!(state.current_screen, Screen::MainMenu));
          }

          #[test]
          fn test_navigation_from_statistics_to_main() {
              let mut state = create_test_app_state();
              
              state.update(Message::NavigateToStatistics);
              assert!(matches!(state.current_screen, Screen::Statistics(_)));
              
              state.update(Message::ReturnToMainMenu);
              assert!(matches!(state.current_screen, Screen::MainMenu));
          }
      }

      #[cfg(test)]
      mod property_tests {
          use super::*;
          use proptest::prelude::*;

          prop_compose! {
              fn arb_character_id()(id in 1u32..1000) -> u32 {
                  id
              }
          }

          prop_compose! {
              fn arb_character_list()(
                  count in 0usize..20,
              )(ids in prop::collection::vec(arb_character_id(), count)) -> Vec<Character> {
                  ids.into_iter()
                      .map(|id| Character {
                          id,
                          kanji: format!("K{}", id),
                          readings: vec!["test".to_string()],
                          meanings: vec!["meaning".to_string()],
                          stroke_count: 5,
                          grade: 1,
                          frequency: Some(100),
                      })
                      .collect()
              }
          }

          proptest! {
              #[test]
              fn prop_learning_session_index_in_bounds(characters in arb_character_list()) {
                  let mut state = AppState {
                      current_screen: Screen::MainMenu,
                      characters: Arc::new(RwLock::new(vec![])),
                      progress: Arc::new(RwLock::new(vec![])),
                      settings: Arc::new(RwLock::new(Default::default())),
                  };
                  
                  state.update(Message::StartLearningSession(characters.clone()));
                  
                  if let Screen::Learning(session) = &state.current_screen {
                      if !characters.is_empty() {
                          prop_assert!(session.current_index < characters.len());
                      }
                  }
              }

              #[test]
              fn prop_practice_session_results_accumulate(
                  characters in arb_character_list(),
                  correct in prop::bool::ANY
              ) {
                  if characters.is_empty() {
                      return Ok(());
                  }

                  let mut state = AppState {
                      current_screen: Screen::MainMenu,
                      characters: Arc::new(RwLock::new(vec![])),
                      progress: Arc::new(RwLock::new(vec![])),
                      settings: Arc::new(RwLock::new(Default::default())),
                  };
                  
                  state.update(Message::StartPracticeSession {
                      characters: characters.clone(),
                      mode: crate::models::PracticeMode::Recognition,
                  });

                  let char_id = characters[0].id;
                  state.update(Message::SubmitPracticeAnswer {
                      character_id: char_id,
                      correct,
                      time_taken_ms: 1000,
                  });
                  
                  if let Screen::Practice(session) = &state.current_screen {
                      prop_assert_eq!(session.results.len(), 1);
                  }
              }

              #[test]
              fn prop_return_to_main_menu_always_works(characters in arb_character_list()) {
                  let mut state = AppState {
                      current_screen: Screen::MainMenu,
                      characters: Arc::new(RwLock::new(vec![])),
                      progress: Arc::new(RwLock::new(vec![])),
                      settings: Arc::new(RwLock::new(Default::default())),
                  };
                  
                  state.update(Message::StartLearningSession(characters));
                  state.update(Message::ReturnToMainMenu);
                  
                  prop_assert!(matches!(state.current_screen, Screen::MainMenu));
              }

              #[test]
              fn prop_advance_never_exceeds_character_count(characters in arb_character_list()) {
                  if characters.is_empty() {
                      return Ok(());
                  }

                  let mut state = AppState {
                      current_screen: Screen::MainMenu,
                      characters: Arc::new(RwLock::new(vec![])),
                      progress: Arc::new(RwLock::new(vec![])),
                      settings: Arc::new(RwLock::new(Default::default())),
                  };
                  
                  let char_count = characters.len();
                  state.update(Message::StartLearningSession(characters));
                  
                  for _ in 0..char_count + 5 {
                      state.update(Message::AdvanceToNextCharacter);
                  }
                  
                  if let Screen::Learning(session) = &state.current_screen {
                      prop_assert!(session.current_index <= char_count);
                  }
              }

              #[test]
              fn prop_go_back_never_goes_negative(
                  characters in arb_character_list(),
                  back_count in 0usize..10
              ) {
                  if characters.is_empty() {
                      return Ok(());
                  }

                  let mut state = AppState {
                      current_screen: Screen::MainMenu,
                      characters: Arc::new(RwLock::new(vec![])),
                      progress: Arc::new(RwLock::new(vec![])),
                      settings: Arc::new(RwLock::new(Default::default())),
                  };
                  
                  state.update(Message::StartLearningSession(characters));
                  
                  for _ in 0..back_count {
                      state.update(Message::GoToPreviousCharacter);
                  }
                  
                  if let Screen::Learning(session) = &state.current_screen {
                      prop_assert_eq!(session.current_index, 0);
                  }
              }
          }
      }

  coverage:
    - "Initial application state is MainMenu"
    - "Navigation from MainMenu to Learning screen"
    - "Navigation from MainMenu to Practice screen"
    - "Navigation from MainMenu to Statistics screen"
    - "Return to MainMenu from Learning screen"
    - "Return to MainMenu from Practice screen"
    - "Return to MainMenu from Statistics screen"
    - "Learning session advances to next character"
    - "Learning session marks complete on last character"
    - "Learning session can go back to previous character"
    - "Learning session cannot go back from first character"
    - "Practice session advances to next character"
    - "Practice session records answer results"
    - "Practice session marks complete on last character"
    - "Empty character list creates immediately complete session"
    - "Messages sent to wrong screen are ignored gracefully"
    - "Session state preserved on navigation"
    - "All Screen enum variants can be constructed"
    - "All Message enum variants can be constructed"
    - "Circular navigation works correctly (main to screen to main)"
    - "Property: Learning session index always in bounds"
    - "Property: Practice session results accumulate correctly"
    - "Property: Return to main menu always succeeds"
    - "Property: Advance never exceeds character count"
    - "Property: Go back never goes negative"

dependencies:
  depends_on:
    - task_id: 1
      reason: "Requires application foundation structure and state module organization established in task 1"

  depended_upon_by:
    - task_id: 7
      reason: "Learning session implementation requires complete state management framework with Screen and Message enums"
    - task_id: 8
      reason: "Practice session implementation requires state management framework to handle practice workflows"
    - task_id: 10
      reason: "Statistics screen requires navigation support and Screen enum variant"

  external:
    - name: "Arc"
      type: "struct"
      status: "already exists"
    - name: "RwLock"
      type: "struct"
      status: "already exists"
    - name: "Task"
      type: "struct"
      status: "needs implementation"
    - name: "Character"
      type: "struct"
      status: "needs implementation"
    - name: "CharacterProgress"
      type: "struct"
      status: "needs implementation"
    - name: "DbError"
      type: "enum"
      status: "needs implementation"
    - name: "RecognitionError"
      type: "enum"
      status: "needs implementation"
---
task:
  id: 7
  name: "SM-2 Spaced Repetition Algorithm and Review Queue"

context:
  description: |
    This task implements the SM-2 spaced repetition algorithm, the proven pedagogical
    engine that schedules flashcard reviews for optimal long-term retention. SM-2,
    developed by SuperMemo, calculates when learners should review cards based on their
    performance, with intervals growing exponentially for successfully recalled items.
    
    The implementation includes the SM2Card struct, which tracks per-card scheduling
    state (ease factor, interval, repetition count, next review date), and the ReviewQueue
    struct, which manages three separate card queues (new, learning, review) with
    intelligent prioritization logic. Learning cards (recently failed or new) take
    priority over due reviews, which take priority over new cards, ensuring learners
    reinforce difficult material before introducing new content.
    
    This is a foundational component for the entire learning system, as effective
    spaced repetition is what distinguishes an SRS from simple flashcards. The SM-2
    algorithm's mathematical properties ensure cards don't regress incorrectly and
    that review intervals grow appropriately based on user performance history.

  key_points:
    - "SM-2 is deterministic and well-specified, making it ideal for comprehensive testing"
    - "Ease factor has a floor of 1.3 to prevent cards from becoming unmemorable"
    - "First two intervals are fixed (1 day, 6 days) per SM-2 specification"
    - "Quality ratings map to user experience: 5=perfect, 4=correct, 3=difficult, 2=incorrect, 1=barely, 0=blackout"
    - "Queue prioritization (learning > review > new) follows SRS best practices for retention"
    - "Daily limits prevent overwhelming users with too many new cards"
    - "Floating-point precision in ease factor calculations requires careful handling"
    - "Review history should be stored for potential future algorithm improvements (FSRS upgrade path)"

files:
  - path: "src/srs/mod.rs"
    description: "Module declaration file for the spaced repetition system (SRS) components"
  
  - path: "src/srs/sm2.rs"
    description: "Implementation of the SM-2 spaced repetition algorithm, including SM2Card struct and review logic"
  
  - path: "src/srs/queue.rs"
    description: "ReviewQueue implementation for managing card prioritization (new, learning, review queues) and daily limits"
  
  - path: "tests/srs_tests.rs"
    description: "Comprehensive unit and property-based tests for SM-2 algorithm and review queue functionality"

functions:
  - file: "src/srs/sm2.rs"
    items:
      - type: "constant"
        name: "INITIAL_EASE_FACTOR"
        description: "Default ease factor for new cards (2.5)"
        invariants: "Value is 2.5"
      
      - type: "constant"
        name: "MINIMUM_EASE_FACTOR"
        description: "Minimum allowed ease factor (1.3)"
        invariants: "Value is 1.3"
      
      - type: "constant"
        name: "FIRST_INTERVAL_DAYS"
        description: "Fixed interval for first review (1 day)"
        invariants: "Value is 1"
      
      - type: "constant"
        name: "SECOND_INTERVAL_DAYS"
        description: "Fixed interval for second review (6 days)"
        invariants: "Value is 6"
      
      - type: "enum"
        name: "CardState"
        description: "Represents the current state of a card in the learning system"
        invariants: "Must be one of: New, Learning, Review"
      
      - type: "enum_variant"
        name: "CardState::New"
        description: "Card has never been reviewed"
      
      - type: "enum_variant"
        name: "CardState::Learning"
        description: "Card is in the learning phase (recently failed or new)"
      
      - type: "enum_variant"
        name: "CardState::Review"
        description: "Card is in review phase with spaced repetition"
      
      - type: "struct"
        name: "SM2Card"
        description: "Flashcard with SM-2 scheduling parameters including ease factor, interval, and next review date"
        invariants: "ease_factor >= 1.3, interval >= 0, repetitions >= 0"
      
      - type: "method"
        name: "SM2Card::new"
        description: "Creates a new SM2Card with default parameters (ease_factor=2.5, interval=0, repetitions=0, state=New)"
        preconditions: "Valid card_id and content provided"
        postconditions: "Returns SM2Card with initial state and default scheduling parameters"
        invariants: "ease_factor = 2.5, interval = 0, repetitions = 0"
      
      - type: "method"
        name: "SM2Card::review"
        description: "Updates card state based on quality rating (0-5), recalculates ease factor, interval, and next review date according to SM-2 algorithm"
        preconditions: "quality must be in range 0..=5"
        postconditions: "ease_factor >= 1.3, next_review_date > current_date, state updated based on quality, if quality < 3 then interval=1 and repetitions=0"
        invariants: "ease_factor never below 1.3, intervals increase monotonically for consecutive correct reviews"
      
      - type: "method"
        name: "SM2Card::calculate_ease_factor"
        description: "Calculates new ease factor based on quality rating using SM-2 formula: EF' = EF + (0.1 - (5-q)*(0.08+(5-q)*0.02))"
        preconditions: "quality in range 0..=5, current ease_factor >= 1.3"
        postconditions: "Returns ease_factor >= 1.3"
        invariants: "Result is clamped to minimum of 1.3"
      
      - type: "method"
        name: "SM2Card::calculate_interval"
        description: "Calculates next interval based on repetition count and ease factor: first=1, second=6, subsequent=previous*ease_factor"
        preconditions: "repetitions >= 0, ease_factor >= 1.3"
        postconditions: "Returns interval >= 1"
        invariants: "First interval is 1, second is 6, subsequent intervals grow by ease_factor"
      
      - type: "method"
        name: "SM2Card::is_due"
        description: "Checks if card is due for review by comparing next_review_date with current date"
        preconditions: "None"
        postconditions: "Returns true if next_review_date <= current_date"
      
      - type: "method"
        name: "SM2Card::get_state"
        description: "Returns the current state of the card"
        postconditions: "Returns CardState"
      
      - type: "method"
        name: "SM2Card::reset_to_learning"
        description: "Resets card to learning state with interval=1, repetitions=0, maintains ease_factor"
        preconditions: "None"
        postconditions: "state = Learning, interval = 1, repetitions = 0, ease_factor unchanged"
  
  - file: "src/srs/queue.rs"
    items:
      - type: "struct"
        name: "ReviewQueue"
        description: "Manages card queues (new, learning, review) with prioritization logic and daily limits"
        invariants: "learning_cards, review_cards, new_cards are separate collections, daily_new_limit > 0"
      
      - type: "struct"
        name: "QueueConfig"
        description: "Configuration for ReviewQueue including daily new card limit and queue size limits"
        invariants: "daily_new_limit > 0, max_learning_size >= 0, max_review_size >= 0"
      
      - type: "method"
        name: "QueueConfig::default"
        description: "Creates default queue configuration with reasonable limits (e.g., 20 new cards/day)"
        postconditions: "Returns QueueConfig with sensible defaults"
      
      - type: "method"
        name: "ReviewQueue::new"
        description: "Creates a new ReviewQueue with the given configuration"
        preconditions: "Valid QueueConfig provided"
        postconditions: "Returns empty ReviewQueue with specified configuration"
      
      - type: "method"
        name: "ReviewQueue::add_card"
        description: "Adds a card to the appropriate queue based on its state (new, learning, or review)"
        preconditions: "Valid SM2Card provided"
        postconditions: "Card is added to correct internal queue based on state"
      
      - type: "method"
        name: "ReviewQueue::get_next_card"
        description: "Returns next card to review based on priority: learning cards first, then due review cards, then new cards (respecting daily limit)"
        preconditions: "None"
        postconditions: "Returns Some(SM2Card) if cards available following priority rules, or None if queue empty or daily limit reached"
        invariants: "Priority order: learning > due_review > new, respects daily_new_limit"
      
      - type: "method"
        name: "ReviewQueue::update_card"
        description: "Updates card in queue after review, potentially moving it between queues based on new state"
        preconditions: "Card exists in queue, card has been reviewed"
        postconditions: "Card moved to appropriate queue based on updated state"
      
      - type: "method"
        name: "ReviewQueue::get_due_count"
        description: "Returns count of cards due for review (learning + due review cards)"
        postconditions: "Returns usize count of due cards"
      
      - type: "method"
        name: "ReviewQueue::get_new_count"
        description: "Returns count of new cards available"
        postconditions: "Returns usize count of new cards"
      
      - type: "method"
        name: "ReviewQueue::get_learning_count"
        description: "Returns count of cards in learning state"
        postconditions: "Returns usize count of learning cards"
      
      - type: "method"
        name: "ReviewQueue::reset_daily_limit"
        description: "Resets the daily new card counter (to be called at start of new day)"
        postconditions: "Daily new card counter is reset to 0"
      
      - type: "method"
        name: "ReviewQueue::is_empty"
        description: "Checks if there are any cards available for review"
        postconditions: "Returns true if no cards available, false otherwise"
      
      - type: "method"
        name: "ReviewQueue::prioritize_learning"
        description: "Internal helper to get next learning card if available"
        postconditions: "Returns Some(SM2Card) from learning queue, or None if empty"
      
      - type: "method"
        name: "ReviewQueue::prioritize_review"
        description: "Internal helper to get next due review card if available"
        postconditions: "Returns Some(SM2Card) from review queue where is_due() is true, or None if empty"
      
      - type: "method"
        name: "ReviewQueue::prioritize_new"
        description: "Internal helper to get next new card if daily limit not reached"
        preconditions: "Daily new card limit not exceeded"
        postconditions: "Returns Some(SM2Card) from new queue if limit allows, or None if empty or limit reached"
  
  - file: "src/srs/mod.rs"
    items:
      - type: "module_declaration"
        name: "mod sm2"
        description: "Module containing SM-2 algorithm implementation and SM2Card struct"
      
      - type: "module_declaration"
        name: "mod queue"
        description: "Module containing ReviewQueue and queue management logic"
      
      - type: "module_declaration"
        name: "pub use sm2::{SM2Card, CardState}"
        description: "Re-exports SM2Card and CardState for public API"
      
      - type: "module_declaration"
        name: "pub use queue::{ReviewQueue, QueueConfig}"
        description: "Re-exports ReviewQueue and QueueConfig for public API"

formal_verification:
  needed: true
  level: "Basic"
  explanation: |
    The SM-2 algorithm involves mathematical calculations with floating-point arithmetic
    and state transitions that must maintain critical invariants for correct scheduling.
    While not safety-critical (failures won't cause harm), incorrect implementation would
    silently degrade learning effectiveness, making errors difficult to detect in production.
    
    Basic formal verification is warranted because:
    1. The ease factor bounds (>= 1.3) are critical for algorithm stability
    2. Interval monotonicity ensures cards don't regress incorrectly
    3. State transitions between learning/review must be deterministic
    4. Floating-point precision errors could accumulate over many reviews
    5. The algorithm's correctness is well-defined mathematically
    
    However, Critical level is not needed because:
    - No safety/security implications
    - Errors are recoverable (users can continue learning)
    - The algorithm is relatively simple with clear specifications
    - Comprehensive unit and property testing can catch most issues

  properties:
    - name: "Ease Factor Lower Bound"
      formal_statement: "∀ card, quality ∈ [0,5]: card.review(quality) ⟹ card.ease_factor >= 1.3"
    
    - name: "Interval Monotonicity for Success"
      formal_statement: "∀ card, quality >= 3: let interval₀ = card.interval in card.review(quality) ⟹ card.interval >= interval₀"
    
    - name: "Failure Reset"
      formal_statement: "∀ card, quality < 3: card.review(quality) ⟹ (card.interval = 1 ∧ card.repetitions = 0)"
    
    - name: "First Interval Invariant"
      formal_statement: "∀ card, quality >= 3: card.repetitions = 0 ⟹ card.review(quality) ⟹ card.interval = 1"
    
    - name: "Second Interval Invariant"
      formal_statement: "∀ card, quality >= 3: card.repetitions = 1 ⟹ card.review(quality) ⟹ card.interval = 6"
    
    - name: "Subsequent Interval Calculation"
      formal_statement: "∀ card, quality >= 3: card.repetitions >= 2 ⟹ card.review(quality) ⟹ card.interval = ⌈card.interval₀ × card.ease_factor⌉"
    
    - name: "Next Review Date Future"
      formal_statement: "∀ card, now: card.review(quality) ⟹ card.next_review_date > now"
    
    - name: "Queue Priority Ordering"
      formal_statement: "∀ queue: queue.get_next_card() returns learning cards before due reviews before new cards"
    
    - name: "Ease Factor Update Formula"
      formal_statement: "∀ card, quality >= 3: new_ef = max(1.3, ef₀ + (0.1 - (5 - quality) × (0.08 + (5 - quality) × 0.02)))"
    
    - name: "Repetition Counter Increment"
      formal_statement: "∀ card, quality >= 3: let reps₀ = card.repetitions in card.review(quality) ⟹ card.repetitions = reps₀ + 1"

  strategy:
    - "Use property-based testing (proptest) to verify mathematical invariants across random inputs"
    - "Implement precondition/postcondition assertions in SM2Card::review() method"
    - "Create deterministic test cases for boundary conditions (quality=0,3,5; repetitions=0,1,2; edge ease factors)"
    - "Use floating-point comparison with appropriate epsilon tolerance (e.g., 0.001) for ease factor assertions"
    - "Verify queue ordering property by constructing queues with known card states and asserting get_next_card() returns expected priority"
    - "Test interval progression over extended sequences (e.g., 10+ consecutive reviews) to detect accumulation errors"
    - "Implement debug assertions in release builds for ease_factor >= 1.3 invariant to catch violations in production"

tests:
  strategy:
    approach: "mixed (unit tests + property-based tests)"
    rationale:
      - "SM-2 algorithm is deterministic and mathematical, making it ideal for unit testing each calculation step"
      - "Property-based testing verifies critical invariants (ease factor bounds, interval monotonicity) across wide input ranges"
      - "Queue prioritization logic requires unit tests for specific scenarios and edge cases"
      - "Floating-point calculations need precision validation to prevent drift over many reviews"
      - "State transitions (new → learning → review) need explicit verification"

  implementation:
    file: "tests/srs_tests.rs"
    location: "separate test file"
    code: |
      use chrono::{Duration, Utc};
      use proptest::prelude::*;

      #[cfg(test)]
      mod sm2_tests {
          use super::*;
          use srs::sm2::*;

          fn create_test_card(card_id: u32) -> SM2Card {
              SM2Card {
                  card_id,
                  ease_factor: 2.5,
                  interval_days: 0,
                  repetitions: 0,
                  next_review_date: Utc::now(),
                  state: CardState::New,
              }
          }

          #[test]
          fn test_new_card_initial_state() {
              let card = create_test_card(1);
              assert_eq!(card.ease_factor, 2.5);
              assert_eq!(card.interval_days, 0);
              assert_eq!(card.repetitions, 0);
              assert!(matches!(card.state, CardState::New));
          }

          #[test]
          fn test_first_review_quality_5_perfect() {
              let mut card = create_test_card(1);
              let before_review = Utc::now();
              
              card.review(5);
              
              assert_eq!(card.interval_days, 1, "First interval should be 1 day");
              assert_eq!(card.repetitions, 1);
              assert_eq!(card.ease_factor, 2.6, "EF should increase by 0.1 for quality 5");
              assert!(matches!(card.state, CardState::Learning));
              assert!(card.next_review_date > before_review);
          }

          #[test]
          fn test_first_review_quality_4_correct() {
              let mut card = create_test_card(1);
              
              card.review(4);
              
              assert_eq!(card.interval_days, 1);
              assert_eq!(card.repetitions, 1);
              assert_eq!(card.ease_factor, 2.5, "EF should stay at 2.5 for quality 4");
              assert!(matches!(card.state, CardState::Learning));
          }

          #[test]
          fn test_first_review_quality_3_difficult() {
              let mut card = create_test_card(1);
              
              card.review(3);
              
              assert_eq!(card.interval_days, 1);
              assert_eq!(card.repetitions, 1);
              assert!(card.ease_factor < 2.5, "EF should decrease for quality 3");
              assert!(card.ease_factor >= 1.3, "EF must respect floor of 1.3");
              assert!(matches!(card.state, CardState::Learning));
          }

          #[test]
          fn test_second_review_quality_4() {
              let mut card = create_test_card(1);
              card.review(4);
              
              card.review(4);
              
              assert_eq!(card.interval_days, 6, "Second interval should be 6 days");
              assert_eq!(card.repetitions, 2);
              assert!(matches!(card.state, CardState::Review));
          }

          #[test]
          fn test_third_review_uses_ease_factor() {
              let mut card = create_test_card(1);
              card.review(4);
              card.review(4);
              
              let ef = card.ease_factor;
              card.review(4);
              
              assert_eq!(card.interval_days, (6.0 * ef).round() as u32);
              assert_eq!(card.repetitions, 3);
              assert!(matches!(card.state, CardState::Review));
          }

          #[test]
          fn test_failed_card_resets_quality_2() {
              let mut card = create_test_card(1);
              card.review(4);
              card.review(4);
              
              card.review(2);
              
              assert_eq!(card.interval_days, 1, "Failed card should reset to interval 1");
              assert_eq!(card.repetitions, 0, "Failed card should reset repetitions");
              assert!(matches!(card.state, CardState::Learning));
          }

          #[test]
          fn test_failed_card_resets_quality_1() {
              let mut card = create_test_card(1);
              card.review(5);
              card.review(5);
              card.review(5);
              
              card.review(1);
              
              assert_eq!(card.interval_days, 1);
              assert_eq!(card.repetitions, 0);
              assert!(matches!(card.state, CardState::Learning));
          }

          #[test]
          fn test_failed_card_resets_quality_0() {
              let mut card = create_test_card(1);
              card.review(4);
              
              card.review(0);
              
              assert_eq!(card.interval_days, 1);
              assert_eq!(card.repetitions, 0);
              assert!(matches!(card.state, CardState::Learning));
          }

          #[test]
          fn test_ease_factor_floor_at_1_3() {
              let mut card = create_test_card(1);
              
              for _ in 0..20 {
                  card.review(3);
              }
              
              assert!(card.ease_factor >= 1.3, "Ease factor must never fall below 1.3");
              assert_eq!(card.ease_factor, 1.3, "Ease factor should reach floor");
          }

          #[test]
          fn test_ease_factor_increases_with_quality_5() {
              let mut card = create_test_card(1);
              let initial_ef = card.ease_factor;
              
              card.review(5);
              
              assert!(card.ease_factor > initial_ef, "Quality 5 should increase EF");
              assert!((card.ease_factor - initial_ef - 0.1).abs() < 0.01, "Should increase by ~0.1");
          }

          #[test]
          fn test_ease_factor_decreases_with_quality_3() {
              let mut card = create_test_card(1);
              let initial_ef = card.ease_factor;
              
              card.review(3);
              
              assert!(card.ease_factor < initial_ef, "Quality 3 should decrease EF");
          }

          #[test]
          fn test_interval_progression_sequence() {
              let mut card = create_test_card(1);
              
              card.review(4);
              assert_eq!(card.interval_days, 1);
              
              card.review(4);
              assert_eq!(card.interval_days, 6);
              
              let ef = card.ease_factor;
              card.review(4);
              assert_eq!(card.interval_days, (6.0 * ef).round() as u32);
              
              let prev_interval = card.interval_days;
              card.review(4);
              assert_eq!(card.interval_days, (prev_interval as f32 * ef).round() as u32);
          }

          #[test]
          fn test_next_review_date_advances() {
              let mut card = create_test_card(1);
              let before = Utc::now();
              
              card.review(4);
              
              let expected_date = before + Duration::days(card.interval_days as i64);
              let diff = (card.next_review_date - expected_date).num_seconds().abs();
              assert!(diff < 2, "Next review date should be interval days in future");
          }
      }

      #[cfg(test)]
      mod queue_tests {
          use super::*;
          use srs::queue::*;
          use srs::sm2::*;

          fn create_test_card(card_id: u32) -> SM2Card {
              SM2Card {
                  card_id,
                  ease_factor: 2.5,
                  interval_days: 0,
                  repetitions: 0,
                  next_review_date: Utc::now(),
                  state: CardState::New,
              }
          }

          #[test]
          fn test_review_queue_initialization() {
              let queue = ReviewQueue::new(20, 100);
              
              assert_eq!(queue.daily_new_limit, 20);
              assert_eq!(queue.daily_review_limit, 100);
              assert_eq!(queue.new_today, 0);
              assert_eq!(queue.reviewed_today, 0);
          }

          #[test]
          fn test_add_card_to_new_queue() {
              let mut queue = ReviewQueue::new(20, 100);
              let card = create_test_card(1);
              
              queue.add_card(card);
              
              assert_eq!(queue.new_cards.len(), 1);
              assert_eq!(queue.learning_cards.len(), 0);
              assert_eq!(queue.review_cards.len(), 0);
          }

          #[test]
          fn test_add_card_to_learning_queue() {
              let mut queue = ReviewQueue::new(20, 100);
              let mut card = create_test_card(1);
              card.state = CardState::Learning;
              card.next_review_date = Utc::now() - Duration::hours(1);
              
              queue.add_card(card);
              
              assert_eq!(queue.learning_cards.len(), 1);
          }

          #[test]
          fn test_add_card_to_review_queue() {
              let mut queue = ReviewQueue::new(20, 100);
              let mut card = create_test_card(1);
              card.state = CardState::Review;
              card.next_review_date = Utc::now() - Duration::days(1);
              
              queue.add_card(card);
              
              assert_eq!(queue.review_cards.len(), 1);
          }

          #[test]
          fn test_priority_learning_over_review() {
              let mut queue = ReviewQueue::new(20, 100);
              
              let mut learning_card = create_test_card(1);
              learning_card.state = CardState::Learning;
              learning_card.next_review_date = Utc::now() - Duration::hours(1);
              
              let mut review_card = create_test_card(2);
              review_card.state = CardState::Review;
              review_card.next_review_date = Utc::now() - Duration::days(1);
              
              queue.add_card(review_card);
              queue.add_card(learning_card);
              
              let next = queue.get_next_card().unwrap();
              assert_eq!(next.card_id, 1, "Learning card should have priority");
          }

          #[test]
          fn test_priority_review_over_new() {
              let mut queue = ReviewQueue::new(20, 100);
              
              let new_card = create_test_card(1);
              
              let mut review_card = create_test_card(2);
              review_card.state = CardState::Review;
              review_card.next_review_date = Utc::now() - Duration::days(1);
              
              queue.add_card(new_card);
              queue.add_card(review_card);
              
              let next = queue.get_next_card().unwrap();
              assert_eq!(next.card_id, 2, "Review card should have priority over new");
          }

          #[test]
          fn test_priority_order_learning_review_new() {
              let mut queue = ReviewQueue::new(20, 100);
              
              let new_card = create_test_card(1);
              
              let mut learning_card = create_test_card(2);
              learning_card.state = CardState::Learning;
              learning_card.next_review_date = Utc::now() - Duration::hours(1);
              
              let mut review_card = create_test_card(3);
              review_card.state = CardState::Review;
              review_card.next_review_date = Utc::now() - Duration::days(1);
              
              queue.add_card(new_card);
              queue.add_card(review_card);
              queue.add_card(learning_card);
              
              assert_eq!(queue.get_next_card().unwrap().card_id, 2, "1st: learning");
              assert_eq!(queue.get_next_card().unwrap().card_id, 3, "2nd: review");
              assert_eq!(queue.get_next_card().unwrap().card_id, 1, "3rd: new");
          }

          #[test]
          fn test_daily_new_limit_enforced() {
              let mut queue = ReviewQueue::new(2, 100);
              
              queue.add_card(create_test_card(1));
              queue.add_card(create_test_card(2));
              queue.add_card(create_test_card(3));
              
              let card1 = queue.get_next_card().unwrap();
              queue.mark_reviewed(card1);
              
              let card2 = queue.get_next_card().unwrap();
              queue.mark_reviewed(card2);
              
              assert!(queue.get_next_card().is_none(), "Should respect daily new limit");
          }

          #[test]
          fn test_daily_review_limit_enforced() {
              let mut queue = ReviewQueue::new(20, 2);
              
              for i in 1..=3 {
                  let mut card = create_test_card(i);
                  card.state = CardState::Review;
                  card.next_review_date = Utc::now() - Duration::days(1);
                  queue.add_card(card);
              }
              
              let card1 = queue.get_next_card().unwrap();
              queue.mark_reviewed(card1);
              
              let card2 = queue.get_next_card().unwrap();
              queue.mark_reviewed(card2);
              
              assert!(queue.get_next_card().is_none(), "Should respect daily review limit");
          }

          #[test]
          fn test_empty_queue_returns_none() {
              let mut queue = ReviewQueue::new(20, 100);
              
              assert!(queue.get_next_card().is_none());
          }

          #[test]
          fn test_not_due_cards_not_returned() {
              let mut queue = ReviewQueue::new(20, 100);
              
              let mut card = create_test_card(1);
              card.state = CardState::Review;
              card.next_review_date = Utc::now() + Duration::days(5);
              queue.add_card(card);
              
              assert!(queue.get_next_card().is_none(), "Future cards should not be due");
          }

          #[test]
          fn test_reset_daily_counters() {
              let mut queue = ReviewQueue::new(20, 100);
              queue.new_today = 10;
              queue.reviewed_today = 50;
              
              queue.reset_daily_counters();
              
              assert_eq!(queue.new_today, 0);
              assert_eq!(queue.reviewed_today, 0);
          }

          #[test]
          fn test_queue_count_methods() {
              let mut queue = ReviewQueue::new(20, 100);
              
              queue.add_card(create_test_card(1));
              
              let mut learning = create_test_card(2);
              learning.state = CardState::Learning;
              learning.next_review_date = Utc::now() - Duration::hours(1);
              queue.add_card(learning);
              
              let mut review = create_test_card(3);
              review.state = CardState::Review;
              review.next_review_date = Utc::now() - Duration::days(1);
              queue.add_card(review);
              
              assert_eq!(queue.new_count(), 1);
              assert_eq!(queue.learning_count(), 1);
              assert_eq!(queue.review_count(), 1);
              assert_eq!(queue.total_due(), 3);
          }
      }

      #[cfg(test)]
      mod property_tests {
          use super::*;
          use proptest::prelude::*;
          use srs::sm2::*;

          prop_compose! {
              fn arb_quality()(quality in 0u8..=5) -> u8 {
                  quality
              }
          }

          prop_compose! {
              fn arb_card()(card_id in 1u32..1000) -> SM2Card {
                  SM2Card {
                      card_id,
                      ease_factor: 2.5,
                      interval_days: 0,
                      repetitions: 0,
                      next_review_date: chrono::Utc::now(),
                      state: CardState::New,
                  }
              }
          }

          proptest! {
              #[test]
              fn prop_ease_factor_never_below_floor(quality in arb_quality()) {
                  let mut card = SM2Card {
                      card_id: 1,
                      ease_factor: 1.3,
                      interval_days: 10,
                      repetitions: 5,
                      next_review_date: chrono::Utc::now(),
                      state: CardState::Review,
                  };
                  
                  card.review(quality);
                  
                  prop_assert!(card.ease_factor >= 1.3, 
                      "Ease factor {} fell below floor 1.3", card.ease_factor);
              }

              #[test]
              fn prop_intervals_monotonic_for_passing_grades(
                  qualities in prop::collection::vec(3u8..=5, 5..20)
              ) {
                  let mut card = SM2Card {
                      card_id: 1,
                      ease_factor: 2.5,
                      interval_days: 0,
                      repetitions: 0,
                      next_review_date: chrono::Utc::now(),
                      state: CardState::New,
                  };
                  
                  let mut prev_interval = 0;
                  for quality in qualities {
                      card.review(quality);
                      if card.repetitions > 2 {
                          prop_assert!(card.interval_days >= prev_interval,
                              "Interval decreased from {} to {} with quality {}",
                              prev_interval, card.interval_days, quality);
                      }
                      prev_interval = card.interval_days;
                  }
              }

              #[test]
              fn prop_failed_cards_always_reset(quality in 0u8..=2) {
                  let mut card = SM2Card {
                      card_id: 1,
                      ease_factor: 2.5,
                      interval_days: 30,
                      repetitions: 10,
                      next_review_date: chrono::Utc::now(),
                      state: CardState::Review,
                  };
                  
                  card.review(quality);
                  
                  prop_assert_eq!(card.interval_days, 1, "Failed card should have interval 1");
                  prop_assert_eq!(card.repetitions, 0, "Failed card should have 0 repetitions");
                  prop_assert!(matches!(card.state, CardState::Learning));
              }

              #[test]
              fn prop_next_review_always_in_future(card in arb_card(), quality in arb_quality()) {
                  let mut test_card = card;
                  let before = chrono::Utc::now();
                  
                  test_card.review(quality);
                  
                  prop_assert!(test_card.next_review_date > before,
                      "Next review date should be in the future");
              }

              #[test]
              fn prop_no_panic_on_valid_quality(card in arb_card(), quality in arb_quality()) {
                  let mut test_card = card;
                  test_card.review(quality);
              }

              #[test]
              fn prop_repetition_count_increases_on_success(quality in 3u8..=5) {
                  let mut card = SM2Card {
                      card_id: 1,
                      ease_factor: 2.5,
                      interval_days: 0,
                      repetitions: 5,
                      next_review_date: chrono::Utc::now(),
                      state: CardState::Review,
                  };
                  
                  card.review(quality);
                  
                  prop_assert_eq!(card.repetitions, 6, 
                      "Repetition count should increase on passing grade");
              }
          }
      }

  coverage:
    - "SM2Card initialization with correct default values"
    - "First review sets interval to 1 day (SM-2 spec)"
    - "Second review sets interval to 6 days (SM-2 spec)"
    - "Third and subsequent reviews use ease factor multiplication"
    - "Quality 5 (perfect) increases ease factor by ~0.1"
    - "Quality 4 (correct) maintains ease factor"
    - "Quality 3 (difficult) decreases ease factor but stays ≥1.3"
    - "Quality 2 (incorrect) resets card to learning state"
    - "Quality 1 (barely) resets card to learning state"
    - "Quality 0 (blackout) resets card to learning state"
    - "Ease factor floor of 1.3 is enforced"
    - "Ease factor cannot decrease below 1.3 with repeated low grades"
    - "Failed cards reset interval to 1 day"
    - "Failed cards reset repetition count to 0"
    - "Failed cards transition back to learning state"
    - "Next review date advances by interval days"
    - "ReviewQueue initialization with correct limits"
    - "ReviewQueue correctly categorizes new cards"
    - "ReviewQueue correctly categorizes learning cards"
    - "ReviewQueue correctly categorizes review cards"
    - "Learning cards have priority over review cards"
    - "Review cards have priority over new cards"
    - "Complete priority order: learning > review > new"
    - "Daily new card limit is enforced"
    - "Daily review limit is enforced"
    - "Empty queue returns None for get_next_card"
    - "Cards not yet due are not returned"
    - "Daily counters can be reset"
    - "Queue count methods return accurate counts"
    - "Property: ease factor never falls below 1.3 for any quality rating"
    - "Property: intervals increase monotonically for passing grades (3-5)"
    - "Property: failed grades (0-2) always reset cards"
    - "Property: next review date is always in the future after review"
    - "Property: no panics for any valid quality rating (0-5)"
    - "Property: repetition count increases on successful reviews"

dependencies:
  depends_on:
    - task_id: 2
      reason: "Needs character database to create cards with actual content for the flashcard system"

  depended_upon_by:
    - task_id: 8
      reason: "Learning session uses SM-2 algorithm for scheduling card reviews and managing review queue"

  external:
    - name: "chrono"
      type: "crate"
      status: "to be imported"
    - name: "proptest"
      type: "crate"
      status: "to be imported"
---
task:
  id: 8
  name: "Learning Session and Practice Modes"

context:
  description: |
    This task implements the core learning experience where all previously built systems
    converge into cohesive user workflows. The learning session manages the presentation
    of flashcards from review queues, collects quality ratings from users, updates SM-2
    spaced repetition state, and tracks session statistics. The practice mode provides
    a progressive four-stage learning experience: passive observation (watch animation),
    guided tracing (with overlay), unguided tracing (stroke order only), and free recall
    (no aids).
    
    These components represent the culmination of the application's educational design,
    where stroke animation, handwriting recognition, spaced repetition algorithms, and
    UI components all integrate to create effective learning experiences. The session
    state machines must handle complex user flows including pause/resume, skipping,
    hints, and validation while maintaining data consistency and providing immediate
    visual feedback.
    
    The implementation emphasizes performance through batch database saves, smooth UI
    transitions, and responsive feedback systems. Session interruption and resume
    capabilities ensure users can learn in flexible time blocks without losing progress.
    Statistics tracking provides insights into learning effectiveness and enables
    adaptive difficulty adjustments.

  key_points:
    - "LearningSession orchestrates review queue progression, quality rating collection, and SM-2 state updates"
    - "PracticeSession implements four progressive difficulty modes with validation-gated advancement"
    - "Batch database persistence (every 5-10 cards) optimizes performance over per-card saves"
    - "Session state machines support pause/resume with full state preservation"
    - "Visual feedback system provides immediate success/failure indicators for user actions"
    - "Statistics tracking captures cards reviewed, quality distribution, timing data, and accuracy rates"
    - "Keyboard shortcuts (1-5 for quality, space, p) enable efficient review flow"
    - "Practice mode combines stroke animation, tracing guides, and handwriting recognition"
    - "Session summary view presents comprehensive completion statistics"
    - "Integration testing verifies complex state transitions and multi-component workflows"

files:
  - path: "src/session/mod.rs"
    description: "Module declaration for session functionality"
  
  - path: "src/session/learning_session.rs"
    description: "LearningSession struct and state machine for review queue progression"
  
  - path: "src/session/practice_session.rs"
    description: "PracticeSession struct and state machine for practice mode progression"
  
  - path: "src/session/practice_mode.rs"
    description: "PracticeMode enum with four difficulty levels and mode transitions"
  
  - path: "src/session/session_statistics.rs"
    description: "SessionStatistics struct tracking progress, accuracy, timing data"
  
  - path: "src/ui/views/learning_session_view.rs"
    description: "UI view for learning session flashcard display and quality rating"
  
  - path: "src/ui/views/practice_session_view.rs"
    description: "UI view for practice mode with canvas, animation, and guides"
  
  - path: "src/ui/views/session_summary_view.rs"
    description: "Session summary screen displaying statistics and results"
  
  - path: "src/ui/components/quality_rating_buttons.rs"
    description: "Quality rating button component for SM-2 ratings (0-5)"
  
  - path: "src/ui/components/progress_bar.rs"
    description: "Progress bar component showing cards remaining in session"
  
  - path: "src/ui/components/practice_guide_overlay.rs"
    description: "Ghost overlay component for tracing guide in practice modes"
  
  - path: "tests/integration/session_workflow_tests.rs"
    description: "Integration tests for complete session workflows and state transitions"

functions:
  - file: "src/learning/session.rs"
    items:
      - type: "struct"
        name: "LearningSession"
        description: "State machine managing review session progression through queued cards"
        invariants: "current_index <= cards.len(), session statistics match actual reviews performed"
      
      - type: "struct"
        name: "SessionStatistics"
        description: "Tracks session metrics including cards reviewed, accuracy, timing data"
        invariants: "cards_reviewed <= total_cards, all timing values are non-negative"
      
      - type: "struct"
        name: "SessionCard"
        description: "Wrapper for a card in a session with session-specific metadata"
      
      - type: "enum"
        name: "SessionState"
        description: "Current state of learning session: Active, Paused, Completed, or Interrupted"
      
      - type: "method"
        name: "LearningSession::new"
        description: "Creates new learning session from review queue"
        preconditions: "queue is not empty"
        postconditions: "Session initialized with cards from queue, state is Active"
      
      - type: "method"
        name: "LearningSession::current_card"
        description: "Returns reference to current card being reviewed"
        preconditions: "session is not completed"
        postconditions: "Returns Some if cards remain, None if session complete"
      
      - type: "method"
        name: "LearningSession::submit_rating"
        description: "Records quality rating for current card and advances to next"
        preconditions: "rating is in range 0-5, session is Active"
        postconditions: "Card state updated via SM-2, statistics incremented, index advanced"
      
      - type: "method"
        name: "LearningSession::skip_card"
        description: "Skips current card and moves it to end of queue"
        preconditions: "session is Active, cards remain"
        postconditions: "current_index advanced, skipped card moved to end"
      
      - type: "method"
        name: "LearningSession::pause"
        description: "Pauses session, allowing resume later"
        postconditions: "SessionState set to Paused"
      
      - type: "method"
        name: "LearningSession::resume"
        description: "Resumes paused session"
        preconditions: "SessionState is Paused"
        postconditions: "SessionState set to Active"
      
      - type: "method"
        name: "LearningSession::complete"
        description: "Marks session as completed and returns final statistics"
        postconditions: "SessionState set to Completed, returns SessionStatistics"
      
      - type: "method"
        name: "LearningSession::progress"
        description: "Returns current progress as (cards_completed, total_cards)"
      
      - type: "method"
        name: "LearningSession::should_save"
        description: "Returns true if batch save threshold reached (every 5-10 cards)"
      
      - type: "method"
        name: "SessionStatistics::new"
        description: "Creates new statistics tracker for session"
      
      - type: "method"
        name: "SessionStatistics::record_review"
        description: "Records a completed review with timing and quality data"
        postconditions: "cards_reviewed incremented, timing and quality statistics updated"
      
      - type: "method"
        name: "SessionStatistics::average_time_per_card"
        description: "Calculates average review time across all cards"
        preconditions: "cards_reviewed > 0"
      
      - type: "method"
        name: "SessionStatistics::accuracy_rate"
        description: "Calculates percentage of reviews rated >= 3 (successful recall)"

  - file: "src/learning/practice.rs"
    items:
      - type: "enum"
        name: "PracticeMode"
        description: "Four progressive difficulty levels for practice sessions"
      
      - type: "enum_variant"
        name: "PracticeMode::WatchAnimation"
        description: "Passive observation mode showing stroke animation"
      
      - type: "enum_variant"
        name: "PracticeMode::TraceWithGuide"
        description: "Guided tracing with ghost overlay showing correct strokes"
      
      - type: "enum_variant"
        name: "PracticeMode::TraceWithoutGuide"
        description: "Unguided tracing showing only stroke order without overlay"
      
      - type: "enum_variant"
        name: "PracticeMode::FreeDrawing"
        description: "Free recall mode with no visual aids"
      
      - type: "struct"
        name: "PracticeSession"
        description: "State machine managing practice mode progression through difficulty levels"
        invariants: "mode advances only on successful recognition, character_index <= characters.len()"
      
      - type: "struct"
        name: "PracticeProgress"
        description: "Tracks user progress through practice modes for current character"
      
      - type: "struct"
        name: "PracticeStatistics"
        description: "Tracks practice session metrics including attempts, successes, time per mode"
      
      - type: "method"
        name: "PracticeSession::new"
        description: "Creates new practice session for given characters starting at WatchAnimation"
        postconditions: "Session initialized with characters, mode is WatchAnimation"
      
      - type: "method"
        name: "PracticeSession::current_character"
        description: "Returns reference to current character being practiced"
        postconditions: "Returns Some if characters remain, None if session complete"
      
      - type: "method"
        name: "PracticeSession::current_mode"
        description: "Returns current practice difficulty mode"
      
      - type: "method"
        name: "PracticeSession::advance_mode"
        description: "Advances to next difficulty level after successful recognition"
        preconditions: "recognition was successful, not already at highest difficulty"
        postconditions: "mode advanced to next level or character advanced if at FreeDrawing"
      
      - type: "method"
        name: "PracticeSession::retry_mode"
        description: "Allows retry of current mode after failed recognition"
        postconditions: "statistics updated with failed attempt"
      
      - type: "method"
        name: "PracticeSession::skip_to_mode"
        description: "Skips ahead to specified difficulty mode"
        postconditions: "mode set to specified level"
      
      - type: "method"
        name: "PracticeSession::reset_character"
        description: "Resets current character back to WatchAnimation mode"
        postconditions: "mode set to WatchAnimation for current character"
      
      - type: "method"
        name: "PracticeSession::show_hint"
        description: "Reveals next stroke as hint without advancing mode"
        postconditions: "hint_count incremented in statistics"
      
      - type: "method"
        name: "PracticeSession::next_character"
        description: "Advances to next character in practice queue"
        preconditions: "current character completed all modes or skipped"
        postconditions: "character_index advanced, mode reset to WatchAnimation"
      
      - type: "method"
        name: "PracticeMode::next"
        description: "Returns next difficulty level in progression sequence"
        postconditions: "Returns Some(next_mode) or None if at highest level"
      
      - type: "method"
        name: "PracticeMode::requires_animation"
        description: "Returns true if mode should play stroke animation"
      
      - type: "method"
        name: "PracticeMode::requires_guide"
        description: "Returns true if mode should show tracing guide overlay"
      
      - type: "method"
        name: "PracticeMode::requires_recognition"
        description: "Returns true if mode requires handwriting recognition validation"

  - file: "src/ui/session_view.rs"
    items:
      - type: "struct"
        name: "SessionView"
        description: "Main view component for learning session interface"
      
      - type: "struct"
        name: "SessionViewState"
        description: "Local UI state for session view including animations and feedback"
      
      - type: "function"
        name: "session_view"
        description: "Renders complete learning session UI with flashcard and quality buttons"
      
      - type: "function"
        name: "render_flashcard"
        description: "Renders current card with character, reading, and meaning"
      
      - type: "function"
        name: "render_quality_buttons"
        description: "Renders quality rating buttons (0-5) with keyboard shortcuts"
      
      - type: "function"
        name: "render_progress_bar"
        description: "Renders progress bar showing cards completed / total cards"
      
      - type: "function"
        name: "render_session_controls"
        description: "Renders pause, skip, and hint buttons"
      
      - type: "function"
        name: "render_feedback_overlay"
        description: "Renders visual feedback (green check / red X) after rating submission"
      
      - type: "function"
        name: "handle_quality_rating"
        description: "Handles quality button click or keyboard shortcut (1-5 keys)"
        postconditions: "Rating submitted to session, feedback animation triggered"
      
      - type: "function"
        name: "handle_keyboard_shortcuts"
        description: "Processes keyboard shortcuts (1-5 for quality, space for next, p for pause)"

  - file: "src/ui/practice_view.rs"
    items:
      - type: "struct"
        name: "PracticeView"
        description: "Main view component for practice mode interface"
      
      - type: "struct"
        name: "PracticeViewState"
        description: "Local UI state for practice view including canvas and animation state"
      
      - type: "function"
        name: "practice_view"
        description: "Renders complete practice mode UI based on current difficulty level"
      
      - type: "function"
        name: "render_practice_canvas"
        description: "Renders drawing canvas with optional guides and animations based on mode"
      
      - type: "function"
        name: "render_mode_indicator"
        description: "Renders current practice mode label and instructions"
      
      - type: "function"
        name: "render_stroke_animation"
        description: "Renders animated stroke playback for WatchAnimation mode"
      
      - type: "function"
        name: "render_tracing_guide"
        description: "Renders ghost overlay showing correct character form for tracing modes"
      
      - type: "function"
        name: "render_practice_controls"
        description: "Renders mode-specific controls (next, retry, hint, skip)"
      
      - type: "function"
        name: "handle_canvas_input"
        description: "Processes drawing input and validates against recognition when complete"
        postconditions: "On successful recognition, advances mode; on failure, shows retry option"
      
      - type: "function"
        name: "handle_animation_complete"
        description: "Handles completion of stroke animation in watch mode"
        postconditions: "Enables advance to next mode button"

  - file: "src/ui/session_summary.rs"
    items:
      - type: "struct"
        name: "SessionSummaryView"
        description: "View component displaying session completion statistics"
      
      - type: "function"
        name: "session_summary_view"
        description: "Renders session summary screen with detailed statistics"
      
      - type: "function"
        name: "render_statistics_grid"
        description: "Renders grid of session statistics (cards reviewed, accuracy, time, etc)"
      
      - type: "function"
        name: "render_quality_distribution"
        description: "Renders chart showing distribution of quality ratings"
      
      - type: "function"
        name: "render_session_actions"
        description: "Renders action buttons (continue reviewing, return to home, etc)"

  - file: "src/learning/session_persistence.rs"
    items:
      - type: "struct"
        name: "SessionSnapshot"
        description: "Serializable representation of session state for persistence"
      
      - type: "function"
        name: "save_session_state"
        description: "Persists current session state to database for resume capability"
        preconditions: "session is in valid state"
        postconditions: "Session state saved to database with timestamp"
      
      - type: "function"
        name: "load_session_state"
        description: "Loads previously saved session state from database"
        postconditions: "Returns Some(session) if saved state exists, None otherwise"
      
      - type: "function"
        name: "clear_session_state"
        description: "Removes saved session state from database after completion"
        postconditions: "Saved session data deleted from database"
      
      - type: "function"
        name: "batch_save_reviews"
        description: "Saves batch of completed reviews to database efficiently"
        preconditions: "reviews vector is not empty"
        postconditions: "All reviews persisted to database, card states updated"

  - file: "src/learning/feedback.rs"
    items:
      - type: "struct"
        name: "FeedbackAnimation"
        description: "Animation state for visual feedback (success/failure indicators)"
      
      - type: "enum"
        name: "FeedbackType"
        description: "Type of feedback to display: Success, Failure, Hint, or Skip"
      
      - type: "function"
        name: "trigger_feedback"
        description: "Initiates feedback animation with specified type and duration"
        postconditions: "Feedback animation started, will auto-dismiss after duration"
      
      - type: "function"
        name: "render_feedback_icon"
        description: "Renders animated feedback icon (checkmark, X, etc) with fade effect"

  - file: "src/learning/mod.rs"
    items:
      - type: "module_declaration"
        name: "session"
        description: "Learning session state machine and logic"
      
      - type: "module_declaration"
        name: "practice"
        description: "Practice mode progression and state management"
      
      - type: "module_declaration"
        name: "session_persistence"
        description: "Session state persistence and resume functionality"
      
      - type: "module_declaration"
        name: "feedback"
        description: "Visual feedback system for user actions"

  - file: "tests/session_integration_tests.rs"
    items:
      - type: "function"
        name: "test_session_full_progression"
        description: "Integration test: complete session progresses through all cards correctly"
      
      - type: "function"
        name: "test_session_quality_ratings"
        description: "Integration test: quality ratings update card state via SM-2 correctly"
      
      - type: "function"
        name: "test_session_pause_resume"
        description: "Integration test: session can be paused and resumed maintaining state"
      
      - type: "function"
        name: "test_session_statistics_accuracy"
        description: "Integration test: session statistics accurately reflect reviews performed"
      
      - type: "function"
        name: "test_session_batch_saving"
        description: "Integration test: batch saves occur at correct intervals"
      
      - type: "function"
        name: "test_session_skip_functionality"
        description: "Integration test: skipped cards move to end of queue correctly"

  - file: "tests/practice_integration_tests.rs"
    items:
      - type: "function"
        name: "test_practice_mode_progression"
        description: "Integration test: practice modes advance in correct sequence on success"
      
      - type: "function"
        name: "test_practice_recognition_validation"
        description: "Integration test: recognition validation correctly advances or retries mode"
      
      - type: "function"
        name: "test_practice_watch_animation"
        description: "Integration test: watch animation mode plays correctly and allows advance"
      
      - type: "function"
        name: "test_practice_trace_with_guide"
        description: "Integration test: trace with guide mode displays overlay and validates input"
      
      - type: "function"
        name: "test_practice_trace_without_guide"
        description: "Integration test: trace without guide mode removes overlay but validates input"
      
      - type: "function"
        name: "test_practice_free_drawing"
        description: "Integration test: free drawing mode has no aids and validates freely"
      
      - type: "function"
        name: "test_practice_hint_system"
        description: "Integration test: hint system reveals strokes without advancing mode"
      
      - type: "function"
        name: "test_practice_character_progression"
        description: "Integration test: completing all modes advances to next character"
      
      - type: "function"
        name: "test_practice_skip_modes"
        description: "Integration test: users can skip ahead to harder modes"
      
      - type: "function"
        name: "test_practice_reset_character"
        description: "Integration test: resetting character returns to WatchAnimation mode"
      
      - type: "function"
        name: "test_practice_statistics_tracking"
        description: "Integration test: practice statistics accurately track attempts and success rates"
      
      - type: "function"
        name: "test_session_keyboard_shortcuts"
        description: "Integration test: keyboard shortcuts (1-5, space, p) work correctly in session view"

formal_verification:
  needed: false
  level: "None"
  explanation: |
    Formal verification is not needed for the learning session and practice mode
    implementation for the following reasons:

    1. UI and State Machine Logic: The core functionality involves UI presentation,
       user interaction handling, and state machine transitions through practice modes
       and review sessions. These are predominantly behavioral concerns that are better
       validated through integration and end-to-end testing rather than formal proofs.

    2. External Dependencies: The session logic primarily orchestrates existing
       components (ReviewQueue, StrokeOrderAnimation, HandwritingCanvas, CharacterCard)
       that have their own correctness guarantees. The session acts as a coordinator
       rather than implementing critical algorithms requiring proof.

    3. Non-Critical Correctness Properties: While the session must progress correctly
       through cards and modes, errors in this system (e.g., incorrect progress tracking,
       missed state transitions) result in poor user experience rather than data
       corruption or safety violations. The SM-2 algorithm (Task 7) handles the critical
       spaced repetition logic separately.

    4. Observable Behavior: Session correctness is directly observable through user
       interaction - users immediately notice if cards don't progress, statistics are
       wrong, or practice modes behave incorrectly. This makes integration testing
       with comprehensive assertions more practical and cost-effective.

    5. State Machine Complexity: While the practice mode state machine has many
       transitions (watch → trace-with-guide → trace-without-guide → free-drawing),
       these are linear progressions with clear success/failure conditions that can
       be exhaustively tested through integration tests covering all transition paths.

    6. Testing Sufficiency: The 18 integration tests specified can comprehensively
       verify state transitions, data flow, session interruption/resume, database
       persistence, and statistics accuracy. Property-based testing could supplement
       by generating random session sequences, but formal verification would be
       overkill for this coordination layer.

    The implementation should focus on robust integration testing, clear state machine
    documentation, and defensive programming (null checks, bounds validation) rather
    than formal proofs.

tests:
  strategy:
    approach: "mixed (unit tests + integration tests)"
    rationale:
      - "Session state machines require unit tests for each state transition and edge case"
      - "Integration tests verify end-to-end flows through complete learning/practice sessions"
      - "Session statistics and progress tracking need verification across multiple operations"
      - "Practice mode progression logic is complex and requires isolated unit testing"
      - "Database batching and save reliability require integration testing with persistence layer"
      - "User interaction flows (quality ratings, mode advancement) benefit from integration tests"

  implementation:
    file: "tests/learning_session_tests.rs"
    location: "create new"
    code: |
      #[cfg(test)]
      mod learning_session_tests {
          use super::*;
          use crate::spaced_repetition::{SM2Card, ReviewQueue, Quality};
          use crate::models::CharacterCard;
          use crate::session::{LearningSession, SessionStatistics, SessionState};
          
          // Mock setup helpers
          fn create_test_cards(count: usize) -> Vec<SM2Card> {
              (0..count)
                  .map(|i| SM2Card::new(format!("char_{}", i)))
                  .collect()
          }
          
          fn create_test_session(card_count: usize) -> LearningSession {
              let cards = create_test_cards(card_count);
              let queue = ReviewQueue::from_cards(cards);
              LearningSession::new(queue)
          }
          
          #[test]
          fn test_session_initialization() {
              // Session starts with correct initial state
              let session = create_test_session(5);
              
              assert_eq!(session.state(), SessionState::Ready);
              assert_eq!(session.total_cards(), 5);
              assert_eq!(session.cards_reviewed(), 0);
              assert_eq!(session.current_card_index(), 0);
          }
          
          #[test]
          fn test_session_progresses_through_all_cards() {
              // Session presents each card in queue order
              let mut session = create_test_session(3);
              
              session.start();
              assert_eq!(session.state(), SessionState::PresentingCard);
              
              let card1 = session.current_card().unwrap();
              session.submit_rating(Quality::Good);
              assert_eq!(session.cards_reviewed(), 1);
              
              let card2 = session.current_card().unwrap();
              assert_ne!(card1.character_id(), card2.character_id());
              session.submit_rating(Quality::Perfect);
              assert_eq!(session.cards_reviewed(), 2);
              
              session.current_card().unwrap();
              session.submit_rating(Quality::Good);
              assert_eq!(session.cards_reviewed(), 3);
              assert_eq!(session.state(), SessionState::Completed);
          }
          
          #[test]
          fn test_quality_ratings_update_card_state() {
              // Each quality rating correctly updates SM-2 card state
              let mut session = create_test_session(1);
              session.start();
              
              let card_before = session.current_card().unwrap().clone();
              let ease_before = card_before.ease_factor();
              let interval_before = card_before.interval();
              
              session.submit_rating(Quality::Good);
              
              let updated_card = session.get_reviewed_card(0).unwrap();
              assert!(updated_card.interval() >= interval_before);
              assert_eq!(updated_card.repetitions(), card_before.repetitions() + 1);
          }
          
          #[test]
          fn test_session_statistics_accuracy() {
              // Statistics correctly track all session metrics
              let mut session = create_test_session(5);
              session.start();
              
              session.submit_rating(Quality::Perfect);
              session.submit_rating(Quality::Good);
              session.submit_rating(Quality::Hard);
              session.submit_rating(Quality::Good);
              session.submit_rating(Quality::Again);
              
              let stats = session.statistics();
              assert_eq!(stats.total_cards, 5);
              assert_eq!(stats.cards_reviewed, 5);
              assert_eq!(stats.perfect_count, 1);
              assert_eq!(stats.good_count, 2);
              assert_eq!(stats.hard_count, 1);
              assert_eq!(stats.again_count, 1);
              assert_eq!(stats.accuracy_rate(), 0.8); // 4/5 correct (excluding Again)
          }
          
          #[test]
          fn test_session_tracks_time_per_card() {
              // Session records time spent on each card
              use std::thread::sleep;
              use std::time::Duration;
              
              let mut session = create_test_session(2);
              session.start();
              
              sleep(Duration::from_millis(100));
              session.submit_rating(Quality::Good);
              
              sleep(Duration::from_millis(150));
              session.submit_rating(Quality::Good);
              
              let stats = session.statistics();
              assert!(stats.average_time_per_card().as_millis() >= 100);
              assert!(stats.total_time().as_millis() >= 250);
          }
          
          #[test]
          fn test_session_can_be_paused_and_resumed() {
              // Session state persists across pause/resume cycles
              let mut session = create_test_session(5);
              session.start();
              
              session.submit_rating(Quality::Good);
              session.submit_rating(Quality::Perfect);
              
              let cards_reviewed = session.cards_reviewed();
              let card_id = session.current_card().unwrap().character_id().to_string();
              
              session.pause();
              assert_eq!(session.state(), SessionState::Paused);
              
              session.resume();
              assert_eq!(session.state(), SessionState::PresentingCard);
              assert_eq!(session.cards_reviewed(), cards_reviewed);
              assert_eq!(session.current_card().unwrap().character_id(), card_id);
          }
          
          #[test]
          fn test_empty_session_handling() {
              // Session handles empty queue gracefully
              let empty_queue = ReviewQueue::new();
              let session = LearningSession::new(empty_queue);
              
              assert_eq!(session.total_cards(), 0);
              assert_eq!(session.state(), SessionState::Empty);
              assert!(session.current_card().is_none());
          }
          
          #[test]
          fn test_session_progress_percentage() {
              // Progress calculation is accurate throughout session
              let mut session = create_test_session(4);
              session.start();
              
              assert_eq!(session.progress_percentage(), 0.0);
              
              session.submit_rating(Quality::Good);
              assert_eq!(session.progress_percentage(), 25.0);
              
              session.submit_rating(Quality::Good);
              assert_eq!(session.progress_percentage(), 50.0);
              
              session.submit_rating(Quality::Good);
              assert_eq!(session.progress_percentage(), 75.0);
              
              session.submit_rating(Quality::Good);
              assert_eq!(session.progress_percentage(), 100.0);
          }
          
          #[test]
          fn test_session_cannot_submit_rating_before_start() {
              // Attempting to rate before starting session fails gracefully
              let mut session = create_test_session(3);
              
              let result = session.submit_rating(Quality::Good);
              assert!(result.is_err());
              assert_eq!(session.cards_reviewed(), 0);
          }
          
          #[test]
          fn test_session_summary_data() {
              // Session summary contains all relevant completion data
              let mut session = create_test_session(3);
              session.start();
              
              session.submit_rating(Quality::Perfect);
              session.submit_rating(Quality::Good);
              session.submit_rating(Quality::Hard);
              
              let summary = session.generate_summary();
              assert_eq!(summary.total_cards, 3);
              assert_eq!(summary.cards_reviewed, 3);
              assert!(summary.session_duration.as_secs() > 0);
              assert!(summary.average_time_per_card.as_millis() > 0);
              assert_eq!(summary.quality_distribution.len(), 3);
          }
      }
      
      #[cfg(test)]
      mod practice_session_tests {
          use super::*;
          use crate::session::{PracticeSession, PracticeMode, PracticeFeedback};
          use crate::models::CharacterData;
          use crate::drawing::StrokeData;
          
          fn create_test_character() -> CharacterData {
              CharacterData {
                  character: "一".to_string(),
                  strokes: vec![
                      StrokeData::new(vec![(0, 50), (100, 50)]),
                  ],
                  meaning: "one".to_string(),
                  pinyin: "yī".to_string(),
              }
          }
          
          #[test]
          fn test_practice_session_starts_in_watch_mode() {
              // Practice session initializes in WatchAnimation mode
              let character = create_test_character();
              let session = PracticeSession::new(character);
              
              assert_eq!(session.current_mode(), PracticeMode::WatchAnimation);
              assert_eq!(session.mode_index(), 0);
          }
          
          #[test]
          fn test_practice_mode_progression() {
              // Practice session progresses through all four modes in order
              let character = create_test_character();
              let mut session = PracticeSession::new(character);
              
              assert_eq!(session.current_mode(), PracticeMode::WatchAnimation);
              
              session.complete_current_mode();
              assert_eq!(session.current_mode(), PracticeMode::TraceWithGuide);
              
              session.complete_current_mode();
              assert_eq!(session.current_mode(), PracticeMode::TraceWithoutGuide);
              
              session.complete_current_mode();
              assert_eq!(session.current_mode(), PracticeMode::FreeDrawing);
              
              session.complete_current_mode();
              assert!(session.is_completed());
          }
          
          #[test]
          fn test_practice_mode_requires_validation() {
              // Trace and free drawing modes require successful validation to advance
              let character = create_test_character();
              let mut session = PracticeSession::new(character);
              
              // Skip to trace mode
              session.complete_current_mode(); // Watch
              session.complete_current_mode(); // TraceWithGuide
              
              assert_eq!(session.current_mode(), PracticeMode::TraceWithoutGuide);
              
              let invalid_strokes = vec![]; // Empty strokes
              let result = session.validate_and_advance(invalid_strokes);
              
              assert!(result.is_err());
              assert_eq!(session.current_mode(), PracticeMode::TraceWithoutGuide);
          }
          
          #[test]
          fn test_practice_mode_validation_success() {
              // Successful validation advances to next mode
              let character = create_test_character();
              let mut session = PracticeSession::new(character.clone());
              
              session.complete_current_mode(); // Watch
              session.complete_current_mode(); // TraceWithGuide
              
              let valid_strokes = character.strokes.clone();
              let result = session.validate_and_advance(valid_strokes);
              
              assert!(result.is_ok());
              assert_eq!(session.current_mode(), PracticeMode::FreeDrawing);
          }
          
          #[test]
          fn test_practice_skip_functionality() {
              // Skip button allows progression without validation
              let character = create_test_character();
              let mut session = PracticeSession::new(character);
              
              session.complete_current_mode(); // Watch
              session.complete_current_mode(); // TraceWithGuide
              
              let current_mode = session.current_mode();
              session.skip_current_mode();
              
              assert_ne!(session.current_mode(), current_mode);
              assert!(session.skip_count() > 0);
          }
          
          #[test]
          fn test_practice_hint_system() {
              // Hint reveals next stroke in sequence
              let character = create_test_character();
              let mut session = PracticeSession::new(character);
              
              session.complete_current_mode(); // Watch
              session.complete_current_mode(); // TraceWithGuide
              
              let hint = session.request_hint();
              assert!(hint.is_some());
              assert_eq!(session.hints_used(), 1);
              
              let hint2 = session.request_hint();
              assert_eq!(session.hints_used(), 2);
          }
          
          #[test]
          fn test_practice_feedback_on_stroke_completion() {
              // Each completed stroke provides accuracy feedback
              let character = create_test_character();
              let mut session = PracticeSession::new(character);
              
              session.complete_current_mode(); // Watch
              session.advance_to_mode(PracticeMode::TraceWithGuide);
              
              let stroke = StrokeData::new(vec![(0, 50), (100, 50)]);
              let feedback = session.evaluate_stroke(stroke);
              
              assert!(feedback.accuracy >= 0.0 && feedback.accuracy <= 1.0);
              assert!(feedback.is_correct || !feedback.is_correct);
          }
          
          #[test]
          fn test_practice_statistics_tracking() {
              // Practice session tracks attempts, accuracy, and time
              let character = create_test_character();
              let mut session = PracticeSession::new(character.clone());
              
              session.complete_current_mode(); // Watch
              session.complete_current_mode(); // TraceWithGuide
              
              session.validate_and_advance(character.strokes.clone()).ok();
              
              let stats = session.get_statistics();
              assert!(stats.total_attempts > 0);
              assert!(stats.successful_strokes >= 0);
              assert!(stats.average_accuracy >= 0.0);
          }
          
          #[test]
          fn test_practice_mode_restart() {
              // User can restart from beginning at any point
              let character = create_test_character();
              let mut session = PracticeSession::new(character);
              
              session.complete_current_mode();
              session.complete_current_mode();
              assert_eq!(session.mode_index(), 2);
              
              session.restart();
              assert_eq!(session.current_mode(), PracticeMode::WatchAnimation);
              assert_eq!(session.mode_index(), 0);
          }
          
          #[test]
          fn test_animation_playback_control() {
              // Watch mode supports play/pause/replay controls
              let character = create_test_character();
              let mut session = PracticeSession::new(character);
              
              assert_eq!(session.current_mode(), PracticeMode::WatchAnimation);
              
              session.play_animation();
              assert!(session.is_animation_playing());
              
              session.pause_animation();
              assert!(!session.is_animation_playing());
              
              session.replay_animation();
              assert!(session.is_animation_playing());
              assert_eq!(session.animation_progress(), 0.0);
          }
      }
      
      #[cfg(test)]
      mod session_integration_tests {
          use super::*;
          use crate::session::{LearningSession, PracticeSession, SessionManager};
          use crate::persistence::SessionRepository;
          use crate::spaced_repetition::{ReviewQueue, Quality};
          
          #[test]
          fn test_session_database_batching() {
              // Session batches saves every N cards, not after each card
              let mut session = create_test_session(15);
              let mut repo = SessionRepository::new_in_memory();
              let batch_size = 5;
              
              session.start();
              
              for i in 0..15 {
                  session.submit_rating(Quality::Good);
                  
                  if (i + 1) % batch_size == 0 {
                      session.save_progress(&mut repo).unwrap();
                  }
              }
              
              let saved_count = repo.get_review_count();
              assert_eq!(saved_count, 15);
          }
          
          #[test]
          fn test_session_interruption_and_resume() {
              // Session can be interrupted, saved, and resumed from exact state
              let mut session = create_test_session(10);
              let mut repo = SessionRepository::new_in_memory();
              
              session.start();
              session.submit_rating(Quality::Good);
              session.submit_rating(Quality::Perfect);
              session.submit_rating(Quality::Hard);
              
              let session_id = session.id();
              let cards_reviewed = session.cards_reviewed();
              
              session.save_progress(&mut repo).unwrap();
              drop(session);
              
              let mut resumed = repo.load_session(session_id).unwrap();
              assert_eq!(resumed.cards_reviewed(), cards_reviewed);
              assert_eq!(resumed.state(), SessionState::Paused);
              
              resumed.resume();
              resumed.submit_rating(Quality::Good);
              assert_eq!(resumed.cards_reviewed(), cards_reviewed + 1);
          }
          
          #[test]
          fn test_complete_learning_flow() {
              // End-to-end: queue -> session -> ratings -> statistics -> completion
              let cards = create_test_cards(5);
              let queue = ReviewQueue::from_cards(cards);
              let mut session = LearningSession::new(queue);
              
              session.start();
              
              let ratings = vec![
                  Quality::Perfect,
                  Quality::Good,
                  Quality::Good,
                  Quality::Hard,
                  Quality::Perfect,
              ];
              
              for rating in ratings {
                  session.submit_rating(rating);
              }
              
              assert_eq!(session.state(), SessionState::Completed);
              
              let summary = session.generate_summary();
              assert_eq!(summary.total_cards, 5);
              assert_eq!(summary.cards_reviewed, 5);
              assert_eq!(summary.perfect_count, 2);
              assert_eq!(summary.good_count, 2);
              assert_eq!(summary.hard_count, 1);
          }
          
          #[test]
          fn test_practice_to_learning_progression() {
              // Character practiced successfully can enter learning queue
              let character = create_test_character();
              let mut practice = PracticeSession::new(character.clone());
              
              // Complete all practice modes
              practice.complete_current_mode(); // Watch
              practice.complete_current_mode(); // TraceWithGuide
              practice.validate_and_advance(character.strokes.clone()).ok();
              practice.validate_and_advance(character.strokes.clone()).ok();
              
              assert!(practice.is_completed());
              
              let sm2_card = SM2Card::new(character.character.clone());
              let mut queue = ReviewQueue::new();
              queue.add_card(sm2_card);
              
              let mut learning = LearningSession::new(queue);
              learning.start();
              
              assert_eq!(
                  learning.current_card().unwrap().character_id(),
                  character.character
              );
          }
          
          #[test]
          fn test_session_statistics_persistence() {
              // Session statistics save and load correctly
              let mut session = create_test_session(3);
              let mut repo = SessionRepository::new_in_memory();
              
              session.start();
              session.submit_rating(Quality::Perfect);
              session.submit_rating(Quality::Good);
              session.submit_rating(Quality::Again);
              
              let stats_before = session.statistics().clone();
              let session_id = session.id();
              
              session.save_progress(&mut repo).unwrap();
              
              let loaded = repo.load_session(session_id).unwrap();
              let stats_after = loaded.statistics();
              
              assert_eq!(stats_before.perfect_count, stats_after.perfect_count);
              assert_eq!(stats_before.good_count, stats_after.good_count);
              assert_eq!(stats_before.again_count, stats_after.again_count);
          }
          
          #[test]
          fn test_concurrent_session_isolation() {
              // Multiple sessions operate independently without interference
              let mut session1 = create_test_session(3);
              let mut session2 = create_test_session(3);
              
              session1.start();
              session2.start();
              
              session1.submit_rating(Quality::Perfect);
              session2.submit_rating(Quality::Good);
              
              assert_eq!(session1.cards_reviewed(), 1);
              assert_eq!(session2.cards_reviewed(), 1);
              assert_ne!(session1.id(), session2.id());
              
              let stats1 = session1.statistics();
              let stats2 = session2.statistics();
              
              assert_eq!(stats1.perfect_count, 1);
              assert_eq!(stats2.perfect_count, 0);
              assert_eq!(stats2.good_count, 1);
          }
      }

  coverage:
    - "Session initialization with correct initial state"
    - "Session progression through all queued cards in order"
    - "Quality ratings correctly update SM-2 card state"
    - "Session statistics track all metrics accurately (cards, ratings, time)"
    - "Time tracking per card and total session duration"
    - "Session pause and resume maintains state correctly"
    - "Empty session/queue handling without crashes"
    - "Progress percentage calculation throughout session"
    - "Rating submission validation (cannot rate before starting)"
    - "Session summary generation with complete data"
    - "Practice session starts in WatchAnimation mode"
    - "Practice mode progression through all four stages"
    - "Validation requirement for trace and free drawing modes"
    - "Successful validation advances to next mode"
    - "Skip functionality allows progression without validation"
    - "Hint system reveals next stroke and tracks usage"
    - "Stroke completion provides accuracy feedback"
    - "Practice statistics tracking (attempts, accuracy, time)"
    - "Practice session restart from beginning"
    - "Animation playback controls (play, pause, replay)"
    - "Database batching saves every N cards efficiently"
    - "Session interruption, save, and exact state resume"
    - "Complete end-to-end learning flow with statistics"
    - "Practice completion enables learning queue entry"
    - "Session statistics persistence and loading"
    - "Concurrent session isolation without interference"

dependencies:
  depends_on:
    - task_id: 2
      reason: "Requires CharacterData model for practice sessions and character display"
    - task_id: 3
      reason: "Requires CharacterCard widget for flashcard presentation in learning sessions"
    - task_id: 4
      reason: "Requires StrokeOrderAnimation component for WatchAnimation practice mode"
    - task_id: 5
      reason: "Requires HandwritingCanvas for drawing input in practice modes"
    - task_id: 6
      reason: "Requires state management framework to coordinate session state across UI"
    - task_id: 7
      reason: "Requires SM-2 algorithm for card scheduling and ReviewQueue for session initialization"

  depended_upon_by:
    - task_id: 10
      reason: "Statistics system requires session completion data for analytics and progress tracking"

  external:
    - name: "SM2Card"
      type: "struct"
      status: "already exists"
    - name: "ReviewQueue"
      type: "struct"
      status: "already exists"
    - name: "Quality"
      type: "enum"
      status: "already exists"
    - name: "CharacterData"
      type: "struct"
      status: "already exists"
    - name: "StrokeData"
      type: "struct"
      status: "already exists"
    - name: "CharacterCard"
      type: "struct"
      status: "already exists"
    - name: "StrokeOrderAnimation"
      type: "struct"
      status: "already exists"
    - name: "HandwritingCanvas"
      type: "struct"
      status: "already exists"
---
task:
  id: 9
  name: "Character Recognition Integration"

context:
  description: |
    This task implements a character recognition engine that validates user-drawn strokes
    in practice mode by analyzing stroke patterns and returning candidate matches with
    confidence scores. The recognition system serves as the critical validation mechanism
    that provides objective assessment of whether users can accurately reproduce Japanese
    characters from memory.

    The implementation bridges the drawing canvas (which captures raw stroke data) and the
    practice session (which needs validation results). It consists of three main subsystems:
    (1) stroke normalization that converts variable-resolution input into consistent
    coordinate space, (2) recognition engine integration via FFI or WASM that interfaces
    with external libraries like hanzi_lookup, and (3) validation logic that interprets
    recognition results against expected characters using configurable confidence thresholds.

    Recognition accuracy is critical for user experience - overly strict thresholds frustrate
    users with false negatives, while loose thresholds allow incorrect forms to pass. The
    system must handle natural handwriting variability while maintaining educational rigor.
    Performance is equally important, with a hard requirement of <200ms latency to maintain
    fluid practice interactions.

  key_points:
    - "Stroke normalization to unit square (0-1 range) ensures resolution independence across devices"
    - "Recognition threshold tuning balances educational rigor (preventing bad habits) with user frustration (false negatives)"
    - "Integration with external recognition library (hanzi_lookup) requires FFI or WASM bridge with careful error handling"
    - "False positive rate <5% is critical to prevent users from learning incorrect stroke patterns"
    - "Performance budget of 200ms includes normalization, recognition, and validation steps"
    - "Feedback generation must provide actionable guidance (stroke count hints, similar characters) rather than generic errors"
    - "Most recognition libraries focus on kanji; kana support may require fallback strategies or custom model training"
    - "Stroke count validation (cheap) can filter obvious errors before expensive recognition"

files:
  - path: "src/recognition/mod.rs"
    description: "Module declaration and public API for character recognition subsystem"
  
  - path: "src/recognition/types.rs"
    description: "Type definitions for recognition including stroke data structures, recognition results, and confidence scores"
  
  - path: "src/recognition/normalizer.rs"
    description: "Stroke normalization functions including coordinate scaling, resampling, and smoothing"
  
  - path: "src/recognition/engine.rs"
    description: "Recognition engine interface and integration with hanzi_lookup or alternative recognition library"
  
  - path: "src/recognition/validator.rs"
    description: "Result validation logic that checks recognition results against expected characters with confidence thresholds"
  
  - path: "src/recognition/feedback.rs"
    description: "Feedback generation for incorrect recognition attempts, including stroke count hints and error messages"
  
  - path: "src/recognition/pipeline.rs"
    description: "End-to-end recognition pipeline coordinating normalization, preprocessing, recognition, and validation"
  
  - path: "tests/recognition_tests.rs"
    description: "Integration tests for recognition pipeline using sample stroke data"
  
  - path: "tests/fixtures/stroke_samples.json"
    description: "Test data containing sample stroke sequences for various kana characters"
  
  - path: "tests/fixtures/false_positive_samples.json"
    description: "Test dataset for validating false positive rate below 5% threshold"

functions:
  - file: "src/recognition/mod.rs"
    items:
      - type: "module_declaration"
        name: "recognition"
        description: "Top-level module for character recognition functionality, containing stroke normalization, recognition interface, and validation logic"

  - file: "src/recognition/types.rs"
    items:
      - type: "struct"
        name: "Point"
        description: "2D point with x and y coordinates (f32)"
      
      - type: "struct"
        name: "Stroke"
        description: "Ordered sequence of points representing a single brush stroke"
        invariants: "Points are ordered chronologically, contains at least 2 points"
      
      - type: "struct"
        name: "StrokeSequence"
        description: "Ordered collection of strokes representing a complete character"
        invariants: "Strokes are ordered by drawing sequence"
      
      - type: "enum"
        name: "PreprocessingOption"
        description: "Options for stroke preprocessing: None, Resample(usize), Smooth, ResampleAndSmooth(usize)"

  - file: "src/recognition/normalizer.rs"
    items:
      - type: "struct"
        name: "NormalizedStroke"
        description: "Represents a stroke with coordinates normalized to 0-1 range, preserving order and direction"
        invariants: "All x and y coordinates are in [0.0, 1.0] range"
      
      - type: "struct"
        name: "BoundingBox"
        description: "Represents the minimum bounding box containing all points in a set of strokes"
        invariants: "min_x <= max_x and min_y <= max_y"
      
      - type: "function"
        name: "calculate_bounding_box"
        description: "Computes the minimum bounding box for a collection of strokes"
        preconditions: "Strokes array is non-empty and contains valid coordinate points"
        postconditions: "Returns bounding box containing all stroke points"
      
      - type: "function"
        name: "normalize_strokes"
        description: "Normalizes stroke coordinates to 0-1 range relative to bounding box, making them resolution-independent"
        preconditions: "Input strokes are non-empty with valid coordinates"
        postconditions: "All coordinates mapped to [0.0, 1.0] range while preserving relative positions and stroke order"
        invariants: "Stroke count and stroke order are preserved"
      
      - type: "function"
        name: "resample_stroke"
        description: "Resamples a stroke to a fixed number of points using linear interpolation to reduce noise and ensure consistency"
        preconditions: "Stroke contains at least 2 points, target_point_count >= 2"
        postconditions: "Returns stroke with exactly target_point_count evenly spaced points"
      
      - type: "function"
        name: "smooth_stroke"
        description: "Applies smoothing filter to reduce noise in stroke points while preserving overall shape"
        preconditions: "Stroke contains at least 3 points for meaningful smoothing"
        postconditions: "Returns smoothed stroke with same point count, reduced high-frequency noise"

  - file: "src/recognition/engine.rs"
    items:
      - type: "struct"
        name: "RecognitionEngine"
        description: "Main interface to character recognition backend (hanzi_lookup or WASM-based recognizer)"
      
      - type: "struct"
        name: "RecognitionResult"
        description: "Single recognition candidate with character and confidence score"
        invariants: "Confidence score is in [0.0, 1.0] range"
      
      - type: "struct"
        name: "RecognitionConfig"
        description: "Configuration parameters for recognition engine (thresholds, max candidates, preprocessing options)"
      
      - type: "method"
        name: "RecognitionEngine::new"
        description: "Creates new recognition engine instance with specified configuration"
        postconditions: "Engine is initialized and ready to process recognition requests"
      
      - type: "method"
        name: "RecognitionEngine::recognize"
        description: "Performs character recognition on normalized strokes and returns ranked candidates"
        preconditions: "Strokes are normalized and preprocessed, engine is initialized"
        postconditions: "Returns list of candidates sorted by confidence (descending), completes within 200ms"
        invariants: "Result list size does not exceed max_candidates configuration"
      
      - type: "function"
        name: "format_strokes_for_recognition"
        description: "Converts normalized stroke data into format required by recognition library"
        preconditions: "Strokes are normalized to 0-1 range"
        postconditions: "Returns data in recognition library's expected format"

  - file: "src/recognition/validator.rs"
    items:
      - type: "struct"
        name: "ValidationConfig"
        description: "Configuration for validation including top-N threshold and minimum confidence score"
      
      - type: "struct"
        name: "ValidationResult"
        description: "Result of validation check indicating success/failure and providing feedback"
      
      - type: "function"
        name: "validate_recognition"
        description: "Checks if expected character appears in top-N recognition results with sufficient confidence"
        preconditions: "Recognition results are sorted by confidence descending, expected character is valid"
        postconditions: "Returns validation result with success boolean and appropriate feedback message"
      
      - type: "function"
        name: "check_stroke_count"
        description: "Validates that the number of strokes matches expected count for the character"
        preconditions: "Expected stroke count is known for the character"
        postconditions: "Returns true if stroke count matches, false otherwise"
      
      - type: "function"
        name: "calculate_confidence_threshold"
        description: "Determines appropriate confidence threshold based on character complexity and user level"
        preconditions: "Character metadata is available"
        postconditions: "Returns confidence threshold in [0.0, 1.0] range appropriate for validation"

  - file: "src/recognition/feedback.rs"
    items:
      - type: "enum"
        name: "FeedbackType"
        description: "Categories of feedback messages: StrokeCountMismatch, LowConfidence, WrongCharacter, Success"
      
      - type: "struct"
        name: "FeedbackMessage"
        description: "Structured feedback with type, message text, and optional suggestions"
      
      - type: "function"
        name: "generate_feedback"
        description: "Generates helpful feedback message based on validation result and recognition candidates"
        preconditions: "Validation result and recognition results are available"
        postconditions: "Returns appropriate feedback message for user"
      
      - type: "function"
        name: "suggest_correction"
        description: "Analyzes failed recognition to provide specific correction suggestions (e.g., stroke order hints)"
        preconditions: "Recognition failed, expected character and actual results available"
        postconditions: "Returns specific actionable suggestions for improvement"
      
      - type: "function"
        name: "format_stroke_count_hint"
        description: "Creates user-friendly message about expected vs actual stroke count"
        preconditions: "Expected and actual stroke counts are known"
        postconditions: "Returns formatted hint message"

  - file: "src/recognition/pipeline.rs"
    items:
      - type: "struct"
        name: "RecognitionPipeline"
        description: "End-to-end recognition pipeline coordinating normalization, preprocessing, recognition, and validation"
      
      - type: "method"
        name: "RecognitionPipeline::new"
        description: "Creates new recognition pipeline with specified engine and configuration"
        postconditions: "Pipeline is ready to process recognition requests"
      
      - type: "method"
        name: "RecognitionPipeline::process"
        description: "Processes raw stroke data through full pipeline and returns validation result with feedback"
        preconditions: "Raw strokes are valid, expected character is provided"
        postconditions: "Returns validation result with confidence scores and feedback within 200ms"
      
      - type: "method"
        name: "RecognitionPipeline::recognize_without_validation"
        description: "Runs recognition without validation, returning all candidates for exploratory use"
        preconditions: "Raw strokes are valid"
        postconditions: "Returns ranked recognition candidates"

formal_verification:
  needed: false
  level: "None"
  explanation: |
    Formal verification is not needed for this character recognition integration task
    for several reasons:
    
    1. Non-deterministic behavior: Character recognition involves heuristic algorithms
       and confidence scoring that are inherently probabilistic. The recognition engine
       produces ranked candidates based on pattern matching that cannot be formally
       specified with mathematical precision.
    
    2. External dependency: The core recognition logic resides in external libraries
       (hanzi_lookup or similar) that are black boxes from this module's perspective.
       We cannot formally verify properties of third-party recognition engines.
    
    3. Empirical validation required: The key quality metrics (false positive rate <5%,
       recognition time <200ms, confidence thresholds) must be validated empirically
       through integration testing with real handwriting samples, not formal proofs.
    
    4. Tolerance for errors: The system includes feedback mechanisms and allows multiple
       attempts. A recognition failure doesn't cause safety issues or data corruption -
       it simply provides incorrect feedback that users can work around.
    
    5. Normalization is straightforward: Stroke normalization (coordinate scaling,
       resampling) involves simple arithmetic transformations that are easily verified
       through unit tests and property-based testing. These operations don't require
       formal proofs.
    
    The appropriate verification strategy is comprehensive integration testing with
    a representative dataset of handwriting samples, combined with property-based
    testing for the normalization functions to ensure they preserve essential stroke
    characteristics (order, direction, relative positions).

tests:
  strategy:
    approach: "mixed (unit + integration + property-based)"
    rationale:
      - "Unit tests verify individual components (normalization, preprocessing) in isolation with deterministic inputs"
      - "Integration tests validate end-to-end recognition pipeline with real stroke data and external library interaction"
      - "Property-based tests ensure normalization preserves mathematical invariants across diverse inputs"
      - "Performance tests verify <200ms latency requirement under realistic conditions"
      - "False positive validation requires statistical testing with known-good and known-bad samples"

  implementation:
    file: "tests/recognition_tests.rs"
    location: "create new"
    code: |
      #[cfg(test)]
      mod stroke_normalization_tests {
          use super::super::*;
          
          #[test]
          fn test_normalize_single_stroke_to_unit_square() {
              // Verify stroke coordinates are scaled to 0-1 range
              let stroke = vec![
                  Point { x: 100.0, y: 200.0 },
                  Point { x: 300.0, y: 400.0 },
              ];
              
              let normalized = normalize_stroke(&stroke);
              
              assert!(normalized.iter().all(|p| p.x >= 0.0 && p.x <= 1.0));
              assert!(normalized.iter().all(|p| p.y >= 0.0 && p.y <= 1.0));
              assert_eq!(normalized.len(), stroke.len());
          }
          
          #[test]
          fn test_normalize_preserves_relative_positions() {
              // Verify that relative positions between points are maintained
              let stroke = vec![
                  Point { x: 0.0, y: 0.0 },
                  Point { x: 50.0, y: 50.0 },
                  Point { x: 100.0, y: 0.0 },
              ];
              
              let normalized = normalize_stroke(&stroke);
              
              // Middle point should still be at relative midpoint
              assert!((normalized[1].x - 0.5).abs() < 0.01);
              assert!((normalized[1].y - 1.0).abs() < 0.01);
          }
          
          #[test]
          fn test_normalize_preserves_stroke_order() {
              // Verify stroke points maintain their sequential order
              let stroke = vec![
                  Point { x: 10.0, y: 10.0 },
                  Point { x: 20.0, y: 20.0 },
                  Point { x: 30.0, y: 30.0 },
              ];
              
              let normalized = normalize_stroke(&stroke);
              
              assert!(normalized[0].x < normalized[1].x);
              assert!(normalized[1].x < normalized[2].x);
          }
          
          #[test]
          fn test_normalize_handles_single_point_stroke() {
              // Edge case: stroke with only one point
              let stroke = vec![Point { x: 50.0, y: 50.0 }];
              
              let normalized = normalize_stroke(&stroke);
              
              assert_eq!(normalized.len(), 1);
              assert!(normalized[0].x >= 0.0 && normalized[0].x <= 1.0);
          }
          
          #[test]
          fn test_resample_stroke_to_fixed_count() {
              // Verify resampling produces consistent point count
              let stroke = vec![
                  Point { x: 0.0, y: 0.0 },
                  Point { x: 0.5, y: 0.5 },
                  Point { x: 1.0, y: 1.0 },
              ];
              
              let resampled = resample_stroke(&stroke, 10);
              
              assert_eq!(resampled.len(), 10);
          }
          
          #[test]
          fn test_resample_preserves_endpoints() {
              // Verify first and last points are preserved
              let stroke = vec![
                  Point { x: 0.0, y: 0.0 },
                  Point { x: 0.5, y: 0.5 },
                  Point { x: 1.0, y: 1.0 },
              ];
              
              let resampled = resample_stroke(&stroke, 5);
              
              assert!((resampled.first().unwrap().x - 0.0).abs() < 0.01);
              assert!((resampled.last().unwrap().x - 1.0).abs() < 0.01);
          }
          
          #[test]
          fn test_smooth_stroke_reduces_noise() {
              // Verify smoothing reduces high-frequency variations
              let noisy_stroke = vec![
                  Point { x: 0.0, y: 0.0 },
                  Point { x: 0.1, y: 0.15 },
                  Point { x: 0.2, y: 0.1 },  // Noise spike
                  Point { x: 0.3, y: 0.25 },
                  Point { x: 0.4, y: 0.4 },
              ];
              
              let smoothed = smooth_stroke(&noisy_stroke, 3);
              
// Check that middle point's noise is reduced
              assert!(smoothed[2].y > noisy_stroke[2].y);
          }
      }
      
      #[cfg(test)]
      mod recognition_integration_tests {
          use super::super::*;
          
          #[test]
          fn test_recognize_simple_hiragana_a() {
              // Integration test: recognize あ (hiragana 'a')
              let strokes = load_sample_strokes("hiragana_a.json");
              
              let result = recognize_character(&strokes);
              
              assert!(result.is_ok());
              let candidates = result.unwrap();
              assert!(!candidates.is_empty());
              assert_eq!(candidates[0].character, 'あ');
              assert!(candidates[0].confidence > 0.7);
          }
          
          #[test]
          fn test_recognize_returns_multiple_candidates() {
              // Verify recognition returns ranked candidates
              let strokes = load_sample_strokes("ambiguous_stroke.json");
              
              let result = recognize_character(&strokes);
              
              assert!(result.is_ok());
              let candidates = result.unwrap();
              assert!(candidates.len() >= 3);
              // Verify descending confidence order
              assert!(candidates[0].confidence >= candidates[1].confidence);
          }
          
          #[test]
          fn test_recognition_performance_within_limit() {
              // Verify recognition completes within 200ms
              let strokes = load_sample_strokes("hiragana_ka.json");
              
              let start = std::time::Instant::now();
              let _result = recognize_character(&strokes);
              let duration = start.elapsed();
              
              assert!(duration.as_millis() < 200);
          }
          
          #[test]
          fn test_validate_correct_character_passes() {
              // Verify validation succeeds for correct character
              let candidates = vec![
                  RecognitionResult { character: 'あ', confidence: 0.85 },
                  RecognitionResult { character: 'ぁ', confidence: 0.10 },
              ];
              
              let is_valid = validate_recognition(&candidates, 'あ', 3, 0.7);
              
              assert!(is_valid);
          }
          
          #[test]
          fn test_validate_low_confidence_fails() {
              // Verify validation fails when confidence below threshold
              let candidates = vec![
                  RecognitionResult { character: 'あ', confidence: 0.65 },
              ];
              
              let is_valid = validate_recognition(&candidates, 'あ', 3, 0.7);
              
              assert!(!is_valid);
          }
          
          #[test]
          fn test_validate_character_not_in_top_n_fails() {
              // Verify validation fails when character not in top N
              let candidates = vec![
                  RecognitionResult { character: 'い', confidence: 0.80 },
                  RecognitionResult { character: 'う', confidence: 0.75 },
                  RecognitionResult { character: 'え', confidence: 0.70 },
                  RecognitionResult { character: 'あ', confidence: 0.60 },
              ];
              
              let is_valid = validate_recognition(&candidates, 'あ', 3, 0.6);
              
              assert!(!is_valid);
          }
      }
      
      #[cfg(test)]
      mod feedback_generation_tests {
          use super::super::*;
          
          #[test]
          fn test_feedback_for_wrong_stroke_count() {
              // Verify helpful feedback when stroke count is incorrect
              let expected_strokes = 3;
              let actual_strokes = 2;
              
              let feedback = generate_feedback(
                  &FeedbackContext {
                      expected_char: 'あ',
                      actual_strokes,
                      expected_strokes,
                      top_candidate: None,
                  }
              );
              
              assert!(feedback.contains("stroke count"));
              assert!(feedback.contains(&expected_strokes.to_string()));
          }
          
          #[test]
          fn test_feedback_for_near_miss() {
              // Verify feedback when similar character was recognized
              let feedback = generate_feedback(
                  &FeedbackContext {
                      expected_char: 'あ',
                      actual_strokes: 3,
                      expected_strokes: 3,
                      top_candidate: Some(RecognitionResult {
                          character: 'ぁ',
                          confidence: 0.85,
                      }),
                  }
              );
              
              assert!(feedback.contains("similar"));
              assert!(feedback.contains('ぁ'));
          }
          
          #[test]
          fn test_feedback_for_no_recognition() {
              // Verify feedback when no candidates found
              let feedback = generate_feedback(
                  &FeedbackContext {
                      expected_char: 'あ',
                      actual_strokes: 3,
                      expected_strokes: 3,
                      top_candidate: None,
                  }
              );
              
              assert!(feedback.contains("not recognized"));
          }
      }
      
      #[cfg(test)]
      mod property_based_tests {
          use super::super::*;
          use proptest::prelude::*;
          
          proptest! {
              #[test]
              fn prop_normalization_always_in_unit_range(
                  points in prop::collection::vec(
                      (0.0f64..1000.0, 0.0f64..1000.0),
                      1..100
                  )
              ) {
                  let stroke: Vec<Point> = points.iter()
                      .map(|(x, y)| Point { x: *x, y: *y })
                      .collect();
                  
                  let normalized = normalize_stroke(&stroke);
                  
                  prop_assert!(normalized.iter().all(|p| p.x >= 0.0 && p.x <= 1.0));
                  prop_assert!(normalized.iter().all(|p| p.y >= 0.0 && p.y <= 1.0));
              }
              
              #[test]
              fn prop_normalization_preserves_point_count(
                  points in prop::collection::vec(
                      (0.0f64..1000.0, 0.0f64..1000.0),
                      1..100
                  )
              ) {
                  let stroke: Vec<Point> = points.iter()
                      .map(|(x, y)| Point { x: *x, y: *y })
                      .collect();
                  
                  let normalized = normalize_stroke(&stroke);
                  
                  prop_assert_eq!(normalized.len(), stroke.len());
              }
              
              #[test]
              fn prop_resample_produces_exact_count(
                  points in prop::collection::vec(
                      (0.0f64..1.0, 0.0f64..1.0),
                      2..50
                  ),
                  target_count in 5usize..100
              ) {
                  let stroke: Vec<Point> = points.iter()
                      .map(|(x, y)| Point { x: *x, y: *y })
                      .collect();
                  
                  let resampled = resample_stroke(&stroke, target_count);
                  
                  prop_assert_eq!(resampled.len(), target_count);
              }
          }
      }
      
      #[cfg(test)]
      mod false_positive_tests {
          use super::super::*;
          
          #[test]
          fn test_false_positive_rate_below_threshold() {
              // Statistical test: verify false positive rate < 5%
              let test_cases = load_test_dataset("false_positive_samples.json");
              let mut false_positives = 0;
              let total_cases = test_cases.len();
              
              for case in test_cases {
                  let result = recognize_character(&case.strokes);
                  if let Ok(candidates) = result {
                      if validate_recognition(&candidates, case.wrong_char, 3, 0.7) {
                          false_positives += 1;
                      }
                  }
              }
              
              let fp_rate = (false_positives as f64) / (total_cases as f64);
              assert!(fp_rate < 0.05, "False positive rate: {:.2}%", fp_rate * 100.0);
          }
      }
      
      // Test helper functions
      fn load_sample_strokes(filename: &str) -> Vec<Vec<Point>> {
          // Load stroke data from JSON test fixture
          let path = format!("tests/fixtures/{}", filename);
          let data = std::fs::read_to_string(&path)
              .expect(&format!("Failed to load test fixture: {}", filename));
          serde_json::from_str(&data).expect("Invalid JSON in test fixture")
      }
      
      fn load_test_dataset(filename: &str) -> Vec<TestCase> {
          let path = format!("tests/fixtures/{}", filename);
          let data = std::fs::read_to_string(&path)
              .expect(&format!("Failed to load test dataset: {}", filename));
          serde_json::from_str(&data).expect("Invalid JSON in test dataset")
      }

  coverage:
    - "Stroke normalization to 0-1 unit square range"
    - "Normalization preserves relative positions between points"
    - "Normalization preserves stroke order and direction"
    - "Normalization handles edge case of single-point stroke"
    - "Stroke resampling to fixed point count"
    - "Resampling preserves start and end points"
    - "Stroke smoothing reduces high-frequency noise"
    - "Recognition returns correct character for known samples"
    - "Recognition returns multiple ranked candidates"
    - "Recognition performance meets <200ms latency requirement"
    - "Validation accepts correct character with sufficient confidence"
    - "Validation rejects character with confidence below threshold"
    - "Validation rejects character not in top-N results"
    - "Feedback generation for incorrect stroke count"
    - "Feedback generation for near-miss similar characters"
    - "Feedback generation when no candidates recognized"
    - "Property: normalization always produces values in [0,1] range"
    - "Property: normalization preserves point count for any input"
    - "Property: resampling produces exact target count for any input"
    - "False positive rate validation below 5% threshold"

dependencies:
  depends_on:
    - task_id: 5
      reason: "Requires stroke data format and structure from HandwritingCanvas component"

  depended_upon_by:
    - task_id: 8
      reason: "PracticeSession needs recognition validation to assess user attempts and control practice flow"

  external:
    - name: "hanzi_lookup"
      type: "crate"
      status: "to be imported"
    - name: "serde"
      type: "crate"
      status: "already exists"
    - name: "serde_json"
      type: "crate"
      status: "already exists"
    - name: "proptest"
      type: "crate"
      status: "to be imported"
---
task:
  id: 10
  name: "Statistics and Progress Visualization"

context:
  description: |
    This task implements comprehensive statistics tracking and visualization to provide
    users with meaningful insights into their learning progress. The Statistics module
    aggregates review data into metrics including accuracy rates, study streaks, cards
    mastered, and time-series data for daily/weekly patterns. These metrics are displayed
    in an engaging statistics screen that motivates continued practice through visual
    progress indicators, streak tracking, and achievement unlocks.
    
    The implementation uses efficient data structures (BTreeMap for time-series data
    enabling fast range queries, HashSet for study day tracking) and maintains statistics
    incrementally during learning sessions. The achievement system provides gamification
    elements that encourage consistent practice and milestone attainment. Time-series
    data enables future analytics and personalized learning recommendations.
    
    This feature directly addresses user motivation by making learning progress visible
    and celebrating accomplishments. Research shows that progress visualization and
    streak mechanics significantly improve learning habit formation and retention.

  key_points:
    - "Statistics are updated incrementally during learning sessions for performance"
    - "BTreeMap provides O(log n) date range queries for time-series statistics"
    - "Streak calculation encourages daily practice habit formation"
    - "Achievement system unlocks at meaningful milestones to celebrate progress"
    - "Timezone-aware day boundaries ensure accurate streak tracking"
    - "Card maturity stages (new/learning/mature) reflect SM-2 spaced repetition intervals"
    - "All statistics calculations are deterministic and testable"
    - "UI components render progress visualizations without business logic"

files:
  - path: "src/statistics.rs"
    description: "Core Statistics struct with metrics aggregation, day/week stats, and streak calculation logic"
  
  - path: "src/statistics/achievement.rs"
    description: "Achievement system with achievement types, unlock conditions, and milestone tracking"
  
  - path: "src/statistics/time_series.rs"
    description: "Time-series data structures (DayStats, WeekStats) using BTreeMap for efficient date range queries"
  
  - path: "src/ui/screens/statistics_screen.rs"
    description: "Statistics screen UI implementation rendering progress visualizations, metrics, and achievements"
  
  - path: "src/ui/components/progress_chart.rs"
    description: "Reusable chart components for visualizing accuracy trends and daily review history"
  
  - path: "src/ui/components/streak_display.rs"
    description: "Streak indicator component with flame emoji and current/longest streak display"
  
  - path: "src/ui/components/achievement_card.rs"
    description: "Achievement card component for displaying unlocked achievements with celebratory animations"
  
  - path: "src/lib.rs"
    description: "Updated to declare statistics module and export Statistics struct"

functions:
  - file: "src/statistics.rs"
    items:
      - type: "module_declaration"
        name: "statistics"
        description: "Module for statistics tracking, aggregation, and achievement system"
      
      - type: "struct"
        name: "Statistics"
        description: "Aggregates review data into meaningful metrics including accuracy, streaks, and time-series data"
        invariants: "total_reviews >= correct_reviews, current_streak >= 0, longest_streak >= current_streak"
      
      - type: "struct"
        name: "DayStats"
        description: "Time-series data structure for daily review aggregations"
        invariants: "reviews_count >= 0, correct_count >= 0, correct_count <= reviews_count"
      
      - type: "struct"
        name: "WeekStats"
        description: "Time-series data structure for weekly review aggregations"
        invariants: "sum of daily stats matches weekly totals"
      
      - type: "enum"
        name: "CardStatus"
        description: "Represents maturity stages of cards: New (never reviewed), Learning (interval < 21 days), Mature (21+ days)"
      
      - type: "struct"
        name: "CardStatusCounts"
        description: "Tracks count of cards by their maturity status"
        invariants: "all counts >= 0"
      
      - type: "method"
        name: "Statistics::new"
        description: "Creates a new Statistics instance with zero values"
        postconditions: "returns Statistics with all metrics initialized to zero/empty"
      
      - type: "method"
        name: "Statistics::record_review"
        description: "Updates statistics after a single card review"
        preconditions: "Statistics instance exists"
        postconditions: "total_reviews incremented, correct_reviews incremented if correct, daily stats updated, study_days updated"
      
      - type: "method"
        name: "Statistics::calculate_accuracy"
        description: "Computes accuracy percentage as correct/total * 100"
        preconditions: "total_reviews >= 0"
        postconditions: "returns f64 between 0.0 and 100.0, or 0.0 if no reviews"
        invariants: "result is between 0.0 and 100.0 inclusive"
      
      - type: "method"
        name: "Statistics::update_streak"
        description: "Updates current and longest streak based on study dates"
        preconditions: "study_days contains valid dates"
        postconditions: "current_streak reflects consecutive days from today backwards, longest_streak updated if current exceeds it"
        invariants: "longest_streak >= current_streak"
      
      - type: "method"
        name: "Statistics::get_day_stats"
        description: "Retrieves statistics for a specific date"
        preconditions: "date is valid"
        postconditions: "returns Option<DayStats> for the specified date"
      
      - type: "method"
        name: "Statistics::get_week_stats"
        description: "Aggregates statistics for a week starting from a given date"
        preconditions: "start_date is valid"
        postconditions: "returns WeekStats aggregating 7 days of data from start_date"
      
      - type: "method"
        name: "Statistics::get_date_range_stats"
        description: "Retrieves statistics for a date range using BTreeMap range queries"
        preconditions: "start_date <= end_date"
        postconditions: "returns iterator over DayStats in the specified range"
      
      - type: "method"
        name: "Statistics::update_card_status_counts"
        description: "Updates the count of cards by their maturity status"
        preconditions: "card data with intervals is available"
        postconditions: "card_status_counts reflects current card distribution by status"
      
      - type: "function"
        name: "calculate_streak_from_dates"
        description: "Helper function to calculate consecutive day streak from a set of study dates"
        preconditions: "study_dates is a valid HashSet of dates"
        postconditions: "returns (current_streak, longest_streak) tuple"
        invariants: "longest_streak >= current_streak, both >= 0"
      
      - type: "function"
        name: "get_today_date"
        description: "Gets today's date normalized to midnight in local timezone"
        postconditions: "returns NaiveDate representing today at 00:00:00 local time"

  - file: "src/statistics/achievement.rs"
    items:
      - type: "module_declaration"
        name: "achievements"
        description: "Module for achievement tracking and milestone-based unlocks"
      
      - type: "enum"
        name: "Achievement"
        description: "Represents different achievement types with their unlock criteria"
      
      - type: "enum_variant"
        name: "Achievement::FirstReview"
        description: "Unlocked after completing first review"
      
      - type: "enum_variant"
        name: "Achievement::Streak7"
        description: "Unlocked after 7-day study streak"
      
      - type: "enum_variant"
        name: "Achievement::Streak30"
        description: "Unlocked after 30-day study streak"
      
      - type: "enum_variant"
        name: "Achievement::Streak100"
        description: "Unlocked after 100-day study streak"
      
      - type: "enum_variant"
        name: "Achievement::Cards100"
        description: "Unlocked after reviewing 100 cards"
      
      - type: "enum_variant"
        name: "Achievement::Cards1000"
        description: "Unlocked after reviewing 1000 cards"
      
      - type: "enum_variant"
        name: "Achievement::Accuracy90"
        description: "Unlocked after achieving 90% accuracy with 100+ reviews"
      
      - type: "enum_variant"
        name: "Achievement::MasteredDeck"
        description: "Unlocked when all cards in a deck reach mature status"
      
      - type: "struct"
        name: "AchievementTracker"
        description: "Tracks which achievements have been unlocked and when"
        invariants: "unlocked achievements remain unlocked"
      
      - type: "method"
        name: "AchievementTracker::new"
        description: "Creates a new AchievementTracker with no unlocked achievements"
        postconditions: "returns empty tracker"
      
      - type: "method"
        name: "AchievementTracker::check_and_unlock"
        description: "Checks statistics against achievement criteria and unlocks new achievements"
        preconditions: "statistics contains valid data"
        postconditions: "returns Vec of newly unlocked achievements, updates internal state"
      
      - type: "method"
        name: "AchievementTracker::is_unlocked"
        description: "Checks if a specific achievement has been unlocked"
        postconditions: "returns bool indicating unlock status"
      
      - type: "method"
        name: "Achievement::criteria_met"
        description: "Checks if the statistics meet this achievement's unlock criteria"
        preconditions: "statistics is valid"
        postconditions: "returns bool indicating if criteria are satisfied"
      
      - type: "method"
        name: "Achievement::title"
        description: "Returns the display title for the achievement"
        postconditions: "returns &str with achievement title"
      
      - type: "method"
        name: "Achievement::description"
        description: "Returns the description of what unlocks the achievement"
        postconditions: "returns &str with achievement description"
      
      - type: "method"
        name: "Achievement::icon"
        description: "Returns the emoji/icon representation of the achievement"
        postconditions: "returns &str with emoji icon"

  - file: "src/ui/screens/statistics_screen.rs"
    items:
      - type: "module_declaration"
        name: "statistics_screen"
        description: "UI module for statistics visualization screen"
      
      - type: "struct"
        name: "StatisticsScreen"
        description: "Screen component that displays statistics and progress visualizations"
      
      - type: "enum"
        name: "StatisticsMessage"
        description: "Messages for statistics screen interactions"
      
      - type: "enum_variant"
        name: "StatisticsMessage::BackPressed"
        description: "User pressed back button to return to previous screen"
      
      - type: "enum_variant"
        name: "StatisticsMessage::TimeRangeChanged"
        description: "User changed the time range filter for statistics display"
      
      - type: "method"
        name: "StatisticsScreen::new"
        description: "Creates a new statistics screen"
        postconditions: "returns initialized StatisticsScreen"
      
      - type: "method"
        name: "StatisticsScreen::view"
        description: "Renders the statistics screen UI with all metrics and visualizations"
        preconditions: "statistics data is available"
        postconditions: "returns iced Element displaying statistics"
      
      - type: "function"
        name: "render_accuracy_card"
        description: "Renders a card displaying accuracy percentage with visual styling"
        postconditions: "returns Element displaying accuracy metric"
      
      - type: "function"
        name: "render_streak_card"
        description: "Renders a card displaying current and longest streak with flame emoji"
        postconditions: "returns Element displaying streak metrics"
      
      - type: "function"
        name: "render_cards_status_card"
        description: "Renders a card showing distribution of cards by status (new/learning/mature)"
        postconditions: "returns Element displaying card status counts"
      
      - type: "function"
        name: "render_daily_history"
        description: "Renders daily review history as a list or simple chart"
        postconditions: "returns Element displaying recent daily review data"
      
      - type: "function"
        name: "render_achievements"
        description: "Renders unlocked achievements with icons and titles"
        postconditions: "returns Element displaying achievement grid"
      
      - type: "function"
        name: "render_achievement_unlock_animation"
        description: "Renders celebratory animation when new achievement is unlocked"
        postconditions: "returns Element with animation overlay"
      
      - type: "function"
        name: "format_streak_text"
        description: "Formats streak number with appropriate emoji and text"
        postconditions: "returns String with formatted streak display"

  - file: "src/learning_session.rs"
    items:
      - type: "method"
        name: "LearningSession::update_statistics"
        description: "Updates statistics after each card review within the learning session"
        preconditions: "review_result is valid, statistics exists"
        postconditions: "statistics is updated with new review data, streak is updated if new day"
      
      - type: "method"
        name: "LearningSession::check_achievements"
        description: "Checks for newly unlocked achievements after statistics update"
        preconditions: "statistics and achievement_tracker exist"
        postconditions: "returns Vec of newly unlocked achievements"

  - file: "src/types.rs"
    items:
      - type: "struct"
        name: "ReviewRecord"
        description: "Represents a single review event with timestamp, card_id, and result"
        invariants: "timestamp is valid, quality is 0-5"
      
      - type: "method"
        name: "ReviewRecord::new"
        description: "Creates a new review record"
        preconditions: "card_id is valid, quality is 0-5"
        postconditions: "returns ReviewRecord with current timestamp"

formal_verification:
  needed: false
  level: "None"
  explanation: |
    Formal verification is not required for this task because:
    
    1. **Deterministic Mathematical Operations**: The statistics calculations (accuracy 
       rates, streak counting, aggregations) are straightforward arithmetic operations 
       that can be thoroughly validated through comprehensive unit tests and property-based 
       testing. The correctness of these calculations doesn't involve complex state 
       transitions or concurrent operations that would benefit from formal methods.
    
    2. **No Safety-Critical Requirements**: This is a visualization and metrics feature 
       for user motivation and progress tracking. Calculation errors would not result in 
       data corruption, financial loss, or safety issues - at worst, they would display 
       incorrect statistics that could be corrected through bug fixes.
    
    3. **Testability Through Examples**: All critical behaviors (accuracy calculation, 
       streak increments, achievement unlocks) can be effectively verified through 
       property-based testing using proptest. Properties like "accuracy equals 
       correct_count/total_count" and "streak increments for consecutive days" are 
       easily expressed as test properties.
    
    4. **Low Complexity Risk**: As noted in the risk assessment, this task has low 
       complexity, integration, and testing risk. The main concern (timezone handling) 
       is a well-understood problem with established testing patterns.
    
    5. **UI/Display Component**: Much of this task involves rendering statistics in 
       the UI, which is inherently difficult to formally verify and better suited to 
       visual testing and user validation.
    
    Property-based testing will provide strong guarantees about statistical invariants 
    (e.g., accuracy is always between 0 and 1, streaks are non-negative, time-series 
    data maintains chronological order) without the overhead of formal verification tools.

tests:
  strategy:
    approach: "mixed (unit tests + property-based testing)"
    rationale:
      - "Statistics calculations are deterministic and can be thoroughly tested with unit tests"
      - "Property-based testing ensures correctness of aggregations across wide input ranges"
      - "Streak logic has edge cases (timezone boundaries, consecutive days) requiring explicit test cases"
      - "Achievement unlocking has clear threshold conditions testable via unit tests"
      - "Time-series aggregation correctness can be verified with property tests"
      - "No UI rendering tests needed - focus on data layer and calculation logic"

  implementation:
    file: "src/statistics.rs"
    location: "in existing test module"
    code: |
      #[cfg(test)]
      mod tests {
          use super::*;
          use chrono::{NaiveDate, Utc};
          use std::collections::{BTreeMap, HashSet};

          // Helper function to create a test Statistics instance
          fn create_test_stats() -> Statistics {
              Statistics {
                  total_reviews: 0,
                  correct_reviews: 0,
                  current_streak: 0,
                  longest_streak: 0,
                  cards_mastered: 0,
                  total_study_time_seconds: 0,
                  study_days: HashSet::new(),
                  daily_stats: BTreeMap::new(),
                  achievements_unlocked: HashSet::new(),
              }
          }

          #[test]
          fn test_accuracy_calculation_zero_reviews() {
              let stats = create_test_stats();
              assert_eq!(stats.accuracy_percentage(), 0.0);
          }

          #[test]
          fn test_accuracy_calculation_perfect_score() {
              let mut stats = create_test_stats();
              stats.total_reviews = 10;
              stats.correct_reviews = 10;
              assert_eq!(stats.accuracy_percentage(), 100.0);
          }

          #[test]
          fn test_accuracy_calculation_partial_score() {
              let mut stats = create_test_stats();
              stats.total_reviews = 20;
              stats.correct_reviews = 15;
              assert_eq!(stats.accuracy_percentage(), 75.0);
          }

          #[test]
          fn test_streak_increments_on_consecutive_days() {
              let mut stats = create_test_stats();
              let day1 = NaiveDate::from_ymd_opt(2024, 1, 1).unwrap();
              let day2 = NaiveDate::from_ymd_opt(2024, 1, 2).unwrap();
              let day3 = NaiveDate::from_ymd_opt(2024, 1, 3).unwrap();

              stats.record_study_day(day1);
              assert_eq!(stats.current_streak, 1);
              assert_eq!(stats.longest_streak, 1);

              stats.record_study_day(day2);
              assert_eq!(stats.current_streak, 2);
              assert_eq!(stats.longest_streak, 2);

              stats.record_study_day(day3);
              assert_eq!(stats.current_streak, 3);
              assert_eq!(stats.longest_streak, 3);
          }

          #[test]
          fn test_streak_resets_when_day_skipped() {
              let mut stats = create_test_stats();
              let day1 = NaiveDate::from_ymd_opt(2024, 1, 1).unwrap();
              let day2 = NaiveDate::from_ymd_opt(2024, 1, 2).unwrap();
              let day4 = NaiveDate::from_ymd_opt(2024, 1, 4).unwrap();

              stats.record_study_day(day1);
              stats.record_study_day(day2);
              assert_eq!(stats.current_streak, 2);
              assert_eq!(stats.longest_streak, 2);

              stats.record_study_day(day4);
              assert_eq!(stats.current_streak, 1);
              assert_eq!(stats.longest_streak, 2);
          }

          #[test]
          fn test_streak_same_day_does_not_increment() {
              let mut stats = create_test_stats();
              let day1 = NaiveDate::from_ymd_opt(2024, 1, 1).unwrap();

              stats.record_study_day(day1);
              assert_eq!(stats.current_streak, 1);

              stats.record_study_day(day1);
              assert_eq!(stats.current_streak, 1);
          }

          #[test]
          fn test_daily_stats_aggregation() {
              let mut stats = create_test_stats();
              let date = NaiveDate::from_ymd_opt(2024, 1, 1).unwrap();

              stats.record_review(date, true, 10);
              stats.record_review(date, false, 15);
              stats.record_review(date, true, 20);

              let day_stats = stats.daily_stats.get(&date).unwrap();
              assert_eq!(day_stats.total_reviews, 3);
              assert_eq!(day_stats.correct_reviews, 2);
              assert_eq!(day_stats.study_time_seconds, 45);
              assert_eq!(day_stats.accuracy_percentage(), 66.66666666666666);
          }

          #[test]
          fn test_multiple_days_stats_aggregation() {
              let mut stats = create_test_stats();
              let day1 = NaiveDate::from_ymd_opt(2024, 1, 1).unwrap();
              let day2 = NaiveDate::from_ymd_opt(2024, 1, 2).unwrap();

              stats.record_review(day1, true, 10);
              stats.record_review(day1, true, 10);
              stats.record_review(day2, false, 20);

              assert_eq!(stats.total_reviews, 3);
              assert_eq!(stats.correct_reviews, 2);
              assert_eq!(stats.total_study_time_seconds, 40);
              assert_eq!(stats.daily_stats.len(), 2);
          }

          #[test]
          fn test_achievement_unlock_first_review() {
              let mut stats = create_test_stats();
              let date = NaiveDate::from_ymd_opt(2024, 1, 1).unwrap();

              stats.record_review(date, true, 10);
              stats.check_and_unlock_achievements();

              assert!(stats.achievements_unlocked.contains(&Achievement::FirstReview));
          }

          #[test]
          fn test_achievement_unlock_streak_milestones() {
              let mut stats = create_test_stats();
              
              for i in 0..7 {
                  let date = NaiveDate::from_ymd_opt(2024, 1, 1 + i).unwrap();
                  stats.record_study_day(date);
              }
              stats.check_and_unlock_achievements();

              assert!(stats.achievements_unlocked.contains(&Achievement::Streak7Days));
              assert!(!stats.achievements_unlocked.contains(&Achievement::Streak30Days));

              for i in 7..30 {
                  let date = NaiveDate::from_ymd_opt(2024, 1, 1 + i).unwrap();
                  stats.record_study_day(date);
              }
              stats.check_and_unlock_achievements();

              assert!(stats.achievements_unlocked.contains(&Achievement::Streak30Days));
          }

          #[test]
          fn test_achievement_unlock_reviews_milestones() {
              let mut stats = create_test_stats();
              let date = NaiveDate::from_ymd_opt(2024, 1, 1).unwrap();

              for _ in 0..100 {
                  stats.record_review(date, true, 5);
              }
              stats.check_and_unlock_achievements();

              assert!(stats.achievements_unlocked.contains(&Achievement::Reviews100));
              assert!(!stats.achievements_unlocked.contains(&Achievement::Reviews1000));
          }

          #[test]
          fn test_cards_mastered_count() {
              let mut stats = create_test_stats();
              
              stats.cards_mastered = 0;
              stats.increment_cards_mastered();
              assert_eq!(stats.cards_mastered, 1);

              stats.increment_cards_mastered();
              assert_eq!(stats.cards_mastered, 2);
          }

          #[test]
          fn test_btreemap_date_ordering() {
              let mut stats = create_test_stats();
              let day3 = NaiveDate::from_ymd_opt(2024, 1, 3).unwrap();
              let day1 = NaiveDate::from_ymd_opt(2024, 1, 1).unwrap();
              let day2 = NaiveDate::from_ymd_opt(2024, 1, 2).unwrap();

              stats.record_review(day3, true, 10);
              stats.record_review(day1, true, 10);
              stats.record_review(day2, true, 10);

              let dates: Vec<_> = stats.daily_stats.keys().collect();
              assert_eq!(dates, vec![&day1, &day2, &day3]);
          }

          #[test]
          fn test_get_date_range_stats() {
              let mut stats = create_test_stats();
              
              for i in 1..=10 {
                  let date = NaiveDate::from_ymd_opt(2024, 1, i).unwrap();
                  stats.record_review(date, true, 10);
              }

              let start = NaiveDate::from_ymd_opt(2024, 1, 3).unwrap();
              let end = NaiveDate::from_ymd_opt(2024, 1, 7).unwrap();
              let range_stats = stats.get_stats_in_range(start, end);

              assert_eq!(range_stats.len(), 5);
              assert!(range_stats.contains_key(&start));
              assert!(range_stats.contains_key(&end));
          }

          #[test]
          fn test_weekly_aggregation() {
              let mut stats = create_test_stats();
              
              for i in 1..=14 {
                  let date = NaiveDate::from_ymd_opt(2024, 1, i).unwrap();
                  stats.record_review(date, i % 2 == 0, 10);
              }

              let week_stats = stats.aggregate_weekly_stats();
              assert_eq!(week_stats.len(), 2);
              
              let first_week = week_stats.first().unwrap();
              assert_eq!(first_week.total_reviews, 7);
          }
      }

      #[cfg(test)]
      mod property_tests {
          use super::*;
          use proptest::prelude::*;
          use chrono::NaiveDate;

          proptest! {
              #[test]
              fn prop_accuracy_always_between_0_and_100(
                  total in 1u32..10000,
                  correct in 0u32..10000
              ) {
                  let mut stats = Statistics {
                      total_reviews: total,
                      correct_reviews: correct.min(total),
                      current_streak: 0,
                      longest_streak: 0,
                      cards_mastered: 0,
                      total_study_time_seconds: 0,
                      study_days: HashSet::new(),
                      daily_stats: BTreeMap::new(),
                      achievements_unlocked: HashSet::new(),
                  };

                  let accuracy = stats.accuracy_percentage();
                  prop_assert!(accuracy >= 0.0 && accuracy <= 100.0);
              }

              #[test]
              fn prop_total_reviews_equals_sum_of_daily_reviews(
                  reviews in prop::collection::vec((0..365i64, 1..100u32), 1..50)
              ) {
                  let mut stats = create_test_stats();
                  
                  for (day_offset, count) in reviews.iter() {
                      let date = NaiveDate::from_ymd_opt(2024, 1, 1)
                          .unwrap()
                          .checked_add_signed(chrono::Duration::days(*day_offset))
                          .unwrap();
                      
                      for _ in 0..*count {
                          stats.record_review(date, true, 5);
                      }
                  }

                  let sum_daily: u32 = stats.daily_stats.values()
                      .map(|ds| ds.total_reviews)
                      .sum();
                  
                  prop_assert_eq!(stats.total_reviews, sum_daily);
              }

              #[test]
              fn prop_current_streak_never_exceeds_longest_streak(
                  days in prop::collection::vec(0..365i64, 1..100)
              ) {
                  let mut stats = create_test_stats();
                  
                  for day_offset in days {
                      let date = NaiveDate::from_ymd_opt(2024, 1, 1)
                          .unwrap()
                          .checked_add_signed(chrono::Duration::days(day_offset))
                          .unwrap();
                      stats.record_study_day(date);
                      
                      prop_assert!(stats.current_streak <= stats.longest_streak);
                  }
              }

              #[test]
              fn prop_study_time_accumulates_correctly(
                  times in prop::collection::vec(1u32..1000, 1..100)
              ) {
                  let mut stats = create_test_stats();
                  let date = NaiveDate::from_ymd_opt(2024, 1, 1).unwrap();
                  
                  let expected_sum: u32 = times.iter().sum();
                  
                  for time in times {
                      stats.record_review(date, true, time);
                  }

                  prop_assert_eq!(stats.total_study_time_seconds, expected_sum);
              }

              #[test]
              fn prop_btreemap_maintains_sorted_order(
                  days in prop::collection::vec(0..365i64, 1..50)
              ) {
                  let mut stats = create_test_stats();
                  
                  for day_offset in days {
                      let date = NaiveDate::from_ymd_opt(2024, 1, 1)
                          .unwrap()
                          .checked_add_signed(chrono::Duration::days(day_offset))
                          .unwrap();
                      stats.record_review(date, true, 5);
                  }

                  let dates: Vec<_> = stats.daily_stats.keys().collect();
                  let mut sorted_dates = dates.clone();
                  sorted_dates.sort();
                  
                  prop_assert_eq!(dates, sorted_dates);
              }
          }

          fn create_test_stats() -> Statistics {
              Statistics {
                  total_reviews: 0,
                  correct_reviews: 0,
                  current_streak: 0,
                  longest_streak: 0,
                  cards_mastered: 0,
                  total_study_time_seconds: 0,
                  study_days: HashSet::new(),
                  daily_stats: BTreeMap::new(),
                  achievements_unlocked: HashSet::new(),
              }
          }
      }

  coverage:
    - "Accuracy calculation returns 0.0 for zero reviews"
    - "Accuracy calculation returns 100.0 for perfect score"
    - "Accuracy calculation returns correct percentage for partial scores"
    - "Streak increments correctly on consecutive days"
    - "Streak resets to 1 when a day is skipped"
    - "Longest streak tracks the maximum streak achieved"
    - "Recording same day multiple times does not increment streak"
    - "Daily stats aggregate reviews, correct answers, and study time correctly"
    - "Multiple days maintain separate statistics"
    - "Total statistics reflect sum of all daily statistics"
    - "Achievement 'FirstReview' unlocks after first review"
    - "Achievement 'Streak7Days' unlocks after 7 consecutive days"
    - "Achievement 'Streak30Days' unlocks after 30 consecutive days"
    - "Achievement 'Reviews100' unlocks after 100 reviews"
    - "Achievement 'Reviews1000' unlocks after 1000 reviews"
    - "Cards mastered count increments correctly"
    - "BTreeMap maintains chronological ordering of dates"
    - "Date range queries return correct subset of statistics"
    - "Weekly aggregation groups daily stats into weeks correctly"
    - "Property: Accuracy percentage always between 0 and 100"
    - "Property: Total reviews equals sum of daily reviews"
    - "Property: Current streak never exceeds longest streak"
    - "Property: Study time accumulates correctly across reviews"
    - "Property: BTreeMap maintains sorted order regardless of insertion order"

dependencies:
  depends_on:
    - task_id: 6
      reason: "Needs navigation framework for statistics screen integration and routing"

  depended_upon_by:
    - task_id: 11
      reason: "Database persistence layer needs Statistics struct schema for storage"
    - task_id: 8
      reason: "LearningSession updates statistics after each review"

  external:
    - name: "chrono::NaiveDate"
      type: "struct"
      status: "already exists"
    - name: "std::collections::BTreeMap"
      type: "struct"
      status: "already exists"
    - name: "std::collections::HashSet"
      type: "struct"
      status: "already exists"
    - name: "iced::Element"
      type: "struct"
      status: "already exists"
    - name: "proptest"
      type: "crate"
      status: "to be imported"
---
task:
  id: 11
  name: "Local Persistence and Database Layer"

context:
  description: |
    This task implements a robust local persistence layer using the redb embedded database
    to provide ACID-compliant storage for all application data including flashcards, spaced
    repetition state, review history, user settings, and statistics. The persistence layer
    is critical for maintaining user trust and motivation by ensuring data integrity across
    application restarts, crashes, and system failures.
    
    The implementation uses redb (a pure Rust embedded database) to avoid external runtime
    dependencies while providing transactional safety. Data is serialized using bincode for
    performance and JSON for human-readable backups. The database file location is determined
    platform-appropriately using the directories crate (XDG on Linux, AppData on Windows,
    Application Support on macOS).
    
    Key architectural decisions include batch operations to minimize I/O overhead during
    session saves, read-heavy optimization leveraging redb's cheap read transactions, and
    export/import functionality for data portability and disaster recovery. The AppDatabase
    wrapper provides a type-safe API that abstracts redb's low-level interface and handles
    all serialization concerns.

  key_points:
    - "redb provides ACID transactions without external database dependencies"
    - "Batch operations critical for performance during session saves (target <100ms for 50 cards)"
    - "Platform-appropriate database paths ensure proper data directory conventions"
    - "Dual export formats: bincode for fast backups, JSON for human readability and portability"
    - "Read transactions are cheap and non-blocking; write transactions serialize and must be batched"
    - "Graceful handling of database corruption through backup/restore mechanisms"
    - "Type-safe wrapper API prevents direct redb misuse and encapsulates serialization"

files:
  - path: "src/db/mod.rs"
    description: "Main database module declaration and public API exports"
  
  - path: "src/db/schema.rs"
    description: "redb table definitions for cards, reviews, settings, and statistics"
  
  - path: "src/db/app_database.rs"
    description: "AppDatabase wrapper struct providing type-safe operations around redb"
  
  - path: "src/db/operations.rs"
    description: "CRUD operations for cards, reviews, settings, and statistics"
  
  - path: "src/db/backup.rs"
    description: "Export and import functionality for database backup and restore"
  
  - path: "src/db/batch.rs"
    description: "Batch operations for efficient multi-record transactions"
  
  - path: "Cargo.toml"
    description: "Updated to include redb, bincode, directories, and serde dependencies"

functions:
  - file: "src/persistence/mod.rs"
    items:
      - type: "module_declaration"
        name: "database"
        description: "Core database wrapper and operations module"
      - type: "module_declaration"
        name: "tables"
        description: "Table definitions for redb schema"
      - type: "module_declaration"
        name: "backup"
        description: "Backup and restore functionality"
      - type: "function"
        name: "get_database_path"
        description: "Returns platform-appropriate path for database file using directories crate"
        postconditions: "Returns valid PathBuf to application data directory"

  - file: "src/persistence/database.rs"
    items:
      - type: "struct"
        name: "AppDatabase"
        description: "Wrapper around redb::Database providing type-safe operations"
        invariants: "Database file remains valid and accessible throughout lifetime"
      - type: "method"
        name: "AppDatabase::new"
        description: "Creates or opens database at default platform path"
        postconditions: "Database is initialized with all required tables"
      - type: "method"
        name: "AppDatabase::open"
        description: "Opens existing database or creates new one at specified path"
        preconditions: "Path must be valid and writable"
        postconditions: "Database is ready for transactions"
      - type: "method"
        name: "AppDatabase::save_card"
        description: "Saves single card to database"
        preconditions: "Card has valid ID"
        postconditions: "Card persisted in cards table"
      - type: "method"
        name: "AppDatabase::save_cards_batch"
        description: "Saves multiple cards in single transaction"
        preconditions: "All cards have valid IDs"
        postconditions: "All cards persisted atomically or none persisted"
      - type: "method"
        name: "AppDatabase::load_card"
        description: "Loads card by ID"
        preconditions: "Card ID exists in database"
        postconditions: "Returns deserialized Card or None"
      - type: "method"
        name: "AppDatabase::load_all_cards"
        description: "Loads all cards from database"
        postconditions: "Returns Vec of all persisted cards"
      - type: "method"
        name: "AppDatabase::delete_card"
        description: "Removes card from database"
        preconditions: "Card ID exists"
        postconditions: "Card no longer in database"
      - type: "method"
        name: "AppDatabase::save_review"
        description: "Saves review history entry"
        preconditions: "Review has valid card_id and timestamp"
        postconditions: "Review persisted in reviews table"
      - type: "method"
        name: "AppDatabase::load_reviews_for_card"
        description: "Loads all review history for specific card"
        postconditions: "Returns chronologically ordered Vec of reviews"
      - type: "method"
        name: "AppDatabase::load_all_reviews"
        description: "Loads entire review history"
        postconditions: "Returns Vec of all review entries"
      - type: "method"
        name: "AppDatabase::save_settings"
        description: "Persists application settings"
        postconditions: "Settings stored in settings table with 'default' key"
      - type: "method"
        name: "AppDatabase::load_settings"
        description: "Loads application settings"
        postconditions: "Returns Settings or default Settings if none exist"
      - type: "method"
        name: "AppDatabase::save_statistics"
        description: "Saves statistics snapshot"
        preconditions: "Statistics timestamp is valid"
        postconditions: "Statistics persisted in statistics table"
      - type: "method"
        name: "AppDatabase::load_statistics"
        description: "Loads latest statistics snapshot"
        postconditions: "Returns Statistics or default Statistics if none exist"
      - type: "method"
        name: "AppDatabase::compact"
        description: "Performs database compaction to reclaim space"
        postconditions: "Database file size optimized"

  - file: "src/persistence/tables.rs"
    items:
      - type: "constant"
        name: "CARDS_TABLE"
        description: "TableDefinition for cards: card_id (u64) -> bincode serialized Card"
      - type: "constant"
        name: "REVIEWS_TABLE"
        description: "TableDefinition for reviews: composite key (card_id, timestamp) -> bincode serialized Review"
      - type: "constant"
        name: "SETTINGS_TABLE"
        description: "TableDefinition for settings: key (str) -> bincode serialized Settings"
      - type: "constant"
        name: "STATISTICS_TABLE"
        description: "TableDefinition for statistics: timestamp (u64) -> bincode serialized Statistics"
      - type: "struct"
        name: "SerializableCard"
        description: "Serialization wrapper for Card with Serialize/Deserialize"
      - type: "struct"
        name: "SerializableReview"
        description: "Serialization wrapper for Review with Serialize/Deserialize"
      - type: "struct"
        name: "SerializableSettings"
        description: "Serialization wrapper for Settings with Serialize/Deserialize"
      - type: "struct"
        name: "SerializableStatistics"
        description: "Serialization wrapper for Statistics with Serialize/Deserialize"

  - file: "src/persistence/backup.rs"
    items:
      - type: "struct"
        name: "DatabaseBackup"
        description: "Container for all database data in portable format"
      - type: "struct"
        name: "BackupMetadata"
        description: "Metadata about backup: version, timestamp, card count, etc."
      - type: "function"
        name: "export_database"
        description: "Exports entire database to JSON file"
        preconditions: "Database is accessible, export path is writable"
        postconditions: "JSON file contains all database data with metadata"
      - type: "function"
        name: "export_database_bincode"
        description: "Exports database to compressed bincode format"
        preconditions: "Database is accessible, export path is writable"
        postconditions: "Bincode file contains all database data, potentially gzipped"
      - type: "function"
        name: "import_database"
        description: "Imports database from JSON backup file"
        preconditions: "Backup file exists and is valid JSON"
        postconditions: "Database contains all data from backup, existing data replaced"
      - type: "function"
        name: "import_database_bincode"
        description: "Imports database from bincode backup file"
        preconditions: "Backup file exists and is valid bincode"
        postconditions: "Database contains all data from backup"
      - type: "function"
        name: "verify_backup"
        description: "Validates backup file integrity without importing"
        postconditions: "Returns Ok if backup is valid, Err with details otherwise"
      - type: "function"
        name: "create_auto_backup"
        description: "Creates timestamped automatic backup in backups directory"
        postconditions: "Backup file created with timestamp in filename"
      - type: "function"
        name: "list_backups"
        description: "Lists all available backup files with metadata"
        postconditions: "Returns sorted Vec of backup file info"
      - type: "function"
        name: "cleanup_old_backups"
        description: "Removes backups older than specified retention period"
        preconditions: "Retention period is positive"
        postconditions: "Only backups within retention period remain"

  - file: "src/persistence/error.rs"
    items:
      - type: "enum"
        name: "PersistenceError"
        description: "Error types for persistence operations"
      - type: "enum_variant"
        name: "PersistenceError::DatabaseError"
        description: "Wraps redb::Error for database operations"
      - type: "enum_variant"
        name: "PersistenceError::SerializationError"
        description: "Wraps bincode or serde_json errors"
      - type: "enum_variant"
        name: "PersistenceError::IoError"
        description: "Wraps std::io::Error for file operations"
      - type: "enum_variant"
        name: "PersistenceError::NotFound"
        description: "Requested item not found in database"
      - type: "enum_variant"
        name: "PersistenceError::InvalidBackup"
        description: "Backup file is corrupted or invalid"
      - type: "enum_variant"
        name: "PersistenceError::PathError"
        description: "Invalid or inaccessible file path"
      - type: "trait_impl"
        name: "impl Display for PersistenceError"
        description: "Formats error messages for display"
      - type: "trait_impl"
        name: "impl Error for PersistenceError"
        description: "Implements std::error::Error trait"
      - type: "trait_impl"
        name: "impl From<redb::Error> for PersistenceError"
        description: "Converts redb errors to PersistenceError"
      - type: "trait_impl"
        name: "impl From<std::io::Error> for PersistenceError"
        description: "Converts IO errors to PersistenceError"

  - file: "tests/persistence_tests.rs"
    items:
      - type: "function"
        name: "test_database_initialization"
        description: "Verifies database creates correctly on first run"
      - type: "function"
        name: "test_save_and_load_card"
        description: "Tests single card persistence round-trip"
      - type: "function"
        name: "test_batch_save_cards"
        description: "Verifies batch operations save all cards atomically"
      - type: "function"
        name: "test_batch_save_performance"
        description: "Ensures batch save of 50 cards completes in <100ms"
      - type: "function"
        name: "test_review_history_persistence"
        description: "Tests saving and loading review history"
      - type: "function"
        name: "test_settings_persistence"
        description: "Verifies settings survive restart"
      - type: "function"
        name: "test_statistics_persistence"
        description: "Tests statistics data persistence"
      - type: "function"
        name: "test_transaction_atomicity"
        description: "Verifies all-or-nothing transaction behavior"
      - type: "function"
        name: "test_concurrent_reads"
        description: "Tests multiple simultaneous read operations"
      - type: "function"
        name: "test_export_import_json"
        description: "Verifies JSON backup/restore produces identical data"
      - type: "function"
        name: "test_export_import_bincode"
        description: "Verifies bincode backup/restore produces identical data"
      - type: "function"
        name: "test_backup_verification"
        description: "Tests backup integrity validation"
      - type: "function"
        name: "test_database_path_platform_appropriate"
        description: "Verifies database path uses correct platform convention"
      - type: "function"
        name: "test_delete_card"
        description: "Tests card deletion removes data correctly"
      - type: "function"
        name: "test_load_nonexistent_card"
        description: "Verifies loading missing card returns None gracefully"

formal_verification:
  needed: false
  level: "None"
  explanation: |
    Formal verification is not required for this task because:
    
    1. **Nature of the Component**: This is a database persistence layer wrapping
       redb, which already provides ACID guarantees. The wrapper code is primarily
       glue logic for serialization/deserialization and transaction management.
    
    2. **External Guarantees**: The redb crate itself handles the critical properties
       (atomicity, consistency, isolation, durability) at a lower level. We rely on
       redb's correctness for transaction safety.
    
    3. **Testing Sufficiency**: The critical properties (data survives restart,
       transactions are atomic, concurrent reads don't block, write serialization,
       backup/restore fidelity) are effectively verified through integration and
       concurrency testing. These properties are observable and testable without
       formal methods.
    
    4. **Serialization Verification**: While serialization correctness is important,
       bincode and serde are mature libraries with their own testing. Round-trip
       property tests (serialize then deserialize equals original) provide sufficient
       confidence without formal proof.
    
    5. **Complexity Level**: This task has "moderate" complexity with "low" testing
       risk. The code is straightforward wrapper logic without complex algorithms or
       subtle concurrency bugs that would benefit from formal verification.
    
    6. **Cost-Benefit Analysis**: The effort to formally verify database wrapper code
       would be disproportionate to the risk. Integration tests, concurrency tests,
       and property-based tests for serialization provide adequate assurance at much
       lower cost.
    
    The acceptance criteria are all testable empirically through integration tests,
    making formal verification unnecessary for this component.

tests:
  strategy:
    approach: "mixed (unit + integration + concurrency)"
    rationale:
      - "Database operations require integration tests with real redb instances to verify ACID properties and data integrity"
      - "Unit tests validate serialization/deserialization logic independently from database layer"
      - "Concurrency tests ensure thread-safety of read/write operations and verify no race conditions"
      - "Integration tests verify database survives restarts and handles corruption gracefully"
      - "Performance tests validate batch operations meet <100ms requirement for 50 cards"

  implementation:
    file: "src/persistence/database.rs"
    location: "in existing test module"
    code: |
      #[cfg(test)]
      mod tests {
          use super::*;
          use crate::core::card::Card;
          use crate::core::deck::Deck;
          use crate::spaced_repetition::sm2::SM2Card;
          use tempfile::TempDir;
          use std::sync::Arc;
          use std::thread;
          use std::time::Instant;

          fn setup_test_db() -> (AppDatabase, TempDir) {
              let temp_dir = TempDir::new().unwrap();
              let db_path = temp_dir.path().join("test.db");
              let db = AppDatabase::new(&db_path).unwrap();
              (db, temp_dir)
          }

          fn create_test_card(id: &str, front: &str, back: &str) -> Card {
              Card::new(id.to_string(), front.to_string(), back.to_string())
          }

          fn create_test_sm2_card(card_id: &str, interval: i32, easiness: f32, repetitions: u32) -> SM2Card {
              SM2Card {
                  card_id: card_id.to_string(),
                  interval,
                  easiness_factor: easiness,
                  repetitions,
                  next_review: chrono::Utc::now(),
              }
          }

          #[test]
          fn test_database_initialization() {
              let (db, _temp_dir) = setup_test_db();
              assert!(db.is_initialized());
          }

          #[test]
          fn test_save_and_load_card() {
              let (db, _temp_dir) = setup_test_db();
              let card = create_test_card("card1", "Front", "Back");
              
              db.save_card(&card).unwrap();
              let loaded = db.load_card("card1").unwrap();
              
              assert_eq!(loaded.id(), card.id());
              assert_eq!(loaded.front(), card.front());
              assert_eq!(loaded.back(), card.back());
          }

          #[test]
          fn test_save_and_load_multiple_cards() {
              let (db, _temp_dir) = setup_test_db();
              let cards = vec![
                  create_test_card("card1", "Front1", "Back1"),
                  create_test_card("card2", "Front2", "Back2"),
                  create_test_card("card3", "Front3", "Back3"),
              ];
              
              for card in &cards {
                  db.save_card(card).unwrap();
              }
              
              let loaded_cards = db.load_all_cards().unwrap();
              assert_eq!(loaded_cards.len(), 3);
          }

          #[test]
          fn test_update_existing_card() {
              let (db, _temp_dir) = setup_test_db();
              let mut card = create_test_card("card1", "Original", "Content");
              db.save_card(&card).unwrap();
              
              card.set_front("Updated".to_string());
              db.save_card(&card).unwrap();
              
              let loaded = db.load_card("card1").unwrap();
              assert_eq!(loaded.front(), "Updated");
          }

          #[test]
          fn test_delete_card() {
              let (db, _temp_dir) = setup_test_db();
              let card = create_test_card("card1", "Front", "Back");
              db.save_card(&card).unwrap();
              
              db.delete_card("card1").unwrap();
              
              assert!(db.load_card("card1").is_err());
          }

          #[test]
          fn test_save_and_load_sm2_card_state() {
              let (db, _temp_dir) = setup_test_db();
              let sm2_card = create_test_sm2_card("card1", 5, 2.5, 3);
              
              db.save_sm2_state(&sm2_card).unwrap();
              let loaded = db.load_sm2_state("card1").unwrap();
              
              assert_eq!(loaded.card_id, sm2_card.card_id);
              assert_eq!(loaded.interval, sm2_card.interval);
              assert_eq!(loaded.easiness_factor, sm2_card.easiness_factor);
              assert_eq!(loaded.repetitions, sm2_card.repetitions);
          }

          #[test]
          fn test_save_review_history() {
              let (db, _temp_dir) = setup_test_db();
              let review = ReviewRecord {
                  card_id: "card1".to_string(),
                  timestamp: chrono::Utc::now(),
                  quality: 4,
                  interval_before: 1,
                  interval_after: 3,
              };
              
              db.save_review(&review).unwrap();
              let history = db.load_review_history("card1").unwrap();
              
              assert_eq!(history.len(), 1);
              assert_eq!(history[0].card_id, review.card_id);
              assert_eq!(history[0].quality, review.quality);
          }

          #[test]
          fn test_save_and_load_statistics() {
              let (db, _temp_dir) = setup_test_db();
              let stats = Statistics {
                  total_cards: 100,
                  cards_reviewed_today: 25,
                  average_retention: 0.85,
                  total_reviews: 500,
              };
              
              db.save_statistics(&stats).unwrap();
              let loaded = db.load_statistics().unwrap();
              
              assert_eq!(loaded.total_cards, stats.total_cards);
              assert_eq!(loaded.cards_reviewed_today, stats.cards_reviewed_today);
              assert_eq!(loaded.average_retention, stats.average_retention);
              assert_eq!(loaded.total_reviews, stats.total_reviews);
          }

          #[test]
          fn test_save_and_load_settings() {
              let (db, _temp_dir) = setup_test_db();
              let settings = Settings {
                  daily_review_limit: 50,
                  new_cards_per_day: 10,
                  theme: "dark".to_string(),
              };
              
              db.save_settings(&settings).unwrap();
              let loaded = db.load_settings().unwrap();
              
              assert_eq!(loaded.daily_review_limit, settings.daily_review_limit);
              assert_eq!(loaded.new_cards_per_day, settings.new_cards_per_day);
              assert_eq!(loaded.theme, settings.theme);
          }

          #[test]
          fn test_batch_save_cards() {
              let (db, _temp_dir) = setup_test_db();
              let cards: Vec<Card> = (0..50)
                  .map(|i| create_test_card(&format!("card{}", i), &format!("Front{}", i), &format!("Back{}", i)))
                  .collect();
              
              let start = Instant::now();
              db.batch_save_cards(&cards).unwrap();
              let duration = start.elapsed();
              
              assert!(duration.as_millis() < 100, "Batch save took {}ms, expected <100ms", duration.as_millis());
              
              let loaded = db.load_all_cards().unwrap();
              assert_eq!(loaded.len(), 50);
          }

          #[test]
          fn test_batch_save_is_atomic() {
              let (db, _temp_dir) = setup_test_db();
              let cards = vec![
                  create_test_card("card1", "Front1", "Back1"),
                  create_test_card("card2", "Front2", "Back2"),
              ];
              
              db.batch_save_cards(&cards).unwrap();
              let count_before = db.load_all_cards().unwrap().len();
              
              // Simulate failure by attempting to save with invalid data
              let invalid_result = db.batch_save_cards(&vec![]);
              
              let count_after = db.load_all_cards().unwrap().len();
              assert_eq!(count_before, count_after, "Transaction should be atomic");
          }

          #[test]
          fn test_database_survives_restart() {
              let temp_dir = TempDir::new().unwrap();
              let db_path = temp_dir.path().join("test.db");
              
              {
                  let db = AppDatabase::new(&db_path).unwrap();
                  let card = create_test_card("card1", "Front", "Back");
                  db.save_card(&card).unwrap();
              }
              
              {
                  let db = AppDatabase::new(&db_path).unwrap();
                  let loaded = db.load_card("card1").unwrap();
                  assert_eq!(loaded.id(), "card1");
              }
          }

          #[test]
          fn test_export_database() {
              let (db, _temp_dir) = setup_test_db();
              let card = create_test_card("card1", "Front", "Back");
              db.save_card(&card).unwrap();
              
              let export_path = _temp_dir.path().join("backup.json");
              db.export_to_json(&export_path).unwrap();
              
              assert!(export_path.exists());
              let content = std::fs::read_to_string(&export_path).unwrap();
              assert!(content.contains("card1"));
          }

          #[test]
          fn test_import_database() {
              let (db, temp_dir) = setup_test_db();
              let card = create_test_card("card1", "Front", "Back");
              db.save_card(&card).unwrap();
              
              let export_path = temp_dir.path().join("backup.json");
              db.export_to_json(&export_path).unwrap();
              
              let (db2, _temp_dir2) = setup_test_db();
              db2.import_from_json(&export_path).unwrap();
              
              let loaded = db2.load_card("card1").unwrap();
              assert_eq!(loaded.id(), "card1");
          }

          #[test]
          fn test_backup_restore_produces_identical_data() {
              let (db, temp_dir) = setup_test_db();
              
              let cards = vec![
                  create_test_card("card1", "Front1", "Back1"),
                  create_test_card("card2", "Front2", "Back2"),
              ];
              let sm2_card = create_test_sm2_card("card1", 5, 2.5, 3);
              
              db.batch_save_cards(&cards).unwrap();
              db.save_sm2_state(&sm2_card).unwrap();
              
              let export_path = temp_dir.path().join("backup.json");
              db.export_to_json(&export_path).unwrap();
              
              let (db2, _temp_dir2) = setup_test_db();
              db2.import_from_json(&export_path).unwrap();
              
              let loaded_cards = db2.load_all_cards().unwrap();
              let loaded_sm2 = db2.load_sm2_state("card1").unwrap();
              
              assert_eq!(loaded_cards.len(), cards.len());
              assert_eq!(loaded_sm2.interval, sm2_card.interval);
          }

          #[test]
          fn test_concurrent_reads() {
              let (db, _temp_dir) = setup_test_db();
              let card = create_test_card("card1", "Front", "Back");
              db.save_card(&card).unwrap();
              
              let db_arc = Arc::new(db);
              let mut handles = vec![];
              
              for _ in 0..10 {
                  let db_clone = Arc::clone(&db_arc);
                  let handle = thread::spawn(move || {
                      db_clone.load_card("card1").unwrap()
                  });
                  handles.push(handle);
              }
              
              for handle in handles {
                  let loaded = handle.join().unwrap();
                  assert_eq!(loaded.id(), "card1");
              }
          }

          #[test]
          fn test_concurrent_writes_serialize_correctly() {
              let (db, _temp_dir) = setup_test_db();
              let db_arc = Arc::new(db);
              let mut handles = vec![];
              
              for i in 0..10 {
                  let db_clone = Arc::clone(&db_arc);
                  let handle = thread::spawn(move || {
                      let card = create_test_card(&format!("card{}", i), &format!("Front{}", i), &format!("Back{}", i));
                      db_clone.save_card(&card).unwrap();
                  });
                  handles.push(handle);
              }
              
              for handle in handles {
                  handle.join().unwrap();
              }
              
              let loaded = db_arc.load_all_cards().unwrap();
              assert_eq!(loaded.len(), 10);
          }

          #[test]
          fn test_platform_appropriate_database_path() {
              let db_path = AppDatabase::default_db_path();
              assert!(db_path.is_absolute());
              
              #[cfg(target_os = "linux")]
              assert!(db_path.to_string_lossy().contains(".local/share") || 
                     db_path.to_string_lossy().contains(".config"));
              
              #[cfg(target_os = "windows")]
              assert!(db_path.to_string_lossy().contains("AppData"));
              
              #[cfg(target_os = "macos")]
              assert!(db_path.to_string_lossy().contains("Application Support"));
          }

          #[test]
          fn test_handle_corrupted_database_gracefully() {
              let temp_dir = TempDir::new().unwrap();
              let db_path = temp_dir.path().join("test.db");
              
              std::fs::write(&db_path, b"corrupted data").unwrap();
              
              let result = AppDatabase::new(&db_path);
              assert!(result.is_err() || result.is_ok(), "Should handle corruption gracefully");
          }

          #[test]
          fn test_empty_database_load_returns_empty() {
              let (db, _temp_dir) = setup_test_db();
              let cards = db.load_all_cards().unwrap();
              assert_eq!(cards.len(), 0);
          }

          #[test]
          fn test_delete_nonexistent_card_fails_gracefully() {
              let (db, _temp_dir) = setup_test_db();
              let result = db.delete_card("nonexistent");
              assert!(result.is_err() || result.is_ok());
          }

          #[test]
          fn test_load_nonexistent_card_fails() {
              let (db, _temp_dir) = setup_test_db();
              let result = db.load_card("nonexistent");
              assert!(result.is_err());
          }

          #[test]
          fn test_serialization_roundtrip_card() {
              let card = create_test_card("card1", "Front", "Back");
              let serialized = bincode::serialize(&card).unwrap();
              let deserialized: Card = bincode::deserialize(&serialized).unwrap();
              
              assert_eq!(card.id(), deserialized.id());
              assert_eq!(card.front(), deserialized.front());
              assert_eq!(card.back(), deserialized.back());
          }

          #[test]
          fn test_serialization_roundtrip_sm2_card() {
              let sm2_card = create_test_sm2_card("card1", 5, 2.5, 3);
              let serialized = bincode::serialize(&sm2_card).unwrap();
              let deserialized: SM2Card = bincode::deserialize(&serialized).unwrap();
              
              assert_eq!(sm2_card.card_id, deserialized.card_id);
              assert_eq!(sm2_card.interval, deserialized.interval);
              assert_eq!(sm2_card.easiness_factor, deserialized.easiness_factor);
          }

          #[test]
          fn test_json_export_is_human_readable() {
              let (db, temp_dir) = setup_test_db();
              let card = create_test_card("card1", "Front", "Back");
              db.save_card(&card).unwrap();
              
              let export_path = temp_dir.path().join("backup.json");
              db.export_to_json(&export_path).unwrap();
              
              let content = std::fs::read_to_string(&export_path).unwrap();
              assert!(content.contains("\"id\""));
              assert!(content.contains("\"front\""));
              assert!(content.contains("\"back\""));
          }

          #[test]
          fn test_batch_save_sm2_states() {
              let (db, _temp_dir) = setup_test_db();
              let sm2_cards: Vec<SM2Card> = (0..50)
                  .map(|i| create_test_sm2_card(&format!("card{}", i), i, 2.5, i as u32))
                  .collect();
              
              let start = Instant::now();
              db.batch_save_sm2_states(&sm2_cards).unwrap();
              let duration = start.elapsed();
              
              assert!(duration.as_millis() < 100, "Batch save took {}ms, expected <100ms", duration.as_millis());
          }
      }

  coverage:
    - "Database initializes correctly on first run"
    - "Single card save and load operations work correctly"
    - "Multiple cards can be saved and loaded"
    - "Existing cards can be updated"
    - "Cards can be deleted successfully"
    - "SM2 card state persists and loads correctly"
    - "Review history is saved and retrieved accurately"
    - "Statistics data persists across operations"
    - "Settings are saved and loaded correctly"
    - "Batch save operations complete within 100ms for 50 cards"
    - "Batch operations are atomic (all-or-nothing)"
    - "Database survives application restart with data intact"
    - "Export produces valid JSON file with readable format"
    - "Import correctly restores all data from backup"
    - "Backup and restore produces identical data"
    - "Concurrent reads don't block each other"
    - "Concurrent writes serialize correctly without data loss"
    - "Database path is platform-appropriate (XDG/AppData/Application Support)"
    - "Corrupted database is handled gracefully"
    - "Empty database returns empty collections without errors"
    - "Deleting nonexistent cards fails gracefully"
    - "Loading nonexistent cards returns appropriate error"
    - "Card serialization roundtrip preserves all data"
    - "SM2Card serialization roundtrip preserves all data"
    - "JSON export format is human-readable"
    - "Batch save of SM2 states meets performance requirements"

dependencies:
  depends_on:
    - task_id: 2
      reason: "Requires Card, Deck, and other data structures to be defined before they can be persisted"
    - task_id: 7
      reason: "Requires SM2Card and spaced repetition state structures to persist learning progress"

  depended_upon_by:
    - task_id: 8
      reason: "LearningSession requires persistence layer to save and restore session state and review progress"
    - task_id: 9
      reason: "Statistics and progress tracking depend on persisted review history and card state"
    - task_id: 10
      reason: "User settings and application configuration require persistent storage"

  external:
    - name: "redb"
      type: "crate"
      status: "to be imported"
    - name: "bincode"
      type: "crate"
      status: "to be imported"
    - name: "directories"
      type: "crate"
      status: "to be imported"
    - name: "serde"
      type: "crate"
      status: "to be imported"
    - name: "serde_json"
      type: "crate"
      status: "to be imported"
    - name: "chrono"
      type: "crate"
      status: "to be imported"
    - name: "tempfile"
      type: "crate"
      status: "to be imported (dev-dependency for tests)"
---
task:
  id: 12
  name: "Visual Feedback and Animation Polish"

context:
  description: |
    This task implements a comprehensive visual feedback and animation system that transforms
    the learning application from functional to delightful. When users answer questions, they
    receive immediate, clear visual feedback: correct answers trigger a satisfying green flash
    with a checkmark icon, while incorrect answers show a red X with a subtle shake animation
    that draws attention without being jarring. Progress indicators show completion status
    through smooth circular arcs, and achievement unlocks celebrate milestones with animated
    popups that slide in, display for a few seconds, and gracefully dismiss.
    
    The architectural significance lies in creating a reusable animation framework that other
    UI components can leverage. Rather than scattering animation logic throughout the codebase,
    this task centralizes timing calculations, easing functions, and state management into
    dedicated modules. The system respects accessibility preferences (prefers-reduced-motion)
    and ensures all visual feedback meets WCAG AA contrast requirements, making the application
    both beautiful and inclusive.
    
    This task solves the problem of providing immediate, multi-modal feedback (color + icon +
    motion) that reinforces learning through positive and negative reinforcement. Research shows
    that timely feedback significantly improves learning outcomes, and well-crafted animations
    increase user engagement and satisfaction.

  key_points:
    - "Animations must be fast enough to feel responsive (200-500ms for feedback) but not so fast that users miss them"
    - "Accessibility is paramount: never rely on color alone, always pair with icons; respect reduced motion preferences"
    - "All feedback colors must meet WCAG AA contrast ratio of 4.5:1 against backgrounds"
    - "Shake effects use damped sine waves to oscillate with decreasing amplitude, avoiding motion sickness"
    - "Progress indicators update smoothly without jumps, using monotonic interpolation"
    - "Achievement animations can be longer (1-2s) as they're celebratory moments users want to savor"
    - "Easing functions like EaseOutElastic create playful, bouncy feedback while EaseOutCubic provides smooth polish"
    - "The animation system is decoupled from business logic, triggered by messages from session and statistics modules"

files:
  - path: "src/ui/feedback.rs"
    description: "Core feedback animation system with FeedbackAnimation enum, animation states, and timing logic"
  
  - path: "src/ui/effects.rs"
    description: "Visual effects including shake, flash, and other micro-interactions"
  
  - path: "src/ui/progress.rs"
    description: "Progress circle component with smooth arc rendering and percentage display"
  
  - path: "src/ui/achievements/popup.rs"
    description: "Achievement unlock popup with slide-in animation and auto-dismiss"
  
  - path: "src/ui/theme/colors.rs"
    description: "Color palette constants for feedback states (success, error, partial, neutral)"
  
  - path: "src/ui/theme/animations.rs"
    description: "Animation timing constants, easing curves, and duration definitions"
  
  - path: "src/ui/mod.rs"
    description: "UI module declarations exposing feedback, effects, progress, and theme modules"
  
  - path: "tests/feedback_animations_test.rs"
    description: "Integration tests for feedback animations, effects, and visual components"

functions:
  - file: "src/ui/feedback.rs"
    items:
      - type: "module_declaration"
        name: "ui::feedback"
        description: "Module containing visual feedback and animation components"
      
      - type: "enum"
        name: "FeedbackType"
        description: "Represents the type of feedback to display (Correct, Incorrect, Partial)"
      
      - type: "struct"
        name: "FeedbackAnimation"
        description: "Manages animated visual feedback for user responses"
        invariants: "Animation progress remains between 0.0 and 1.0"
      
      - type: "method"
        name: "FeedbackAnimation::new"
        description: "Creates a new feedback animation with specified type and duration"
        postconditions: "Returns FeedbackAnimation with progress at 0.0"
      
      - type: "method"
        name: "FeedbackAnimation::update"
        description: "Updates animation state based on elapsed time"
        preconditions: "Delta time must be non-negative"
        postconditions: "Progress advances toward 1.0, returns true when complete"
      
      - type: "method"
        name: "FeedbackAnimation::view"
        description: "Renders the feedback animation as an iced Element"
      
      - type: "method"
        name: "FeedbackAnimation::color"
        description: "Returns the appropriate color for the current feedback type"
        postconditions: "Returns color meeting WCAG AA contrast requirements"
      
      - type: "struct"
        name: "ShakeEffect"
        description: "Implements oscillating shake animation with decay for error feedback"
        invariants: "Offset decays to zero over animation duration"
      
      - type: "method"
        name: "ShakeEffect::new"
        description: "Creates a new shake effect with specified amplitude and duration"
        postconditions: "Returns ShakeEffect with initial offset at 0.0"
      
      - type: "method"
        name: "ShakeEffect::update"
        description: "Updates shake position using damped sine wave"
        preconditions: "Delta time must be non-negative"
        postconditions: "Returns current x-offset, converges to 0.0 when complete"
      
      - type: "method"
        name: "ShakeEffect::is_complete"
        description: "Returns true when shake animation has finished"
        postconditions: "Returns true only when amplitude has decayed below threshold"
      
      - type: "function"
        name: "shake_offset"
        description: "Calculates shake offset using damped sine wave formula"
        preconditions: "Progress must be between 0.0 and 1.0"
        postconditions: "Returns offset value that decays toward zero"

  - file: "src/ui/progress.rs"
    items:
      - type: "module_declaration"
        name: "ui::progress"
        description: "Module containing progress indicator components"
      
      - type: "struct"
        name: "ProgressCircle"
        description: "Circular progress indicator for session completion"
        invariants: "Progress value clamped between 0.0 and 1.0"
      
      - type: "method"
        name: "ProgressCircle::new"
        description: "Creates a new progress circle with initial progress value"
        preconditions: "Progress should be between 0.0 and 1.0"
        postconditions: "Returns ProgressCircle with clamped progress value"
      
      - type: "method"
        name: "ProgressCircle::set_progress"
        description: "Updates the progress value with smooth interpolation"
        preconditions: "New progress should be between 0.0 and 1.0"
        postconditions: "Progress value updated and clamped"
      
      - type: "method"
        name: "ProgressCircle::view"
        description: "Renders the progress circle as an iced Element"
        postconditions: "Returns circular arc from 0 to progress * 360 degrees"
      
      - type: "function"
        name: "draw_progress_arc"
        description: "Helper function to draw partial circular arc using canvas primitives"
        preconditions: "Progress must be between 0.0 and 1.0, radius must be positive"
        postconditions: "Draws arc with smooth antialiasing"

  - file: "src/ui/achievements/popup.rs"
    items:
      - type: "module_declaration"
        name: "ui::achievement_popup"
        description: "Module for achievement celebration animations"
      
      - type: "struct"
        name: "AchievementPopup"
        description: "Animated popup that displays when achievements are unlocked"
        invariants: "Auto-dismisses after display duration completes"
      
      - type: "method"
        name: "AchievementPopup::new"
        description: "Creates a new achievement popup with title, description, and icon"
        postconditions: "Returns popup with animation progress at 0.0"
      
      - type: "method"
        name: "AchievementPopup::update"
        description: "Updates animation state and handles auto-dismiss timing"
        preconditions: "Delta time must be non-negative"
        postconditions: "Returns true when popup should be dismissed"
      
      - type: "method"
        name: "AchievementPopup::view"
        description: "Renders the animated popup with slide-in and fade effects"
        postconditions: "Applies translation and opacity based on animation progress"
      
      - type: "function"
        name: "slide_in_easing"
        description: "Easing function for slide-in animation using ease-out-elastic"
        preconditions: "Progress must be between 0.0 and 1.0"
        postconditions: "Returns eased value with elastic bounce effect"

  - file: "src/ui/theme/colors.rs"
    items:
      - type: "module_declaration"
        name: "ui::colors"
        description: "Module defining color palette for feedback states"
      
      - type: "constant"
        name: "COLOR_SUCCESS"
        description: "Green color for correct answers (WCAG AA compliant)"
      
      - type: "constant"
        name: "COLOR_ERROR"
        description: "Red color for incorrect answers (WCAG AA compliant)"
      
      - type: "constant"
        name: "COLOR_PARTIAL"
        description: "Yellow/orange color for partial credit (WCAG AA compliant)"
      
      - type: "constant"
        name: "COLOR_PROGRESS"
        description: "Blue color for progress indicators"
      
      - type: "constant"
        name: "COLOR_ACHIEVEMENT"
        description: "Gold color for achievement celebrations"
      
      - type: "function"
        name: "feedback_color"
        description: "Returns appropriate color for given feedback type"
        preconditions: "FeedbackType must be valid enum variant"
        postconditions: "Returns WCAG AA compliant color"

  - file: "src/ui/theme/animations.rs"
    items:
      - type: "module_declaration"
        name: "ui::animation"
        description: "Core animation utilities and easing functions"
      
      - type: "enum"
        name: "EasingCurve"
        description: "Enum defining different easing curve types (Linear, EaseIn, EaseOut, EaseInOut, EaseOutElastic, EaseOutCubic)"
      
      - type: "function"
        name: "apply_easing"
        description: "Applies the specified easing curve to a linear progress value"
        preconditions: "Progress must be between 0.0 and 1.0"
        postconditions: "Returns eased value between 0.0 and 1.0"
        invariants: "Monotonically increasing (output grows as progress grows)"
      
      - type: "function"
        name: "ease_out_elastic"
        description: "Elastic easing function with overshoot and bounce back"
        preconditions: "t must be between 0.0 and 1.0"
        postconditions: "Returns value that overshoots 1.0 then settles"
      
      - type: "function"
        name: "ease_out_cubic"
        description: "Cubic easing function for smooth deceleration"
        preconditions: "t must be between 0.0 and 1.0"
        postconditions: "Returns smoothly eased value"
      
      - type: "struct"
        name: "AnimationState"
        description: "Tracks animation timing and progress"
        invariants: "Progress remains between 0.0 and 1.0"
      
      - type: "method"
        name: "AnimationState::new"
        description: "Creates a new animation state with specified duration"
        preconditions: "Duration must be positive"
        postconditions: "Returns state with elapsed time at 0.0"
      
      - type: "method"
        name: "AnimationState::advance"
        description: "Advances animation by delta time and returns current progress"
        preconditions: "Delta must be non-negative"
        postconditions: "Elapsed time increases, progress clamped to 1.0 when complete"
      
      - type: "method"
        name: "AnimationState::is_complete"
        description: "Returns true when animation has reached its duration"
        postconditions: "Returns true iff progress >= 1.0"
      
      - type: "constant"
        name: "FEEDBACK_DURATION_MS"
        description: "Standard duration for feedback animations (300ms)"
      
      - type: "constant"
        name: "SHAKE_DURATION_MS"
        description: "Duration for shake effect (400ms)"
      
      - type: "constant"
        name: "ACHIEVEMENT_DURATION_MS"
        description: "Duration for achievement popup display (3000ms)"

  - file: "src/ui/icons.rs"
    items:
      - type: "module_declaration"
        name: "ui::icons"
        description: "Icon rendering for feedback states"
      
      - type: "function"
        name: "checkmark_icon"
        description: "Renders a checkmark icon for correct feedback"
        postconditions: "Returns iced Element with checkmark graphic"
      
      - type: "function"
        name: "x_icon"
        description: "Renders an X icon for incorrect feedback"
        postconditions: "Returns iced Element with X graphic"
      
      - type: "function"
        name: "achievement_icon"
        description: "Renders trophy/star icon for achievement unlocks"
        preconditions: "Icon name must be valid achievement icon identifier"
        postconditions: "Returns iced Element with achievement icon"

  - file: "src/ui/accessibility.rs"
    items:
      - type: "module_declaration"
        name: "ui::accessibility"
        description: "Accessibility utilities for animations"
      
      - type: "function"
        name: "should_reduce_motion"
        description: "Checks system preference for reduced motion"
        postconditions: "Returns true if user prefers reduced motion"
      
      - type: "function"
        name: "apply_motion_preference"
        description: "Adjusts animation duration based on motion preference"
        preconditions: "Duration must be positive"
        postconditions: "Returns reduced duration if motion should be reduced, otherwise original"
      
      - type: "function"
        name: "ensure_contrast"
        description: "Verifies color contrast meets WCAG AA requirements"
        preconditions: "Foreground and background colors must be valid RGB"
        postconditions: "Returns true if contrast ratio >= 4.5:1"

  - file: "tests/feedback_animations_test.rs"
    items:
      - type: "function"
        name: "test_feedback_animation_completion"
        description: "Verifies feedback animation completes in expected time"
      
      - type: "function"
        name: "test_shake_returns_to_center"
        description: "Ensures shake effect offset returns to zero at completion"
      
      - type: "function"
        name: "test_progress_circle_rendering"
        description: "Tests progress circle at 0%, 50%, and 100%"
      
      - type: "function"
        name: "test_achievement_popup_auto_dismiss"
        description: "Verifies achievement popup dismisses after display duration"
      
      - type: "function"
        name: "test_color_contrast_requirements"
        description: "Validates all feedback colors meet WCAG AA contrast"
      
      - type: "function"
        name: "test_easing_monotonicity"
        description: "Property test ensuring easing functions are monotonically increasing"

formal_verification:
  needed: false
  level: "None"
  explanation: |
    Formal verification is not needed for visual feedback and animation polish because:
    
    1. Animation logic is primarily presentational and aesthetic rather than safety-critical.
    The correctness of animations (timing, easing curves, visual effects) is subjectively
    evaluated through visual inspection and user experience testing, not formal proofs.
    
    2. Animation failures are gracefully degradable - if an animation doesn't render correctly,
    it doesn't compromise data integrity, learning progress, or system state. The worst case
    is a poor user experience, not a system failure.
    
    3. The mathematical properties involved (easing functions, progress calculations, color
    interpolation) are well-established and can be adequately validated through unit tests
    with known input/output pairs. Property-based testing can verify boundary conditions
    (e.g., progress values stay in 0-1 range) without full formal verification.
    
    4. Integration with the iced framework means animation rendering is delegated to a
    well-tested library. Our code primarily configures animations rather than implementing
    low-level rendering logic.
    
    5. Accessibility concerns (WCAG contrast, motion preferences) are better addressed through
    integration testing with real rendering and automated accessibility tools rather than
    formal proofs.
    
    6. The complexity-to-risk ratio doesn't justify formal verification effort. These are
    UI enhancements where standard testing practices (unit tests for calculations, integration
    tests for triggering, visual regression tests for appearance) provide adequate confidence.
    
    Standard testing with visual inspection and integration tests is the appropriate quality
    assurance approach for this component.

tests:
  strategy:
    approach: "mixed (unit + integration + property-based)"
    rationale:
      - "Animation state transitions and timing calculations require unit tests for deterministic verification"
      - "Visual feedback components interact with application state requiring integration tests"
      - "Accessibility features (contrast, motion preferences) need isolated unit testing"
      - "Animation completion and frame timing are mathematical properties testable without rendering"
      - "Integration tests verify feedback triggers correctly in response to user actions"
      - "Property-based tests validate timing calculations across all possible progress values"

  implementation:
    file: "tests/feedback_animations_test.rs"
    location: "create new"
    code: |
      #[cfg(test)]
      mod tests {
          use super::*;
          use std::time::Duration;

          #[test]
          fn test_feedback_animation_correct_state() {
              let feedback = FeedbackAnimation::Correct;
              assert_eq!(feedback.color(), Color::from_rgb(0.0, 0.8, 0.0));
              assert_eq!(feedback.icon(), Icon::Checkmark);
              assert_eq!(feedback.duration(), Duration::from_millis(300));
          }

          #[test]
          fn test_feedback_animation_incorrect_state() {
              let feedback = FeedbackAnimation::Incorrect;
              assert_eq!(feedback.color(), Color::from_rgb(0.9, 0.0, 0.0));
              assert_eq!(feedback.icon(), Icon::Cross);
              assert_eq!(feedback.duration(), Duration::from_millis(500));
          }

          #[test]
          fn test_shake_effect_amplitude_decay() {
              let shake = ShakeEffect::new(10.0, Duration::from_millis(500));
              let amp1 = shake.amplitude_at(0.1);
              let amp2 = shake.amplitude_at(0.5);
              let amp3 = shake.amplitude_at(0.9);
              assert!(amp1 > amp2);
              assert!(amp2 > amp3);
          }

          #[test]
          fn test_shake_effect_returns_to_center() {
              let shake = ShakeEffect::new(15.0, Duration::from_millis(500));
              let final_offset = shake.offset_at(1.0);
              assert!(final_offset.abs() < 0.01);
          }

          #[test]
          fn test_progress_circle_at_boundaries() {
              let circle = ProgressCircle::new(50.0);
              assert_eq!(circle.arc_angle(0.0), 0.0);
              assert!((circle.arc_angle(0.5) - std::f32::consts::PI).abs() < 0.01);
              assert!((circle.arc_angle(1.0) - 2.0 * std::f32::consts::PI).abs() < 0.01);
          }

          #[test]
          fn test_color_palette_contrast_ratios() {
              let success_color = FeedbackColor::success();
              let error_color = FeedbackColor::error();
              let background = Color::WHITE;
              assert!(contrast_ratio(success_color, background) >= 4.5);
              assert!(contrast_ratio(error_color, background) >= 4.5);
          }
      }

      #[cfg(test)]
      mod integration_tests {
          use super::*;

          #[test]
          fn test_feedback_triggered_on_correct_review() {
              let mut session = LearningSession::new();
              let mut app_state = AppState::new();
              session.submit_review(ReviewOutcome::Correct);
              let messages = session.update(&mut app_state);
              assert!(messages.iter().any(|m| matches!(m, Message::ShowFeedback(FeedbackAnimation::Correct))));
          }

          #[test]
          fn test_achievement_popup_triggered_by_statistics() {
              let mut stats = Statistics::new();
              let mut app_state = AppState::new();
              stats.record_review(ReviewOutcome::Correct);
              let messages = stats.update(&mut app_state);
              if stats.total_reviews() == 1 {
                  assert!(messages.iter().any(|m| matches!(m, Message::ShowAchievement(_))));
              }
          }
      }

      #[cfg(test)]
      mod property_tests {
          use proptest::prelude::*;

          proptest! {
              #[test]
              fn prop_progress_circle_angle_bounds(progress in 0.0f32..=1.0f32) {
                  let circle = ProgressCircle::new(50.0);
                  let angle = circle.arc_angle(progress);
                  prop_assert!(angle >= 0.0);
                  prop_assert!(angle <= 2.0 * std::f32::consts::PI + 0.01);
              }

              #[test]
              fn prop_easing_monotonic(t in 0.0f32..=1.0f32) {
                  if t < 1.0 {
                      let current = Easing::EaseOutCubic.apply(t);
                      let next = Easing::EaseOutCubic.apply(t + 0.01);
                      prop_assert!(next >= current);
                  }
              }
          }
      }

  coverage:
    - "FeedbackAnimation enum correctly maps to colors, icons, and durations"
    - "ShakeEffect amplitude decreases over time with proper decay"
    - "ShakeEffect returns to center position at completion"
    - "ProgressCircle renders correct arc angles at boundaries"
    - "Feedback colors meet WCAG AA contrast requirements"
    - "Reduced motion preference is respected"
    - "Correct review triggers success feedback in session"
    - "Achievement unlock triggers popup animation"
    - "Progress circle angle remains bounded for all values"
    - "Easing functions are monotonically increasing"

dependencies:
  depends_on:
    - task_id: 1
      reason: "Needs animation API from iced foundation"
    - task_id: 6
      reason: "Needs message system to trigger feedback"

  depended_upon_by: []

  external:
    - name: "iced::Color"
      type: "struct"
      status: "already exists"
    - name: "iced::Element"
      type: "struct"
      status: "already exists"
    - name: "std::time::Duration"
      type: "struct"
      status: "already exists"
---
task:
  id: 13
  name: "UI/UX Polish and Accessibility"

context:
  description: |
    This task implements comprehensive UI/UX polish and accessibility features to ensure
    the flashcard application meets WCAG 2.1 Level AA standards and provides an excellent
    user experience for all users, including those with disabilities.
    
    Accessibility is both an ethical imperative and legal requirement in many jurisdictions.
    Good UX design reduces cognitive load and makes learning more effective. Professional
    polish builds trust and encourages continued use. Keyboard navigation and proper
    contrast benefit all users, not just those with disabilities.
    
    The implementation covers five key areas:
    1. Color palette with WCAG-compliant contrast ratios (4.5:1 for normal text, 3:1 for large text)
    2. Typography scale with consistent sizing (16-18px body, 14px secondary, 12px minimum)
    3. Touch-friendly target sizes (48x48px minimum for all interactive elements)
    4. Keyboard navigation with shortcuts (1-5 for quality, Space for next, Escape for cancel)
    5. Screen reader support with proper semantic markup and ARIA-like labels
    
    The outcome is an application that is usable by keyboard alone, readable with screen
    readers, accessible to users with low vision, and provides a professional, polished
    experience that builds trust and encourages continued use.

  key_points:
    - "WCAG AA requires 4.5:1 contrast for normal text, 3:1 for large text and UI components"
    - "Minimum touch target size is 48x48px (44x44px iOS minimum) for accessibility"
    - "Keyboard focus indicators must be visible with minimum 2px border and 3:1 contrast"
    - "Color should not be the sole indicator of meaning - add icons or text labels"
    - "Font size minimum is 12px, with 14-16px recommended for body text"
    - "8px base unit provides consistent spacing rhythm throughout application"
    - "Screen reader testing requires platform-specific tools (NVDA, JAWS, VoiceOver)"
    - "Keyboard shortcuts enable efficient navigation for power users and accessibility"
    - "Responsive layouts ensure usability across mobile, tablet, and desktop devices"
    - "Focus management ensures logical tab order through interactive elements"

files:
  - path: "src/ui/theme.rs"
    description: "Defines WCAG-compliant color palette with documented contrast ratios and typography scale constants"
  - path: "src/ui/colors.rs"
    description: "Color constants and utility functions for theme colors with accessibility guarantees"
  - path: "src/ui/typography.rs"
    description: "Typography scale constants including font sizes, weights, and line heights"
  - path: "src/ui/keyboard.rs"
    description: "Keyboard shortcut handlers and navigation logic for accessibility"
  - path: "src/ui/components/button.rs"
    description: "Accessible button component with proper touch target sizing (48x48px minimum)"
  - path: "src/ui/components/text_input.rs"
    description: "Accessible text input component with focus indicators and keyboard support"
  - path: "src/ui/components/card.rs"
    description: "Card component with responsive layout and proper spacing using 8px base unit"
  - path: "src/ui/layout.rs"
    description: "Responsive layout utilities and helpers for adaptive window sizing"
  - path: "src/ui/accessibility.rs"
    description: "Accessibility utilities including screen reader support and ARIA-like semantics"
  - path: "src/ui/focus.rs"
    description: "Focus management system with visible focus indicators (2px border minimum)"
  - path: "src/screens/flashcard_screen.rs"
    description: "Updated flashcard screen with keyboard shortcuts (1-5 for quality, Space for next)"
  - path: "src/screens/deck_list_screen.rs"
    description: "Updated deck list screen with keyboard navigation and responsive layout"
  - path: "src/screens/settings_screen.rs"
    description: "Updated settings screen with accessible controls and keyboard support"
  - path: "src/screens/help_screen.rs"
    description: "Help screen documenting keyboard shortcuts and accessibility features"
  - path: "tests/accessibility_tests.rs"
    description: "Integration tests for accessibility features including contrast ratios and touch target validation"

functions:
  - file: "src/ui/colors.rs"
    items:
      - type: "module_declaration"
        name: "colors"
        description: "Module containing WCAG-compliant color palette and contrast utilities"
      - type: "struct"
        name: "ColorPalette"
        description: "Defines application color scheme with documented contrast ratios"
      - type: "constant"
        name: "PRIMARY_TEXT"
        description: "Primary text color (dark gray/black) for main content"
      - type: "constant"
        name: "SECONDARY_TEXT"
        description: "Secondary text color for less prominent content"
      - type: "constant"
        name: "BACKGROUND"
        description: "Main background color (light/white)"
      - type: "constant"
        name: "SURFACE"
        description: "Surface color for cards and elevated elements"
      - type: "constant"
        name: "PRIMARY"
        description: "Primary brand color for main actions"
      - type: "constant"
        name: "SECONDARY"
        description: "Secondary accent color"
      - type: "constant"
        name: "SUCCESS"
        description: "Color for success states and positive feedback"
      - type: "constant"
        name: "WARNING"
        description: "Color for warning states"
      - type: "constant"
        name: "ERROR"
        description: "Color for error states and destructive actions"
      - type: "constant"
        name: "FOCUS_INDICATOR"
        description: "Color for keyboard focus indicator border"
      - type: "function"
        name: "contrast_ratio"
        description: "Calculates contrast ratio between two colors"
        preconditions: "Both colors must be valid RGB values"
        postconditions: "Returns ratio between 1.0 and 21.0"
        invariants: "Ratio is commutative (order doesn't matter)"
      - type: "function"
        name: "meets_wcag_aa"
        description: "Checks if color pair meets WCAG AA contrast requirements"
        preconditions: "Valid foreground and background colors, valid text size"
        postconditions: "Returns true if contrast ratio meets threshold"

  - file: "src/ui/typography.rs"
    items:
      - type: "module_declaration"
        name: "typography"
        description: "Module defining consistent typography scale and text styles"
      - type: "struct"
        name: "TextStyle"
        description: "Defines font size, weight, and line height for text elements"
      - type: "constant"
        name: "HEADING_1"
        description: "Style for primary headings (24px, bold)"
      - type: "constant"
        name: "HEADING_2"
        description: "Style for secondary headings (20px, semibold)"
      - type: "constant"
        name: "HEADING_3"
        description: "Style for tertiary headings (18px, semibold)"
      - type: "constant"
        name: "BODY_LARGE"
        description: "Style for large body text (18px, regular)"
      - type: "constant"
        name: "BODY"
        description: "Style for normal body text (16px, regular)"
      - type: "constant"
        name: "BODY_SMALL"
        description: "Style for small body text (14px, regular)"
      - type: "constant"
        name: "CAPTION"
        description: "Style for captions and labels (12px, regular)"
      - type: "function"
        name: "apply_text_style"
        description: "Applies typography style to iced Text widget"

  - file: "src/ui/spacing.rs"
    items:
      - type: "module_declaration"
        name: "spacing"
        description: "Module defining consistent spacing scale based on 8px unit"
      - type: "constant"
        name: "SPACE_XXS"
        description: "Extra extra small spacing (4px)"
      - type: "constant"
        name: "SPACE_XS"
        description: "Extra small spacing (8px)"
      - type: "constant"
        name: "SPACE_SM"
        description: "Small spacing (12px)"
      - type: "constant"
        name: "SPACE_MD"
        description: "Medium spacing (16px)"
      - type: "constant"
        name: "SPACE_LG"
        description: "Large spacing (24px)"
      - type: "constant"
        name: "SPACE_XL"
        description: "Extra large spacing (32px)"
      - type: "constant"
        name: "SPACE_XXL"
        description: "Extra extra large spacing (48px)"

  - file: "src/ui/touch_targets.rs"
    items:
      - type: "module_declaration"
        name: "touch_targets"
        description: "Module ensuring minimum touch target sizes for accessibility"
      - type: "constant"
        name: "MIN_TOUCH_SIZE"
        description: "Minimum touch target size (48px) for accessibility"
      - type: "function"
        name: "ensure_touch_size"
        description: "Wraps widget to ensure minimum 48x48px touch target"
        preconditions: "Valid widget provided"
        postconditions: "Returned widget has minimum touch target size"
      - type: "function"
        name: "accessible_button"
        description: "Creates button with proper touch target and focus indicator"
        postconditions: "Button meets WCAG touch target and focus requirements"

  - file: "src/ui/keyboard.rs"
    items:
      - type: "module_declaration"
        name: "keyboard"
        description: "Module handling keyboard shortcuts and navigation"
      - type: "enum"
        name: "KeyboardShortcut"
        description: "Enumeration of all keyboard shortcuts in the application"
      - type: "enum_variant"
        name: "KeyboardShortcut::RateQuality"
        description: "Shortcuts for quality rating (1-5 keys)"
      - type: "enum_variant"
        name: "KeyboardShortcut::NextCard"
        description: "Space bar to show next flashcard"
      - type: "enum_variant"
        name: "KeyboardShortcut::Cancel"
        description: "Escape key to cancel current operation"
      - type: "enum_variant"
        name: "KeyboardShortcut::Submit"
        description: "Enter key to submit form or confirm action"
      - type: "enum_variant"
        name: "KeyboardShortcut::Help"
        description: "F1 or ? to show help dialog"
      - type: "function"
        name: "handle_keyboard_event"
        description: "Processes keyboard events and dispatches appropriate messages"
        preconditions: "Valid keyboard event"
        postconditions: "Returns Some(Message) if shortcut matched, None otherwise"
      - type: "function"
        name: "keyboard_shortcuts_help"
        description: "Returns formatted list of keyboard shortcuts for help screen"

  - file: "src/ui/focus.rs"
    items:
      - type: "module_declaration"
        name: "focus"
        description: "Module managing focus indicators and tab order"
      - type: "struct"
        name: "FocusState"
        description: "Tracks which element currently has keyboard focus"
      - type: "function"
        name: "focus_indicator_style"
        description: "Returns style for visible focus indicator (2px border)"
        postconditions: "Style meets WCAG visibility requirements"
      - type: "function"
        name: "next_focusable"
        description: "Moves focus to next element in tab order"
      - type: "function"
        name: "previous_focusable"
        description: "Moves focus to previous element in tab order"

  - file: "src/ui/responsive.rs"
    items:
      - type: "module_declaration"
        name: "responsive"
        description: "Module providing responsive layout utilities"
      - type: "struct"
        name: "Breakpoints"
        description: "Defines window size breakpoints for responsive layouts"
      - type: "constant"
        name: "MOBILE_MAX"
        description: "Maximum width for mobile layout (640px)"
      - type: "constant"
        name: "TABLET_MAX"
        description: "Maximum width for tablet layout (1024px)"
      - type: "function"
        name: "get_layout_mode"
        description: "Determines layout mode based on window dimensions"
        preconditions: "Valid window dimensions"
        postconditions: "Returns Mobile, Tablet, or Desktop mode"
      - type: "function"
        name: "responsive_column"
        description: "Creates column with responsive spacing and alignment"
      - type: "function"
        name: "responsive_row"
        description: "Creates row with responsive wrapping and spacing"

  - file: "src/ui/accessibility.rs"
    items:
      - type: "module_declaration"
        name: "accessibility"
        description: "Module providing screen reader and accessibility utilities"
      - type: "struct"
        name: "AriaLabel"
        description: "Wrapper for accessible labels and descriptions"
      - type: "function"
        name: "screen_reader_text"
        description: "Creates visually hidden text for screen readers"
      - type: "function"
        name: "announce"
        description: "Announces message to screen reader via ARIA live region"
        postconditions: "Message queued for screen reader announcement"
      - type: "function"
        name: "set_aria_label"
        description: "Sets accessible label for widget"

  - file: "src/screens/home.rs"
    items:
      - type: "method"
        name: "Home::view"
        description: "Updated to use accessible color palette and typography"
      - type: "method"
        name: "Home::handle_keyboard"
        description: "Handles keyboard navigation on home screen"

  - file: "src/screens/practice.rs"
    items:
      - type: "method"
        name: "Practice::view"
        description: "Updated with accessible colors, touch targets, and focus indicators"
      - type: "method"
        name: "Practice::handle_keyboard"
        description: "Handles keyboard shortcuts for quality rating (1-5) and navigation"

  - file: "src/screens/add_card.rs"
    items:
      - type: "method"
        name: "AddCard::view"
        description: "Updated with accessible form elements and focus management"
      - type: "method"
        name: "AddCard::handle_keyboard"
        description: "Handles Enter to submit, Escape to cancel"

  - file: "src/screens/settings.rs"
    items:
      - type: "method"
        name: "Settings::view"
        description: "Updated with accessible controls and contrast-compliant colors"
      - type: "method"
        name: "Settings::handle_keyboard"
        description: "Handles keyboard navigation in settings"

  - file: "src/screens/help.rs"
    items:
      - type: "method"
        name: "Help::view"
        description: "Updated to display keyboard shortcuts and accessibility features"

  - file: "src/main.rs"
    items:
      - type: "method"
        name: "App::update"
        description: "Updated to handle keyboard shortcut messages"
      - type: "function"
        name: "main"
        description: "Updated to set initial window size and enable accessibility features"

  - file: "tests/accessibility_tests.rs"
    items:
      - type: "function"
        name: "test_color_contrast_ratios"
        description: "Verifies all color pairs meet WCAG AA contrast requirements"
        postconditions: "All text/background combinations pass 4.5:1 ratio"
      - type: "function"
        name: "test_touch_target_sizes"
        description: "Validates all interactive elements meet 48x48px minimum"
      - type: "function"
        name: "test_keyboard_shortcuts"
        description: "Tests that all keyboard shortcuts dispatch correct messages"
      - type: "function"
        name: "test_focus_indicators"
        description: "Verifies focus indicators are visible and properly styled"
      - type: "function"
        name: "test_typography_sizes"
        description: "Ensures all text meets minimum size requirements (12px+)"
      - type: "function"
        name: "test_responsive_breakpoints"
        description: "Tests layout adapts correctly at different window sizes"
      - type: "function"
        name: "test_aria_labels"
        description: "Validates accessible labels are present on interactive elements"
      - type: "function"
        name: "test_tab_order"
        description: "Verifies logical tab navigation order through UI"

formal_verification:
  needed: false
  level: "None"
  explanation: |
    UI/UX polish and accessibility features are primarily presentation-layer concerns
    that are best validated through manual testing with assistive technologies,
    user testing, and integration tests rather than formal verification.
    
    The properties being ensured (color contrast ratios, touch target sizes, keyboard
    navigation, screen reader compatibility) are:
    
    1. Visual/perceptual properties that require human validation or automated
       accessibility scanners rather than formal proofs
    2. User experience qualities that depend on subjective assessment and real-world
       testing with diverse users
    3. Platform-specific behaviors (screen reader announcements, focus indicators)
       that vary by OS and assistive technology
    
    While some properties like "all buttons are minimum 48x48px" could theoretically
    be verified formally, the cost-benefit ratio is poor compared to simple runtime
    assertions or integration tests. The acceptance criteria (WCAG compliance,
    minimum touch targets, keyboard navigation) are better validated through:
    
    - Automated accessibility testing tools (contrast checkers, WAVE, axe)
    - Manual testing with actual screen readers (NVDA, JAWS, VoiceOver)
    - Keyboard-only navigation testing
    - Integration tests verifying keyboard event handlers are registered
    - Visual regression testing for consistent styling
    
    The risk profile is low-to-medium with primary risks in testing methodology
    rather than correctness of implementation. Accessibility bugs are typically
    caught through user testing and accessibility audits, not formal proofs.

tests:
  strategy:
    approach: "mixed (unit tests + integration tests + manual verification)"
    rationale:
      - "Accessibility features require multiple testing approaches - automated tests for measurable properties (contrast ratios, sizes) and manual testing for screen reader compatibility"
      - "Unit tests verify individual accessibility utilities (contrast checking, keyboard handlers, focus management)"
      - "Integration tests validate that accessibility features work together correctly in actual UI components"
      - "Manual verification checklist ensures human-validated WCAG compliance and usability with assistive technologies"
      - "Property-based tests ensure color contrast calculations work correctly across all possible color combinations"

  implementation:
    file: "tests/accessibility_tests.rs"
    location: "create new"
    code: |
      #[cfg(test)]
      mod accessibility_tests {
          use super::*;
          
          mod color_contrast_tests {
              use crate::ui::theme::{ColorPalette, contrast_ratio};
              
              #[test]
              fn test_primary_text_meets_wcag_aa() {
                  let palette = ColorPalette::default();
                  let ratio = contrast_ratio(palette.text_primary, palette.background);
                  assert!(ratio >= 4.5, "Primary text contrast ratio {:.2} does not meet WCAG AA (4.5:1)", ratio);
              }
              
              #[test]
              fn test_secondary_text_meets_wcag_aa() {
                  let palette = ColorPalette::default();
                  let ratio = contrast_ratio(palette.text_secondary, palette.background);
                  assert!(ratio >= 4.5, "Secondary text contrast ratio {:.2} does not meet WCAG AA (4.5:1)", ratio);
              }
              
              #[test]
              fn test_large_text_meets_wcag_aa() {
                  let palette = ColorPalette::default();
                  let ratio = contrast_ratio(palette.text_large, palette.background);
                  assert!(ratio >= 3.0, "Large text contrast ratio {:.2} does not meet WCAG AA (3:1)", ratio);
              }
              
              #[test]
              fn test_button_colors_meet_wcag_aa() {
                  let palette = ColorPalette::default();
                  let ratio = contrast_ratio(palette.button_text, palette.button_background);
                  assert!(ratio >= 4.5, "Button text contrast ratio {:.2} does not meet WCAG AA", ratio);
              }
              
              #[test]
              fn test_error_state_colors_meet_wcag_aa() {
                  let palette = ColorPalette::default();
                  let ratio = contrast_ratio(palette.error_text, palette.background);
                  assert!(ratio >= 4.5, "Error text contrast ratio {:.2} does not meet WCAG AA", ratio);
              }
              
              #[test]
              fn test_success_state_colors_meet_wcag_aa() {
                  let palette = ColorPalette::default();
                  let ratio = contrast_ratio(palette.success_text, palette.background);
                  assert!(ratio >= 4.5, "Success text contrast ratio {:.2} does not meet WCAG AA", ratio);
              }
              
              #[test]
              fn test_focus_indicator_has_sufficient_contrast() {
                  let palette = ColorPalette::default();
                  let ratio = contrast_ratio(palette.focus_indicator, palette.background);
                  assert!(ratio >= 3.0, "Focus indicator contrast ratio {:.2} does not meet WCAG AA (3:1)", ratio);
              }
          }
          
          mod typography_tests {
              use crate::ui::theme::{TypographyScale, MIN_FONT_SIZE, BODY_FONT_SIZE};
              
              #[test]
              fn test_body_text_size_meets_minimum() {
                  assert!(BODY_FONT_SIZE >= 14, "Body font size {}px is below recommended 14px", BODY_FONT_SIZE);
              }
              
              #[test]
              fn test_no_text_below_absolute_minimum() {
                  let scale = TypographyScale::default();
                  assert!(scale.small >= MIN_FONT_SIZE, "Small text {}px is below minimum {}px", scale.small, MIN_FONT_SIZE);
                  assert!(scale.body >= MIN_FONT_SIZE, "Body text {}px is below minimum {}px", scale.body, MIN_FONT_SIZE);
                  assert!(scale.secondary >= MIN_FONT_SIZE, "Secondary text {}px is below minimum {}px", scale.secondary, MIN_FONT_SIZE);
              }
              
              #[test]
              fn test_typography_scale_is_consistent() {
                  let scale = TypographyScale::default();
                  assert!(scale.heading1 > scale.heading2, "H1 should be larger than H2");
                  assert!(scale.heading2 > scale.heading3, "H2 should be larger than H3");
                  assert!(scale.heading3 > scale.body, "H3 should be larger than body");
                  assert!(scale.body >= scale.secondary, "Body should be same or larger than secondary");
              }
          }
          
          mod touch_target_tests {
              use crate::ui::components::{Button, TouchTarget};
              use iced::Size;
              
              const MIN_TOUCH_TARGET: f32 = 48.0;
              
              #[test]
              fn test_button_meets_minimum_touch_target() {
                  let button = Button::new("Test");
                  let size = button.min_size();
                  assert!(size.width >= MIN_TOUCH_TARGET, "Button width {}px is below minimum {}px", size.width, MIN_TOUCH_TARGET);
                  assert!(size.height >= MIN_TOUCH_TARGET, "Button height {}px is below minimum {}px", size.height, MIN_TOUCH_TARGET);
              }
              
              #[test]
              fn test_quality_rating_buttons_meet_touch_target() {
                  let button = Button::quality_rating(1);
                  let size = button.min_size();
                  assert!(size.width >= MIN_TOUCH_TARGET && size.height >= MIN_TOUCH_TARGET,
                          "Quality rating button {}x{} is below minimum {}x{}", 
                          size.width, size.height, MIN_TOUCH_TARGET, MIN_TOUCH_TARGET);
              }
              
              #[test]
              fn test_icon_buttons_meet_touch_target() {
                  let button = Button::icon("⚙");
                  let size = button.min_size();
                  assert!(size.width >= MIN_TOUCH_TARGET && size.height >= MIN_TOUCH_TARGET,
                          "Icon button {}x{} is below minimum {}x{}", 
                          size.width, size.height, MIN_TOUCH_TARGET, MIN_TOUCH_TARGET);
              }
          }
          
          mod keyboard_navigation_tests {
              use crate::ui::keyboard::{KeyboardHandler, Shortcut, Action};
              use iced::keyboard::{Key, Modifiers};
              
              #[test]
              fn test_quality_rating_shortcuts_registered() {
                  let handler = KeyboardHandler::new();
                  
                  for quality in 1..=5 {
                      let key = Key::Character(quality.to_string());
                      let action = handler.handle_key(key, Modifiers::empty());
                      assert!(matches!(action, Some(Action::RateQuality(_))),
                              "Key {} should map to quality rating", quality);
                  }
              }
              
              #[test]
              fn test_space_advances_to_next_card() {
                  let handler = KeyboardHandler::new();
                  let action = handler.handle_key(Key::Character(" ".into()), Modifiers::empty());
                  assert!(matches!(action, Some(Action::NextCard)),
                          "Space key should advance to next card");
              }
              
              #[test]
              fn test_escape_cancels_or_returns() {
                  let handler = KeyboardHandler::new();
                  let action = handler.handle_key(Key::Named(iced::keyboard::key::Named::Escape), Modifiers::empty());
                  assert!(matches!(action, Some(Action::Cancel) | Some(Action::Back)),
                          "Escape key should cancel or go back");
              }
              
              #[test]
              fn test_tab_navigation_order() {
                  let handler = KeyboardHandler::new();
                  let action = handler.handle_key(Key::Named(iced::keyboard::key::Named::Tab), Modifiers::empty());
                  assert!(matches!(action, Some(Action::FocusNext)),
                          "Tab key should move focus to next element");
              }
              
              #[test]
              fn test_shift_tab_reverse_navigation() {
                  let handler = KeyboardHandler::new();
                  let mut modifiers = Modifiers::empty();
                  modifiers.insert(Modifiers::SHIFT);
                  let action = handler.handle_key(Key::Named(iced::keyboard::key::Named::Tab), modifiers);
                  assert!(matches!(action, Some(Action::FocusPrevious)),
                          "Shift+Tab should move focus to previous element");
              }
              
              #[test]
              fn test_enter_activates_focused_element() {
                  let handler = KeyboardHandler::new();
                  let action = handler.handle_key(Key::Named(iced::keyboard::key::Named::Enter), Modifiers::empty());
                  assert!(matches!(action, Some(Action::Activate)),
                          "Enter key should activate focused element");
              }
          }
          
          mod focus_management_tests {
              use crate::ui::focus::{FocusManager, FocusState};
              
              #[test]
              fn test_focus_indicator_is_visible() {
                  let mut manager = FocusManager::new();
                  manager.focus_first();
                  
                  let state = manager.current_state();
                  assert!(state.has_focus(), "First element should be focusable");
                  assert!(state.indicator_visible(), "Focus indicator should be visible");
              }
              
              #[test]
              fn test_focus_cycles_through_elements() {
                  let mut manager = FocusManager::with_elements(vec!["btn1", "btn2", "btn3"]);
                  manager.focus_first();
                  
                  manager.focus_next();
                  manager.focus_next();
                  manager.focus_next();
                  
                  assert_eq!(manager.focused_element(), Some("btn1"));
              }
              
              #[test]
              fn test_focus_skip_disabled_elements() {
                  let mut manager = FocusManager::new();
                  manager.add_element("btn1", true);
                  manager.add_element("btn2", false);
                  manager.add_element("btn3", true);
                  
                  manager.focus_first();
                  assert_eq!(manager.focused_element(), Some("btn1"));
                  
                  manager.focus_next();
                  assert_eq!(manager.focused_element(), Some("btn3"), "Should skip disabled btn2");
              }
          }
          
          mod responsive_layout_tests {
              use crate::ui::layout::{ResponsiveLayout, Breakpoint};
              use iced::Size;
              
              #[test]
              fn test_layout_adapts_to_narrow_window() {
                  let layout = ResponsiveLayout::new();
                  let window_size = Size::new(400.0, 600.0);
                  
                  let columns = layout.column_count(window_size);
                  assert_eq!(columns, 1, "Narrow window should use single column");
              }
              
              #[test]
              fn test_layout_uses_multiple_columns_on_wide_window() {
                  let layout = ResponsiveLayout::new();
                  let window_size = Size::new(1200.0, 800.0);
                  
                  let columns = layout.column_count(window_size);
                  assert!(columns > 1, "Wide window should use multiple columns");
              }
              
              #[test]
              fn test_breakpoints_are_logical() {
                  assert!(Breakpoint::TABLET > Breakpoint::MOBILE);
                  assert!(Breakpoint::DESKTOP > Breakpoint::TABLET);
                  assert!(Breakpoint::MOBILE >= 320.0, "Should support smallest mobile devices");
              }
          }
          
          mod spacing_tests {
              use crate::ui::theme::{Spacing, BASE_UNIT};
              
              #[test]
              fn test_spacing_follows_8px_grid() {
                  assert_eq!(BASE_UNIT, 8, "Base spacing unit should be 8px");
                  
                  let spacing = Spacing::default();
                  assert_eq!(spacing.xs % BASE_UNIT, 0, "XS spacing should be multiple of base unit");
                  assert_eq!(spacing.sm % BASE_UNIT, 0, "SM spacing should be multiple of base unit");
                  assert_eq!(spacing.md % BASE_UNIT, 0, "MD spacing should be multiple of base unit");
                  assert_eq!(spacing.lg % BASE_UNIT, 0, "LG spacing should be multiple of base unit");
                  assert_eq!(spacing.xl % BASE_UNIT, 0, "XL spacing should be multiple of base unit");
              }
              
              #[test]
              fn test_spacing_scale_is_progressive() {
                  let spacing = Spacing::default();
                  assert!(spacing.xs < spacing.sm);
                  assert!(spacing.sm < spacing.md);
                  assert!(spacing.md < spacing.lg);
                  assert!(spacing.lg < spacing.xl);
              }
          }
          
          mod integration_tests {
              use crate::ui::components::{Button, Card};
              use crate::ui::theme::Theme;
              
              #[test]
              fn test_theme_applied_consistently_to_all_components() {
                  let theme = Theme::default();
                  let button = Button::new("Test").theme(&theme);
                  let card = Card::new().theme(&theme);
                  
                  assert_eq!(button.background_color(), theme.palette.button_background);
                  assert_eq!(card.background_color(), theme.palette.card_background);
              }
              
              #[test]
              fn test_components_respect_accessibility_settings() {
                  let mut theme = Theme::default();
                  theme.set_high_contrast(true);
                  
                  let button = Button::new("Test").theme(&theme);
                  let contrast = button.contrast_ratio();
                  assert!(contrast >= 7.0, "High contrast mode should achieve 7:1 ratio (WCAG AAA)");
              }
              
              #[test]
              fn test_keyboard_and_mouse_interactions_equivalent() {
                  let button = Button::new("Test");
                  
                  let click_result = button.on_click();
                  let keyboard_result = button.on_key_activate();
                  
                  assert_eq!(click_result, keyboard_result, 
                             "Keyboard activation should produce same result as mouse click");
              }
          }
      }
      
      #[cfg(test)]
      mod property_tests {
          use proptest::prelude::*;
          use crate::ui::theme::contrast_ratio;
          use iced::Color;
          
          proptest! {
              #[test]
              fn prop_contrast_ratio_is_symmetric(
                  r1 in 0.0f32..1.0, g1 in 0.0f32..1.0, b1 in 0.0f32..1.0,
                  r2 in 0.0f32..1.0, g2 in 0.0f32..1.0, b2 in 0.0f32..1.0
              ) {
                  let color1 = Color::from_rgb(r1, g1, b1);
                  let color2 = Color::from_rgb(r2, g2, b2);
                  
                  let ratio1 = contrast_ratio(color1, color2);
                  let ratio2 = contrast_ratio(color2, color1);
                  
                  prop_assert!((ratio1 - ratio2).abs() < 0.01, 
                               "Contrast ratio should be symmetric");
              }
              
              #[test]
              fn prop_contrast_ratio_is_always_at_least_one(
                  r1 in 0.0f32..1.0, g1 in 0.0f32..1.0, b1 in 0.0f32..1.0,
                  r2 in 0.0f32..1.0, g2 in 0.0f32..1.0, b2 in 0.0f32..1.0
              ) {
                  let color1 = Color::from_rgb(r1, g1, b1);
                  let color2 = Color::from_rgb(r2, g2, b2);
                  
                  let ratio = contrast_ratio(color1, color2);
                  prop_assert!(ratio >= 1.0, "Contrast ratio should always be at least 1.0");
              }
              
              #[test]
              fn prop_black_white_contrast_is_maximum(
                  r in 0.0f32..1.0, g in 0.0f32..1.0, b in 0.0f32..1.0
              ) {
                  let test_color = Color::from_rgb(r, g, b);
                  let black = Color::from_rgb(0.0, 0.0, 0.0);
                  let white = Color::from_rgb(1.0, 1.0, 1.0);
                  
                  let max_contrast = contrast_ratio(black, white);
                  let test_contrast = contrast_ratio(test_color, white);
                  
                  prop_assert!(test_contrast <= max_contrast,
                               "Black/white contrast should be maximum");
              }
              
              #[test]
              fn prop_identical_colors_have_1_to_1_contrast(
                  r in 0.0f32..1.0, g in 0.0f32..1.0, b in 0.0f32..1.0
              ) {
                  let color = Color::from_rgb(r, g, b);
                  let ratio = contrast_ratio(color, color);
                  
                  prop_assert!((ratio - 1.0).abs() < 0.01,
                               "Identical colors should have 1:1 contrast ratio");
              }
          }
      }

  coverage:
    - "WCAG AA contrast ratio (4.5:1) for primary text colors"
    - "WCAG AA contrast ratio (4.5:1) for secondary text colors"
    - "WCAG AA contrast ratio (3:1) for large text colors"
    - "WCAG AA contrast ratio for button text/background combinations"
    - "WCAG AA contrast ratio for error state colors"
    - "WCAG AA contrast ratio for success state colors"
    - "WCAG AA contrast ratio (3:1) for focus indicators"
    - "Body text meets 14px minimum recommended size"
    - "All text meets 12px absolute minimum size"
    - "Typography scale follows logical progression (H1 > H2 > H3 > body)"
    - "All buttons meet 48x48px minimum touch target size"
    - "Quality rating buttons (1-5) meet touch target requirements"
    - "Icon-only buttons meet touch target requirements"
    - "Keyboard shortcuts 1-5 trigger quality ratings"
    - "Space key advances to next flashcard"
    - "Escape key cancels operations or returns to previous screen"
    - "Tab key moves focus to next element"
    - "Shift+Tab moves focus to previous element"
    - "Enter key activates focused element"
    - "Focus indicators are visible on focused elements"
    - "Focus cycles from last element back to first"
    - "Focus navigation skips disabled elements"
    - "Narrow windows use single-column layout"
    - "Wide windows use multi-column layout"
    - "Responsive breakpoints follow logical progression"
    - "All spacing values are multiples of 8px base unit"
    - "Spacing scale increases progressively (XS < SM < MD < LG < XL)"
    - "Theme colors applied consistently to all components"
    - "Components respect high contrast mode settings"
    - "Keyboard and mouse interactions produce equivalent results"
    - "Contrast ratio calculation is symmetric"
    - "Contrast ratio is always at least 1.0"
    - "Black/white contrast is maximum possible"
    - "Identical colors have 1:1 contrast ratio"
    - "Manual verification checklist for screen reader testing"
    - "Manual verification checklist for keyboard-only navigation"
    - "Manual verification checklist for visual contrast inspection"
    - "Manual verification checklist for responsive layout testing"
    - "Manual verification checklist for WCAG 2.1 Level AA compliance"

dependencies:
  depends_on:
    - task_id: 6
      reason: "Needs complete UI structure to polish and apply accessibility features"
    - task_id: 8
      reason: "Needs all screens implemented to apply consistency and accessibility across entire application"

  depended_upon_by: []

  external:
    - name: "iced"
      type: "crate"
      status: "already exists"
    - name: "iced::Color"
      type: "struct"
      status: "already exists"
    - name: "iced::keyboard"
      type: "module"
      status: "already exists"
    - name: "iced::Size"
      type: "struct"
      status: "already exists"
    - name: "proptest"
      type: "crate"
      status: "to be imported"
---
task:
  id: 14
  name: "Testing, Documentation, and Release Preparation"

context:
  description: |
    This task represents the final production-readiness phase of the Hanzi/Kanji learning
    application. It transforms a functional prototype into a shippable product through
    comprehensive testing, professional documentation, and cross-platform distribution
    packaging. This includes implementing a test suite with >80% code coverage (unit,
    integration, and property-based tests), creating user-facing documentation with
    screenshots and tutorials, configuring optimized release builds, and packaging the
    application for Linux (AppImage/deb), macOS (app bundle/DMG), and Windows (MSI installer).
    
    The testing strategy encompasses multiple layers: integration tests validate complete
    learning workflows and practice modes, property-based tests ensure mathematical
    correctness of the SM-2 spaced repetition algorithm, performance benchmarks establish
    baselines (60fps animations, <100ms database operations, <50ms recognition latency),
    and manual testing on clean VMs verifies deployment readiness. Documentation includes
    a comprehensive user manual built with mdBook covering installation, features, practice
    modes, and troubleshooting.
    
    Release preparation involves configuring Cargo release profiles with aggressive
    optimizations (LTO, opt-level=3, symbol stripping), creating platform-specific build
    scripts, setting up CI/CD pipelines with GitHub Actions for automated testing and
    release builds, and preparing distribution packages that follow platform conventions.
    This task ensures the application meets production quality standards and provides a
    smooth installation experience across all target platforms.

  key_points:
    - "Achieves >80% test coverage through mixed testing strategy combining unit, integration, property-based, and performance tests"
    - "Property-based tests validate SM-2 algorithm invariants (EF bounds [1.3, 2.5], interval monotonicity, determinism)"
    - "Performance benchmarks enforce critical targets: 60fps animation rendering, <100ms database batch operations, <50ms character recognition"
    - "Integration tests use temporary databases to ensure test isolation and prevent production data contamination"
    - "User manual written for end-users (not developers) using mdBook with screenshots demonstrating all features"
    - "Release builds use aggressive optimization: opt-level=3, lto=true, strip=true for minimal binary size and maximum performance"
    - "Platform-specific packaging follows conventions: AppImage/deb for Linux, signed app bundle for macOS, MSI installer for Windows"
    - "CI/CD pipeline automates testing, building, and release creation with GitHub Actions"
    - "Code signing required for macOS (notarization) and Windows (SmartScreen) to avoid security warnings"
    - "Manual testing on clean VMs validates that all runtime dependencies are bundled or documented"
    - "Benchmark suite establishes performance baselines to detect regressions in future development"
    - "Test helpers provide factory functions and utilities to reduce test code duplication"

files:
  - path: "tests/integration_tests.rs"
    description: "Integration tests for complete learning workflows and practice modes"
  
  - path: "tests/sm2_properties.rs"
    description: "Property-based tests for SM-2 algorithm correctness and invariants"
  
  - path: "tests/statistics_properties.rs"
    description: "Property-based tests for statistics calculations and aggregations"
  
  - path: "tests/database_integration.rs"
    description: "Integration tests for database operations with temporary test databases"
  
  - path: "tests/recognition_integration.rs"
    description: "Integration tests for character recognition workflows"
  
  - path: "benches/animation_benchmark.rs"
    description: "Performance benchmarks for animation rendering and frame rates"
  
  - path: "benches/database_benchmark.rs"
    description: "Performance benchmarks for database batch operations and queries"
  
  - path: "benches/recognition_benchmark.rs"
    description: "Performance benchmarks for character recognition latency"
  
  - path: "Cargo.toml"
    description: "Updated with release profile, benchmark dependencies, and dev-dependencies"
  
  - path: "docs/user_manual/getting_started.md"
    description: "User manual section covering installation and first-time setup"
  
  - path: "docs/user_manual/features.md"
    description: "User manual section documenting all application features"
  
  - path: "docs/user_manual/practice_modes.md"
    description: "User manual section explaining practice modes and learning workflows"
  
  - path: "docs/user_manual/troubleshooting.md"
    description: "User manual section for common issues and solutions"
  
  - path: "docs/user_manual/book.toml"
    description: "mdBook configuration for user manual generation"
  
  - path: ".github/workflows/ci.yml"
    description: "GitHub Actions CI pipeline for automated testing"
  
  - path: ".github/workflows/release.yml"
    description: "GitHub Actions workflow for automated release builds and packaging"
  
  - path: "build-scripts/linux-appimage.sh"
    description: "Build script for creating Linux AppImage distribution"
  
  - path: "build-scripts/linux-deb.sh"
    description: "Build script for creating Debian package"
  
  - path: "build-scripts/macos-bundle.sh"
    description: "Build script for creating macOS application bundle"
  
  - path: "build-scripts/windows-installer.wxs"
    description: "WiX configuration for Windows MSI installer"
  
  - path: "resources/linux/hanzi-learner.desktop"
    description: "Linux desktop entry file for application menu integration"
  
  - path: "resources/linux/hanzi-learner.appdata.xml"
    description: "Linux AppStream metadata for software centers"
  
  - path: "resources/macos/Info.plist"
    description: "macOS application bundle property list"
  
  - path: "resources/icons/icon.icns"
    description: "macOS application icon in ICNS format"
  
  - path: "resources/icons/icon.ico"
    description: "Windows application icon in ICO format"
  
  - path: "resources/icons/icon-512.png"
    description: "Linux application icon in PNG format"
  
  - path: "tests/test_helpers/mod.rs"
    description: "Shared test utilities and helper functions for test database setup"
  
  - path: "tests/test_helpers/temp_db.rs"
    description: "Helper for creating and managing temporary test databases"
  
  - path: ".cargo/config.toml"
    description: "Cargo configuration for platform-specific build settings"
  
  - path: "docs/screenshots/.gitkeep"
    description: "Directory placeholder for user manual screenshots"

functions:
  - file: "tests/integration_tests.rs"
    items:
      - type: "module_declaration"
        name: "integration_tests"
        description: "Root module for all integration tests"
      
      - type: "function"
        name: "setup_test_db"
        description: "Creates a temporary database for integration testing"
        postconditions: "Returns a valid Database instance with clean state"
      
      - type: "function"
        name: "teardown_test_db"
        description: "Cleans up temporary database after test completion"
        preconditions: "Database must be valid temporary instance"
      
      - type: "function"
        name: "test_complete_learning_session"
        description: "End-to-end test of a complete learning workflow from start to finish"
        postconditions: "User statistics and card states are correctly updated"
      
      - type: "function"
        name: "test_practice_mode_flow"
        description: "Tests complete practice mode interaction including recognition and feedback"
        postconditions: "Practice statistics are recorded accurately"
      
      - type: "function"
        name: "test_spaced_repetition_schedule"
        description: "Validates SM-2 algorithm produces correct scheduling over multiple reviews"
        postconditions: "Card intervals follow expected SM-2 progression"
      
      - type: "function"
        name: "test_character_unlocking_progression"
        description: "Tests character unlocking as user progresses through levels"
        postconditions: "Characters unlock at correct milestones"
      
      - type: "function"
        name: "test_statistics_tracking"
        description: "Validates accuracy and session statistics are tracked correctly"
        postconditions: "All statistics match expected calculations"
      
      - type: "function"
        name: "test_database_persistence"
        description: "Verifies data persists correctly across application restarts"
        postconditions: "All user data survives database reload"
      
      - type: "function"
        name: "test_concurrent_database_access"
        description: "Tests database handles concurrent read/write operations safely"
        postconditions: "No data corruption under concurrent access"
      
      - type: "function"
        name: "test_animation_playback"
        description: "Validates animation frames render in correct sequence"
        postconditions: "Animation completes all frames without errors"

  - file: "tests/property_tests.rs"
    items:
      - type: "module_declaration"
        name: "property_tests"
        description: "Property-based tests using proptest"
      
      - type: "function"
        name: "prop_sm2_intervals_always_increase"
        description: "Property test ensuring SM-2 intervals increase for correct answers"
        invariants: "For quality >= 3, next interval > previous interval"
      
      - type: "function"
        name: "prop_sm2_efactor_bounds"
        description: "Property test ensuring E-Factor stays within valid range [1.3, 2.5]"
        invariants: "E-Factor never falls below 1.3 or exceeds 2.5"
      
      - type: "function"
        name: "prop_accuracy_calculation_bounds"
        description: "Property test ensuring accuracy percentage stays in [0, 100]"
        invariants: "Accuracy always between 0.0 and 100.0 inclusive"
      
      - type: "function"
        name: "prop_statistics_never_negative"
        description: "Property test ensuring all statistics remain non-negative"
        invariants: "Total attempts, correct answers, streaks are always >= 0"
      
      - type: "function"
        name: "prop_card_state_transitions_valid"
        description: "Property test ensuring card state transitions follow valid FSM rules"
        invariants: "All state transitions are valid according to SRS rules"
      
      - type: "function"
        name: "prop_stroke_normalization_idempotent"
        description: "Property test ensuring normalizing strokes twice produces same result"
        invariants: "normalize(normalize(x)) == normalize(x)"
      
      - type: "function"
        name: "prop_recognition_score_bounds"
        description: "Property test ensuring recognition scores stay in [0, 1]"
        invariants: "Recognition confidence always between 0.0 and 1.0"

  - file: "benches/performance_benchmarks.rs"
    items:
      - type: "module_declaration"
        name: "performance_benchmarks"
        description: "Performance benchmark suite using criterion"
      
      - type: "function"
        name: "bench_animation_frame_rate"
        description: "Benchmarks animation rendering to ensure 60fps target"
        postconditions: "Frame rendering time < 16.67ms"
      
      - type: "function"
        name: "bench_database_batch_save"
        description: "Benchmarks batch database operations for multiple cards"
        postconditions: "Batch save time < 100ms for 100 cards"
      
      - type: "function"
        name: "bench_database_query_cards"
        description: "Benchmarks querying due cards from database"
        postconditions: "Query time < 10ms for typical workload"
      
      - type: "function"
        name: "bench_stroke_recognition"
        description: "Benchmarks character recognition latency"
        postconditions: "Recognition latency < 100ms"
      
      - type: "function"
        name: "bench_sm2_calculation"
        description: "Benchmarks SM-2 algorithm calculation speed"
        postconditions: "SM-2 calculation < 1ms"
      
      - type: "function"
        name: "bench_statistics_aggregation"
        description: "Benchmarks statistics calculation and aggregation"
        postconditions: "Statistics aggregation < 50ms"
      
      - type: "function"
        name: "bench_ui_rendering"
        description: "Benchmarks UI component rendering performance"
        postconditions: "UI render time < 16.67ms per frame"
      
      - type: "function"
        name: "bench_stroke_normalization"
        description: "Benchmarks stroke data normalization"
        postconditions: "Normalization < 5ms"

  - file: "docs/user_manual.md"
    items:
      - type: "module_declaration"
        name: "user_manual"
        description: "User-facing documentation covering all features"

  - file: "Cargo.toml"
    items:
      - type: "constant"
        name: "[profile.release]"
        description: "Release build optimization configuration"
        invariants: "opt-level=3, lto=true, strip=true for maximum optimization"
      
      - type: "constant"
        name: "[profile.release-with-debug]"
        description: "Release build with debug symbols for profiling"
        invariants: "Optimized but retains debug information"

  - file: "build_scripts/build_linux.sh"
    items:
      - type: "function"
        name: "build_linux_release"
        description: "Builds optimized Linux release binary"
        postconditions: "Produces statically linked release binary"
      
      - type: "function"
        name: "create_appimage"
        description: "Creates AppImage package for Linux distribution"
        postconditions: "Produces portable .AppImage file"
      
      - type: "function"
        name: "create_deb_package"
        description: "Creates Debian package for Ubuntu/Debian systems"
        postconditions: "Produces installable .deb file"

  - file: "build_scripts/build_macos.sh"
    items:
      - type: "function"
        name: "build_macos_release"
        description: "Builds optimized macOS release binary"
        postconditions: "Produces universal binary for Intel and Apple Silicon"
      
      - type: "function"
        name: "create_app_bundle"
        description: "Creates macOS .app bundle with proper structure"
        postconditions: "Produces signed and notarized .app bundle"
      
      - type: "function"
        name: "create_dmg_installer"
        description: "Creates DMG installer for macOS distribution"
        postconditions: "Produces distributable .dmg file"
      
      - type: "function"
        name: "sign_and_notarize"
        description: "Code signs and notarizes macOS application"
        preconditions: "Valid Apple Developer certificate available"
        postconditions: "Application passes Gatekeeper requirements"

  - file: "build_scripts/build_windows.sh"
    items:
      - type: "function"
        name: "build_windows_release"
        description: "Builds optimized Windows release binary"
        postconditions: "Produces optimized .exe file"
      
      - type: "function"
        name: "create_msi_installer"
        description: "Creates MSI installer using WiX toolset"
        postconditions: "Produces installable .msi file"
      
      - type: "function"
        name: "sign_windows_executable"
        description: "Code signs Windows executable and installer"
        preconditions: "Valid code signing certificate available"
        postconditions: "Executable passes Windows SmartScreen"

  - file: ".github/workflows/ci.yml"
    items:
      - type: "module_declaration"
        name: "ci_pipeline"
        description: "GitHub Actions CI/CD pipeline configuration"
      
      - type: "function"
        name: "test_job"
        description: "Runs all tests on multiple platforms"
        postconditions: "All unit, integration, and property tests pass"
      
      - type: "function"
        name: "bench_job"
        description: "Runs benchmarks and checks performance targets"
        postconditions: "All benchmarks meet performance criteria"
      
      - type: "function"
        name: "build_job"
        description: "Builds release artifacts for all platforms"
        postconditions: "Release binaries built for Linux, macOS, Windows"
      
      - type: "function"
        name: "release_job"
        description: "Creates GitHub release with distribution packages"
        preconditions: "All tests pass, builds succeed, version tag pushed"
        postconditions: "Release published with all platform packages"

  - file: "tests/test_utils.rs"
    items:
      - type: "module_declaration"
        name: "test_utils"
        description: "Shared utilities for testing"
      
      - type: "function"
        name: "create_test_card"
        description: "Factory function for creating test flashcards"
        postconditions: "Returns valid Card instance with test data"
      
      - type: "function"
        name: "create_test_user"
        description: "Factory function for creating test user accounts"
        postconditions: "Returns valid User instance with test data"
      
      - type: "function"
        name: "assert_approx_equal"
        description: "Helper for asserting floating point equality with tolerance"
        invariants: "Uses epsilon comparison for numerical stability"
      
      - type: "function"
        name: "simulate_stroke_sequence"
        description: "Generates simulated stroke data for testing recognition"
        postconditions: "Returns valid stroke sequence matching expected format"
      
      - type: "function"
        name: "capture_animation_frame"
        description: "Captures animation frame for visual regression testing"
        postconditions: "Returns frame buffer for comparison"

  - file: "tests/smoke_tests.rs"
    items:
      - type: "module_declaration"
        name: "smoke_tests"
        description: "Basic smoke tests for critical functionality"
      
      - type: "function"
        name: "test_application_starts"
        description: "Verifies application can start without crashing"
        postconditions: "Application initializes successfully"
      
      - type: "function"
        name: "test_database_connection"
        description: "Verifies database can be opened and accessed"
        postconditions: "Database operations succeed"
      
      - type: "function"
        name: "test_ui_renders"
        description: "Verifies UI can render without errors"
        postconditions: "Main UI components display correctly"
      
      - type: "function"
        name: "test_config_loads"
        description: "Verifies configuration loads successfully"
        postconditions: "Configuration values are valid"

  - file: "tests/regression_tests.rs"
    items:
      - type: "module_declaration"
        name: "regression_tests"
        description: "Tests for previously identified bugs"
      
      - type: "function"
        name: "test_issue_xyz_fix"
        description: "Template for regression test for specific bug fixes"
        postconditions: "Previously buggy behavior now works correctly"

  - file: "scripts/test_release_builds.sh"
    items:
      - type: "function"
        name: "test_on_clean_vm"
        description: "Tests release build on clean VM without dev dependencies"
        preconditions: "Clean VM or container environment available"
        postconditions: "Application runs successfully on clean system"
      
      - type: "function"
        name: "verify_all_features"
        description: "Smoke tests all major features in release build"
        postconditions: "All critical features functional in release mode"
      
      - type: "function"
        name: "check_dependencies"
        description: "Verifies all runtime dependencies are bundled or documented"
        postconditions: "No missing dependencies on target platform"

  - file: "scripts/generate_screenshots.sh"
    items:
      - type: "function"
        name: "capture_ui_screenshots"
        description: "Generates screenshots for documentation"
        postconditions: "Creates screenshot images for all major UI views"
      
      - type: "function"
        name: "annotate_screenshots"
        description: "Adds annotations to screenshots for documentation"
        postconditions: "Screenshots have helpful callouts and labels"

  - file: "docs/CHANGELOG.md"
    items:
      - type: "module_declaration"
        name: "changelog"
        description: "Version history and release notes"

  - file: "docs/CONTRIBUTING.md"
    items:
      - type: "module_declaration"
        name: "contributing_guide"
        description: "Guidelines for contributors"

  - file: "docs/ARCHITECTURE.md"
    items:
      - type: "module_declaration"
        name: "architecture_documentation"
        description: "Technical architecture documentation"

formal_verification:
  needed: true
  level: "Basic"
  explanation: |
    While this task focuses primarily on testing and release preparation, formal verification
    is needed at a basic level to ensure that the test infrastructure itself and critical
    testing properties are sound. The property-based tests for the SM-2 algorithm mentioned
    in the implementation hints require formal specification of properties to verify. Additionally,
    performance benchmarks require formally specified performance invariants to validate against.
    
    However, this is not critical-level verification because:
    1. Most code being written is test code, not production algorithms
    2. The primary verification burden falls on the tests themselves, which are validated through execution
    3. Documentation and build configuration don't require formal proofs
    4. The task is focused on quality assurance of existing code, not implementing new critical algorithms
    
    Basic verification is appropriate to ensure:
    - Property-based test specifications correctly capture SM-2 algorithm invariants
    - Performance benchmarks have well-defined success criteria
    - Integration test scenarios cover the complete state space of user workflows
    - Test isolation properties prevent cross-contamination between test runs

  properties:
    - name: "Test Database Isolation"
      formal_statement: "∀ test₁, test₂ ∈ IntegrationTests : test₁ ≠ test₂ ⟹ database(test₁) ∩ database(test₂) = ∅"
    
    - name: "SM-2 Algorithm Monotonicity"
      formal_statement: "∀ card ∈ Cards, quality ∈ [0,5] : interval_new(card, quality) ≥ 0 ∧ (quality ≥ 3 ⟹ interval_new ≥ interval_old)"
    
    - name: "SM-2 EF Bounds"
      formal_statement: "∀ card ∈ Cards, updates ∈ ℕ : 1.3 ≤ EF(card) ≤ 2.5"
    
    - name: "Performance Frame Rate Guarantee"
      formal_statement: "∀ animation ∈ CriticalAnimations : frame_time(animation) ≤ 16.67ms ⟹ fps ≥ 60"
    
    - name: "Database Operation Latency"
      formal_statement: "∀ batch ∈ BatchOperations : |batch| ≤ 1000 ⟹ save_time(batch) < 100ms"
    
    - name: "Test Coverage Completeness"
      formal_statement: "∀ feature ∈ PublicAPI : ∃ test ∈ TestSuite : covers(test, feature)"
    
    - name: "Integration Test Determinism"
      formal_statement: "∀ test ∈ IntegrationTests, runs ∈ ℕ : result(test, run₁) = result(test, run₂) when inputs are identical"

  strategy:
    - "Use proptest to encode SM-2 algorithm properties as executable specifications"
    - "Implement property-based generators that cover the valid input domain for card review scenarios"
    - "Create formal benchmark assertions with statistical analysis to ensure performance properties hold across runs"
    - "Use type-system guarantees (Rust's ownership) to enforce test database isolation at compile time"
    - "Employ code coverage tools (tarpaulin/llvm-cov) to verify test coverage completeness property"
    - "Document formal performance requirements in benchmark code comments with mathematical bounds"
    - "Use quickcheck-style shrinking to find minimal failing cases when properties are violated"

tests:
  strategy:
    approach: "mixed"
    rationale:
      - "Integration tests validate end-to-end workflows including complete learning sessions, practice modes, and user interactions across the entire application stack"
      - "Property-based tests ensure mathematical correctness of SM-2 algorithm, statistics calculations, and data invariants under all possible inputs"
      - "Unit tests verify individual components like configuration parsing, database operations, and UI state management in isolation"
      - "Performance benchmarks establish baseline metrics for animation rendering (60fps target), database batch operations (<100ms), and character recognition latency"
      - "Manual testing on clean VMs validates release builds, installation packages, and cross-platform compatibility"
      - "Mixed approach achieves >80% code coverage while ensuring production readiness across functional correctness, performance, and deployment concerns"

  implementation:
    file: "tests/integration_tests.rs"
    location: "create new"
    code: |
      //! Integration tests for complete user workflows and system behavior
      
      use tempfile::TempDir;
      use std::path::PathBuf;
      use std::time::Duration;
      
      mod learning_session_tests {
          use super::*;
          
          #[test]
          fn test_complete_learning_session_workflow() {
              let temp_dir = TempDir::new().unwrap();
              let db_path = temp_dir.path().join("test.db");
              let mut app = create_test_app(db_path.clone());
              
              app.load_lesson("hiragana_basic").unwrap();
              assert_eq!(app.current_lesson().unwrap().name, "hiragana_basic");
              
              app.start_learning_session().unwrap();
              assert!(app.is_session_active());
              
              let char = app.get_next_character().unwrap();
              assert!(char.character.len() > 0);
              
              let stroke_data = simulate_drawing(char.character.clone());
              let result = app.recognize_and_grade(stroke_data).unwrap();
              assert!(result.confidence >= 0.0 && result.confidence <= 1.0);
              
              app.record_response(char.id, result.correct, 4).unwrap();
              let stats = app.get_character_stats(char.id).unwrap();
              assert_eq!(stats.repetitions, 1);
              
              for _ in 0..9 {
                  if let Some(next_char) = app.get_next_character() {
                      let strokes = simulate_drawing(next_char.character.clone());
                      let result = app.recognize_and_grade(strokes).unwrap();
                      app.record_response(next_char.id, result.correct, 3).unwrap();
                  }
              }
              
              let summary = app.end_session().unwrap();
              assert_eq!(summary.total_characters, 10);
              assert!(summary.accuracy >= 0.0 && summary.accuracy <= 100.0);
              
              drop(app);
              let restored_app = create_test_app(db_path);
              let history = restored_app.get_session_history().unwrap();
              assert_eq!(history.len(), 1);
          }
          
          #[test]
          fn test_spaced_repetition_scheduling() {
              let temp_dir = TempDir::new().unwrap();
              let mut app = create_test_app(temp_dir.path().join("test.db"));
              
              app.load_lesson("test_lesson").unwrap();
              app.start_learning_session().unwrap();
              
              let char = app.get_next_character().unwrap();
              let char_id = char.id;
              
              app.record_response(char_id, true, 5).unwrap();
              let stats = app.get_character_stats(char_id).unwrap();
              let first_interval = stats.interval;
              assert!(first_interval >= 1.0);
              
              app.advance_time(Duration::from_secs(first_interval as u64 * 86400)).unwrap();
              
              app.start_learning_session().unwrap();
              let due_chars = app.get_due_characters().unwrap();
              assert!(due_chars.iter().any(|c| c.id == char_id));
              
              app.record_response(char_id, true, 5).unwrap();
              let stats = app.get_character_stats(char_id).unwrap();
              let second_interval = stats.interval;
              
              assert!(second_interval > first_interval);
              assert_eq!(stats.repetitions, 2);
              assert!(stats.easiness_factor >= 1.3);
          }
          
          #[test]
          fn test_practice_mode_workflow() {
              let temp_dir = TempDir::new().unwrap();
              let mut app = create_test_app(temp_dir.path().join("test.db"));
              
              app.start_practice_mode("hiragana_basic").unwrap();
              assert!(app.is_practice_mode());
              
              let chars = app.get_practice_characters().unwrap();
              assert!(chars.len() > 0);
              
              let char_id = chars[0].id;
              app.set_practice_character(char_id).unwrap();
              
              for _ in 0..5 {
                  let strokes = simulate_drawing(chars[0].character.clone());
                  let result = app.recognize_and_grade(strokes).unwrap();
                  app.record_practice_attempt(char_id, result.correct).unwrap();
              }
              
              let stats = app.get_character_stats(char_id).unwrap();
              assert_eq!(stats.repetitions, 0);
              
              let practice_history = app.get_practice_history(char_id).unwrap();
              assert_eq!(practice_history.len(), 5);
          }
      }
      
      fn create_test_app(db_path: PathBuf) -> Application {
          let config = Config::default();
          Application::new(config, db_path).unwrap()
      }
      
      fn simulate_drawing(character: String) -> Vec<Stroke> {
          load_reference_strokes(&character).unwrap_or_else(|| {
              vec![Stroke {
                  points: vec![
                      Point { x: 100.0, y: 100.0, timestamp: 0 },
                      Point { x: 200.0, y: 200.0, timestamp: 100 },
                  ],
              }]
          })
      }
      
      fn load_reference_strokes(character: &str) -> Option<Vec<Stroke>> {
          None
      }

  coverage:
    - "Complete learning session workflow from lesson load to session summary"
    - "Spaced repetition scheduling with SM-2 algorithm across multiple reviews"
    - "Practice mode workflow without affecting SRS statistics"
    - "Database initialization and schema migration from older versions"
    - "Batch database operations performance (<100ms for 1000 records)"
    - "Database transaction commit and rollback behavior"
    - "Canvas stroke capture from pointer input events"
    - "Animation rendering performance at 60fps target"
    - "Application state machine transitions and validation"
    - "Stroke recognition accuracy (>85% target) and latency (<50ms)"
    - "Progress tracking across multiple learning sessions"
    - "Statistics aggregation by week and month periods"
    - "Configuration file loading, validation, and error handling"
    - "Configuration migration from legacy formats"
    - "Character statistics updates after each response"
    - "Session history persistence and retrieval"
    - "Due character scheduling based on interval timing"
    - "Practice attempt recording separate from SRS repetitions"
    - "Multiple stroke rendering in complex characters"
    - "Invalid state transitions rejection"
    - "Batch character insertion and verification"
    - "Performance degradation with complex animations"
    - "Recognition confidence scoring (0.0-1.0 range)"
    - "Daily goal tracking and progress calculation"
    - "SM-2 easiness factor bounds enforcement [1.3, 2.5]"
    - "SM-2 interval monotonicity for successful reviews"
    - "Failed response interval reset behavior"
    - "Accuracy percentage normalization to [0, 100]"
    - "Stroke normalization shape preservation"
    - "Resampled stroke endpoint preservation"
    - "Bounding box containment of all points"
    - "Session duration calculation correctness"

dependencies:
  depends_on:
    - task_id: 1
      reason: "All features must be implemented before final testing"
    - task_id: 2
      reason: "All features must be implemented before final testing"
    - task_id: 3
      reason: "All features must be implemented before final testing"
    - task_id: 4
      reason: "All features must be implemented before final testing"
    - task_id: 5
      reason: "All features must be implemented before final testing"
    - task_id: 6
      reason: "All features must be implemented before final testing"
    - task_id: 7
      reason: "All features must be implemented before final testing"
    - task_id: 8
      reason: "All features must be implemented before final testing"
    - task_id: 9
      reason: "All features must be implemented before final testing"
    - task_id: 10
      reason: "All features must be implemented before final testing"
    - task_id: 11
      reason: "All features must be implemented before final testing"
    - task_id: 12
      reason: "All features must be implemented before final testing"
    - task_id: 13
      reason: "All features must be implemented before final testing"

  depended_upon_by: []

  external:
    - name: "proptest"
      type: "crate"
      status: "to be imported"
    - name: "criterion"
      type: "crate"
      status: "to be imported"
    - name: "tempfile"
      type: "crate"
      status: "to be imported"
    - name: "mdBook"
      type: "crate"
      status: "to be imported"
    - name: "cargo-bundle"
      type: "crate"
      status: "to be imported"
    - name: "WiX Toolset"
      type: "external"
      status: "needs installation"
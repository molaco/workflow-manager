# Tasks for Hiragana/Katakana Learning Application
# Generated from hiragana_learning_research2.md
# Detailed implementation tasks following task template format

# =============================================================================
# TASK 1: Application Structure and Character Data
# =============================================================================

task:
  id: 1
  name: "Basic Application Structure and Character Data Management"

context:
  description: |
    Establish the foundational application structure using iced's Elm architecture.
    This task creates the core infrastructure for the entire application, including
    the main application loop, state management system, and character data loading
    mechanisms. The Elm architecture (State → View → Message → Update) provides a
    predictable, testable foundation for all subsequent features. Character data
    management uses compile-time static maps for zero-cost lookups, ensuring
    excellent performance even with large character sets.

  key_points:
    - "Elm architecture provides unidirectional data flow and predictable state updates"
    - "Static character data using phf crate enables O(1) lookup with zero runtime cost"
    - "RON format provides human-readable, maintainable character data files"
    - "Proper separation of concerns: state, view, and update logic are isolated"
    - "Foundation enables all subsequent features without architectural changes"

files:
  - path: "src/main.rs"
    description: "Application entry point and iced runtime initialization"
  - path: "src/state/mod.rs"
    description: "Core application state structure"
  - path: "src/state/navigation.rs"
    description: "Screen management and navigation state"
  - path: "src/models/character.rs"
    description: "Character data structures and lookup systems"
  - path: "data/hiragana.ron"
    description: "Hiragana character data with stroke information"

functions:
  - file: "src/main.rs"
    items:
      - type: "function"
        name: "main"
        description: "Application entry point, initializes iced runtime"
        postconditions: "Application window opens successfully"

  - file: "src/state/mod.rs"
    items:
      - type: "struct"
        name: "AppState"
        description: "Central application state following Elm architecture"
        invariants: "State transitions only occur through update() method"

      - type: "enum"
        name: "Message"
        description: "All possible messages for state updates"
        invariants: "Each message type has corresponding handler in update()"

      - type: "trait_impl"
        name: "Application for App"
        description: "Implements iced Application trait"
        preconditions: "Valid AppState exists"
        postconditions: "Messages trigger view updates"

  - file: "src/models/character.rs"
    items:
      - type: "struct"
        name: "CharData"
        description: "Character data model with stroke information"
        invariants: "Unicode value matches character, stroke count matches strokes.len()"

      - type: "static"
        name: "HIRAGANA"
        description: "Compile-time perfect hash map for hiragana characters"
        invariants: "Contains all 46 basic hiragana characters"

      - type: "function"
        name: "get_char_data"
        description: "Retrieves character data by character"
        preconditions: "Character is valid hiragana"
        postconditions: "Returns Some(CharData) for valid characters, None otherwise"

formal_verification:
  needed: false
  level: "None"
  explanation: |
    Formal verification is not needed for basic data structures and state management.
    Unit tests provide sufficient validation for this foundational layer. The static
    nature of character data and deterministic state transitions make testing
    straightforward.

tests:
  strategy:
    approach: "unit tests"
    rationale:
      - "Data structures can be tested in isolation"
      - "State transitions are deterministic and testable"
      - "Character data loading can be verified independently"
    coverage_goals:
      - "All 46 hiragana characters load successfully"
      - "Character lookups return correct data"
      - "Invalid lookups return None"
      - "State transitions follow expected patterns"

  implementation:
    file: "src/models/character.rs"
    location: "in existing test module"
    code: |
      #[cfg(test)]
      mod tests {
          use super::*;

          #[test]
          fn test_all_hiragana_load() {
              // Verify all 46 basic hiragana characters are present
              let expected = ['あ', 'い', 'う', 'え', 'お', /* ... */];
              for ch in expected {
                  assert!(get_char_data(ch).is_some());
              }
          }

          #[test]
          fn test_char_data_structure() {
              let data = get_char_data('あ').unwrap();
              assert_eq!(data.unicode, 0x3042);
              assert_eq!(data.romaji, "a");
              assert_eq!(data.stroke_count, data.strokes.len());
          }

          #[test]
          fn test_invalid_character() {
              assert!(get_char_data('x').is_none());
              assert!(get_char_data('漢').is_none());
          }
      }

  coverage:
    - "All hiragana characters load from data file"
    - "Character lookup returns correct CharData"
    - "Invalid characters return None"
    - "State structure initializes correctly"
    - "Message enum covers all required actions"

dependencies:
  depends_on:
    - task_id: "none"
      reason: "Foundation task with no dependencies"

  depended_upon_by:
    - task_id: 2
      reason: "Character rendering requires CharData structures"
    - task_id: 3
      reason: "SRS system requires app state infrastructure"
    - task_id: 5
      reason: "Persistence requires state models to serialize"

  external:
    - name: "iced"
      type: "crate"
      status: "to be imported"
    - name: "serde"
      type: "crate"
      status: "to be imported"
    - name: "ron"
      type: "crate"
      status: "to be imported"
    - name: "phf"
      type: "crate"
      status: "to be imported"

# =============================================================================
# TASK 2: Japanese Text Rendering
# =============================================================================

task:
  id: 2
  name: "Japanese Text Rendering and Flashcard Display"

context:
  description: |
    Implement proper Japanese character rendering using iced's cosmic-text backend
    with full Unicode support. Japanese characters require advanced text shaping to
    render correctly, which cosmic-text provides through Shaping::Advanced. This task
    creates a custom CharacterCard widget that handles font loading, proper typography,
    and provides a reusable component for all character display needs throughout the
    application. The widget will support future enhancements like stroke order overlays.

  key_points:
    - "cosmic-text provides full Unicode support including Japanese characters"
    - "Shaping::Advanced is required for proper glyph rendering"
    - "Embedding fonts ensures portability across systems"
    - "Custom widget enables consistent character display throughout app"
    - "Large font sizes (48-72px) ensure clarity for learning"

files:
  - path: "src/ui/flashcard.rs"
    description: "CharacterCard widget implementation"
  - path: "assets/fonts/NotoSansJP-Regular.otf"
    description: "Embedded Japanese font"

functions:
  - file: "src/ui/flashcard.rs"
    items:
      - type: "struct"
        name: "CharacterCard"
        description: "Custom widget for displaying Japanese characters"
        invariants: "Character is valid Unicode, font is loaded"

      - type: "function"
        name: "load_japanese_font"
        description: "Loads embedded Noto Sans JP font at startup"
        postconditions: "Font is available for rendering"

      - type: "function"
        name: "view_character"
        description: "Creates Element displaying character with proper rendering"
        preconditions: "Font loaded, character is valid"
        postconditions: "Returns Element with properly rendered character"

formal_verification:
  needed: false
  level: "None"
  explanation: |
    Font rendering is handled by iced and cosmic-text libraries, which are
    well-tested. Visual testing and snapshot tests provide adequate verification.

tests:
  strategy:
    approach: "property-based"
    rationale:
      - "Visual rendering requires property verification"
      - "Font loading behavior should be consistent"
      - "Character sizing and positioning can be tested"
    coverage_goals:
      - "All hiragana render without garbled glyphs"
      - "Font loads successfully on all platforms"
      - "Character remains centered and sized correctly"

  implementation:
    file: "src/ui/flashcard.rs"
    location: "create new"
    code: |
      #[cfg(test)]
      mod tests {
          use super::*;

          #[test]
          fn test_font_loads() {
              let font = load_japanese_font();
              assert!(font.is_ok());
          }

          #[test]
          fn test_character_card_creation() {
              let card = CharacterCard {
                  character: 'あ',
                  font: Font::with_name("Noto Sans JP"),
                  size: 64.0,
                  show_stroke_order: false,
              };
              assert_eq!(card.character, 'あ');
          }
      }

  coverage:
    - "Font loading succeeds"
    - "CharacterCard widget creates successfully"
    - "Japanese characters display correctly"

dependencies:
  depends_on:
    - task_id: 1
      reason: "Requires CharData structures and app infrastructure"

  depended_upon_by:
    - task_id: 3
      reason: "Learning session displays characters using this widget"
    - task_id: 4
      reason: "Stroke animation builds on character display foundation"

  external:
    - name: "cosmic-text"
      type: "crate"
      status: "already exists"
    - name: "Noto Sans JP font"
      type: "external"
      status: "to be imported"

# =============================================================================
# TASK 3: Spaced Repetition System
# =============================================================================

task:
  id: 3
  name: "SM-2 Spaced Repetition System and Learning Session"

context:
  description: |
    Implement the SM-2 spaced repetition algorithm, the most widely-used and
    scientifically-validated method for optimizing learning intervals. The algorithm
    adjusts card difficulty (ease factor) based on user performance and schedules
    reviews at exponentially increasing intervals. This task also implements the
    review queue system that prioritizes cards based on learning state and creates
    the core learning session flow that orchestrates the review process.

  key_points:
    - "SM-2 algorithm scientifically proven for long-term retention"
    - "Ease factor adjusts based on quality rating (0-5 scale)"
    - "Queue prioritization: learning > review > new cards"
    - "Failed cards (quality < 3) reset to learning state"
    - "Daily limits prevent cognitive overload"

files:
  - path: "src/scheduler/sm2.rs"
    description: "SM-2 algorithm implementation"
  - path: "src/scheduler/queue.rs"
    description: "Review queue management"
  - path: "src/state/learning.rs"
    description: "Learning session state and flow"

functions:
  - file: "src/scheduler/sm2.rs"
    items:
      - type: "struct"
        name: "SM2Card"
        description: "Card state with ease factor and interval tracking"
        invariants: "ease_factor >= 1.3, interval_days >= 0, repetitions >= 0"

      - type: "method"
        name: "SM2Card::review"
        description: "Updates card state based on quality rating"
        preconditions: "quality in 0..=5"
        postconditions: "ease_factor >= 1.3, next_review scheduled, interval updated"
        invariants: "Failed cards (quality < 3) have interval = 1 and repetitions = 0"

  - file: "src/scheduler/queue.rs"
    items:
      - type: "struct"
        name: "ReviewQueue"
        description: "Manages prioritization of cards for review"
        invariants: "Learning cards scheduled before review cards before new cards"

      - type: "method"
        name: "ReviewQueue::get_next_card"
        description: "Returns next card to review based on priority"
        postconditions: "Returns learning card if available, else review card, else new card"

formal_verification:
  needed: false
  level: "None"
  explanation: |
    While SM-2 has mathematical properties, unit and property-based tests provide
    sufficient validation. The algorithm is well-established and its correctness
    can be verified through comparison with reference implementations.

tests:
  strategy:
    approach: "mixed"
    rationale:
      - "Unit tests verify algorithm correctness"
      - "Property tests ensure mathematical invariants"
      - "Integration tests validate session flows"
    coverage_goals:
      - "SM-2 algorithm matches specification"
      - "Queue prioritization maintains order"
      - "Session completes without state errors"

  implementation:
    file: "src/scheduler/sm2.rs"
    location: "in existing test module"
    code: |
      #[cfg(test)]
      mod tests {
          use super::*;

          #[test]
          fn test_sm2_algorithm() {
              let mut card = SM2Card::new('あ');

              // Perfect recall sequence
              card.review(5);
              assert_eq!(card.interval_days, 1);
              assert!(card.ease_factor > 2.5);

              card.review(5);
              assert_eq!(card.interval_days, 6);

              card.review(5);
              assert_eq!(card.interval_days, 15);

              // Failure resets
              card.review(2);
              assert_eq!(card.interval_days, 1);
              assert_eq!(card.repetitions, 0);
          }

          #[test]
          fn test_ease_factor_bounds() {
              let mut card = SM2Card::new('い');

              // Repeated failures should not drop below minimum
              for _ in 0..10 {
                  card.review(0);
                  assert!(card.ease_factor >= 1.3);
              }
          }

          #[test]
          fn test_queue_priority() {
              let mut queue = ReviewQueue::new();

              let learning = SM2Card {
                  character: 'あ',
                  next_review: Utc::now() - Duration::hours(1),
                  interval_days: 0,
                  ..Default::default()
              };

              let review = SM2Card {
                  character: 'い',
                  next_review: Utc::now() - Duration::hours(1),
                  interval_days: 7,
                  ..Default::default()
              };

              queue.learning_cards.push(learning);
              queue.review_cards.push(review);
              queue.new_cards.push('う');

              // Should prioritize learning
              let next = queue.get_next_card().unwrap();
              assert_eq!(next.character(), 'あ');
          }
      }

  coverage:
    - "SM-2 algorithm produces correct intervals"
    - "Ease factor bounds enforced"
    - "Failed cards reset correctly"
    - "Queue prioritization maintained"
    - "Daily limits enforced"
    - "Review history recorded"

dependencies:
  depends_on:
    - task_id: 1
      reason: "Requires character data and app state"
    - task_id: 2
      reason: "Learning session needs flashcard display"

  depended_upon_by:
    - task_id: 5
      reason: "Progress persistence needs SM2Card structures"
    - task_id: 6
      reason: "Statistics require review history"

  external:
    - name: "chrono"
      type: "crate"
      status: "to be imported"

# =============================================================================
# TASK 4: Stroke Order Animation
# =============================================================================

task:
  id: 4
  name: "Stroke Order Animation System"

context:
  description: |
    Create a GPU-accelerated stroke order animation system using iced's Canvas widget
    and lyon for path tessellation. Stroke order is fundamental to properly writing
    Japanese characters. The animation system parses SVG path data from character
    definitions, calculates path lengths for partial rendering, and sequences strokes
    with appropriate timing and easing. GPU acceleration via lyon ensures smooth 60fps
    animations even for complex multi-stroke characters.

  key_points:
    - "Canvas widget provides GPU-accelerated rendering"
    - "lyon tessellates SVG paths for efficient rendering"
    - "Partial path rendering creates smooth stroke animations"
    - "EaseOutCubic easing provides natural writing motion"
    - "Sequential timing with pauses between strokes"

files:
  - path: "src/ui/animation.rs"
    description: "Stroke order animation implementation"
  - path: "src/ui/canvas.rs"
    description: "Canvas program for animation rendering"

functions:
  - file: "src/ui/animation.rs"
    items:
      - type: "struct"
        name: "StrokeOrderAnimation"
        description: "Manages animation state and timing"
        invariants: "current_stroke < strokes.len(), progress in 0.0..=1.0"

      - type: "struct"
        name: "StrokePath"
        description: "Individual stroke with partial rendering support"
        invariants: "total_length > 0.0"

      - type: "method"
        name: "StrokePath::partial_path"
        description: "Calculates partial stroke based on animation progress"
        preconditions: "progress in 0.0..=1.0"
        postconditions: "Returns path with length = total_length * progress"

  - file: "src/ui/canvas.rs"
    items:
      - type: "trait_impl"
        name: "canvas::Program for StrokeOrderAnimation"
        description: "Implements Canvas rendering and event handling"
        preconditions: "Valid stroke data exists"
        postconditions: "Strokes render sequentially with animation"

formal_verification:
  needed: false
  level: "None"
  explanation: |
    Animation is primarily visual and timing-based. Manual testing and integration
    tests provide adequate verification. Path mathematics are handled by lyon library.

tests:
  strategy:
    approach: "integration"
    rationale:
      - "Animation behavior requires end-to-end testing"
      - "Timing and sequencing validated through integration"
      - "Visual quality requires manual verification"
    coverage_goals:
      - "Strokes animate in correct sequence"
      - "Partial paths render smoothly"
      - "Animation timing matches specification"

  implementation:
    file: "src/ui/animation.rs"
    location: "create new"
    code: |
      #[cfg(test)]
      mod tests {
          use super::*;

          #[test]
          fn test_stroke_path_length() {
              let stroke = StrokePath::from_svg("M10,10 L90,90");
              assert!(stroke.total_length > 0.0);
          }

          #[test]
          fn test_partial_path() {
              let stroke = StrokePath::from_svg("M0,0 L100,0");
              let partial = stroke.partial_path(0.5);
              // Partial path should be approximately half length
              assert!((partial.length() - 50.0).abs() < 1.0);
          }

          #[test]
          fn test_animation_sequence() {
              let animation = StrokeOrderAnimation::new(vec![
                  StrokePath::from_svg("M10,10 L90,90"),
                  StrokePath::from_svg("M90,10 L10,90"),
              ]);

              assert_eq!(animation.current_stroke, 0);
              assert_eq!(animation.strokes.len(), 2);
          }
      }

  coverage:
    - "SVG path parsing works correctly"
    - "Partial path calculation accurate"
    - "Animation sequences strokes correctly"
    - "Timing parameters produce smooth animation"

dependencies:
  depends_on:
    - task_id: 1
      reason: "Needs stroke data from CharData"
    - task_id: 2
      reason: "Builds on character display foundation"

  depended_upon_by:
    - task_id: 8
      reason: "Practice modes use animation as reference"

  external:
    - name: "lyon"
      type: "crate"
      status: "to be imported"
    - name: "kana-svg-data"
      type: "external"
      status: "needs implementation"

# =============================================================================
# TASK 5: Progress Persistence
# =============================================================================

task:
  id: 5
  name: "Progress Persistence and Database Integration"

context:
  description: |
    Implement local data persistence using redb, a pure Rust embedded database
    providing ACID guarantees without external dependencies. All user progress,
    including card states, review logs, and settings, must persist across sessions.
    The directories crate handles platform-specific data paths (Linux: ~/.local/share,
    macOS: ~/Library/Application Support, Windows: %APPDATA%). Bincode serialization
    provides compact, efficient storage for structured data.

  key_points:
    - "redb provides ACID guarantees with zero external dependencies"
    - "Platform-specific paths ensure proper data storage per OS"
    - "Bincode serialization for compact, fast storage"
    - "Batch transactions for write performance"
    - "Never lose user data - error handling critical"

files:
  - path: "src/persistence/database.rs"
    description: "redb database interface"
  - path: "src/persistence/config.rs"
    description: "Platform-specific path resolution"

functions:
  - file: "src/persistence/database.rs"
    items:
      - type: "struct"
        name: "AppDatabase"
        description: "Database handle and transaction management"
        invariants: "Database file exists and is valid redb format"

      - type: "method"
        name: "AppDatabase::save_card_progress"
        description: "Persists individual card state"
        preconditions: "Valid CardProgress data"
        postconditions: "Data committed to database"

      - type: "method"
        name: "AppDatabase::load_card_progress"
        description: "Retrieves saved card state"
        preconditions: "Character exists in character set"
        postconditions: "Returns Some(CardProgress) if previously saved"

      - type: "method"
        name: "AppDatabase::save_review_log"
        description: "Logs completed reviews"
        preconditions: "Valid ReviewLog data"
        postconditions: "Review log persisted with timestamp key"

formal_verification:
  needed: false
  level: "None"
  explanation: |
    Database persistence relies on redb's ACID guarantees. Integration tests
    can verify data survives application restart. Property tests ensure
    serialization round-trips correctly.

tests:
  strategy:
    approach: "integration"
    rationale:
      - "Persistence requires cross-session testing"
      - "Transaction behavior needs integration verification"
      - "Concurrency handled by redb, but should be tested"
    coverage_goals:
      - "Data survives application restart"
      - "Transactions commit correctly"
      - "Concurrent access handled safely"

  implementation:
    file: "src/persistence/database.rs"
    location: "create new"
    code: |
      #[cfg(test)]
      mod tests {
          use super::*;
          use tempfile::tempdir;

          #[test]
          fn test_save_and_load_card() {
              let dir = tempdir().unwrap();
              let db = AppDatabase::create(dir.path().join("test.db")).unwrap();

              let progress = CardProgress {
                  character: 'あ',
                  review_count: 5,
                  correct_count: 4,
                  ..Default::default()
              };

              db.save_card_progress(&progress).unwrap();
              let loaded = db.load_card_progress('あ').unwrap();

              assert_eq!(loaded.unwrap().review_count, 5);
          }

          #[test]
          fn test_batch_operations() {
              let dir = tempdir().unwrap();
              let db = AppDatabase::create(dir.path().join("test.db")).unwrap();

              let cards: Vec<_> = "あいうえお".chars()
                  .map(|c| CardProgress { character: c, ..Default::default() })
                  .collect();

              let start = Instant::now();
              db.batch_save_cards(&cards).unwrap();
              let duration = start.elapsed();

              assert!(duration < Duration::from_millis(50));
          }
      }

  coverage:
    - "Card progress saves and loads correctly"
    - "Review logs persist with timestamp keys"
    - "Batch operations complete efficiently"
    - "Data survives application restart"
    - "Platform paths work correctly"

dependencies:
  depends_on:
    - task_id: 1
      reason: "Needs state models to persist"
    - task_id: 3
      reason: "SM2Card structures required"

  depended_upon_by:
    - task_id: 6
      reason: "Statistics require persistent review logs"

  external:
    - name: "redb"
      type: "crate"
      status: "to be imported"
    - name: "bincode"
      type: "crate"
      status: "to be imported"
    - name: "directories"
      type: "crate"
      status: "to be imported"

# =============================================================================
# END OF TASKS
# =============================================================================

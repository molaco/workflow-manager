task:
  id: 1
  name: "Project Structure and Application Foundation"

context:
  description: |
    This task establishes the foundational Rust project structure with iced GUI framework
    integration, serving as the architectural skeleton upon which all subsequent features
    will be built. The task creates a modular organization that separates concerns into
    distinct modules: state management, UI components, domain models, data persistence,
    scheduling logic, and data utilities.

    The iced framework (version 0.13) implements the Elm architecture pattern, providing
    a predictable update-view cycle with immutable state management. This architectural
    choice ensures type-safe UI development with clear separation between application
    logic and presentation.

    At this foundational stage, the implementation focuses on creating the project skeleton
    with minimal but functional code: a compilable application that displays a basic window,
    demonstrating the complete application lifecycle from initialization through rendering.
    All modules are created with placeholder mod.rs files to establish the structure,
    enabling parallel development of features in subsequent tasks.

    The Cargo.toml configuration includes all necessary dependencies with appropriate
    feature flags: iced with canvas support for custom drawing, tokio for async runtime,
    and the directories crate for cross-platform data path detection. Release profile
    optimizations are configured from the start to ensure efficient production builds.

  key_points:
    - "Establishes modular architecture with 7 distinct modules separating concerns"
    - "Implements iced::Application trait following Elm architecture pattern for predictable state management"
    - "Configures iced 0.13 with canvas, tokio, and advanced features for full GUI capabilities"
    - "Creates compilable 'Hello World' window demonstrating complete application lifecycle"
    - "Sets foundation for parallel development of subsequent features across modules"
    - "Includes Cargo.toml optimizations for release builds with LTO and minimal codegen units"

files:
  - path: "/home/molaco/Documents/japanese/Cargo.toml"
    description: "Project manifest - configure iced 0.13 with canvas/tokio features, directories crate, and release optimizations"
  - path: "/home/molaco/Documents/japanese/src/main.rs"
    description: "Application entry point - initialize iced Application and launch GUI window"
  - path: "/home/molaco/Documents/japanese/src/lib.rs"
    description: "Library root - declare and expose all application modules"
  - path: "/home/molaco/Documents/japanese/src/app.rs"
    description: "Main Application struct implementing iced::Application trait with Message/update/view lifecycle"
  - path: "/home/molaco/Documents/japanese/src/state/mod.rs"
    description: "State module root - declares state management submodules"
  - path: "/home/molaco/Documents/japanese/src/ui/mod.rs"
    description: "UI module root - declares UI component submodules"
  - path: "/home/molaco/Documents/japanese/src/models/mod.rs"
    description: "Models module root - declares data model submodules"
  - path: "/home/molaco/Documents/japanese/src/persistence/mod.rs"
    description: "Persistence module root - declares database and storage submodules"
  - path: "/home/molaco/Documents/japanese/src/scheduler/mod.rs"
    description: "Scheduler module root - declares spaced repetition algorithm submodules"
  - path: "/home/molaco/Documents/japanese/src/data/mod.rs"
    description: "Data module root - declares character data and asset loading submodules"

functions:
  - file: "/home/molaco/Documents/japanese/src/main.rs"
    items:
      - type: "function"
        name: "main"
        description: "Application entry point that initializes and runs the iced application with window settings"
        preconditions: "None"
        postconditions: "Application window is created and event loop starts; returns Result for error handling"
        invariants: "Must not panic during initialization"

      - type: "struct"
        name: "HabitTrackerApp"
        description: "Main application struct implementing iced::Application trait, maintaining application state throughout lifecycle"
        invariants: "Maintains application state throughout lifecycle; state is always valid"

      - type: "trait_impl"
        name: "impl iced::Application for HabitTrackerApp"
        description: "Implements the iced Application trait with Elm architecture pattern for update-view cycle"
        postconditions: "Application follows Elm update-view cycle with immutable state updates"
        invariants: "Follows Elm architecture pattern with immutable updates"

      - type: "method"
        name: "HabitTrackerApp::new"
        description: "Constructor that initializes the application with default state"
        preconditions: "None"
        postconditions: "Returns initialized HabitTrackerApp instance with valid default state"
        invariants: "Always succeeds; provides valid initial state"

      - type: "method"
        name: "HabitTrackerApp::title"
        description: "Returns the window title string for the application"
        postconditions: "Returns non-empty static string for window title"
        invariants: "Always returns the same title string"

      - type: "method"
        name: "HabitTrackerApp::update"
        description: "Handles application messages and updates state according to Elm architecture"
        preconditions: "Valid Message enum variant is provided"
        postconditions: "State is updated according to message; returns Command for side effects"
        invariants: "Pure function - same message produces same state transition"

      - type: "method"
        name: "HabitTrackerApp::view"
        description: "Renders the current application state to UI elements"
        preconditions: "Valid application state exists"
        postconditions: "Returns iced Element tree representing current UI"
        invariants: "Pure function - same state produces same UI"

      - type: "enum"
        name: "Message"
        description: "Enum defining all possible application messages and events for state updates"
        invariants: "Exhaustive set of all user interactions and system events"

  - file: "/home/molaco/Documents/japanese/src/lib.rs"
    items:
      - type: "module_declaration"
        name: "pub mod state"
        description: "Declares and exports the state management module for application state structures"

      - type: "module_declaration"
        name: "pub mod ui"
        description: "Declares and exports the UI components and rendering module"

      - type: "module_declaration"
        name: "pub mod models"
        description: "Declares and exports the data models and domain types module"

      - type: "module_declaration"
        name: "pub mod persistence"
        description: "Declares and exports the data persistence and storage module"

      - type: "module_declaration"
        name: "pub mod scheduler"
        description: "Declares and exports the task scheduling and recurring event management module"

      - type: "module_declaration"
        name: "pub mod data"
        description: "Declares and exports the data utilities and resource management module"

  - file: "/home/molaco/Documents/japanese/src/app.rs"
    items:
      - type: "struct"
        name: "App"
        description: "Main application struct implementing iced::Application trait with state management"
        invariants: "Maintains valid application state throughout lifecycle"

      - type: "trait_impl"
        name: "impl iced::Application for App"
        description: "Implements the iced Application trait providing update, view, and lifecycle methods"
        invariants: "Follows Elm architecture with pure update and view functions"

      - type: "method"
        name: "App::new"
        description: "Creates a new App instance with initialized default state"
        postconditions: "Returns App with valid initial state"

      - type: "method"
        name: "App::title"
        description: "Returns the application window title"
        postconditions: "Returns static string for window title"

      - type: "method"
        name: "App::update"
        description: "Processes messages and updates application state"
        preconditions: "Valid Message is provided"
        postconditions: "State updated according to message semantics"

      - type: "method"
        name: "App::view"
        description: "Renders application state to UI element tree"
        preconditions: "Valid state exists"
        postconditions: "Returns Element representing current UI state"

      - type: "enum"
        name: "Message"
        description: "Application message types for state updates and events"

  - file: "/home/molaco/Documents/japanese/src/state/mod.rs"
    items:
      - type: "module_declaration"
        name: "state"
        description: "State module root - placeholder module for application state management structures and logic"

  - file: "/home/molaco/Documents/japanese/src/ui/mod.rs"
    items:
      - type: "module_declaration"
        name: "ui"
        description: "UI module root - placeholder module for user interface components and view rendering logic"

  - file: "/home/molaco/Documents/japanese/src/models/mod.rs"
    items:
      - type: "module_declaration"
        name: "models"
        description: "Models module root - placeholder module for data structures representing domain entities and types"

  - file: "/home/molaco/Documents/japanese/src/persistence/mod.rs"
    items:
      - type: "module_declaration"
        name: "persistence"
        description: "Persistence module root - placeholder module for data storage, retrieval, and serialization logic"

  - file: "/home/molaco/Documents/japanese/src/scheduler/mod.rs"
    items:
      - type: "module_declaration"
        name: "scheduler"
        description: "Scheduler module root - placeholder module for task scheduling and recurring event management"

  - file: "/home/molaco/Documents/japanese/src/data/mod.rs"
    items:
      - type: "module_declaration"
        name: "data"
        description: "Data module root - placeholder module for data initialization, validation, and management utilities"

  - file: "/home/molaco/Documents/japanese/Cargo.toml"
    items:
      - type: "constant"
        name: "[package]"
        description: "Package metadata defining project name, version, and Rust edition"
        invariants: "Edition must be 2021 or later for modern Rust features"

      - type: "constant"
        name: "[dependencies]"
        description: "Project dependencies including iced 0.13 with canvas, tokio, and advanced features; directories crate for cross-platform paths"
        invariants: "iced version 0.13 with canvas, tokio, and advanced features enabled; includes directories, serde, chrono"

      - type: "constant"
        name: "[profile.release]"
        description: "Release build optimization settings with LTO and minimal codegen units for performance"
        postconditions: "Optimized binary with LTO, opt-level=3, and codegen-units=1"

formal_verification:
  needed: false
  level: "None"
  explanation: |
    Formal verification is not needed for Task 1 (Project Structure and Application Foundation) because:
    
    1. SCOPE: This task involves basic scaffolding code - module declarations, project structure setup, and minimal trait implementations. There are no complex algorithms, data structures, or invariants to verify.
    
    2. RISK PROFILE: The code consists of standard boilerplate for iced GUI applications. The iced::Application trait implementation at this stage contains only simple message passing and basic view rendering with no critical business logic.
    
    3. VERIFICATION OVERKILL: Formal verification would provide negligible value for:
       - Module organization (pub mod declarations)
       - Empty or trivial trait method implementations
       - Dependency declarations in Cargo.toml
       - "Hello World" window rendering
    
    4. SUFFICIENT ASSURANCE: The Rust compiler's type system, ownership model, and borrow checker provide adequate safety guarantees for this structural code. Standard testing (compilation, smoke tests) is sufficient.
    
    5. NO CRITICAL PROPERTIES: There are no safety-critical, security-sensitive, or correctness-critical properties to verify at this foundational stage. No data integrity constraints, no concurrent access patterns, no algorithmic correctness requirements.
    
    RECOMMENDATION: Rely on Rust's compile-time guarantees and basic integration testing. Reserve formal verification for later tasks involving complex state management, data processing logic, or critical application features.

tests:
  strategy:
    approach: "unit tests with compilation verification"
    rationale:
      - "Task focuses on project structure and foundational setup with minimal business logic"
      - "Primary verification ensures project compiles with iced dependencies correctly configured"
      - "Tests validate iced::Application trait implementation and basic lifecycle methods"
      - "Verifies module structure is correctly organized and accessible"
      - "Smoke tests confirm iced integration works and application can be instantiated"
      - "No complex logic exists yet, so tests focus on structural integrity and compilation success"

  implementation:
    file: "/home/molaco/Documents/japanese/src/app.rs"
    location: "create new"
    code: |
      #[cfg(test)]
      mod tests {
          use super::*;
          
          #[test]
          fn test_app_instantiation() {
              // Verify that HabitTrackerApp can be created
              // This ensures the Application trait's new method works correctly
              let app = HabitTrackerApp::new();
              // Test passes if instantiation succeeds without panicking
              assert!(true);
          }
          
          #[test]
          fn test_app_title() {
              // Verify the application title is set correctly
              let app = HabitTrackerApp::new();
              let title = <HabitTrackerApp as iced::Application>::title(&app);
              assert!(!title.is_empty(), "Application title should not be empty");
              assert!(title.contains("Habit") || title.contains("Japanese"), 
                      "Title should be relevant to the application purpose");
          }
          
          #[test]
          fn test_app_update_message_handling() {
              // Verify that the update method can handle messages without panicking
              let mut app = HabitTrackerApp::new();
              // Create a simple test message (assuming Message enum exists)
              // The update should return a Command
              let _cmd = app.update(Message::default());
              // Test passes if update completes without panic
          }
          
          #[test]
          fn test_app_view_renders() {
              // Verify that the view method produces valid iced Element
              let app = HabitTrackerApp::new();
              let _element = app.view();
              // Test passes if view() returns without panic
              // This confirms the UI rendering pipeline is functional
          }
          
          #[test]
          fn test_message_enum_exists() {
              // Verify Message enum compiles and has required traits
              let _msg = Message::default();
              // Test passes if Message type is properly defined
          }
      }

  coverage:
    - "HabitTrackerApp struct instantiation via new() method"
    - "Application trait implementation compiles correctly"
    - "Application title() method returns non-empty string"
    - "Message enum is properly defined with required traits"
    - "Update method accepts messages and returns Command without panicking"
    - "View method renders and returns valid iced Element"
    - "All module imports are accessible (state, ui, models, persistence, scheduler, data)"
    - "Project compiles successfully with iced 0.13 dependencies"
    - "Basic Elm architecture pattern is correctly implemented"
    - "Type-safe message passing works as expected"

dependencies:
  depends_on: []

  depended_upon_by:
    - task_id: 2
      reason: "Character data structures need module structure to exist"
    - task_id: 3
      reason: "Font loading requires application foundation"
    - task_id: 6
      reason: "State management builds on application structure"

  external:
    - name: "iced"
      type: "crate"
      status: "to be imported"
    - name: "iced::Application"
      type: "trait"
      status: "to be imported"
    - name: "iced::Element"
      type: "struct"
      status: "to be imported"
    - name: "iced::Command"
      type: "enum"
      status: "to be imported"
    - name: "iced::Settings"
      type: "struct"
      status: "to be imported"
    - name: "directories"
      type: "crate"
      status: "to be imported"
---
task:
  id: 2
  name: "Character Data Structures and Loading System"

context:
  description: |
    This task establishes the foundational character database for the entire Japanese learning application.
    It defines core data structures for representing hiragana and katakana characters, including their Unicode
    values, romanization, stroke path data, and metadata needed for animation and learning features.
    
    The implementation uses a compile-time perfect hash map (phf::Map) to provide zero-cost O(1) character
    lookups while maintaining human-readable data in RON (Rusty Object Notation) format. The character data
    is embedded directly into the binary at compile time using include_str!(), eliminating runtime I/O overhead
    and ensuring data availability without external file dependencies.
    
    This architecture choice prioritizes performance and simplicity for the MVP while maintaining flexibility
    to switch to runtime loading or binary serialization formats (like bincode) in future iterations if needed.
    The stroke path data, sourced from repositories like kana-svg-data or animCJK, enables stroke-order animation
    and practice features that are central to the learning experience.

  key_points:
    - "Compile-time embedding trades binary size (~100KB for stroke data) for zero runtime initialization cost and guaranteed data availability"
    - "phf::Map provides perfect hashing for O(1) lookups without HashMap runtime overhead or lazy initialization complexity"
    - "RON format enables human-readable data editing and version control visibility, supporting easy corrections and additions"
    - "Stroke path data stored as SVG strings supports on-demand parsing for animation, avoiding upfront processing cost for characters that may never be animated"
    - "Frequency rank metadata enables ordered character presentation (teaching common characters first) and adaptive learning algorithms"
    - "Separation of hiragana and katakana databases allows selective loading and independent extension (e.g., adding dakuten, handakuten variations later)"

files:
  - path: "src/models/character.rs"
    description: "Defines CharData and StrokePath structs representing kana characters with Unicode, romanization, stroke paths, and metadata"
  - path: "src/models/mod.rs"
    description: "Module declaration file exposing the character module"
  - path: "src/data/mod.rs"
    description: "Data module root declaring and exposing hiragana and katakana submodules, plus high-level query functions"
  - path: "src/data/hiragana.rs"
    description: "Hiragana character database with phf::Map and lookup functions, embedding hiragana.ron data"
  - path: "src/data/katakana.rs"
    description: "Katakana character database with phf::Map and lookup functions, embedding katakana.ron data"
  - path: "data/hiragana.ron"
    description: "RON-formatted data file containing all 46 hiragana characters with stroke paths, Unicode values, romanization, and frequency rankings"
  - path: "data/katakana.ron"
    description: "RON-formatted data file containing all 46 katakana characters with stroke paths, Unicode values, romanization, and frequency rankings"
  - path: "src/lib.rs"
    description: "Library root file declaring models and data modules to expose character data structures and lookup functions"
  - path: "Cargo.toml"
    description: "Project manifest requiring dependencies: serde, ron, phf, phf_codegen for serialization and compile-time lookups; proptest for property-based testing"

functions:
  - file: "src/models/character.rs"
    items:
      - type: "enum"
        name: "CharacterType"
        description: "Discriminates between hiragana and katakana character types"
        invariants: "Only two variants exist: Hiragana and Katakana"
      - type: "enum_variant"
        name: "CharacterType::Hiragana"
        description: "Represents a hiragana character"
      - type: "enum_variant"
        name: "CharacterType::Katakana"
        description: "Represents a katakana character"
      - type: "struct"
        name: "StrokeData"
        description: "Represents a single stroke with SVG path data and optional median points for direction visualization"
        invariants: "Path data must be valid SVG path string; median points array length matches stroke segment count if present"
      - type: "struct"
        name: "CharData"
        description: "Complete representation of a kana character including Unicode, romanization, stroke data, and metadata"
        invariants: "unicode must be valid kana character; stroke_count must equal stroke_paths.len(); frequency_rank must be 1-46 for standard kana"
      - type: "method"
        name: "CharData::new(unicode: char, romanization: String, stroke_count: usize, stroke_paths: Vec<StrokeData>, frequency_rank: usize, character_type: CharacterType) -> Self"
        description: "Constructor for CharData with all required fields"
        preconditions: "stroke_count must match stroke_paths.len(); unicode must be valid hiragana or katakana"
        postconditions: "Returns a fully initialized CharData instance"
      - type: "method"
        name: "CharData::unicode_char(&self) -> char"
        description: "Returns the character as a Rust char type"
        postconditions: "Returns the unicode field value"
      - type: "method"
        name: "CharData::is_hiragana(&self) -> bool"
        description: "Checks if character is hiragana type"
        postconditions: "Returns true if character_type is CharacterType::Hiragana"
      - type: "method"
        name: "CharData::is_katakana(&self) -> bool"
        description: "Checks if character is katakana type"
        postconditions: "Returns true if character_type is CharacterType::Katakana"
      - type: "method"
        name: "StrokeData::new(path: String, median_points: Option<Vec<(f32, f32)>>) -> Self"
        description: "Constructor for StrokeData with SVG path and optional median points"
        preconditions: "path must be valid SVG path syntax"
        postconditions: "Returns initialized StrokeData instance"

  - file: "src/data/mod.rs"
    items:
      - type: "module_declaration"
        name: "mod hiragana"
        description: "Module containing hiragana character database"
      - type: "module_declaration"
        name: "mod katakana"
        description: "Module containing katakana character database"
      - type: "function"
        name: "pub fn get_character(c: char) -> Option<&'static CharData>"
        description: "Retrieves character data by Unicode character from both hiragana and katakana databases"
        preconditions: "Input character should be valid hiragana or katakana Unicode point"
        postconditions: "Returns Some(&CharData) if found in either database, None otherwise"
      - type: "function"
        name: "pub fn get_all_hiragana() -> Vec<&'static CharData>"
        description: "Returns all hiragana characters as a vector"
        postconditions: "Returns vector of 46 standard hiragana CharData references"
      - type: "function"
        name: "pub fn get_all_katakana() -> Vec<&'static CharData>"
        description: "Returns all katakana characters as a vector"
        postconditions: "Returns vector of 46 standard katakana CharData references"
      - type: "function"
        name: "pub fn get_by_romanization(romanization: &str) -> Vec<&'static CharData>"
        description: "Retrieves character data by romanization string (e.g., 'ka', 'shi')"
        preconditions: "Romanization should be valid Hepburn romanization"
        postconditions: "Returns Vec of matching CharData (may contain both hiragana and katakana for the same sound)"

  - file: "src/data/hiragana.rs"
    items:
      - type: "constant"
        name: "const HIRAGANA_DATA_STR: &str"
        description: "Embedded RON file contents for hiragana characters using include_str! macro"
        invariants: "Contains compile-time embedded hiragana.ron file contents"
      - type: "constant"
        name: "static HIRAGANA_MAP: phf::Map<&'static str, CharData>"
        description: "Static phf::Map providing O(1) lookup for hiragana characters by romanization"
        invariants: "Contains all 46 standard hiragana characters; available for entire program lifetime; collision-free perfect hash"
      - type: "function"
        name: "pub fn get_hiragana(romanization: &str) -> Option<&'static CharData>"
        description: "Retrieves specific hiragana character data by romanization"
        preconditions: "Input should be valid hiragana romanization"
        postconditions: "Returns Some(&CharData) if character exists in database, None otherwise"
      - type: "function"
        name: "pub fn get_hiragana_by_char(c: char) -> Option<&'static CharData>"
        description: "Retrieves specific hiragana character data by Unicode char"
        preconditions: "Input must be valid hiragana Unicode character"
        postconditions: "Returns Some(&CharData) if character exists, None otherwise"

  - file: "src/data/katakana.rs"
    items:
      - type: "constant"
        name: "const KATAKANA_DATA_STR: &str"
        description: "Embedded RON file contents for katakana characters using include_str! macro"
        invariants: "Contains compile-time embedded katakana.ron file contents"
      - type: "constant"
        name: "static KATAKANA_MAP: phf::Map<&'static str, CharData>"
        description: "Static phf::Map providing O(1) lookup for katakana characters by romanization"
        invariants: "Contains all 46 standard katakana characters; available for entire program lifetime; collision-free perfect hash"
      - type: "function"
        name: "pub fn get_katakana(romanization: &str) -> Option<&'static CharData>"
        description: "Retrieves specific katakana character data by romanization"
        preconditions: "Input should be valid katakana romanization"
        postconditions: "Returns Some(&CharData) if character exists in database, None otherwise"
      - type: "function"
        name: "pub fn get_katakana_by_char(c: char) -> Option<&'static CharData>"
        description: "Retrieves specific katakana character data by Unicode char"
        preconditions: "Input must be valid katakana Unicode character"
        postconditions: "Returns Some(&CharData) if character exists, None otherwise"

formal_verification:
  needed: false
  level: "None"
  explanation: |
    Formal verification is not needed for this task because:

    1. Static, Deterministic Data: The character data is completely static and deterministic.
       All 92 characters have fixed Unicode values, romanization, and stroke paths that
       do not change at runtime. This makes the system highly predictable and testable
       through conventional means.

    2. Property Testing is Sufficient: The critical properties identified (all 92 characters
       present, valid Unicode points, correct stroke counts, valid SVG paths) are well-suited
       to property-based testing rather than formal verification. Property tests can efficiently
       validate data completeness and structural integrity.

    3. Low Risk Profile: The task has been assessed as low risk across all dimensions
       (complexity, integration, testing). There are no safety-critical requirements,
       concurrent access patterns, or complex invariants that would justify the overhead
       of formal verification.

    4. No Complex Invariants: The system does not maintain complex state invariants or
       perform intricate transformations that could benefit from formal proofs. The main
       concerns are data completeness and format validity, which are straightforward to
       test with unit and property tests.

    5. Verification Overhead Not Justified: Formal verification requires significant
       investment in time and expertise. For a data loading system with deterministic
       behavior and comprehensive test coverage, this overhead is not warranted.

    The recommended testing strategy (unit tests + property tests) provides adequate
    assurance for this task while remaining cost-effective and maintainable.

tests:
  strategy:
    approach: "mixed (unit tests + property-based tests)"
    rationale:
      - "Character data is static and deterministic, making unit tests ideal for verifying data integrity, lookup correctness, and completeness"
      - "Property-based tests ensure data invariants hold across all 92 characters (valid Unicode, stroke counts, romanization patterns)"
      - "SVG path parsing requires both unit tests for valid paths and property tests for error handling edge cases"
      - "Compile-time phf::Map lookups need verification of O(1) performance characteristics and collision-free hashing"

  implementation:
    file: "src/data/mod.rs"
    location: "in existing test module"
    code: |
      #[cfg(test)]
      mod tests {
          use super::*;
          
          // ============================================================================
          // Test 1-2: Character Count Verification
          // ============================================================================
          
          #[test]
          fn test_hiragana_count() {
              let hiragana_chars = get_all_hiragana();
              let count = hiragana_chars.len();
              assert_eq!(
                  count, 46,
                  "Expected 46 hiragana characters, found {}",
                  count
              );
          }
          
          #[test]
          fn test_katakana_count() {
              let katakana_chars = get_all_katakana();
              let count = katakana_chars.len();
              assert_eq!(
                  count, 46,
                  "Expected 46 katakana characters, found {}",
                  count
              );
          }
          
          // ============================================================================
          // Test 3-4: Unicode Validity
          // ============================================================================
          
          #[test]
          fn test_hiragana_unicode_validity() {
              for char_data in get_all_hiragana() {
                  let code_point = char_data.unicode as u32;
                  assert!(
                      code_point >= 0x3040 && code_point <= 0x309F,
                      "Character '{}' (romanization: {}) has invalid hiragana Unicode: U+{:04X}",
                      char_data.unicode,
                      char_data.romanization,
                      code_point
                  );
                  
                  assert!(
                      char::from_u32(code_point).is_some(),
                      "Invalid Unicode code point U+{:04X} for {}",
                      code_point,
                      char_data.romanization
                  );
              }
          }
          
          #[test]
          fn test_katakana_unicode_validity() {
              for char_data in get_all_katakana() {
                  let code_point = char_data.unicode as u32;
                  assert!(
                      code_point >= 0x30A0 && code_point <= 0x30FF,
                      "Character '{}' (romanization: {}) has invalid katakana Unicode: U+{:04X}",
                      char_data.unicode,
                      char_data.romanization,
                      code_point
                  );
                  
                  assert!(
                      char::from_u32(code_point).is_some(),
                      "Invalid Unicode code point U+{:04X} for {}",
                      code_point,
                      char_data.romanization
                  );
              }
          }
          
          // ============================================================================
          // Test 5-6: Stroke Count Validation
          // ============================================================================
          
          #[test]
          fn test_stroke_counts_within_valid_range() {
              for char_data in get_all_hiragana() {
                  assert!(
                      char_data.stroke_count >= 1 && char_data.stroke_count <= 4,
                      "Hiragana '{}' has invalid stroke count: {}",
                      char_data.romanization,
                      char_data.stroke_count
                  );
              }
              
              for char_data in get_all_katakana() {
                  assert!(
                      char_data.stroke_count >= 1 && char_data.stroke_count <= 4,
                      "Katakana '{}' has invalid stroke count: {}",
                      char_data.romanization,
                      char_data.stroke_count
                  );
              }
          }
          
          #[test]
          fn test_stroke_count_matches_path_count() {
              for char_data in get_all_hiragana() {
                  let path_count = char_data.stroke_paths.len();
                  assert_eq!(
                      char_data.stroke_count, path_count,
                      "Hiragana '{}': stroke_count ({}) doesn't match path count ({})",
                      char_data.romanization,
                      char_data.stroke_count,
                      path_count
                  );
              }
              
              for char_data in get_all_katakana() {
                  let path_count = char_data.stroke_paths.len();
                  assert_eq!(
                      char_data.stroke_count, path_count,
                      "Katakana '{}': stroke_count ({}) doesn't match path count ({})",
                      char_data.romanization,
                      char_data.stroke_count,
                      path_count
                  );
              }
          }
          
          // ============================================================================
          // Test 7-8: SVG Path Parsing
          // ============================================================================
          
          #[test]
          fn test_svg_paths_are_non_empty() {
              for char_data in get_all_hiragana() {
                  for (i, stroke) in char_data.stroke_paths.iter().enumerate() {
                      assert!(
                          !stroke.path.is_empty(),
                          "Hiragana '{}' stroke {} has empty SVG path",
                          char_data.romanization,
                          i + 1
                      );
                      
                      assert!(
                          stroke.path.starts_with('M') || stroke.path.starts_with('m'),
                          "Hiragana '{}' stroke {} doesn't start with M/m command: {}",
                          char_data.romanization,
                          i + 1,
                          stroke.path
                      );
                  }
              }
              
              for char_data in get_all_katakana() {
                  for (i, stroke) in char_data.stroke_paths.iter().enumerate() {
                      assert!(
                          !stroke.path.is_empty(),
                          "Katakana '{}' stroke {} has empty SVG path",
                          char_data.romanization,
                          i + 1
                      );
                      
                      assert!(
                          stroke.path.starts_with('M') || stroke.path.starts_with('m'),
                          "Katakana '{}' stroke {} doesn't start with M/m command: {}",
                          char_data.romanization,
                          i + 1,
                          stroke.path
                      );
                  }
              }
          }
          
          #[test]
          fn test_svg_paths_parse_without_panics() {
              fn validate_svg_path(path: &str) -> bool {
                  let valid_commands = "MLCQAZmlcqaz";
                  let mut chars = path.chars().peekable();
                  
                  while let Some(ch) = chars.next() {
                      if ch.is_alphabetic() {
                          if !valid_commands.contains(ch) {
                              return false;
                          }
                      }
                  }
                  true
              }
              
              for char_data in get_all_hiragana() {
                  for (i, stroke) in char_data.stroke_paths.iter().enumerate() {
                      assert!(
                          validate_svg_path(&stroke.path),
                          "Hiragana '{}' stroke {} has invalid SVG path syntax: {}",
                          char_data.romanization,
                          i + 1,
                          stroke.path
                      );
                  }
              }
              
              for char_data in get_all_katakana() {
                  for (i, stroke) in char_data.stroke_paths.iter().enumerate() {
                      assert!(
                          validate_svg_path(&stroke.path),
                          "Katakana '{}' stroke {} has invalid SVG path syntax: {}",
                          char_data.romanization,
                          i + 1,
                          stroke.path
                      );
                  }
              }
          }
          
          // ============================================================================
          // Test 9-10: Lookup Correctness
          // ============================================================================
          
          #[test]
          fn test_lookup_returns_correct_character() {
              let a_hiragana = get_by_romanization("a");
              assert!(!a_hiragana.is_empty(), "Failed to lookup romanization 'a'");
              
              let hiragana_only: Vec<_> = a_hiragana.iter()
                  .filter(|c| c.is_hiragana())
                  .collect();
              assert_eq!(hiragana_only.len(), 1);
              assert_eq!(hiragana_only[0].unicode, 'あ');
              
              let katakana_only: Vec<_> = a_hiragana.iter()
                  .filter(|c| c.is_katakana())
                  .collect();
              assert_eq!(katakana_only.len(), 1);
              assert_eq!(katakana_only[0].unicode, 'ア');
              
              let ka_chars = get_by_romanization("ka");
              let ka_hiragana: Vec<_> = ka_chars.iter()
                  .filter(|c| c.is_hiragana())
                  .collect();
              assert_eq!(ka_hiragana[0].unicode, 'か');
              
              let ka_katakana: Vec<_> = ka_chars.iter()
                  .filter(|c| c.is_katakana())
                  .collect();
              assert_eq!(ka_katakana[0].unicode, 'カ');
          }
          
          #[test]
          fn test_lookup_nonexistent_returns_empty() {
              assert!(
                  get_by_romanization("invalid_key").is_empty(),
                  "Expected empty vec for invalid lookup"
              );
              
              assert!(
                  get_by_romanization("nonexistent").is_empty(),
                  "Expected empty vec for nonexistent romanization"
              );
              
              assert!(
                  get_by_romanization("").is_empty(),
                  "Expected empty vec for empty string lookup"
              );
          }
          
          // ============================================================================
          // Test 11: Romanization Correctness
          // ============================================================================
          
          #[test]
          fn test_romanization_consistency() {
              for char_data in get_all_hiragana() {
                  let lookup_result = get_by_romanization(&char_data.romanization);
                  assert!(
                      lookup_result.iter().any(|c| c.unicode == char_data.unicode),
                      "Hiragana '{}' not found by its own romanization",
                      char_data.romanization
                  );
              }
              
              for char_data in get_all_katakana() {
                  let lookup_result = get_by_romanization(&char_data.romanization);
                  assert!(
                      lookup_result.iter().any(|c| c.unicode == char_data.unicode),
                      "Katakana '{}' not found by its own romanization",
                      char_data.romanization
                  );
              }
          }
          
          // ============================================================================
          // Test 12: Data Completeness
          // ============================================================================
          
          #[test]
          fn test_all_basic_kana_present() {
              let expected_romanizations = vec![
                  "a", "i", "u", "e", "o",
                  "ka", "ki", "ku", "ke", "ko",
                  "sa", "shi", "su", "se", "so",
                  "ta", "chi", "tsu", "te", "to",
                  "na", "ni", "nu", "ne", "no",
                  "ha", "hi", "fu", "he", "ho",
                  "ma", "mi", "mu", "me", "mo",
                  "ya", "yu", "yo",
                  "ra", "ri", "ru", "re", "ro",
                  "wa", "wo", "n",
              ];
              
              for romanization in expected_romanizations {
                  let results = get_by_romanization(romanization);
                  let has_hiragana = results.iter().any(|c| c.is_hiragana());
                  let has_katakana = results.iter().any(|c| c.is_katakana());
                  
                  assert!(
                      has_hiragana,
                      "Missing expected hiragana character: {}",
                      romanization
                  );
                  assert!(
                      has_katakana,
                      "Missing expected katakana character: {}",
                      romanization
                  );
              }
          }
      }

      // ============================================================================
      // Property-Based Tests (using proptest)
      // ============================================================================
      
      #[cfg(test)]
      mod property_tests {
          use super::*;
          use proptest::prelude::*;
          
          proptest! {
              #[test]
              fn prop_all_unicode_values_are_valid_chars(index in 0..46usize) {
                  let hiragana_chars = get_all_hiragana();
                  if index < hiragana_chars.len() {
                      let char_data = hiragana_chars[index];
                      let code_point = char_data.unicode as u32;
                      prop_assert!(char::from_u32(code_point).is_some());
                  }
                  
                  let katakana_chars = get_all_katakana();
                  if index < katakana_chars.len() {
                      let char_data = katakana_chars[index];
                      let code_point = char_data.unicode as u32;
                      prop_assert!(char::from_u32(code_point).is_some());
                  }
              }
              
              #[test]
              fn prop_stroke_paths_match_stroke_count(index in 0..46usize) {
                  let hiragana_chars = get_all_hiragana();
                  if index < hiragana_chars.len() {
                      let char_data = hiragana_chars[index];
                      prop_assert_eq!(char_data.stroke_count, char_data.stroke_paths.len());
                  }
                  
                  let katakana_chars = get_all_katakana();
                  if index < katakana_chars.len() {
                      let char_data = katakana_chars[index];
                      prop_assert_eq!(char_data.stroke_count, char_data.stroke_paths.len());
                  }
              }
              
              #[test]
              fn prop_romanization_is_lowercase_alphanumeric(index in 0..46usize) {
                  let hiragana_chars = get_all_hiragana();
                  if index < hiragana_chars.len() {
                      let romanization = &hiragana_chars[index].romanization;
                      prop_assert!(romanization.chars().all(|c| c.is_ascii_lowercase()));
                  }
                  
                  let katakana_chars = get_all_katakana();
                  if index < katakana_chars.len() {
                      let romanization = &katakana_chars[index].romanization;
                      prop_assert!(romanization.chars().all(|c| c.is_ascii_lowercase()));
                  }
              }
              
              #[test]
              fn prop_frequency_ranks_in_valid_range(index in 0..46usize) {
                  let hiragana_chars = get_all_hiragana();
                  if index < hiragana_chars.len() {
                      let rank = hiragana_chars[index].frequency_rank;
                      prop_assert!(rank >= 1 && rank <= 46);
                  }
                  
                  let katakana_chars = get_all_katakana();
                  if index < katakana_chars.len() {
                      let rank = katakana_chars[index].frequency_rank;
                      prop_assert!(rank >= 1 && rank <= 46);
                  }
              }
          }
      }

  coverage:
    - "Character count verification: 46 hiragana and 46 katakana characters are present"
    - "Unicode validity: All characters have valid Unicode code points in correct ranges (U+3040-U+309F for hiragana, U+30A0-U+30FF for katakana)"
    - "Stroke count validation: All stroke counts are within valid range (1-4) and match actual path counts"
    - "SVG path non-emptiness: All stroke paths contain valid SVG data"
    - "SVG path syntax validation: All paths start with M/m command and contain only valid SVG commands"
    - "SVG path parsing safety: All paths can be parsed without panics or errors"
    - "Lookup correctness: Functions return correct CharData for known romanization keys"
    - "Lookup error handling: Returns empty results for non-existent and invalid keys"
    - "Romanization consistency: Characters can be found by their romanization field"
    - "Data completeness: All 46 basic kana characters are present in both hiragana and katakana sets"
    - "Property: Unicode values are valid characters across all entries"
    - "Property: Stroke paths count matches stroke_count field for all characters"
    - "Property: Romanization keys are lowercase ASCII across all entries"
    - "Property: Frequency ranks are within valid range (1-46) for all characters"

dependencies:
  depends_on:
    - task_id: 1
      reason: "Requires models/ module structure and basic project scaffolding to exist before defining character data structures"

  depended_upon_by:
    - task_id: 3
      reason: "Font rendering system needs character data and Unicode values to display kana characters"
    - task_id: 4
      reason: "Stroke animation engine requires stroke path data from CharData to render animated stroke order"
    - task_id: 7
      reason: "Flashcard system needs character database for selecting characters, displaying them, and tracking learning progress"

  external:
    - name: "serde"
      type: "crate"
      status: "to be imported"
    - name: "serde::Serialize"
      type: "trait"
      status: "to be imported"
    - name: "serde::Deserialize"
      type: "trait"
      status: "to be imported"
    - name: "ron"
      type: "crate"
      status: "to be imported"
    - name: "phf"
      type: "crate"
      status: "to be imported"
    - name: "phf::Map"
      type: "struct"
      status: "to be imported"
    - name: "phf_codegen"
      type: "crate"
      status: "to be imported"
    - name: "proptest"
      type: "crate"
      status: "to be imported"
---
task:
  id: 3
  name: "Japanese Font Integration and Text Rendering"

context:
  description: |
    This task implements the critical Japanese text rendering infrastructure for the kana learning application.
    It embeds the Noto Sans JP font directly into the binary, configures iced's cosmic-text backend for proper
    Unicode text shaping, and creates a custom CharacterCard widget for flashcard-style character display.
    
    Proper Japanese text rendering is non-negotiable for a kana learning application. While iced supports full
    Unicode rendering through cosmic-text, it requires explicit font loading and advanced shaping configuration
    to correctly render complex scripts like Japanese. The CharacterCard widget abstracts these rendering
    complexities and provides a consistent, reusable interface for displaying kana characters throughout the
    application.
    
    The implementation uses compile-time font embedding via include_bytes!() to ensure the application remains
    portable across platforms without external font dependencies. The CharacterCard widget implements iced's
    Widget trait, integrating seamlessly with the existing UI framework while providing specialized functionality
    for educational character display including configurable sizing and optional stroke order overlays.

  key_points:
    - "Noto Sans JP provides excellent Japanese character coverage with educational readability (~900KB embedded)"
    - "cosmic-text requires Shaping::Advanced configuration for proper Japanese glyph rendering and ligature support"
    - "Font::with_name() references must exactly match the embedded font's family name metadata"
    - "CharacterCard implements iced::Widget trait for seamless integration with layout and rendering pipeline"
    - "Compile-time embedding ensures zero runtime font loading failures and cross-platform portability"
    - "Custom widget centralizes character rendering logic for consistency across flashcard and practice modes"

files:
  - path: "/home/molaco/Documents/japanese/assets/fonts/NotoSansJP-Regular.otf"
    description: "Embedded Noto Sans JP Regular font file for Japanese kana rendering (binary asset)"
  - path: "/home/molaco/Documents/japanese/src/main.rs"
    description: "Application entry point - modified to load and register Japanese font at startup using include_bytes! macro"
  - path: "/home/molaco/Documents/japanese/src/ui/widgets/character_card.rs"
    description: "Custom iced widget implementing CharacterCard for flashcard-style character display with configurable sizing and styling"
  - path: "/home/molaco/Documents/japanese/src/ui/widgets/mod.rs"
    description: "Widget module declaration file - exposes character_card module to parent ui module"
  - path: "/home/molaco/Documents/japanese/src/ui/mod.rs"
    description: "UI module root - modified to include widgets submodule declaration"
  - path: "/home/molaco/Documents/japanese/Cargo.toml"
    description: "Project manifest - add iced dependency with advanced text shaping features for Japanese rendering"

functions:
  - file: "/home/molaco/Documents/japanese/assets/fonts/NotoSansJP-Regular.otf"
    items:
      - type: "constant"
        name: "NotoSansJP-Regular.otf"
        description: "Binary font file embedded at compile time using include_bytes! macro. Noto Sans JP Regular weight font providing comprehensive Japanese kana coverage with excellent educational readability. File size approximately 900KB."
        invariants: "Font data is immutable and statically embedded; valid OpenType font format with magic number 0x4F54544F"

  - file: "/home/molaco/Documents/japanese/src/main.rs"
    items:
      - type: "constant"
        name: "NOTO_SANS_JP"
        description: "Static byte array containing embedded Noto Sans JP Regular font data loaded via include_bytes! macro from assets/fonts/NotoSansJP-Regular.otf"
        postconditions: "Returns non-empty byte slice with valid OTF/TTF format"
        invariants: "Font data remains valid and immutable for application lifetime; size is 700KB-1MB"

      - type: "constant"
        name: "NOTO_SANS_JP_FAMILY"
        description: "String constant containing exact font family name 'Noto Sans JP' for Font::with_name() references"
        invariants: "Must exactly match font family name in embedded font file metadata"

      - type: "method"
        name: "Application::new"
        description: "Application initialization method modified to load Japanese font at startup before any rendering operations. Uses iced::font::load to register embedded font data with the renderer."
        preconditions: "iced runtime is initialized"
        postconditions: "Application state initialized with Japanese font loaded and available for rendering via Font::with_name('Noto Sans JP')"

  - file: "/home/molaco/Documents/japanese/src/ui/widgets/character_card.rs"
    items:
      - type: "struct"
        name: "CharacterCard"
        description: "Custom iced widget implementing flashcard-style display of Japanese kana characters. Provides configurable font size, styling, centering, and optional stroke order overlay support. Implements Widget trait for integration with iced rendering pipeline."
        invariants: "Character must be valid Unicode; font size must be positive; uses Shaping::Advanced for proper Japanese glyph rendering"

      - type: "struct"
        name: "CharacterCardStyle"
        description: "Style configuration struct for CharacterCard widget specifying font size, foreground/background colors, padding, border radius, and border color"
        invariants: "Font size must be positive; color values must be valid RGBA; padding and border radius must be non-negative"

      - type: "method"
        name: "CharacterCard::new"
        description: "Constructor creating new CharacterCard widget with specified character and default styling (64px font, black on white, 20px padding, 8px border radius)"
        preconditions: "Character must be valid UTF-8"
        postconditions: "Returns initialized CharacterCard with default CharacterCardStyle and centering enabled"

      - type: "method"
        name: "CharacterCard::size"
        description: "Builder method setting custom font size in pixels for character display"
        preconditions: "Size must be positive f32 value"
        postconditions: "Returns self with font size updated in style configuration"

      - type: "method"
        name: "CharacterCard::with_style"
        description: "Builder method applying complete custom CharacterCardStyle configuration"
        postconditions: "Returns self with custom style replacing default styling"

      - type: "method"
        name: "CharacterCard::show_stroke_order"
        description: "Builder method enabling optional stroke order guide overlay rendering"
        postconditions: "Returns self with stroke_order_enabled flag set to provided boolean value"

      - type: "method"
        name: "CharacterCard::center_horizontal"
        description: "Builder method controlling horizontal centering of character within widget bounds"
        postconditions: "Returns self with horizontal centering flag updated"

      - type: "method"
        name: "CharacterCard::center_vertical"
        description: "Builder method controlling vertical centering of character within widget bounds"
        postconditions: "Returns self with vertical centering flag updated"

      - type: "method"
        name: "CharacterCard::character"
        description: "Getter method returning the character stored in the widget"
        postconditions: "Returns char value being displayed"

      - type: "trait_impl"
        name: "Widget<Message> for CharacterCard"
        description: "Implements iced::Widget trait enabling CharacterCard integration with iced rendering and layout system. Provides width(), height(), layout(), and draw() methods."
        invariants: "Must implement all required Widget trait methods; draw() must use Shaping::Advanced"

      - type: "method"
        name: "Widget::width"
        description: "Returns width layout constraint for the widget (typically Length::Shrink or Length::Fill)"
        postconditions: "Returns iced::Length value specifying width requirement"

      - type: "method"
        name: "Widget::height"
        description: "Returns height layout constraint for the widget (typically Length::Shrink or Length::Fill)"
        postconditions: "Returns iced::Length value specifying height requirement"

      - type: "method"
        name: "Widget::layout"
        description: "Calculates layout node with dimensions based on font metrics, padding, and limit constraints. Uses renderer text measurement with Noto Sans JP font."
        preconditions: "Renderer must have Japanese font loaded; limits must be valid"
        postconditions: "Returns iced::advanced::layout::Node with calculated bounds including padding"

      - type: "method"
        name: "Widget::draw"
        description: "Renders character to screen using cosmic-text with Shaping::Advanced for proper Japanese glyph rendering. Centers character within calculated bounds using horizontal and vertical alignment."
        preconditions: "Font must be loaded; layout must be calculated; renderer and style valid"
        postconditions: "Character drawn centered within widget bounds using Font::with_name('Noto Sans JP') with advanced shaping; optional stroke order overlay rendered if enabled"
        invariants: "Must use Shaping::Advanced for proper Japanese character rendering"

      - type: "constant"
        name: "DEFAULT_FONT_SIZE"
        description: "Default font size constant (64.0 pixels) for character display when no custom size specified"

      - type: "constant"
        name: "DEFAULT_PADDING"
        description: "Default padding constant (20.0 pixels) applied around character for comfortable spacing"

  - file: "/home/molaco/Documents/japanese/src/ui/widgets/mod.rs"
    items:
      - type: "module_declaration"
        name: "character_card"
        description: "Module declaration for character_card widget implementation"

  - file: "/home/molaco/Documents/japanese/src/ui/mod.rs"
    items:
      - type: "module_declaration"
        name: "widgets"
        description: "Module declaration for widgets submodule containing custom iced widgets"

formal_verification:
  needed: false
  level: "None"
  explanation: |
    Formal verification is not needed for this Japanese font integration and text rendering task for the following reasons:
    
    1. UI/Rendering Code Nature: This task involves UI rendering and text display, which are inherently difficult to formally verify. Formal methods are not well-suited for visual output verification.
    
    2. Explicit Task Specification: The task overview explicitly states "formal_verification: false", indicating this was already assessed and deemed inappropriate for this component.
    
    3. Integration Testing More Appropriate: The task correctly identifies integration testing as the primary strategy. Visual rendering quality, glyph coverage, and text centering are best verified through integration tests with actual font rendering, not formal proofs.
    
    4. No Safety-Critical Properties: While the task has critical functional properties (no missing glyphs, correct centering), these are quality concerns rather than safety-critical invariants that require mathematical proof. They can be adequately verified through comprehensive integration and visual regression testing.
    
    5. Platform and Configuration Dependent: Font loading and rendering behavior can vary by platform and configuration, making formal verification impractical. Empirical testing across target platforms is more valuable.

tests:
  strategy:
    approach: "integration"
    rationale:
      - "Font loading and text rendering cannot be unit tested in isolation - requires full iced runtime and graphics backend"
      - "Japanese text rendering quality depends on cosmic-text integration, font metrics, and shaper configuration"
      - "Visual properties like centering and glyph presence require actual rendering pipeline execution"
      - "Focus on functional correctness (no panics, expected behavior) rather than visual regression for MVP"

  implementation:
    file: "/home/molaco/Documents/japanese/tests/japanese_font_integration_test.rs"
    location: "create new"
    code: |
      //! Integration tests for Japanese font loading and character rendering
      
      #[cfg(test)]
      mod japanese_font_tests {
          use kana_master::ui::widgets::CharacterCard;
          
          #[test]
          fn test_font_constant_defined() {
              const NOTO_SANS_JP_BYTES: &[u8] = include_bytes!("../assets/fonts/NotoSansJP-Regular.otf");
              assert!(NOTO_SANS_JP_BYTES.len() > 100_000, "Font file should be at least 100KB");
              assert!(NOTO_SANS_JP_BYTES.len() < 2_000_000, "Font file should be under 2MB");
              
              let magic = u32::from_be_bytes([
                  NOTO_SANS_JP_BYTES[0],
                  NOTO_SANS_JP_BYTES[1],
                  NOTO_SANS_JP_BYTES[2],
                  NOTO_SANS_JP_BYTES[3],
              ]);
              assert!(
                  magic == 0x4F54544F || magic == 0x00010000 || magic == 0x74727565,
                  "Font file should have valid OTF/TTF magic number"
              );
          }
          
          #[test]
          fn test_all_hiragana_characters_defined() {
              let hiragana_chars = vec![
                  'あ', 'い', 'う', 'え', 'お',
                  'か', 'き', 'く', 'け', 'こ',
                  'さ', 'し', 'す', 'せ', 'そ',
                  'た', 'ち', 'つ', 'て', 'と',
                  'な', 'に', 'ぬ', 'ね', 'の',
                  'は', 'ひ', 'ふ', 'へ', 'ほ',
                  'ま', 'み', 'む', 'め', 'も',
                  'や', 'ゆ', 'よ',
                  'ら', 'り', 'る', 'れ', 'ろ',
                  'わ', 'を', 'ん',
              ];
              
              for ch in hiragana_chars.iter() {
                  let unicode = *ch as u32;
                  assert!(
                      unicode >= 0x3040 && unicode <= 0x309F,
                      "Character {} should be in hiragana Unicode block",
                      ch
                  );
              }
              
              assert_eq!(hiragana_chars.len(), 46, "Should have all 46 basic hiragana characters");
          }
          
          #[test]
          fn test_all_katakana_characters_defined() {
              let katakana_chars = vec![
                  'ア', 'イ', 'ウ', 'エ', 'オ',
                  'カ', 'キ', 'ク', 'ケ', 'コ',
                  'サ', 'シ', 'ス', 'セ', 'ソ',
                  'タ', 'チ', 'ツ', 'テ', 'ト',
                  'ナ', 'ニ', 'ヌ', 'ネ', 'ノ',
                  'ハ', 'ヒ', 'フ', 'ヘ', 'ホ',
                  'マ', 'ミ', 'ム', 'メ', 'モ',
                  'ヤ', 'ユ', 'ヨ',
                  'ラ', 'リ', 'ル', 'レ', 'ロ',
                  'ワ', 'ヲ', 'ン',
              ];
              
              for ch in katakana_chars.iter() {
                  let unicode = *ch as u32;
                  assert!(
                      unicode >= 0x30A0 && unicode <= 0x30FF,
                      "Character {} should be in katakana Unicode block",
                      ch
                  );
              }
              
              assert_eq!(katakana_chars.len(), 46, "Should have all 46 basic katakana characters");
          }
          
          #[test]
          fn test_character_card_instantiation() {
              let test_chars = vec!['あ', 'か', 'さ', 'ア', 'カ', 'サ'];
              
              for ch in test_chars {
                  let _card = CharacterCard::new(ch).size(48.0);
                  let _card_medium = CharacterCard::new(ch).size(64.0);
                  let _card_large = CharacterCard::new(ch).size(72.0);
              }
          }
      }
      
      #[cfg(test)]
      mod character_card_widget_tests {
          use kana_master::ui::widgets::CharacterCard;
          
          #[test]
          fn test_character_card_builder_configurations() {
              let card = CharacterCard::new('あ').size(64.0);
              assert_eq!(card.character(), 'あ');
          }
          
          #[test]
          fn test_character_card_with_stroke_order() {
              let card = CharacterCard::new('か')
                  .size(72.0)
                  .show_stroke_order(true);
              
              assert_eq!(card.character(), 'か');
              assert!(card.has_stroke_order_enabled());
          }
          
          #[test]
          fn test_character_card_centering() {
              let card = CharacterCard::new('さ')
                  .size(48.0)
                  .center_horizontal(true)
                  .center_vertical(true);
              
              assert!(card.is_centered_horizontal());
              assert!(card.is_centered_vertical());
          }
      }

  coverage:
    - "Embedded Noto Sans JP font file is present and accessible"
    - "Font file has valid OTF/TTF magic number and reasonable size"
    - "All 46 basic hiragana characters are defined in valid Unicode range"
    - "All 46 basic katakana characters are defined in valid Unicode range"
    - "CharacterCard widget can be instantiated without panicking"
    - "CharacterCard accepts size parameter for 48px, 64px, and 72px rendering"
    - "CharacterCard builder pattern works correctly"
    - "CharacterCard optional stroke order overlay can be enabled"
    - "CharacterCard horizontal and vertical centering can be configured"

dependencies:
  depends_on:
    - task_id: 1
      reason: "Requires application foundation and ui/ module structure for widget integration"

  depended_upon_by:
    - task_id: 7
      reason: "Flashcard system needs CharacterCard widget for character display"
    - task_id: 8
      reason: "Practice mode displays characters using this rendering system"

  external:
    - name: "iced"
      type: "crate"
      status: "to be imported"
    - name: "iced::Widget"
      type: "trait"
      status: "already exists"
    - name: "iced::Font"
      type: "struct"
      status: "already exists"
    - name: "iced::advanced::text::Shaping"
      type: "enum"
      status: "already exists"
    - name: "iced::Length"
      type: "enum"
      status: "already exists"
---
task:
  id: 4
  name: "Stroke Order Animation System"

context:
  description: |
    The Stroke Order Animation System implements a GPU-accelerated, stroke-by-stroke animation 
    component for teaching proper Japanese character writing sequences. This system is the primary 
    visual pedagogy tool in the application, rendering character strokes sequentially with smooth 
    partial path drawing, configurable timing, and natural easing curves that mimic human handwriting motion.
    
    Architecturally, this task builds upon the iced Canvas widget foundation (Task 1) and integrates 
    character stroke data from the database layer (Task 2). The system uses lyon's path tessellation 
    for GPU-accelerated rendering, ensuring 60fps performance even on lower-end hardware. Each stroke 
    animates over 500-800ms with 200-300ms pauses between strokes, creating a natural teaching rhythm.
    
    The implementation solves several technical challenges: SVG path parsing with support for MoveTo, 
    LineTo, and Bezier curve commands; accurate partial path calculation via arc-length parameterization; 
    and smooth animation interpolation using cubic easing functions. The StrokeOrderAnimation component 
    maintains animation state, manages timing, and coordinates rendering while remaining reusable across 
    different practice modes.
    
    This system is critical for learner success because stroke order animation provides visual 
    reinforcement of correct writing patterns. Smooth, artifact-free rendering with proper timing 
    helps learners internalize the motor patterns needed for authentic character writing.

key_points:
    - "GPU-accelerated rendering via lyon tessellation ensures smooth 60fps animation on diverse hardware"
    - "Implements canvas::Program trait for iced integration, enabling declarative UI composition"
    - "Precomputes stroke lengths for O(1) partial path calculation during animation frames"
    - "SVG path parser supports M, L, C, S, Q commands with adaptive bezier curve subdivision for length accuracy"
    - "Animation state machine manages Playing, Paused, PauseBetweenStrokes, and Completed states with deterministic transitions"
    - "EaseOutCubic easing mimics natural pen lift motion for pedagogically effective animation"
    - "Color differentiation (black=completed, blue=animating, gray=pending) provides clear visual progress feedback"
    - "Partial path rendering maintains stroke continuity through accurate arc-length interpolation"
    - "Configurable timing allows tuning stroke_duration (500-800ms) and pause_duration (200-300ms) based on user feedback"
    - "Reusable component architecture enables integration into multiple practice modes"

files:
  - path: "src/ui/animation/mod.rs"
    description: "Module declaration file exposing StrokeOrderAnimation, StrokePath, and animation utilities as public API"
  
  - path: "src/ui/animation/stroke_order.rs"
    description: "Main StrokeOrderAnimation component implementing canvas::Program trait for rendering animated stroke sequences with timing and state management"
  
  - path: "src/ui/animation/path.rs"
    description: "StrokePath struct and PathSegment enum definitions with length calculations and SVG path command representations"
  
  - path: "src/ui/animation/controller.rs"
    description: "Animation controller module with AnimationState enum, AnimationConfig struct, and EasingFunction definitions"
  
  - path: "src/ui/animation/path_parser.rs"
    description: "SVG path data parser that converts path strings into PathSegment enums with support for M, L, C, S, Q commands"
  
  - path: "src/ui/animation/geometry.rs"
    description: "Geometric calculation utilities for bezier curve length approximation, point-at-parameter calculation, and adaptive subdivision"
  
  - path: "src/ui/animation/easing.rs"
    description: "Easing function implementations including linear, ease-out-cubic, and ease-in-out-quad for animation timing curves"
  
  - path: "src/ui/animation/renderer.rs"
    description: "Partial path rendering utilities that calculate and draw stroke segments based on animation progress using lyon tessellation"
  
  - path: "tests/stroke_animation_tests.rs"
    description: "Comprehensive test suite for stroke animation including path parsing, length calculation, partial rendering, state transitions, and property-based tests"

functions:
  - file: "src/ui/animation/mod.rs"
    items:
      - type: "module_declaration"
        name: "pub mod stroke_order"
        description: "Public module containing StrokeOrderAnimation struct and AnimationState enum"
        
      - type: "module_declaration"
        name: "pub mod path"
        description: "Public module containing StrokePath struct and PathSegment enum for SVG path representation"
        
      - type: "module_declaration"
        name: "pub mod controller"
        description: "Public module containing animation controller and AnimationConfig"
        
      - type: "module_declaration"
        name: "mod easing"
        description: "Private module with easing functions for animation timing curves"
        
      - type: "module_declaration"
        name: "mod path_parser"
        description: "Private module with SVG path string parsing utilities"
        
      - type: "module_declaration"
        name: "mod geometry"
        description: "Private module with geometric calculations for bezier curves and line lengths"

      - type: "module_declaration"
        name: "mod renderer"
        description: "Private module with partial path rendering functions for canvas drawing"

  - file: "src/ui/animation/stroke_order.rs"
    items:
      - type: "struct"
        name: "StrokeOrderAnimation"
        description: "Main animation component managing state, timing, and rendering for stroke order display. Contains vector of StrokePath instances, current stroke index, animation progress, state, and configuration."
        invariants: "current_stroke_index <= strokes.len(); animation_progress in [0.0, 1.0]; if state is Completed then current_stroke_index == strokes.len() - 1 and progress == 1.0"
        
      - type: "method"
        name: "StrokeOrderAnimation::new"
        description: "Creates new StrokeOrderAnimation from vector of stroke paths and configuration. Parses all paths and initializes animation in Stopped state."
        preconditions: "stroke_paths is non-empty; all paths contain valid SVG data"
        postconditions: "Returns StrokeOrderAnimation with state=Stopped, current_stroke_index=0, progress=0.0"
        invariants: "All stroke paths are validated and precomputed with total lengths"
        
      - type: "method"
        name: "StrokeOrderAnimation::play"
        description: "Starts animation playback or resumes from paused state. Transitions to Playing state and begins frame updates."
        preconditions: "Animation is not in Completed state (allows restart after reset)"
        postconditions: "state is Playing or PauseBetweenStrokes; animation begins advancing on update calls"
        
      - type: "method"
        name: "StrokeOrderAnimation::pause"
        description: "Pauses animation at current position without resetting progress or stroke index"
        postconditions: "state is Paused; progress and current_stroke_index remain unchanged"
        
      - type: "method"
        name: "StrokeOrderAnimation::reset"
        description: "Resets animation to initial state with first stroke at 0% progress"
        postconditions: "state=Stopped; current_stroke_index=0; progress=0.0"
        
      - type: "method"
        name: "StrokeOrderAnimation::update"
        description: "Updates animation state based on elapsed time delta. Advances progress, handles stroke transitions, manages pause periods, and detects completion."
        preconditions: "delta_time >= Duration::ZERO"
        postconditions: "Animation progress advanced; stroke index incremented if stroke completed; state transitioned if appropriate; returns true if visual redraw needed"
        invariants: "Progress remains in [0.0, 1.0]; current_stroke_index never exceeds stroke count"
        
      - type: "method"
        name: "StrokeOrderAnimation::get_stroke_colors"
        description: "Returns color classification for each stroke based on animation progress: Completed (black), Animating (blue), or Pending (gray)"
        postconditions: "Returns Vec<StrokeColor> with length equal to stroke count"
        invariants: "Exactly one stroke is Animating unless animation is Completed or Stopped"
        
      - type: "method"
        name: "StrokeOrderAnimation::calculate_total_duration"
        description: "Computes total animation duration including all stroke durations and inter-stroke pauses"
        postconditions: "Returns Duration = (num_strokes * stroke_duration) + ((num_strokes - 1) * pause_duration)"
        
      - type: "trait_impl"
        name: "canvas::Program for StrokeOrderAnimation"
        description: "Implements iced Canvas Program trait enabling rendering to canvas widget with draw method and update lifecycle"
        invariants: "draw method is pure function of animation state; produces consistent output for same state"
        
      - type: "method"
        name: "StrokeOrderAnimation::draw"
        description: "Renders current animation frame to canvas. Draws completed strokes in black, current stroke partially in blue based on progress, and skips pending strokes. Uses lyon tessellation for GPU-accelerated rendering."
        preconditions: "bounds.width > 0 and bounds.height > 0; renderer is valid iced canvas::Frame"
        postconditions: "All completed strokes rendered as full paths; current stroke rendered as partial path up to progress; pending strokes not rendered"
        
      - type: "enum"
        name: "StrokeColor"
        description: "Color classification for stroke rendering state"
        
      - type: "enum_variant"
        name: "StrokeColor::Completed"
        description: "Stroke has finished animating and should render in black"
        
      - type: "enum_variant"
        name: "StrokeColor::Animating"
        description: "Stroke is currently animating and should render in blue with partial path"
        
      - type: "enum_variant"
        name: "StrokeColor::Pending"
        description: "Stroke has not started animating and should render in light gray or be hidden"

  - file: "src/ui/animation/controller.rs"
    items:
      - type: "enum"
        name: "AnimationState"
        description: "Represents current lifecycle state of stroke order animation including playback control and inter-stroke pauses"
        
      - type: "enum_variant"
        name: "AnimationState::Playing"
        description: "Animation is actively running; progress advances on update calls"
        
      - type: "enum_variant"
        name: "AnimationState::Paused"
        description: "Animation is paused by user; can be resumed with play()"
        
      - type: "enum_variant"
        name: "AnimationState::Stopped"
        description: "Animation is at initial state; reset to this state"
        
      - type: "enum_variant"
        name: "AnimationState::Completed"
        description: "All strokes have been animated to completion; no further updates"
        
      - type: "enum_variant"
        name: "AnimationState::PauseBetweenStrokes"
        description: "Animation is in configured pause period between completing one stroke and starting next; automatically transitions to Playing after pause_duration"
        
      - type: "struct"
        name: "AnimationConfig"
        description: "Configuration parameters for stroke animation timing and easing. Contains stroke_duration, pause_duration, and easing function."
        invariants: "stroke_duration > Duration::ZERO; pause_duration >= Duration::ZERO"
        
      - type: "method"
        name: "AnimationConfig::default"
        description: "Creates default configuration with 650ms stroke duration, 250ms pause, and EaseOutCubic easing"
        postconditions: "Returns AnimationConfig with DEFAULT_STROKE_DURATION_MS, DEFAULT_PAUSE_DURATION_MS, EaseOutCubic"
        
      - type: "method"
        name: "AnimationConfig::new"
        description: "Creates custom AnimationConfig with specified timing and easing parameters"
        preconditions: "stroke_duration > Duration::ZERO; pause_duration >= Duration::ZERO"
        postconditions: "Returns AnimationConfig with provided values"
        
      - type: "constant"
        name: "DEFAULT_STROKE_DURATION_MS"
        description: "Default duration for animating a single stroke in milliseconds (650ms provides natural handwriting feel)"
        
      - type: "constant"
        name: "DEFAULT_PAUSE_DURATION_MS"
        description: "Default pause between consecutive strokes in milliseconds (250ms allows visual separation)"
        
      - type: "constant"
        name: "COMPLETE_STROKE_COLOR"
        description: "iced::Color constant for completed strokes (black: Color::BLACK)"

      - type: "constant"
        name: "ANIMATING_STROKE_COLOR"
        description: "iced::Color constant for currently animating stroke (blue: rgb(0.2, 0.4, 0.8))"
        
      - type: "constant"
        name: "PENDING_STROKE_COLOR"
        description: "iced::Color constant for pending strokes (light gray: rgb(0.7, 0.7, 0.7))"
        
      - type: "enum"
        name: "EasingFunction"
        description: "Easing curve types for animation timing interpolation"
        
      - type: "enum_variant"
        name: "EasingFunction::Linear"
        description: "Linear interpolation with no easing"
        
      - type: "enum_variant"
        name: "EasingFunction::EaseOutCubic"
        description: "Cubic ease-out for natural deceleration mimicking pen lift"
        
      - type: "enum_variant"
        name: "EasingFunction::EaseInOutQuad"
        description: "Quadratic ease-in-out for smooth acceleration and deceleration"
        
      - type: "method"
        name: "EasingFunction::apply"
        description: "Applies easing function to input parameter t in [0.0, 1.0] and returns eased value"
        preconditions: "t in [0.0, 1.0]"
        postconditions: "Returns value in [0.0, 1.0]"
        invariants: "apply(0.0) == 0.0; apply(1.0) == 1.0; function is continuous"

  - file: "src/ui/animation/path.rs"
    items:
      - type: "struct"
        name: "StrokePath"
        description: "Represents a single character stroke with parsed PathSegment vector and precomputed total_length for accurate partial rendering. Cached length enables O(1) partial path calculation."
        invariants: "total_length >= 0.0; segments.len() > 0; first segment is MoveTo; total_length equals sum of all segment lengths"
        
      - type: "method"
        name: "StrokePath::from_svg_path"
        description: "Parses SVG path data string into StrokePath with segments and precomputed total length. Uses path_parser module for parsing."
        preconditions: "svg_data contains valid SVG path commands (M, L, C, S, Q, Z)"
        postconditions: "Returns Ok(StrokePath) with parsed segments and calculated total_length, or Err(ParseError) if invalid syntax"
        
      - type: "method"
        name: "StrokePath::calculate_partial_path"
        description: "Generates new StrokePath containing segments from start up to specified progress fraction [0.0, 1.0]. Handles partial segment rendering when progress falls mid-segment."
        preconditions: "progress in [0.0, 1.0]"
        postconditions: "Returns StrokePath with total_length = progress * self.total_length; maintains path continuity; partial segment is correctly subdivided"
        invariants: "Returned path starts at same point as original; path is continuous"
        
      - type: "method"
        name: "StrokePath::get_end_point"
        description: "Returns the final (x, y) coordinate of the stroke path based on last segment's endpoint"
        postconditions: "Returns (f32, f32) tuple representing last point in path"
        
      - type: "method"
        name: "StrokePath::new"
        description: "Creates StrokePath from pre-parsed segments with length calculation"
        preconditions: "segments is non-empty; first segment is MoveTo"
        postconditions: "Returns StrokePath with total_length computed from all segments"
        
      - type: "enum"
        name: "PathSegment"
        description: "Individual SVG path command representing drawing operations. Each variant stores absolute coordinates and control points."
        
      - type: "enum_variant"
        name: "PathSegment::MoveTo { x: f32, y: f32 }"
        description: "Move pen to absolute position (x, y) without drawing. Used as stroke starting point."
        
      - type: "enum_variant"
        name: "PathSegment::LineTo { x:f32, y: f32 }"
        description: "Draw straight line from current position to (x, y)"
        
      - type: "enum_variant"
        name: "PathSegment::CubicBezier { c1_x: f32, c1_y: f32, c2_x: f32, c2_y: f32, x: f32, y: f32 }"
        description: "Draw cubic bezier curve with control points (c1_x, c1_y) and (c2_x, c2_y) to endpoint (x, y)"
        
      - type: "enum_variant"
        name: "PathSegment::QuadraticBezier { c_x: f32, c_y: f32, x: f32, y: f32 }"
        description: "Draw quadratic bezier curve with single control point (c_x, c_y) to endpoint (x, y)"
        
      - type: "enum_variant"
        name: "PathSegment::SmoothCubic { c2_x: f32, c2_y: f32, x: f32, y: f32 }"
        description: "Draw smooth cubic bezier using reflected previous control point as c1 and explicit (c2_x, c2_y) to endpoint (x, y). First control point is calculated from previous segment."
        
      - type: "enum_variant"
        name: "PathSegment::ClosePath"
        description: "Close current path by drawing line back to most recent MoveTo position (Z command)"
        
      - type: "method"
        name: "PathSegment::calculate_length"
        description: "Calculates geometric length of this segment starting from given start_point. Uses exact calculation for lines and adaptive subdivision for bezier curves."
        preconditions: "start is valid (x, y) coordinate tuple"
        postconditions: "Returns non-negative f32 length; MoveTo returns 0.0; LineTo uses Euclidean distance; bezier curves use numerical approximation"
        
      - type: "method"
        name: "PathSegment::get_endpoint"
        description: "Returns the final (x, y) coordinate that this segment draws to"
        postconditions: "Returns (f32, f32) endpoint coordinates; MoveTo returns its own position"
        
      - type: "method"
        name: "PathSegment::subdivide_at_length"
        description: "Creates new PathSegment representing portion of this segment up to specified arc length from start. Used for partial path rendering."
        preconditions: "target_length >= 0.0 and target_length <= self.calculate_length(start); start is segment start point"
        postconditions: "Returns PathSegment of same type with endpoint at target arc length; maintains curve continuity"

  - file: "src/ui/animation/path_parser.rs"
    items:
      - type: "function"
        name: "parse_svg_path_data"
        description: "Main entry point for parsing SVG path data strings into vector of PathSegment enums. Handles whitespace, comma separators, and command repetition."
        preconditions: "path_str contains valid SVG path syntax with commands M, L, C, S, Q, Z"
        postconditions: "Returns Ok(Vec<PathSegment>) with all parsed commands, or Err(ParseError) with detailed error message and position"
        
      - type: "struct"
        name: "PathParser"
        description: "Stateful parser maintaining current position in path string, current pen position, and last control point for smooth curve commands"
        invariants: "position <= input.len(); current_point tracks pen position after each command"
        
      - type: "method"
        name: "PathParser::new"
        description: "Creates PathParser initialized with input path string and starting position"
        preconditions: "path_string is non-empty"
        postconditions: "Returns PathParser with position=0, current_point=(0.0, 0.0), last_control_point=None"
        
      - type: "method"
        name: "PathParser::parse"
        description: "Main parsing loop that iterates through path string, identifies commands, and builds segment vector"
        postconditions: "Returns Ok(Vec<PathSegment>) or Err(ParseError); consumes entire input; validates path starts with MoveTo"
        
      - type: "method"
        name: "PathParser::parse_command"
        description: "Parses single SVG command character (M/m, L/l, C/c, S/s, Q/q, Z/z) and its parameters. Handles both absolute (uppercase) and relative (lowercase) commands."
        preconditions: "Current position points to valid command character"
        postconditions: "Returns PathSegment and advances parser position past command and parameters; updates current_point and last_control_point"
        
      - type: "method"
        name: "PathParser::parse_moveto"
        description: "Parses MoveTo command parameters (M x,y or m dx,dy)"
        postconditions: "Returns PathSegment::MoveTo with absolute coordinates; updates current_point"
        
      - type: "method"
        name: "PathParser::parse_lineto"
        description: "Parses LineTo command parameters (L x,y or l dx,dy)"
        postconditions: "Returns PathSegment::LineTo with absolute coordinates; updates current_point"
        
      - type: "method"
        name: "PathParser::parse_cubic_bezier"
        description: "Parses cubic bezier command parameters (C x1,y1 x2,y2 x,y or c dx1,dy1 dx2,dy2 dx,dy)"
        postconditions: "Returns PathSegment::CubicBezier with absolute coordinates; updates current_point and last_control_point to c2"
        
      - type: "method"
        name: "PathParser::parse_smooth_cubic"
        description: "Parses smooth cubic bezier command (S x2,y2 x,y or s dx2,dy2 dx,dy). Calculates c1 by reflecting last_control_point across current_point."
        preconditions: "If last_control_point is None, uses current_point as c1"
        postconditions: "Returns PathSegment::SmoothCubic; updates current_point and last_control_point"
        
      - type: "method"
        name: "PathParser::parse_quadratic_bezier"
        description: "Parses quadratic bezier command parameters (Q x1,y1 x,y or q dx1,dy1 dx,dy)"
        postconditions: "Returns PathSegment::QuadraticBezier with absolute coordinates; updates current_point and last_control_point"
        
      - type: "method"
        name: "PathParser::parse_coordinate_pair"
        description: "Parses single x,y coordinate pair from path string with whitespace and comma handling"
        postconditions: "Returns (f32, f32) tuple and advances position past coordinates and separators"
        
      - type: "method"
        name: "PathParser::skip_whitespace"
        description: "Advances parser position past whitespace and comma separators"
        postconditions: "position points to next non-whitespace character or end of string"
        
      - type: "method"
        name: "PathParser::parse_number"
        description: "Parses floating-point number from current position supporting decimal points, negative signs, and scientific notation"
        postconditions: "Returns f32 value and advances position; handles malformed numbers with error"
        
      - type: "function"
        name: "normalize_path"
        description: "Converts all relative path commands to absolute coordinates for simplified processing. Transforms lowercase commands (m, l, c, s, q) to uppercase equivalents with absolute positions."
        preconditions: "segments contains valid PathSegment vector with mixed absolute/relative commands"
        postconditions: "Returns Vec<PathSegment> with only absolute coordinates; semantically equivalent path"
        
      - type: "struct"
        name: "ParseError"
        description: "Error type for path parsing failures containing error message and character position"
        
      - type: "method"
        name: "ParseError::new"
        description: "Creates ParseError with message and position"
        postconditions: "Returns ParseError instance"

  - file: "src/ui/animation/geometry.rs"
    items:
      - type: "struct"
        name: "Point2D"
        description: "2D point with x and y floating-point coordinates. Used throughout geometry calculations."
        
      - type: "method"
        name: "Point2D::new"
        description: "Creates Point2D from x, y coordinates"
        postconditions: "Returns Point2D { x, y }"
        
      - type: "function"
        name: "line_length"
        description: "Calculates Euclidean distance between two points using Pythagorean theorem"
        preconditions: "p1 and p2 are valid Point2D instances"
        postconditions: "Returns non-negative f32 distance = sqrt((p2.x - p1.x)² + (p2.y - p1.y)²)"
        
      - type: "function"
        name: "cubic_bezier_length"
        description: "Approximates cubic bezier curve length via adaptive subdivision. Recursively subdivides curve until segments are flat enough (flatness tolerance), then sums line segment lengths."
        preconditions: "p0, c1, c2, p1 form valid cubic bezier curve points"
        postconditions: "Returns f32 length approximation within 0.1% tolerance; uses recursive subdivision up to max_depth=10"
        invariants: "Result is always non-negative; converges to true arc length as subdivision depth increases"
        
      - type: "function"
        name: "quadratic_bezier_length"
        description: "Approximates quadratic bezier curve length using adaptive subdivision similar to cubic bezier"
        preconditions: "p0, c, p1 form valid quadratic bezier curve"
        postconditions: "Returns f32 length approximation within 0.1% tolerance"
        
      - type: "function"
        name: "cubic_bezier_point_at"
        description: "Calculates point on cubic bezier curve at parameter t using De Casteljau's algorithm. Implements B(t) = (1-t)³P0 + 3(1-t)²tC1 + 3(1-t)t²C2 + t³P1."
        preconditions: "t in [0.0, 1.0]; p0, c1, c2, p1 are valid points"
        postconditions: "Returns Point2D on curve; t=0.0 returns p0; t=1.0 returns p1"
        invariants: "Result lies on bezier curve; interpolation is smooth"
        
      - type: "function"
        name: "quadratic_bezier_point_at"
        description: "Calculates point on quadratic bezier curve at parameter t. Implements B(t) = (1-t)²P0 + 2(1-t)tC + t²P1."
        preconditions: "t in [0.0, 1.0]; p0, c, p1 are valid points"
        postconditions: "Returns Point2D on curve; t=0.0 returns p0; t=1.0 returns p1"
        
      - type: "function"
        name: "cubic_bezier_length_at_t"
        description: "Finds parameter t corresponding to target arc length along cubic bezier using binary search. Solves: arc_length(0, t) = target_length."
        preconditions: "target_length >= 0.0 and target_length <= total curve length"
        postconditions: "Returns t in [0.0, 1.0] such that arc length from start to t approximately equals target_length within 0.01 tolerance"
        
      - type: "function"
        name: "quadratic_bezier_length_at_t"
        description: "Finds parameter t corresponding to target arc length along quadratic bezier using binary search"
        preconditions: "target_length >= 0.0 and target_length <= total curve length"
        postconditions: "Returns t in [0.0, 1.0] such that arc length from start to t equals target_length"
        
      - type: "function"
        name: "subdivide_adaptive"
        description: "Recursively subdivides bezier curve until flatness criterion is met. Returns vector of line segments approximating curve for length calculation."
        preconditions: "max_depth > 0; tolerance > 0.0; curve points are valid"
        postconditions: "Returns Vec<(Point2D, Point2D)> of line segments; segments connect continuously; total length approximates curve length"
        
      - type: "function"
        name: "flatness_measure"
        description: "Calculates flatness of bezier curve segment using maximum perpendicular distance of control points from line connecting endpoints"
        preconditions: "Curve points are valid"
        postconditions: "Returns f32 >= 0.0; smaller values indicate flatter curves; 0.0 means perfectly flat"
        
      - type: "function"
        name: "subdivide_cubic_bezier"
        description: "Subdivides cubic bezier at t=0.5 into two cubic bezier curves using De Casteljau subdivision"
        preconditions: "p0, c1, c2, p1 form valid cubic bezier"
        postconditions: "Returns ((p0_left, c1_left, c2_left, p_mid), (p_mid, c1_right, c2_right, p1)); curves are continuous at junction"

  - file: "src/ui/animation/easing.rs"
    items:
      - type: "function"
        name: "ease_out_cubic"
        description: "Cubic ease-out easing function implementing f(t) = 1 - (1-t)³. Provides rapid initial change that decelerates toward end, mimicking natural pen lift motion."
        preconditions: "t in [0.0, 1.0]"
        postconditions: "Returns value in [0.0, 1.0] with deceleration curve; derivative decreases as t approaches 1.0"
        invariants: "f(0.0) = 0.0; f(1.0) = 1.0; function is monotonically increasing; smooth and continuous"
        
      - type: "function"
        name: "ease_in_out_cubic"
        description: "Cubic ease-in-out easing function for smooth acceleration and deceleration. Implements piecewise function: t < 0.5 => 4t³, t >= 0.5 => 1 - 4(1-t)³."
        preconditions: "t in [0.0, 1.0]"
        postconditions: "Returns value in [0.0, 1.0]; symmetric around t=0.5; smooth at transition point"
        invariants: "f(0.0) = 0.0; f(0.5) = 0.5; f(1.0) = 1.0; derivative is zero at t=0 and t=1"
        
      - type: "function"
        name: "ease_in_out_quad"
        description: "Quadratic ease-in-out for gentler acceleration/deceleration than cubic"
        preconditions: "t in [0.0, 1.0]"
        postconditions: "Returns value in [0.0, 1.0]"
        invariants: "f(0.0) = 0.0; f(1.0) = 1.0; continuous and smooth"
        
      - type: "function"
        name: "linear"
        description: "Linear interpolation with no easing: f(t) = t. Used for testing and constant-speed animation."
        preconditions: "t in [0.0, 1.0]"
        postconditions: "Returns t unchanged"
        invariants: "f(t) = t for all t; constant velocity"
        
      - type: "function"
        name: "ease_in_cubic"
        description: "Cubic ease-in easing function f(t) = t³ for smooth acceleration from rest"
        preconditions: "t in [0.0, 1.0]"
        postconditions: "Returns value in [0.0, 1.0] with acceleration curve"
        invariants: "f(0.0) = 0.0; f(1.0) = 1.0; derivative is zero at t=0"

  - file: "src/ui/animation/renderer.rs"
    items:
      - type: "function"
        name: "render_partial_stroke"
        description: "Renders stroke path up to specified progress fraction using iced canvas Frame. Calculates target arc length, builds partial path, tessellates with lyon, and draws to canvas."
        preconditions: "progress in [0.0, 1.0]; stroke has valid segments; frame is valid iced::canvas::Frame; color is valid iced::Color"
        postconditions: "Path drawn from start to progress point; maintains visual continuity; stroke rendered with specified color and width"
        
      - type: "function"
        name: "render_complete_stroke"
        description: "Renders entire stroke path without partial calculation. Optimized path for completed strokes."
        preconditions: "stroke is valid StrokePath; frame is valid canvas Frame"
        postconditions: "Complete stroke path rendered to canvas with specified color and width"
        
      - type: "function"
        name: "build_partial_path"
        description: "Constructs lyon Path builder for partial stroke based on target arc length. Iterates through segments, accumulating length until target reached, then creates partial segment."
        preconditions: "target_length >= 0.0 and target_length <= stroke.total_length; stroke has valid segments"
        postconditions: "Returns lyon::path::Path containing segments up to target length; path is continuous and valid for tessellation"
        
      - type: "function"
        name: "build_complete_path"
        description: "Constructs lyon Path builder for complete stroke. Converts all PathSegments to lyon path commands."
        preconditions: "stroke has valid segments starting with MoveTo"
        postconditions: "Returns lyon::path::Path representing complete stroke; ready for tessellation"
        
      - type: "function"
        name: "interpolate_segment"
        description: "Calculates point along segment at specified arc length distance from start. Handles linear and bezier segment types differently."
        preconditions: "distance >= 0.0 and distance <= segment.calculate_length(start_point); segment is valid PathSegment"
        postconditions: "Returns Point2D on segment at exact arc length distance from start; maintains curve shape for bezier segments"
        
      - type: "function"
        name: "path_segment_to_lyon"
        description: "Converts PathSegment enum to lyon path builder commands. Maps MoveTo, LineTo, CubicBezier, etc. to lyon API calls."
        preconditions: "segment is valid PathSegment; builder is valid lyon PathBuilder; start_point provides current pen position"
        postconditions: "Segment added to lyon path builder; builder cursor updated to segment endpoint"
        
      - type: "constant"
        name: "DEFAULT_STROKE_WIDTH"
        description: "Default stroke width for rendering in pixels (2.0px provides good visibility)"
        
      - type: "constant"
        name: "STROKE_TOLERANCE"
        description: "Lyon tessellation tolerance for curve flattening (0.1 balances quality and performance)"

formal_verification:
  needed: false
  level: "None"
  explanation: |
    Formal verification is not required for the Stroke Order Animation System for the following reasons:

    1. NON-CRITICAL UI ANIMATION COMPONENT
       The stroke order animation is a visual teaching tool for displaying character writing sequences.
       Errors in animation timing, path rendering, or easing curves would be immediately visible to users
       and do not pose safety, security, or data integrity risks. The worst-case failure is a suboptimal
       visual learning experience, not system corruption or safety hazards.

    2. DETERMINISTIC BUT TIMING-SENSITIVE BEHAVIOR
       While the animation logic is deterministic (path calculations, segment interpolation), the correctness
       depends on timing and visual perception rather than mathematical proofs. The quality of easing curves
       and animation smoothness must be validated through visual inspection and user experience testing,
       which formal verification cannot address.

    3. ADEQUATE ALTERNATIVE VERIFICATION METHODS
       The task specification correctly identifies property-based testing as the appropriate verification
       approach. The critical properties can be effectively verified through:
       - Unit tests for path segment calculation and interpolation logic
       - Property-based tests ensuring partial path continuity across all input ranges
       - Integration tests verifying animation state machine transitions (playing → paused → reset)
       - Visual regression tests confirming timing and easing quality at 60fps

    4. SIMPLE COMPUTATIONAL DOMAIN
       The core logic involves:
       - Path segment interpolation (linear algebra on bezier curves)
       - Animation progress calculation (time-based percentage completion)
       - State transitions (play/pause/reset)
       These are straightforward operations that can be thoroughly tested without formal proofs.

    5. GPU ACCELERATION MAKES FORMAL VERIFICATION IMPRACTICAL
       The system uses lyon tessellation and GPU rendering for performance. Formal verification of GPU
       shader execution and rendering pipelines is extremely complex and not cost-effective for a UI
       animation component. The rendering correctness is best validated through visual testing.

    6. NO MEMORY SAFETY OR CONCURRENCY CONCERNS
       Rust's type system and ownership model already provide memory safety guarantees. The animation
       runs on a single thread with deterministic state updates. There are no race conditions, deadlocks,
       or complex concurrent behaviors that would benefit from formal verification.

    7. COST-BENEFIT ANALYSIS
       Formal verification would require:
       - Specifying formal properties for visual smoothness (subjective quality metric)
       - Proving timing constraints that depend on hardware performance
       - Modeling GPU tessellation and rendering behavior
       
       The cost vastly outweighs the benefit when standard testing provides sufficient confidence
       for a non-critical visual component.

    The task overview correctly sets formal_verification: false. Property-based testing combined with
    integration tests provides the appropriate level of confidence for this animation system. Formal
    verification would be engineering overkill with no practical benefit.

tests:
  strategy:
    approach: "mixed (unit + integration + property-based)"
    rationale:
      - "Unit tests verify deterministic components: path parsing, segment length calculations, and individual state transitions"
      - "Integration tests validate complex interactions: animation timing across multiple strokes, state machine transitions, and total duration calculations"
      - "Property-based tests ensure mathematical correctness: monotonicity of partial paths, bounds preservation in easing functions, and consistency of length calculations across diverse inputs"
      - "Animation logic is deterministic and timing-based, making it well-suited to automated testing without visual inspection"
      - "Critical properties (path continuity, progress interpolation) are testable through programmatic assertions"
      - "Performance characteristics (60fps requirement) verified through timing assertions within tests"
      - "Edge cases (empty strokes, zero durations, boundary progress values) explicitly tested to prevent runtime failures"
      - "Separation of concerns: geometric calculations, animation state, and rendering logic tested independently before integration"
  
  implementation:
    file: "tests/stroke_animation_tests.rs"
    location: "create new"
    code: |
      //! Comprehensive test suite for Stroke Order Animation System
      //! 
      //! This module tests the GPU-accelerated stroke-by-stroke animation system
      //! including path parsing, length calculations, partial path rendering,
      //! animation state transitions, and timing accuracy.
      
      use crate::ui::animation::path::{PathSegment, StrokePath};
      use crate::ui::animation::stroke_order::{
          AnimationConfig, AnimationState, EasingFunction, StrokeColor, StrokeOrderAnimation,
      };
      use std::time::Duration;
      
      // ===== Path Segment Parsing Tests =====
      // Verify SVG command parsing for all supported segment types
      
      #[cfg(test)]
      mod path_parsing_tests {
          use super::*;
      
          #[test]
          fn test_parse_moveto_command() {
              let svg_cmd = "M 10 20";
              let segment = PathSegment::parse(svg_cmd).expect("Failed to parse MoveTo command");
              
              assert!(
                  matches!(segment, PathSegment::MoveTo { x: 10.0, y: 20.0 }),
                  "Expected MoveTo(10.0, 20.0), got {:?}",
                  segment
              );
          }
      
          #[test]
          fn test_parse_lineto_command() {
              let svg_cmd = "L 30 40";
              let segment = PathSegment::parse(svg_cmd).expect("Failed to parse LineTo command");
              
              assert!(
                  matches!(segment, PathSegment::LineTo { x: 30.0, y: 40.0 }),
                  "Expected LineTo(30.0, 40.0), got {:?}",
                  segment
              );
          }
      
          #[test]
          fn test_parse_cubic_bezier_command() {
              let svg_cmd = "C 10 20, 30 40, 50 60";
              let segment = PathSegment::parse(svg_cmd).expect("Failed to parse CubicBezier");
              
              if let PathSegment::CubicBezier {
                  c1_x,
                  c1_y,
                  c2_x,
                  c2_y,
                  x,
                  y,
              } = segment
              {
                  assert_eq!(c1_x, 10.0, "Control point 1 x coordinate mismatch");
                  assert_eq!(c1_y, 20.0, "Control point 1 y coordinate mismatch");
                  assert_eq!(c2_x, 30.0, "Control point 2 x coordinate mismatch");
                  assert_eq!(c2_y, 40.0, "Control point 2 y coordinate mismatch");
                  assert_eq!(x, 50.0, "End point x coordinate mismatch");
                  assert_eq!(y, 60.0, "End point y coordinate mismatch");
              } else {
                  panic!("Expected CubicBezier variant, got {:?}", segment);
              }
          }
      
          #[test]
          fn test_parse_smooth_cubic_command() {
              let svg_cmd = "S 30 40, 50 60";
              let segment = PathSegment::parse(svg_cmd).expect("Failed to parse SmoothCubic");
              
              if let PathSegment::SmoothCubic { c2_x, c2_y, x, y } = segment {
                  assert_eq!(c2_x, 30.0);
                  assert_eq!(c2_y, 40.0);
                  assert_eq!(x, 50.0);
                  assert_eq!(y, 60.0);
              } else {
                  panic!("Expected SmoothCubic variant, got {:?}", segment);
              }
          }
      
          #[test]
          fn test_parse_quadratic_bezier_command() {
              let svg_cmd = "Q 10 20, 30 40";
              let segment = PathSegment::parse(svg_cmd).expect("Failed to parse QuadraticBezier");
              
              if let PathSegment::QuadraticBezier { c_x, c_y, x, y } = segment {
                  assert_eq!(c_x, 10.0);
                  assert_eq!(c_y, 20.0);
                  assert_eq!(x, 30.0);
                  assert_eq!(y, 40.0);
              } else {
                  panic!("Expected QuadraticBezier variant, got {:?}", segment);
              }
          }
      
          #[test]
          fn test_parse_complete_svg_path() {
              let svg_path = "M 0 0 L 100 0 L 100 100 L 0 100 Z";
              let stroke = StrokePath::from_svg_path(svg_path)
                  .expect("Failed to parse complete SVG path");
              
              assert_eq!(stroke.segments.len(), 5, "Square path should have 5 segments");
              assert!(
                  stroke.total_length > 0.0,
                  "Total length must be positive for non-empty path"
              );
              // Square perimeter: 100 + 100 + 100 + 100 = 400
              assert!(
                  (stroke.total_length - 400.0).abs() < 1.0,
                  "Expected perimeter ~400, got {}",
                  stroke.total_length
              );
          }
      
          #[test]
          fn test_parse_invalid_svg_command() {
              let invalid_cmd = "X 10 20"; // X is not a valid SVG command
              let result = PathSegment::parse(invalid_cmd);
              
              assert!(
                  result.is_err(),
                  "Parsing invalid command should return error"
              );
          }
      
          #[test]
          fn test_parse_malformed_coordinates() {
              let malformed = "M abc def";
              let result = PathSegment::parse(malformed);
              
              assert!(
                  result.is_err(),
                  "Malformed coordinates should fail to parse"
              );
          }
      
          #[test]
          fn test_parse_path_with_negative_coordinates() {
              let svg_path = "M -10 -20 L 30 -40";
              let stroke = StrokePath::from_svg_path(svg_path)
                  .expect("Should handle negative coordinates");
              
              assert_eq!(stroke.segments.len(), 2);
          }
      }
      
      // ===== Length Calculation Tests =====
      // Verify geometric length calculations for all segment types
      
      #[cfg(test)]
      mod length_calculation_tests {
          use super::*;
      
          #[test]
          fn test_line_segment_length_3_4_5_triangle() {
              let start = (0.0, 0.0);
              let segment = PathSegment::LineTo { x: 3.0, y: 4.0 };
              
              let length = segment.calculate_length(start);
              
              // Pythagorean theorem: sqrt(3^2 + 4^2) = 5
              assert!(
                  (length - 5.0).abs() < 0.001,
                  "Expected length 5.0, got {}",
                  length
              );
          }
      
          #[test]
          fn test_moveto_has_zero_length() {
              let start = (10.0, 20.0);
              let segment = PathSegment::MoveTo { x: 100.0, y: 200.0 };
              
              let length = segment.calculate_length(start);
              
              assert_eq!(length, 0.0, "MoveTo should have zero length");
          }
      
          #[test]
          fn test_stroke_total_length_calculation() {
              // Rectangle path: 10 + 10 +10 + 10 = 30 (without closing Z)
              let svg_path = "M 0 0 L 10 0 L 10 10 L 0 10";
              let stroke = StrokePath::from_svg_path(svg_path)
                  .expect("Failed to parse rectangle path");
              
              assert!(
                  (stroke.total_length - 30.0).abs() < 0.001,
                  "Expected total length 30.0, got {}",
                  stroke.total_length
              );
          }
      
          #[test]
          fn test_bezier_curve_length_straight_line() {
              // Bezier curve with control points on the line should approximate line length
              let start = (0.0, 0.0);
              let segment = PathSegment::CubicBezier {
                  c1_x: 10.0,
                  c1_y: 0.0,
                  c2_x: 20.0,
                  c2_y: 0.0,
                  x: 30.0,
                  y: 0.0,
              };
              
              let length = segment.calculate_length(start);
              
              // Should be close to 30.0 for straight line
              assert!(
                  (length - 30.0).abs() < 1.0,
                  "Straight bezier should approximate line length, got {}",
                  length
              );
          }
      
          #[test]
          fn test_bezier_curve_length_is_positive() {
              let start = (0.0, 0.0);
              let segment = PathSegment::CubicBezier {
                  c1_x: 5.0,
                  c1_y: 10.0,
                  c2_x: 15.0,
                  c2_y: 10.0,
                  x: 20.0,
                  y: 0.0,
              };
              
              let length = segment.calculate_length(start);
              
              assert!(length > 0.0, "Bezier length must be positive");
              assert!(
                  length >= 20.0,
                  "Curved path should be >= straight-line distance"
              );
          }
      
          #[test]
          fn test_quadratic_bezier_length() {
              let start = (0.0, 0.0);
              let segment = PathSegment::QuadraticBezier {
                  c_x: 10.0,
                  c_y: 10.0,
                  x: 20.0,
                  y: 0.0,
              };
              
              let length = segment.calculate_length(start);
              
              assert!(length > 0.0);
              assert!(length >= 20.0); // Must be >= straight distance
          }
      }
      
      // ===== Partial Path Calculation Tests =====
      // Verify progressive path rendering at various progress points
      
      #[cfg(test)]
      mod partial_path_tests {
          use super::*;
      
          #[test]
          fn test_partial_path_at_zero_progress() {
              let svg_path = "M 0 0 L 100 0";
              let stroke = StrokePath::from_svg_path(svg_path).unwrap();
              
              let partial = stroke.calculate_partial_path(0.0);
              
              assert_eq!(
                  partial.segments.len(),
                  1,
                  "At 0% progress, only MoveTo should be present"
              );
              assert!(matches!(partial.segments[0], PathSegment::MoveTo { .. }));
          }
      
          #[test]
          fn test_partial_path_at_full_progress() {
              let svg_path = "M 0 0 L 100 0 L 100 100";
              let stroke = StrokePath::from_svg_path(svg_path).unwrap();
              
              let partial = stroke.calculate_partial_path(1.0);
              
              assert_eq!(
                  partial.segments.len(),
                  stroke.segments.len(),
                  "At 100% progress, all segments should be included"
              );
          }
      
          #[test]
          fn test_partial_path_at_midpoint() {
              let svg_path = "M 0 0 L 100 0";
              let stroke = StrokePath::from_svg_path(svg_path).unwrap();
              
              let partial = stroke.calculate_partial_path(0.5);
              
              assert_eq!(partial.segments.len(), 2);
              if let PathSegment::LineTo { x, y } = partial.segments[1] {
                  assert!(
                      (x - 50.0).abs() < 0.5,
                      "At 50% progress, x should be ~50, got {}",
                      x
                  );
                  assert!((y - 0.0).abs() < 0.1, "y should remain at 0");
              } else {
                  panic!("Expected LineTo at segment 1");
              }
          }
      
          #[test]
          fn test_partial_path_across_multiple_segments() {
              // Two equal segments: 50 + 50 = 100 total
              let svg_path = "M 0 0 L 50 0 L 100 0";
              let stroke = StrokePath::from_svg_path(svg_path).unwrap();
              
              // 75% progress should be in the middle of second segment
              let partial = stroke.calculate_partial_path(0.75);
              
              assert_eq!(
                  partial.segments.len(),
                  3,
                  "Should include MoveTo + 2 LineTos"
              );
          }
      
          #[test]
          fn test_partial_path_continuity() {
              let svg_path = "M 0 0 L 100 0 L 100 100";
              let stroke = StrokePath::from_svg_path(svg_path).unwrap();
              
              // Test continuity by checking adjacent progress values
              let partial_40 = stroke.calculate_partial_path(0.40);
              let partial_41 = stroke.calculate_partial_path(0.41);
              
              let end_40 = partial_40.get_end_point();
              let end_41 = partial_41.get_end_point();
              
              let distance =
                  ((end_41.0 - end_40.0).powi(2) + (end_41.1 - end_40.1).powi(2)).sqrt();
              
              assert!(
                  distance < 2.5,
                  "Adjacent progress values should have continuous endpoints, distance: {}",
                  distance
              );
          }
      
          #[test]
          fn test_partial_path_length_monotonicity() {
              let svg_path = "M 0 0 L 100 0 L 100 100 L 0 100";
              let stroke = StrokePath::from_svg_path(svg_path).unwrap();
              
              let mut prev_length = 0.0;
              for progress in [0.0, 0.25, 0.5, 0.75, 1.0] {
                  let partial = stroke.calculate_partial_path(progress);
                  assert!(
                      partial.total_length >= prev_length,
                      "Length should increase monotonically: {} vs {} at progress {}",
                      partial.total_length,
                      prev_length,
                      progress
                  );
                  prev_length = partial.total_length;
              }
          }
      }
      
      // ===== Animation State Transition Tests =====
      // Verify animation lifecycle management
      
      #[cfg(test)]
      mod animation_state_tests {
          use super::*;
      
          #[test]
          fn test_animation_initial_state() {
              let strokes = vec![StrokePath::from_svg_path("M 0 0 L 100 0").unwrap()];
              let config = AnimationConfig {
                  stroke_duration: Duration::from_millis(500),
                  pause_duration: Duration::from_millis(200),
                  ease: EasingFunction::EaseOutCubic,
              };
              
              let animation = StrokeOrderAnimation::new(strokes, config);
              
              assert_eq!(animation.current_stroke_index, 0);
              assert_eq!(animation.state, AnimationState::Paused);
              assert_eq!(animation.progress, 0.0);
          }
      
          #[test]
          fn test_animation_play_pause_transitions() {
              let strokes = vec![StrokePath::from_svg_path("M 0 0 L 100 0").unwrap()];
              let config = AnimationConfig::default();
              let mut animation = StrokeOrderAnimation::new(strokes, config);
              
              animation.play();
              assert_eq!(
                  animation.state,
                  AnimationState::Playing,
                  "Animation should transition to Playing"
              );
              
              animation.pause();
              assert_eq!(
                  animation.state,
                  AnimationState::Paused,
                  "Animation should transition to Paused"
              );
          }
      
          #[test]
          fn test_animation_reset() {
              let strokes = vec![
                  StrokePath::from_svg_path("M 0 0 L 100 0").unwrap(),
                  StrokePath::from_svg_path("M 0 0 L 0 100").unwrap(),
              ];
              let config = AnimationConfig::default();
              let mut animation = StrokeOrderAnimation::new(strokes, config);
              
              // Advance animation state
              animation.current_stroke_index = 1;
              animation.progress = 0.75;
              animation.state = AnimationState::Playing;
              
              animation.reset();
              
              assert_eq!(animation.current_stroke_index, 0, "Should reset to first stroke");
              assert_eq!(animation.progress, 0.0, "Should reset progress to 0");
              assert_eq!(animation.state, AnimationState::Paused, "Should pause on reset");
          }
      
          #[test]
          fn test_animation_stroke_completion_advances_index() {
              let strokes = vec![
                  StrokePath::from_svg_path("M 0 0 L 100 0").unwrap(),
                  StrokePath::from_svg_path("M 0 0 L 0 100").unwrap(),
              ];
              let config = AnimationConfig {
                  stroke_duration: Duration::from_millis(500),
                  pause_duration: Duration::from_millis(0),
                  ease: EasingFunction::Linear,
              };
              let mut animation = StrokeOrderAnimation::new(strokes, config);
              animation.play();
              
              let start = std::time::Instant::now();
              animation.update(start);
              animation.update(start + Duration::from_millis(500));
              
              assert_eq!(
                  animation.current_stroke_index, 1,
                  "Should advance to next stroke"
              );
              assert_eq!(animation.progress, 0.0, "Progress should reset for new stroke");
          }
      
          #[test]
          fn test_animation_full_completion() {
              let strokes = vec![StrokePath::from_svg_path("M 0 0 L 100 0").unwrap()];
              let config = AnimationConfig {
                  stroke_duration: Duration::from_millis(100),
                  pause_duration: Duration::from_millis(0),
                  ease: EasingFunction::Linear,
              };
              let mut animation = StrokeOrderAnimation::new(strokes, config);
              animation.play();
              
              let start = std::time::Instant::now();
              animation.update(start);
              animation.update(start + Duration::from_millis(200));
              
              assert_eq!(
                  animation.state,
                  AnimationState::Completed,
                  "Animation should complete"
              );
              assert_eq!(animation.progress, 1.0, "Final progress should be 1.0");
          }
      
          #[test]
          fn test_animation_pause_between_strokes() {
              let strokes = vec![
                  StrokePath::from_svg_path("M 0 0 L 100 0").unwrap(),
                  StrokePath::from_svg_path("M 0 0 L 0 100").unwrap(),
              ];
              let config = AnimationConfig {
                  stroke_duration: Duration::from_millis(500),
                  pause_duration: Duration::from_millis(200),
                  ease: EasingFunction::Linear,
              };
              let mut animation = StrokeOrderAnimation::new(strokes, config);
              animation.play();
              
              let start = std::time::Instant::now();
              animation.update(start);
              
              // After first stroke completes
              animation.update(start + Duration::from_millis(500));
              assert_eq!(
                  animation.state,
                  AnimationState::PauseBetweenStrokes,
                  "Should pause between strokes"
              );
              
              // After pause duration
              animation.update(start + Duration::from_millis(700));
              assert_eq!(
                  animation.state,
                  AnimationState::Playing,
                  "Should resume playing after pause"
              );
              assert_eq!(
                  animation.current_stroke_index, 1,
                  "Should be on second stroke"
              );
          }
      
          #[test]
          fn test_empty_stroke_list_completes_immediately() {
              let strokes: Vec<StrokePath> = vec![];
              let config = AnimationConfig::default();
              let animation = StrokeOrderAnimation::new(strokes, config);
              
              assert_eq!(
                  animation.state,
                  AnimationState::Completed,
                  "Empty animation should be completed"
              );
              assert_eq!(
                  animation.calculate_total_duration(),
                  Duration::ZERO,
                  "Empty animation duration should be zero"
              );
          }
      }

      // ===== Easing Function Tests =====
      // Verify easing curve correctness
      
      #[cfg(test)]
      mod easing_tests {
          use super::*;
      
          #[test]
          fn test_linear_easing_identity() {
              let easing = EasingFunction::Linear;
              
              assert_eq!(easing.apply(0.0), 0.0);
              assert_eq!(easing.apply(0.5), 0.5);
              assert_eq!(easing.apply(1.0), 1.0);
          }
      
          #[test]
          fn test_ease_out_cubic_endpoints() {
              let easing = EasingFunction::EaseOutCubic;
              
              assert_eq!(easing.apply(0.0), 0.0, "Should start at 0");
              assert_eq!(easing.apply(1.0), 1.0, "Should end at 1");
          }
      
          #[test]
          fn test_ease_out_cubic_deceleration_curve() {
              let easing = EasingFunction::EaseOutCubic;
              
              // Early changes should be larger than late changes (deceleration)
              let early_delta = easing.apply(0.2) - easing.apply(0.1);
              let late_delta = easing.apply(0.9) - easing.apply(0.8);
              
              assert!(
                  early_delta > late_delta,
                  "EaseOutCubic should decelerate: early {} > late {}",
                  early_delta,
                  late_delta
              );
          }
      
          #[test]
          fn test_all_easing_functions_preserve_bounds() {
              let easings = vec![
                  EasingFunction::Linear,
                  EasingFunction::EaseOutCubic,
                  EasingFunction::EaseInOutQuad,
              ];
              
              for easing in easings {
                  for t in [0.0, 0.25, 0.5, 0.75, 1.0] {
                      let result = easing.apply(t);
                      assert!(
                          result >= 0.0 && result <= 1.0,
                          "{:?} at t={} should be in [0,1], got {}",
                          easing,
                          t,
                          result
                      );
                  }
              }
          }
      
          #[test]
          fn test_easing_monotonicity() {
              let easings = vec![
                  EasingFunction::Linear,
                  EasingFunction::EaseOutCubic,
                  EasingFunction::EaseInOutQuad,
              ];
              
              for easing in easings {
                  let mut prev = 0.0;
                  for i in 0..=100 {
                      let t = i as f32 / 100.0;
                      let result = easing.apply(t);
                      assert!(
                          result >= prev,
                          "{:?} should be monotonic: {} >= {} at t={}",
                          easing,
                          result,
                          prev,
                          t
                      );
                      prev = result;
                  }
              }
          }
      }
      
      // ===== Timing and Duration Tests =====
      // Verify animation timing calculations
      
      #[cfg(test)]
      mod timing_tests {
          use super::*;
      
          #[test]
          fn test_total_animation_duration_calculation() {
              let strokes = vec![
                  StrokePath::from_svg_path("M 0 0 L 100 0").unwrap(),
                  StrokePath::from_svg_path("M 0 0 L 0 100").unwrap(),
              ];
              let config = AnimationConfig {
                  stroke_duration: Duration::from_millis(600),
                  pause_duration: Duration::from_millis(300),
                  ease: EasingFunction::Linear,
              };
              let animation = StrokeOrderAnimation::new(strokes, config);
              
              let total = animation.calculate_total_duration();

              // 2 strokes * 600ms + 1 pause * 300ms = 1500ms
              assert_eq!(
                  total,
                  Duration::from_millis(1500),
                  "Total duration calculation incorrect"
              );
          }
      
          #[test]
          fn test_duration_single_stroke_no_pause() {
              let strokes = vec![StrokePath::from_svg_path("M 0 0 L 100 0").unwrap()];
              let config = AnimationConfig {
                  stroke_duration: Duration::from_millis(800),
                  pause_duration: Duration::from_millis(200),
                  ease: EasingFunction::Linear,
              };
              let animation = StrokeOrderAnimation::new(strokes, config);
              
              // Single stroke: no pause after
              assert_eq!(
                  animation.calculate_total_duration(),
                  Duration::from_millis(800)
              );
          }
      
          #[test]
          fn test_full_animation_timing_sequence() {
              let strokes = vec![
                  StrokePath::from_svg_path("M 0 0 L 100 0").unwrap(),
                  StrokePath::from_svg_path("M 100 0 L 100 100").unwrap(),
                  StrokePath::from_svg_path("M 100 100 L 0 100").unwrap(),
              ];
              let config = AnimationConfig {
                  stroke_duration: Duration::from_millis(500),
                  pause_duration: Duration::from_millis(200),
                  ease: EasingFunction::Linear,
              };
              let mut animation = StrokeOrderAnimation::new(strokes, config);
              animation.play();
              
              let start = std::time::Instant::now();
              animation.update(start);
              
              // Test checkpoints throughout animation
              let checkpoints = vec![
                  (0, 0, 0.0, AnimationState::Playing),
                  (250, 0, 0.5, AnimationState::Playing),
                  (500, 0, 1.0, AnimationState::PauseBetweenStrokes),
                  (700, 1, 0.0, AnimationState::Playing),
                  (950, 1, 0.5, AnimationState::Playing),
                  (1200, 1, 1.0, AnimationState::PauseBetweenStrokes),
                  (1400, 2, 0.0, AnimationState::Playing),
                  (1900, 2, 1.0, AnimationState::Completed),
              ];
              
              for (millis, expected_index, expected_progress, expected_state) in checkpoints {
                  animation.update(start + Duration::from_millis(millis));
                  
                  assert_eq!(
                      animation.current_stroke_index, expected_index,
                      "At {}ms: stroke index mismatch",
                      millis
                  );
                  
                  if expected_state != AnimationState::PauseBetweenStrokes {
                      assert!(
                          (animation.progress - expected_progress).abs() < 0.1,
                          "At {}ms: expected progress {}, got {}",
                          millis,
                          expected_progress,
                          animation.progress
                      );
                  }
                  
                  assert_eq!(
                      animation.state, expected_state,
                      "At {}ms: state mismatch",
                      millis
                  );
              }
          }
      }
      
      // ===== Rendering State Tests =====
      // Verify visual state differentiation
      
      #[cfg(test)]
      mod rendering_tests {
          use super::*;
      
          #[test]
          fn test_stroke_color_differentiation() {
              let strokes = vec![
                  StrokePath::from_svg_path("M 0 0 L 100 0").unwrap(),
                  StrokePath::from_svg_path("M 0 0 L 0 100").unwrap(),
                  StrokePath::from_svg_path("M 0 0 L 50 50").unwrap(),
              ];
              let config = AnimationConfig::default();
              let mut animation = StrokeOrderAnimation::new(strokes, config);
              animation.current_stroke_index = 1;
              animation.progress = 0.5;
              
              let colors = animation.get_stroke_colors();
              
              assert_eq!(
                  colors[0],
                  StrokeColor::Completed,
                  "Completed stroke should be black"
              );
              assert_eq!(
                  colors[1],
                  StrokeColor::Animating,
                  "Current stroke should be blue"
              );
              assert_eq!(
                  colors[2],
                  StrokeColor::Pending,
                  "Future stroke should be gray"
              );
          }
      
          #[test]
          fn test_all_strokes_completed_color() {
              let strokes = vec![
                  StrokePath::from_svg_path("M 0 0 L 100 0").unwrap(),
                  StrokePath::from_svg_path("M 0 0 L 0 100").unwrap(),
              ];
              let config = AnimationConfig::default();
              let mut animation = StrokeOrderAnimation::new(strokes, config);
              animation.state = AnimationState::Completed;
              animation.current_stroke_index = 1;
              animation.progress = 1.0;
              
              let colors = animation.get_stroke_colors();
              
              assert_eq!(colors[0], StrokeColor::Completed);
              assert_eq!(colors[1], StrokeColor::Completed);
          }
      }
      
      // ===== Property-Based Tests =====
      // Verify mathematical properties across diverse inputs
      
      #[cfg(test)]
      mod property_tests {
          use super::*;
          use proptest::prelude::*;
      
          fn progress_strategy() -> impl Strategy<Value = f32> {
              (0.0..=1.0_f32)
          }
      
          fn simple_line_path_strategy() -> impl Strategy<Value = String> {
              (0.0..1000.0_f32, 0.0..1000.0_f32, 0.0..1000.0_f32, 0.0..1000.0_f32)
                  .prop_map(|(x1, y1, x2, y2)| format!("M {} {} L {} {}", x1, y1, x2, y2))
          }
      
          fn multi_segment_path_strategy() -> impl Strategy<Value = String> {
              prop::collection::vec((0.0..1000.0_f32, 0.0..1000.0_f32), 2..10).prop_map(
                  |points| {
                      let mut path = format!("M {} {}", points[0].0, points[0].1);
                      for (x, y) in &points[1..] {
                          path.push_str(&format!(" L {} {}", x, y));
                      }
                      path
                  },
              )
          }
      
          proptest! {
              #[test]
              fn prop_partial_path_length_monotonic(
                  svg_path in simple_line_path_strategy(),
                  p1 in progress_strategy(),
                  p2 in progress_strategy()
              ) {
                  let stroke = StrokePath::from_svg_path(&svg_path).unwrap();
                  
                  let partial1 = stroke.calculate_partial_path(p1);
                  let partial2 = stroke.calculate_partial_path(p2);
                  
                  let len1 = partial1.total_length;
                  let len2 = partial2.total_length;
                  
                  if p1 <= p2 {
                      prop_assert!(
                          len1 <= len2 + 0.01,
                          "Partial path length should increase with progress: {} vs {} at {}-{}",
                          len1, len2, p1, p2
                      );
                  }
              }
      
              #[test]
              fn prop_partial_path_bounded_by_total(
                  svg_path in simple_line_path_strategy(),
                  progress in progress_strategy()
              ) {
                  let stroke = StrokePath::from_svg_path(&svg_path).unwrap();
                  let partial = stroke.calculate_partial_path(progress);
                  
                  prop_assert!(partial.total_length >= 0.0, "Length must be non-negative");
                  prop_assert!(
                      partial.total_length <= stroke.total_length + 0.1,
                      "Partial length {} should not exceed total {}",
                      partial.total_length, stroke.total_length
                  );
              }
      
              #[test]
              fn prop_easing_preserves_domain_bounds(t in progress_strategy()) {
                  let easings = vec![
                      EasingFunction::Linear,
                      EasingFunction::EaseOutCubic,
                      EasingFunction::EaseInOutQuad,
                  ];
                  
                  for easing in easings {
                      let result = easing.apply(t);
                      prop_assert!(
                          result >= -0.001 && result <= 1.001,
                          "{:?} should map [0,1] to [0,1], got {} for t={}",
                          easing, result, t
                      );
                  }
              }
      
              #[test]
              fn prop_stroke_length_always_positive(svg_path in multi_segment_path_strategy()) {
                  let stroke = StrokePath::from_svg_path(&svg_path).unwrap();
                  prop_assert!(stroke.total_length >= 0.0, "Total length must be non-negative");
              }
      
              #[test]
              fn prop_animation_duration_formula(
                  num_strokes in 1_usize..20,
                  stroke_ms in 100_u64..2000,
                  pause_ms in 0_u64..1000
              ) {
                  let strokes: Vec<StrokePath> = (0..num_strokes)
                      .map(|i| StrokePath::from_svg_path(&format!("M 0 0 L {} 0", i * 10)).unwrap())
                      .collect();
                  
                  let config = AnimationConfig {
                      stroke_duration: Duration::from_millis(stroke_ms),
                      pause_duration: Duration::from_millis(pause_ms),
                      ease: EasingFunction::Linear,
                  };
                  
                  let animation = StrokeOrderAnimation::new(strokes, config);
                  let total = animation.calculate_total_duration();
                  
                  // Formula: n * stroke_duration + (n-1) * pause_duration
                  let expected = Duration::from_millis(
                      num_strokes as u64 * stroke_ms + (num_strokes as u64 - 1) * pause_ms
                  );
                  
                  prop_assert_eq!(total, expected, "Duration formula incorrect");
              }
      
              #[test]
              fn prop_partial_path_at_boundaries(svg_path in simple_line_path_strategy()) {
                  let stroke = StrokePath::from_svg_path(&svg_path).unwrap();
                  
                  let start_partial = stroke.calculate_partial_path(0.0);
                  let end_partial = stroke.calculate_partial_path(1.0);
                  
                  prop_assert!(start_partial.total_length < 0.1, "Start should have ~zero length");
                  prop_assert!(
                      (end_partial.total_length - stroke.total_length).abs() < 0.1,
                      "End should match total length"
                  );
              }
      
              #[test]
              fn prop_path_continuity_fine_grained(
                  svg_path in multi_segment_path_strategy(),
                  progress in 0.0..0.99_f32
              ) {
                  let stroke = StrokePath::from_svg_path(&svg_path).unwrap();
                  
                  let p1 = stroke.calculate_partial_path(progress);
                  let p2 = stroke.calculate_partial_path(progress + 0.01);
                  
                  let end1 = p1.get_end_point();
                  let end2 = p2.get_end_point();
                  
                  let distance = ((end2.0 - end1.0).powi(2) + (end2.1 - end1.1).powi(2)).sqrt();
                  
                  prop_assert!(
                      distance < stroke.total_length * 0.02,
                      "Continuity violated: distance {} too large for 1% progress increment",
                      distance
                  );
              }
          }
      }
      
      // ===== Edge Case Tests =====
      // Verify handling of boundary conditions
      
      #[cfg(test)]
      mod edge_case_tests {
          use super::*;
      
          #[test]
          fn test_single_point_path() {
              let svg_path = "M 50 50";
              let stroke = StrokePath::from_svg_path(svg_path).unwrap();
              
              assert_eq!(stroke.total_length, 0.0);
              assert_eq!(stroke.segments.len(), 1);
          }
      
          #[test]
          fn test_zero_length_stroke() {
              let svg_path = "M 10 10 M 20 20"; // Only MoveTo commands
              let stroke = StrokePath::from_svg_path(svg_path).unwrap();
              
              assert_eq!(stroke.total_length, 0.0);
          }
      
          #[test]
          fn test_very_short_animation_duration() {
              let strokes = vec![StrokePath::from_svg_path("M 0 0 L 100 0").unwrap()];
              let config = AnimationConfig {
                  stroke_duration: Duration::from_millis(1),
                  pause_duration: Duration::from_millis(0),
                  ease: EasingFunction::Linear,
              };
              let mut animation = StrokeOrderAnimation::new(strokes, config);
              animation.play();
              
              let start = std::time::Instant::now();
              animation.update(start);
              animation.update(start + Duration::from_millis(5));
              
              assert_eq!(animation.state, AnimationState::Completed);
          }
      
          #[test]
          fn test_progress_clamping_at_boundaries() {
              let svg_path = "M 0 0 L 100 0";
              let stroke = StrokePath::from_svg_path(svg_path).unwrap();
              
              // Test beyond boundaries
              let partial_negative = stroke.calculate_partial_path(-0.1);
              let partial_over = stroke.calculate_partial_path(1.5);
              
              assert!(partial_negative.total_length >= 0.0);
              assert!(partial_over.total_length <= stroke.total_length + 0.1);
          }
      
          #[test]
          fn test_animation_update_when_paused() {
              let strokes = vec![StrokePath::from_svg_path("M 0 0 L 100 0").unwrap()];
              let config = AnimationConfig::default();
              let mut animation = StrokeOrderAnimation::new(strokes, config);
              
              let start = std::time::Instant::now();
              animation.update(start);
              animation.update(start + Duration::from_millis(1000));
              
              // Should remain at 0 progress when paused
              assert_eq!(animation.progress, 0.0);
              assert_eq!(animation.state, AnimationState::Paused);
          }
      
          #[test]
          fn test_very_large_coordinate_values() {
              let svg_path = "M 10000 10000 L 20000 20000";
              let stroke = StrokePath::from_svg_path(svg_path).unwrap();
              
              assert!(stroke.total_length > 0.0);
              assert!(!stroke.total_length.is_nan());
              assert!(!stroke.total_length.is_infinite());
          }
      }
  
  coverage:
    - "SVG MoveTo command parsing with absolute coordinates"
    - "SVG LineTo command parsing with absolute coordinates"
    - "SVG CubicBezier command parsing with two control points"
    - "SVG SmoothCubic command parsing with reflected control point"
    - "SVG QuadraticBezier command parsing with single control point"
    - "Complete SVG path parsing with multiple segments"
    - "Invalid SVG command rejection and error handling"
    - "Malformed coordinate parsing error handling"
    - "Negative coordinate support in path parsing"
    - "Line segment length calculation using Pythagorean theorem"
    - "MoveTo command zero-length invariant"
    - "Total stroke length aggregation across segments"
    - "Cubic bezier curve length approximation for straight lines"
    - "Cubic bezier curve length approximation for curved paths"
    - "Quadratic bezier curve length calculation"
    - "Partial path at 0% progress (start point only)"
    - "Partial path at 100% progress (complete path)"
    - "Partial path at 50% progress (midpoint interpolation)"
    - "Partial path spanning multiple segments"
    - "Partial path continuity between adjacent progress values"
    - "Partial path length monotonic increase with progress"
    - "Animation initialization to paused state at stroke 0"
    - "Play state transition from paused"
    - "Pause state transition from playing"
    - "Reset functionality restoring initial state"
    - "Stroke completion advancing to next stroke index"
    - "Full animation completion to Completed state"
    - "Pause duration between consecutive strokes"
    - "Empty stroke list immediate completion"
    - "Linear easing identity function"
    - "EaseOutCubic endpoint values (0 and 1)"
    - "EaseOutCubic deceleration curve shape"
    - "All easing functions preserve [0,1] domain bounds"
    - "Easing function monotonicity throughout domain"
    - "Total animation duration formula: n*stroke + (n-1)*pause"
    - "Single stroke duration without pause"
    - "Full multi-stroke animation timing sequence"
    - "Stroke color differentiation: completed, animating, pending"
    - "All strokes marked completed after animation finishes"
    - "Property: partial path length increases monotonically with progress"
    - "Property: partial path length bounded by total stroke length"
    - "Property: easing functions map [0,1] to [0,1]"
    - "Property: stroke lengths are always non-negative"
    - "Property: animation duration formula correctness across parameter ranges"
    - "Property: partial path at 0.0 has ~zero length"
    - "Property: partial path at 1.0 matches total length"
    - "Property: path endpoint continuity for fine-grained progress increments"
    - "Edge case: single point path with zero length"
    - "Edge case: path with only MoveTo commands"
    - "Edge case: very short animation duration (1ms)"
    - "Edge case: progress clamping at negative and >1.0 values"
    - "Edge case: animation updates when in paused state"
    - "Edge case: very large coordinate values without overflow"

dependencies:
  depends_on:
    - task_id: 1
      reason: "Requires iced Canvas widget and rendering infrastructure from UI foundation task"
    - task_id: 2
      reason: "Requires stroke path data from character database for animation content"

  depended_upon_by:
    - task_id: 8
      reason: "Practice mode uses StrokeOrderAnimation component for interactive stroke order teaching"

  external:
    - name: "iced::canvas::Program"
      type: "trait"
      status: "already exists"
    - name: "iced::canvas::Frame"
      type: "struct"
      status: "already exists"
    - name: "iced::Color"
      type: "struct"
      status: "already exists"
    - name: "lyon::path::Path"
      type: "struct"
      status: "to be imported"
    - name: "lyon::path::Builder"
      type: "struct"
      status: "to be imported"
    - name: "lyon::tessellation"
      type: "module"
      status: "to be imported"
    - name: "std::time::Duration"
      type: "struct"
      status: "already exists"
    - name: "std::time::Instant"
      type: "struct"
      status: "already exists"
    - name: "proptest"
      type: "crate"
      status: "to be imported"
---
task:
  id: 5
  name: "Handwriting Canvas and Input System"

context:
  description: |
    The Handwriting Canvas and Input System is a critical component of the Japanese character
    learning application that enables kinesthetic learning through interactive drawing practice.
    This task implements an interactive canvas widget using the iced framework's canvas::Program
    trait to capture user handwriting input through mouse or touch interfaces.

    The system serves multiple architectural purposes:
    1. Input Capture: Records stroke sequences with precise timing and coordinate data
    2. Visual Feedback: Provides real-time rendering of strokes with smooth anti-aliased paths
    3. Data Export: Normalizes stroke data for consumption by the character recognition system
    4. Practice Interface: Forms the foundation for handwriting practice exercises

    The implementation must balance responsiveness (smooth drawing at varying input speeds),
    accuracy (precise stroke capture without noise), and usability (natural drawing feel
    with appropriate visual feedback). The canvas operates as a state machine transitioning
    between idle, drawing, and completed states while maintaining stroke history for
    recognition validation and progress tracking.

    This component integrates with the broader application by providing standardized stroke
    data to the recognition system (Task 9) and serving as the primary interaction surface
    for practice mode (Task 8). The design supports future enhancements including stroke-order
    validation, guide image overlays, and pressure-sensitive stylus input.

  key_points:
    - "Implements iced canvas::Program trait for interactive drawing with event-driven state management"
    - "Applies 2px distance threshold to prevent excessive point density and reduce input noise"
    - "Uses lyon Path rendering with round caps and joins for natural stroke appearance"
    - "Stores timestamps with each point to enable future velocity analysis and recognition enhancement"
    - "Normalizes coordinates to 0-1 range for device-independent recognition processing"
    - "Maintains clear separation between current stroke (being drawn) and completed strokes (history)"
    - "Supports both mouse and touch input for cross-platform compatibility (desktop and touch devices)"
    - "Provides undo/clear operations for error correction during practice"

files:
  - path: "src/ui/handwriting_canvas.rs"
    description: "Main HandwritingCanvas widget implementing canvas::Program trait for interactive drawing with mouse/touch event handling and stroke rendering"
  - path: "src/ui/drawing_state.rs"
    description: "DrawingState struct maintaining stroke history, current active stroke, and drawing state machine with clear/undo operations"
  - path: "src/ui/canvas_message.rs"
    description: "CanvasMessage enum defining interaction events (StartStroke, AddPoint, EndStroke, Clear, Undo)"
  - path: "src/ui/canvas_renderer.rs"
    description: "Rendering helper functions for drawing strokes with anti-aliasing, proper styling, and visual feedback"
  - path: "src/ui/mod.rs"
    description: "UI module root declaring and exposing handwriting_canvas, drawing_state, canvas_message, and canvas_renderer submodules"
  - path: "src/types/stroke.rs"
    description: "Stroke and Point data structures with timestamp recording, normalization methods, and distance calculations"
  - path: "src/types/mod.rs"
    description: "Types module root declaring stroke module for stroke-related data structures"

functions:
  - file: "src/types/stroke.rs"
    items:
      - type: struct
        name: "Point"
        description: "Represents a point in a stroke with x, y coordinates and timestamp in milliseconds"
        invariants: "Timestamp is monotonically increasing within a stroke; coordinates represent canvas pixel positions"
      - type: struct
        name: "Stroke"
        description: "A sequence of points forming a continuous stroke with metadata"
        invariants: "Must contain at least 2 points for a valid stroke; points are ordered chronologically"
      - type: method
        name: "Stroke::new"
        description: "Creates a new empty stroke with no points"
        postconditions: "Returns a stroke with empty points vector ready to accept points"
      - type: method
        name: "Stroke::add_point"
        description: "Adds a point to the stroke with 2px distance threshold filtering to reduce noise"
        preconditions: "Point coordinates are valid; timestamp is >= last point's timestamp"
        postconditions: "Point is added only if distance from last point >= 2px threshold or if this is the first point"
      - type: method
        name: "Stroke::normalize"
        description: "Normalizes stroke coordinates to 0-1 range for device-independent recognition"
        preconditions: "Stroke contains at least 2 points; canvas_width and canvas_height are positive"
        postconditions: "Returns Vec<(f32, f32)> with all coordinates mapped to [0.0, 1.0] range"
      - type: method
        name: "Stroke::is_empty"
        description: "Checks if stroke has no points"
        postconditions: "Returns true if points vector is empty, false otherwise"
      - type: function
        name: "calculate_distance"
        description: "Calculates Euclidean distance between two points using sqrt(dx² + dy²)"
        preconditions: "Both points have valid coordinates"
        postconditions: "Returns non-negative distance value in pixels"
  - file: "src/ui/drawing_state.rs"
    items:
      - type: struct
        name: "DrawingState"
        description: "Maintains stroke history, current active stroke, and drawing state machine"
        invariants: "current_stroke is Some only when is_drawing is true; completed_strokes contains only valid strokes with >= 2 points"
      - type: method
        name: "DrawingState::new"
        description: "Creates a new empty drawing state with no strokes"
        postconditions: "Returns state with empty completed_strokes vector, no current stroke, and is_drawing false"
      - type: method
        name: "DrawingState::start_stroke"
        description: "Begins a new stroke at given position, transitioning to drawing state"
        preconditions: "No stroke is currently being drawn (is_drawing is false)"
        postconditions: "current_stroke is Some with initial point; is_drawing is true"
      - type: method
        name: "DrawingState::add_point"
        description: "Adds a point to the current stroke with threshold filtering"
        preconditions: "current_stroke is Some; is_drawing is true"
        postconditions: "Point added if distance threshold met; returns true if point was added, false if filtered out"
      - type: method
        name: "DrawingState::end_stroke"
        description: "Completes the current stroke and adds to history if valid"
        preconditions: "current_stroke is Some; is_drawing is true"
        postconditions: "current_stroke is moved to completed_strokes vector if it has >= 2 points; current_stroke set to None; is_drawing is false"
      - type: method
        name: "DrawingState::clear"
        description: "Clears all strokes and resets drawing state to initial conditions"
        postconditions: "completed_strokes is empty; current_stroke is None; is_drawing is false"
      - type: method
        name: "DrawingState::undo_last"
        description: "Removes the last completed stroke from history"
        preconditions: "completed_strokes is not empty"
        postconditions: "Last stroke is removed from completed_strokes vector; if vector was empty, no change occurs"
      - type: method
        name: "DrawingState::get_completed_strokes"
        description: "Returns reference to completed strokes for rendering and export"
        postconditions: "Returns immutable reference to completed_strokes vector"
      - type: method
        name: "DrawingState::get_current_stroke"
        description: "Returns reference to current stroke being drawn for rendering"
        postconditions: "Returns Option reference to current_stroke (Some if drawing, None otherwise)"
  - file: "src/ui/handwriting_canvas.rs"
    items:
      - type: struct
        name: "HandwritingCanvas"
        description: "Canvas widget implementing canvas::Program for interactive drawing with state management"
        invariants: "drawing_state always reflects accurate stroke history; state transitions follow proper sequence"
      - type: method
        name: "HandwritingCanvas::new"
        description: "Creates a new handwriting canvas instance with empty state"
        postconditions: "Returns canvas with empty DrawingState and default configuration"
      - type: method
        name: "HandwritingCanvas::clear"
        description: "Clears all strokes from the canvas, resetting to initial state"
        postconditions: "All strokes are removed from drawing state; canvas is ready for new input"
      - type: method
        name: "HandwritingCanvas::undo"
        description: "Removes the last stroke from canvas using undo operation"
        postconditions: "Last completed stroke is removed if exists; no change if no strokes present"
      - type: method
        name: "HandwritingCanvas::export_normalized_strokes"
        description: "Returns all completed strokes in normalized format for recognition system"
        preconditions: "canvas_width and canvas_height are positive"
        postconditions: "Returns Vec<Vec<(f32, f32)>> with all strokes normalized to 0-1 coordinate range"
      - type: trait_impl
        name: "canvas::Program for HandwritingCanvas"
        description: "Implements iced canvas program trait for interactive drawing with event handling and rendering"
      - type: method
        name: "canvas::Program::update"
        description: "Handles canvas events (mouse/touch) to update drawing state through state machine transitions"
        preconditions: "Event is valid canvas event (mouse button, cursor move, touch)"
        postconditions: "Drawing state updated appropriately; returns event::Status::Captured for handled events and request_redraw when visual update needed"
      - type: method
        name: "canvas::Program::draw"
        description: "Renders all strokes with anti-aliasing, proper line styling, and visual feedback"
        preconditions: "Frame and bounds are valid canvas rendering context"
        postconditions: "All completed strokes rendered with black color; current stroke rendered with gray color; all strokes use 3px width with round caps and joins"
      - type: method
        name: "canvas::Program::mouse_interaction"
        description: "Returns appropriate cursor interaction state for canvas area"
        postconditions: "Returns Crosshair cursor when mouse is within canvas bounds for drawing feedback"
      - type: method
        name: "HandwritingCanvas::handle_start_stroke"
        description: "Internal handler for stroke start events from mouse button press or touch start"
        preconditions: "Point coordinates are within canvas bounds"
        postconditions: "New stroke initiated in drawing state"
      - type: method
        name: "HandwritingCanvas::handle_add_point"
        description: "Internal handler for adding points during cursor/touch movement"
        preconditions: "Stroke is currently being drawn"
        postconditions: "Point added to current stroke if distance threshold met"
      - type: method
        name: "HandwritingCanvas::handle_end_stroke"
        description: "Internal handler for stroke completion from mouse button release or touch end"
        preconditions: "Stroke is currently being drawn"
        postconditions: "Current stroke finalized and added to completed strokes"
      - type: constant
        name: "DISTANCE_THRESHOLD"
        description: "Minimum distance (2.0px) between points to reduce noise and excessive point density"
      - type: constant
        name: "STROKE_WIDTH"
        description: "Width of rendered strokes (3.0px) for clear visibility"
  - file: "src/ui/canvas_renderer.rs"
    items:
      - type: function
        name: "render_stroke"
        description: "Renders a single stroke to the canvas frame using lyon Path with anti-aliasing"
        preconditions: "Stroke contains at least 2 points; frame and color are valid; bounds define valid canvas area"
        postconditions: "Stroke is drawn with specified color, 3px width, round caps and joins, anti-aliased rendering"
      - type: function
        name: "create_stroke_path"
        description: "Converts stroke points to lyon Path for rendering"
        preconditions: "Points vector has at least 2 elements"
        postconditions: "Returns lyon Path with move_to for first point and line_to for subsequent points"

formal_verification:
  needed: false
  level: "None"
  explanation: |
    Formal verification is not needed for the Handwriting Canvas and Input System for the following reasons:

    1. UI Input Handling Nature: This task involves interactive drawing canvas operations (mouse/touch input, stroke recording, visual feedback). UI interaction code is inherently non-deterministic from a user behavior perspective and relies on framework correctness rather than algorithmic correctness that would benefit from formal proofs.

    2. No Safety-Critical Requirements: The system captures handwriting strokes for character recognition practice. There are no safety, security, or financial implications if the system behaves incorrectly. The worst-case scenario is incorrect stroke capture, which users can immediately observe and retry.

    3. Low Algorithmic Complexity: The core operations are straightforward:
       - Appending points to stroke sequences
       - Managing state transitions (drawing/not drawing)
       - Timestamp recording
       - Basic normalization of coordinate data
       These operations don't involve complex invariants or mathematical properties that require formal proof.

    4. Observable Behavior: The canvas provides immediate visual feedback. Users can directly observe if strokes are captured correctly, making runtime testing and manual verification highly effective. This observability makes formal verification less valuable than integration and manual testing.

    5. Explicit Testing Strategy: The task overview indicates formal_verification: false with low testing risk and medium complexity. Integration testing is marked as needed, which is the appropriate verification approach for UI components that depend on framework behavior and user interaction.

    6. Alternative Verification Approaches: Standard testing methods are more cost-effective:
       - Property-based testing for stroke normalization
       - Integration tests for canvas rendering and input handling
       - Manual testing for touch/mouse interaction
       - Snapshot testing for visual regression

    Recommendation: Rely on integration testing, property-based testing for data transformations, and manual testing for user interaction flows.

tests:
  strategy:
    approach: "mixed (unit + integration)"
    rationale:
      - "Unit tests verify stroke data structures and normalization logic in isolation"
      - "Integration tests validate event handling state machine with simulated mouse events"
      - "Distance threshold filtering requires systematic verification across input ranges"
      - "Canvas implements canvas::Program requiring integration testing for state transitions"
      - "Critical properties like stroke continuity and sequence maintenance need dedicated test coverage"
      - "Mixed approach provides comprehensive coverage from data structures to user interactions"
  
  implementation:
    file: "src/ui/handwriting_canvas.rs"
    location: "in existing file with #[cfg(test)] modules"
    code: |
      #[cfg(test)]
      mod tests {
          use super::*;
          use crate::types::stroke::{Stroke, Point};
          use std::time::{SystemTime, UNIX_EPOCH};

          // Helper function to get current timestamp in milliseconds
          fn current_timestamp() -> u64 {
              SystemTime::now()
                  .duration_since(UNIX_EPOCH)
                  .unwrap()
                  .as_millis() as u64
          }

          // ========== Unit Tests: Stroke Data Structure ==========

          #[test]
          fn test_stroke_point_storage_with_timestamps() {
              // Verify stroke correctly stores points with timestamps in sequence
              let mut stroke = Stroke::new();
              let t1 = current_timestamp();
              let p1 = Point::new(10.0, 20.0, t1);
              let p2 = Point::new(15.0, 25.0, t1 + 10);
              let p3 = Point::new(20.0, 30.0, t1 + 20);
              
              stroke.add_point(p1);
              stroke.add_point(p2);
              stroke.add_point(p3);
              
              assert_eq!(stroke.points.len(), 3);
              assert_eq!(stroke.points[0].x, 10.0);
              assert_eq!(stroke.points[0].y, 20.0);
              assert_eq!(stroke.points[1].timestamp, t1 + 10);
              assert_eq!(stroke.points[2].timestamp, t1 + 20);
              
              // Verify timestamps are monotonically increasing
              for i in 1..stroke.points.len() {
                  assert!(stroke.points[i].timestamp >= stroke.points[i-1].timestamp);
              }
          }

          #[test]
          fn test_coordinate_normalization_to_0_1_range() {
              // Test normalization maps canvas coordinates to 0-1 range correctly
              let mut stroke = Stroke::new();
              let t = current_timestamp();
              
              stroke.add_point(Point::new(0.0, 0.0, t));
              stroke.add_point(Point::new(100.0, 50.0, t + 10));
              stroke.add_point(Point::new(200.0, 200.0, t + 20));
              stroke.add_point(Point::new(50.0, 150.0, t + 30));
              
              let normalized = stroke.normalize(200.0, 200.0);
              
              assert_eq!(normalized.len(), 4);
              
              // Test corner points
              assert_eq!(normalized[0], (0.0, 0.0));
              assert_eq!(normalized[2], (1.0, 1.0));
              
              // Test intermediate points
              assert!((normalized[1].0 - 0.5).abs() < 0.001);
              assert!((normalized[1].1 - 0.25).abs() < 0.001);
              assert!((normalized[3].0 - 0.25).abs() < 0.001);
              assert!((normalized[3].1 - 0.75).abs() < 0.001);
              
              // Verify all values are in 0-1 range
              for (x, y) in normalized {
                  assert!(x >= 0.0 && x <= 1.0, "x coordinate out of range: {}", x);
                  assert!(y >= 0.0 && y <= 1.0, "y coordinate out of range: {}", y);
              }
          }

          #[test]
          fn test_distance_threshold_filtering_2px() {
              // Verify distance threshold prevents excessive point density
              let p1 = Point::new(10.0, 10.0, current_timestamp());
              let p2 = Point::new(10.5, 10.5, current_timestamp()); // ~0.707px distance
              let p3 = Point::new(15.0, 15.0, current_timestamp()); // ~7.07px distance
              
              const THRESHOLD: f32 = 2.0;
              
              // Points too close should not meet threshold
              assert!(p1.distance_to(&p2) < THRESHOLD);
              
              // Points far enough should meet threshold
              assert!(p1.distance_to(&p3) >= THRESHOLD);
              
              // Test actual DrawingState filtering
              let mut state = DrawingState::new();
              state.start_stroke(Point::new(10.0, 10.0, current_timestamp()));
              
              // Add 10 points very close together (0.1px increments)
              for i in 1..=10 {
                  let t = current_timestamp();
                  state.add_point(Point::new(10.0 + (i as f32) * 0.1, 10.0, t));
              }
              
              if let Some(ref stroke) = state.current_stroke {
                  // Should have filtered out most points due to threshold
                  assert!(stroke.points.len() < 10, "Expected fewer points after threshold filtering");
                  
                  // Verify consecutive points meet minimum distance (with small tolerance)
                  for i in 1..stroke.points.len() {
                      let dist = stroke.points[i-1].distance_to(&stroke.points[i]);
                      assert!(dist >= 1.9, "Consecutive points too close: {}px", dist);
                  }
              } else {
                  panic!("Expected current_stroke to exist");
              }
          }

          // ========== Integration Tests: Mouse Event Handling ==========

          #[test]
          fn test_mouse_event_sequence_handling() {
              // Test complete mouse event flow: ButtonPressed -> CursorMoved -> ButtonReleased
              let mut canvas = HandwritingCanvas::new();
              let t1 = current_timestamp();
              
              // Simulate ButtonPressed event (start stroke)
              let start_point = Point::new(10.0, 10.0, t1);
              canvas.handle_start_stroke(start_point);
              
              assert!(canvas.state.is_drawing);
              assert!(canvas.state.current_stroke.is_some());
              
              // Simulate CursorMoved events (add points)
              canvas.handle_add_point(Point::new(20.0, 20.0, t1 + 10));
              canvas.handle_add_point(Point::new(30.0, 30.0, t1 + 20));
              canvas.handle_add_point(Point::new(40.0, 40.0, t1 + 30));
              
              if let Some(ref stroke) = canvas.state.current_stroke {
                  assert!(stroke.points.len() >= 2, "Expected multiple points in current stroke");
              }
              
              // Simulate ButtonReleased event (end stroke)
              canvas.handle_end_stroke();
              
              assert!(!canvas.state.is_drawing);
              assert!(canvas.state.current_stroke.is_none());
              assert_eq!(canvas.state.completed_strokes.len(), 1);
              
              // Verify completed stroke has all points
              assert!(canvas.state.completed_strokes[0].points.len() >= 2);
          }

          #[test]
          fn test_multiple_stroke_sequence_maintenance() {
              // Verify system correctly maintains multiple strokes in chronological order
              let mut canvas = HandwritingCanvas::new();
              let base_time = current_timestamp();
              
              // Draw first stroke
              canvas.handle_start_stroke(Point::new(10.0, 10.0, base_time));
              canvas.handle_add_point(Point::new(20.0, 20.0, base_time + 10));
              canvas.handle_add_point(Point::new(30.0, 30.0, base_time + 20));
              canvas.handle_end_stroke();
              
              // Draw second stroke
              canvas.handle_start_stroke(Point::new(50.0, 50.0, base_time + 100));
              canvas.handle_add_point(Point::new(60.0, 60.0, base_time + 110));
              canvas.handle_add_point(Point::new(70.0, 70.0, base_time + 120));
              canvas.handle_end_stroke();
              
              // Draw third stroke
              canvas.handle_start_stroke(Point::new(100.0, 100.0, base_time + 200));
              canvas.handle_add_point(Point::new(110.0, 110.0, base_time + 210));
              canvas.handle_end_stroke();
              
              assert_eq!(canvas.state.completed_strokes.len(), 3);
              
              // Verify strokes are in correct sequence
              assert_eq!(canvas.state.completed_strokes[0].points[0].x, 10.0);
              assert_eq!(canvas.state.completed_strokes[1].points[0].x, 50.0);
              assert_eq!(canvas.state.completed_strokes[2].points[0].x, 100.0);
              
              // Verify timestamps are chronologically ordered
              let t0 = canvas.state.completed_strokes[0].points[0].timestamp;
              let t1 = canvas.state.completed_strokes[1].points[0].timestamp;
              let t2 = canvas.state.completed_strokes[2].points[0].timestamp;
              assert!(t1 > t0 && t2 > t1, "Strokes not in chronological order");
          }

          #[test]
          fn test_clear_operation_removes_all_strokes() {
              // Test clear button removes all strokes and resets state
              let mut canvas = HandwritingCanvas::new();
              let t = current_timestamp();
              
              // Add multiple strokes
              canvas.handle_start_stroke(Point::new(10.0, 10.0, t));
              canvas.handle_add_point(Point::new(20.0, 20.0, t + 10));
              canvas.handle_end_stroke();
              
              canvas.handle_start_stroke(Point::new(50.0, 50.0, t + 100));
              canvas.handle_add_point(Point::new(60.0, 60.0, t + 110));
              canvas.handle_end_stroke();
              
              assert_eq!(canvas.state.completed_strokes.len(), 2);
              
              // Clear all strokes
              canvas.clear();
              
              assert_eq!(canvas.state.completed_strokes.len(), 0);
              assert!(!canvas.state.is_drawing);
              assert!(canvas.state.current_stroke.is_none());
          }

          // ========== Additional Unit Tests ==========

          #[test]
          fn test_stroke_data_export() {
              // Test export of stroke data as Vec<Vec<Point>>
              let mut canvas = HandwritingCanvas::new();
              let t = current_timestamp();
              
              // Draw a stroke
              canvas.handle_start_stroke(Point::new(10.0, 10.0, t));
              canvas.handle_add_point(Point::new(20.0, 20.0, t + 10));
              canvas.handle_add_point(Point::new(30.0, 30.0, t + 20));
              canvas.handle_end_stroke();
              
              let exported = canvas.export_normalized_strokes(100.0, 100.0);
              
              assert_eq!(exported.len(), 1);
              assert!(exported[0].len() >= 2);
              
              // Verify normalized coordinates are in 0-1 range
              for stroke_points in exported {
                  for (x, y) in stroke_points {
                      assert!(x >= 0.0 && x <= 1.0);
                      assert!(y >= 0.0 && y <= 1.0);
                  }
              }
          }
      }

      #[cfg(test)]
      mod drawing_state_tests {
          use super::*;
          use crate::ui::drawing_state::DrawingState;
          use crate::types::stroke::Point;

          #[test]
          fn test_undo_removes_last_stroke() {
              // Test undo operation removes most recent completed stroke
              let mut state = DrawingState::new();
              let t = super::tests::current_timestamp();
              
              // Add first stroke
              state.start_stroke(Point::new(10.0, 10.0, t));
              state.add_point(Point::new(20.0, 20.0, t + 10));
              state.end_stroke();
              
              // Add second stroke
              state.start_stroke(Point::new(50.0, 50.0, t + 100));
              state.add_point(Point::new(60.0, 60.0, t + 110));
              state.end_stroke();
              
              // Add third stroke
              state.start_stroke(Point::new(100.0, 100.0, t + 200));
              state.add_point(Point::new(110.0, 110.0, t + 210));
              state.end_stroke();
              
              assert_eq!(state.get_completed_strokes().len(), 3);
              
              // Undo last stroke
              state.undo_last();
              assert_eq!(state.get_completed_strokes().len(), 2);
              
              // Verify correct stroke was removed
              assert_eq!(state.get_completed_strokes()[1].points[0].x, 50.0);
              
              // Undo again
              state.undo_last();
              assert_eq!(state.get_completed_strokes().len(), 1);
              
              // Undo one more time
              state.undo_last();
              assert_eq!(state.get_completed_strokes().len(), 0);
              
              // Undo on empty list should not panic
              state.undo_last();
              assert_eq!(state.get_completed_strokes().len(), 0);
          }
      }
  
  coverage:
    - "Stroke point storage with timestamps in chronological sequence"
    - "Coordinate normalization to 0-1 range for recognition compatibility"
    - "Distance threshold filtering enforces 2px minimum spacing"
    - "Mouse event sequence handling: ButtonPressed -> CursorMoved -> ButtonReleased"
    - "Multiple stroke sequence maintenance in chronological order"
    - "Clear operation removes all strokes and resets state"
    - "Undo operation removes most recent stroke without affecting others"
    - "Stroke data export in normalized format for recognition system"

dependencies:
  depends_on:
    - task_id: 1
      reason: "Requires iced framework foundation with Canvas widget support for implementing canvas::Program trait and interactive drawing functionality"
  
  depended_upon_by:
    - task_id: 8
      reason: "Practice mode requires HandwritingCanvas widget as primary interaction surface for handwriting exercises and character tracing"
    - task_id: 9
      reason: "Recognition system consumes normalized stroke data (Vec<Vec<Point>>) exported by HandwritingCanvas for character validation and recognition"
  
  external:
    - name: "iced::widget::canvas"
      type: "module"
      status: "to be imported"
    - name: "iced::widget::canvas::Program"
      type: "trait"
      status: "to be imported"
    - name: "iced::widget::canvas::Frame"
      type: "struct"
      status: "to be imported"
    - name: "iced::widget::canvas::Path"
      type: "struct"
      status: "to be imported"
    - name: "iced::mouse::Interaction"
      type: "enum"
      status: "to be imported"
    - name: "iced::event::Status"
      type: "enum"
      status: "to be imported"
    - name: "iced::Rectangle"
      type: "struct"
      status: "to be imported"
    - name: "iced::Point"
      type: "struct"
      status: "to be imported"
    - name: "lyon::path::Path"
      type: "struct"
      status: "to be imported"
    - name: "lyon::path::builder::Builder"
      type: "trait"
      status: "to be imported"
    - name: "lyon::tessellation::LineCap"
      type: "enum"
      status: "to be imported"
    - name: "lyon::tessellation::LineJoin"
      type: "enum"
      status: "to be imported"
    - name: "std::time::SystemTime"
      type: "struct"
      status: "already exists"
    - name: "std::time::UNIX_EPOCH"
      type: "constant"
      status: "already exists"
---
task:
  id: 6
  name: "Application State Management and Navigation"

context:
  description: |
    Task 6 implements the Elm architecture state management system, which serves as the
    control flow backbone of the entire application. This establishes the core pattern
    where all user interactions flow as Messages through a pure update() function that
    produces new state and optional async Tasks for side effects.
    
    The state management system consists of four key components:
    1. AppState - the root state container holding the current screen and shared data
    2. Screen enum - representing all application screens (MainMenu, Learning, Practice, 
       Statistics, Settings) where each variant carries screen-specific state
    3. Message enum - an exhaustive enumeration of all user interactions, navigation 
       events, and async operation results
    4. Application::update() - the pure state transition function that routes messages
       to appropriate handlers and returns updated state plus optional Tasks
    
    This architecture ensures predictable, testable application behavior by separating
    pure state transitions from side effects. All database operations, recognition
    requests, and async work are encoded as Task values returned from update(), 
    maintaining referential transparency and enabling comprehensive unit testing without
    mocking external systems.
    
    The implementation follows Elm architecture principles strictly: update() must be
    pure (no side effects), state transitions must be total (handle all message types),
    and async operations must use Task::perform() to eventually produce new Messages
    that re-enter the update cycle. Session state (learning/practice) is owned by Screen
    variants, while shared state (progress, settings) lives in AppState via Arc<RwLock>
    for thread-safe access.

  key_points:
    - "Elm architecture enforces separation between pure state logic (update) and side effects (Tasks)"
    - "Screen enum variants own their session state, ensuring cleanup on navigation"
    - "Message enum must be exhaustive - all user interactions and async results represented"
    - "update() function must be total - pattern matching on all Message and Screen combinations"
    - "Shared state accessed via Arc<RwLock> requires careful lock ordering to prevent deadlocks"
    - "Navigation triggers screen initialization via async Tasks that return Messages"
    - "State transitions must maintain invariants (no unreachable states, session consistency)"
    - "Large update() function should be decomposed into screen-specific handlers for maintainability"

files:
  - path: "/home/molaco/Documents/japanese/src/state/mod.rs"
    description: "Module declaration file exposing Screen, Message, AppState, and navigation submodules for state management"
  - path: "/home/molaco/Documents/japanese/src/state/screen.rs"
    description: "Defines Screen enum with variants for all application screens (MainMenu, Learning, Practice, Statistics, Settings) and associated state structs (LearningState, PracticeState, StatisticsState)"
  - path: "/home/molaco/Documents/japanese/src/state/message.rs"
    description: "Defines Message enum covering all user interactions, navigation events, system messages, and async operation results"
  - path: "/home/molaco/Documents/japanese/src/state/app_state.rs"
    description: "Defines AppState struct as the root state container holding current screen, shared progress data, and settings with Arc<RwLock> for thread-safety"
  - path: "/home/molaco/Documents/japanese/src/state/navigation.rs"
    description: "Helper functions for screen transitions, state initialization, navigation stack management, and Task creation for async operations"
  - path: "/home/molaco/Documents/japanese/src/state/update_handlers.rs"
    description: "Screen-specific update handler functions to decompose main update() logic into manageable pieces for each screen type"
  - path: "/home/molaco/Documents/japanese/src/application.rs"
    description: "Implementation of Application::update() function - the core state transition handler implementing Elm architecture with message routing"
  - path: "/home/molaco/Documents/japanese/src/types.rs"
    description: "Common type definitions including PracticeMode, ReviewRating, Point, Stroke, CanvasState, SettingKey, and SettingValue enums/structs"

functions:
  - file: "/home/molaco/Documents/japanese/src/state/mod.rs"
    items:
      - type: "module_declaration"
        name: "pub mod screen"
        description: "Module containing Screen enum and screen-specific state types (LearningState, PracticeState, StatisticsState)"
      - type: "module_declaration"
        name: "pub mod message"
        description: "Module containing Message enum defining all application events and user interactions"
      - type: "module_declaration"
        name: "pub mod navigation"
        description: "Module containing navigation helper functions for screen transitions and async Task creation"
      - type: "struct"
        name: "AppState"
        description: "Root application state container holding current screen, progress tracker via Arc<RwLock>, and application settings via Arc<RwLock>"
        invariants: "Always contains valid screen state; shared data (progress, settings) is thread-safe via Arc<RwLock>; screen variant matches actual screen-specific state"
      - type: "method"
        name: "AppState::new"
        description: "Creates initial AppState with MainMenu screen and loads progress/settings from database"
        postconditions: "Returns AppState with initialized MainMenu screen and loaded user data from persistence layer"
      - type: "method"
        name: "AppState::current_screen"
        description: "Returns immutable reference to current Screen enum variant"
        postconditions: "Returns &Screen reference to active screen"
      - type: "method"
        name: "AppState::current_screen_mut"
        description: "Returns mutable reference to current Screen enum variant for state modifications"
        postconditions: "Returns &mut Screen reference allowing screen state mutations"

  - file: "/home/molaco/Documents/japanese/src/state/screen.rs"
    items:
      - type: "enum"
        name: "Screen"
        description: "Represents all application screens where each variant carries screen-specific state data"
        invariants: "Each variant maintains valid state for its screen type; state transitions preserve data integrity; no dangling references"
      - type: "enum_variant"
        name: "Screen::MainMenu"
        description: "Main menu screen with no additional state, serves as application entry point"
      - type: "enum_variant"
        name: "Screen::Learning(LearningState)"
        description: "Learning session screen carrying active session state including review queue and current character"
      - type: "enum_variant"
        name: "Screen::Practice(PracticeState)"
        description: "Practice session screen carrying practice mode state including drawing canvas and current character"
      - type: "enum_variant"
        name: "Screen::Statistics(StatisticsState)"
        description: "Statistics and progress visualization screen carrying loaded stats data and performance metrics"
      - type: "enum_variant"
        name: "Screen::Settings"
        description: "Settings configuration screen with no additional state, modifies AppState settings directly"
      - type: "struct"
        name: "LearningState"
        description: "State for learning session including current character, review queue, session progress counter, and show_details flag"
        invariants: "Review queue never empty during active session; current_character always references valid character; current_index <= review_queue.len()"
      - type: "method"
        name: "LearningState::new"
        description: "Creates new learning session state with initialized review queue from SRS algorithm"
        preconditions: "Review items available in database; SRS algorithm provides non-empty queue"
        postconditions: "Returns LearningState with populated review queue, current_index=0, and first character loaded"
      - type: "method"
        name: "LearningState::current_character"
        description: "Returns immutable reference to current character being learned"
        postconditions: "Returns &Character reference to current review item"
      - type: "method"
        name: "LearningState::advance_to_next"
        description: "Advances to next character in review queue, increments current_index"
        preconditions: "Review queue not empty; current_index < queue length"
        postconditions: "Current character updated to next in queue or session marked complete if last item"
      - type: "method"
        name: "LearningState::session_progress"
        description: "Returns tuple (reviewed_count, total_count) for progress bar display"
        postconditions: "Returns (usize, usize) where reviewed_count <= total_count"
      - type: "struct"
        name: "PracticeState"
        description: "State for practice session including mode selector, current character, drawing canvas state, and recognition result"
        invariants: "Canvas state synchronized with current character; practice mode remains constant during session; recognition_result only present after submission"
      - type: "method"
        name: "PracticeState::new"
        description: "Creates new practice session state for given mode and character set"
        preconditions: "Valid PracticeMode and character set provided"
        postconditions: "Returns PracticeState with initialized empty canvas, first character loaded, and no recognition result"
      - type: "method"
        name: "PracticeState::current_character"
        description: "Returns immutable reference to current character being practiced"
        postconditions: "Returns &Character reference to active practice character"
      - type: "method"
        name: "PracticeState::canvas_state"
        description: "Returns immutable reference to drawing canvas state containing stroke history"
        postconditions: "Returns &CanvasState reference to current canvas data"
      - type: "method"
        name: "PracticeState::canvas_state_mut"
        description: "Returns mutable reference to drawing canvas state for stroke modifications"
        postconditions: "Returns &mut CanvasState allowing stroke additions/removals"
      - type: "method"
        name: "PracticeState::submit_drawing"
        description: "Submits current canvas drawing for character recognition and validation"
        preconditions: "Canvas contains at least one stroke"
        postconditions: "Recognition result stored in state; feedback ready for UI display"
      - type: "struct"
        name: "StatisticsState"
        description: "State for statistics screen with loaded character progress history and computed performance metrics"
        invariants: "Progress data consistent with database; metrics accurately computed from historical data"
      - type: "method"
        name: "StatisticsState::new"
        description: "Creates statistics state by loading all progress data from database and computing metrics"
        postconditions: "Returns StatisticsState with complete progress history, aggregated stats, and visualization data"
      - type: "method"
        name: "StatisticsState::character_progress"
        description: "Returns progress data map for all characters with review history"
        postconditions: "Returns HashMap<CharacterId, ProgressData> containing per-character statistics"
      - type: "method"
        name: "StatisticsState::overall_stats"
        description: "Returns aggregated statistics across all characters including total reviews, accuracy, streaks"
        postconditions: "Returns OverallStats struct with computed aggregate metrics"

  - file: "/home/molaco/Documents/japanese/src/state/message.rs"
    items:
      - type: "enum"
        name: "Message"
        description: "Exhaustive enumeration of all user interactions and system events that trigger application state changes"
        invariants: "All variants are Clone + Debug; message dispatching is total (handles all variants)"
      - type: "enum_variant"
        name: "Message::NavigateToMainMenu"
        description: "Navigate to main menu screen, clears current session state"
      - type: "enum_variant"
        name: "Message::NavigateToLearning"
        description: "Navigate to learning session screen, triggers async session initialization via Task"
      - type: "enum_variant"
        name: "Message::NavigateToPractice(PracticeMode)"
        description: "Navigate to practice screen with specified mode (Timed, Freestyle, or Specific character set)"
      - type: "enum_variant"
        name: "Message::NavigateToStatistics"
        description: "Navigate to statistics screen, triggers async data loading via Task"
      - type: "enum_variant"
        name: "Message::NavigateToSettings"
        description: "Navigate to settings configuration screen"
      - type: "enum_variant"
        name: "Message::LearningSessionStarted(Result<LearningState, String>)"
        description: "Learning session initialization completed, carries initialized state or error message"
      - type: "enum_variant"
        name: "Message::ReviewResponse(ReviewRating)"
        description: "User rated current character in learning session with Again/Hard/Good/Easy rating"
      - type: "enum_variant"
        name: "Message::NextReviewItem"
        description: "Advance to next character in learning session review queue"
      - type: "enum_variant"
        name: "Message::LearningSessionComplete"
        description: "All review items completed in learning session, triggers completion flow"
      - type: "enum_variant"
        name: "Message::PracticeSessionStarted(Result<PracticeState, String>)"
        description: "Practice session initialization completed, carries initialized state or error message"
      - type: "enum_variant"
        name: "Message::DrawingStrokeStarted(Point)"
        description: "User started drawing stroke at point coordinates on canvas"
      - type: "enum_variant"
        name: "Message::DrawingStrokeContinued(Point)"
        description: "User continued drawing stroke to point coordinates, extends current stroke"
      - type: "enum_variant"
        name: "Message::DrawingStrokeEnded"
        description: "User finished drawing stroke, completes current stroke and adds to history"
      - type: "enum_variant"
        name: "Message::ClearCanvas"
        description: "Clear all strokes from drawing canvas, resets canvas to empty state"
      - type: "enum_variant"
        name: "Message::UndoStroke"
        description: "Remove last completed stroke from canvas stroke history"
      - type: "enum_variant"
        name: "Message::SubmitDrawing"
        description: "Submit current canvas drawing for character recognition, triggers async recognition Task"
      - type: "enum_variant"
        name: "Message::RecognitionResult(Result<RecognitionResponse, String>)"
        description: "Character recognition engine returned result with match confidence or error"
      - type: "enum_variant"
        name: "Message::NextPracticeCharacter"
        description: "Move to next character in practice session, clears canvas for new character"
      - type: "enum_variant"
        name: "Message::StatisticsLoaded(Result<StatisticsState, String>)"
        description: "Statistics data loaded from database, carries computed state or error message"
      - type: "enum_variant"
        name: "Message::SettingChanged(SettingKey, SettingValue)"
        description: "User changed application setting, triggers setting persistence Task"
      - type: "enum_variant"
        name: "Message::ExitApplication"
        description: "User requested application exit, triggers cleanup and shutdown"
      - type: "enum_variant"
        name: "Message::Noop"
        description: "No-op message for Tasks that don't produce meaningful results, maintains message flow"

  - file: "/home/molaco/Documents/japanese/src/state/navigation.rs"
    items:
      - type: "function"
        name: "navigate_to_learning"
        description: "Creates async Task to initialize learning session by loading review queue from database and return LearningSessionStarted message"
        postconditions: "Returns Task<Message> that queries SRS algorithm, builds review queue, creates LearningState, and produces LearningSessionStarted message"
      - type: "function"
        name: "navigate_to_practice"
        description: "Creates async Task to initialize practice session for given mode and return PracticeSessionStarted message"
        preconditions: "Valid PracticeMode provided (Timed, Freestyle, or Specific with character list)"
        postconditions: "Returns Task<Message> that loads appropriate character set, initializes canvas, creates PracticeState, and produces PracticeSessionStarted message"
      - type: "function"
        name: "navigate_to_statistics"
        description: "Creates async Task to load statistics data from database and return StatisticsLoaded message"
        postconditions: "Returns Task<Message> that queries all character progress, computes metrics, creates StatisticsState, and produces StatisticsLoaded message"
      - type: "function"
        name: "save_review_result"
        description: "Creates async Task to persist review rating to database using SM-2 algorithm update"
        preconditions: "Valid character ID and ReviewRating (Again/Hard/Good/Easy) provided"
        postconditions: "Returns Task<Message> that updates character progress, recalculates next review date via SM-2, persists to database, and produces Noop message"
      - type: "function"
        name: "save_practice_result"
        description: "Creates async Task to persist practice attempt result to database"
        preconditions: "Valid character ID and RecognitionResponse with match confidence provided"
        postconditions: "Returns Task<Message> that records practice session data, updates practice statistics, persists to database, and produces Noop message"
      - type: "function"
        name: "save_setting"
        description: "Creates async Task to persist setting change to database"
        preconditions: "Valid SettingKey and SettingValue provided matching expected types"
        postconditions: "Returns Task<Message> that updates setting in database, updates shared settings Arc<RwLock>, and produces Noop message"

  - file: "/home/molaco/Documents/japanese/src/application.rs"
    items:
      - type: "trait_impl"
        name: "impl Application for App"
        description: "iced::Application trait implementation for main App struct providing update and view methods"
        invariants: "Follows Elm architecture pattern; update is pure function; all side effects via Task"
      - type: "method"
        name: "App::update"
        description: "Core state transition function implementing Elm architecture update logic; routes all messages to appropriate screen-specific handlers"
        preconditions: "AppState is in valid state; Message is well-formed variant"
        postconditions: "Returns new AppState and optional Task for async operations; state remains consistent; no side effects in function body"
        invariants: "Pure function with referential transparency; same inputs always produce same outputs; all async operations via Task; no panics on valid inputs"
      - type: "method"
        name: "App::update_learning"
        description: "Handles learning session specific messages (ReviewResponse, NextReviewItem, LearningSessionComplete)"
        preconditions: "Current screen is Screen::Learning with valid LearningState"
        postconditions: "Learning state updated according to message; Task for database save operations if rating provided; session completion handled"
      - type: "method"
        name: "App::update_practice"
        description: "Handles practice session specific messages (drawing events, submission, recognition results)"
        preconditions: "Current screen is Screen::Practice with valid PracticeState"
        postconditions: "Practice state updated; canvas modified for drawing messages; Task for recognition if submission message; result stored if recognition message"
      - type: "method"
        name: "App::update_statistics"
        description: "Handles statistics screen specific messages (data refresh, filter changes)"
        preconditions: "Current screen is Screen::Statistics with valid StatisticsState"
        postconditions: "Statistics state refreshed if needed; filters applied to displayed data"
      - type: "method"
        name: "App::update_settings"
        description: "Handles settings screen specific messages (SettingChanged with key-value pairs)"
        preconditions: "Current screen is Screen::Settings"
        postconditions: "Settings updated in shared Arc<RwLock>; Task created to persist changes to database"
      - type: "method"
        name: "App::handle_navigation"
        description: "Handles navigation messages and performs screen transitions with state initialization"
        preconditions: "Valid navigation message (NavigateToMainMenu, NavigateToLearning, NavigateToPractice, NavigateToStatistics, NavigateToSettings)"
        postconditions: "Screen changed to target variant; initialization Task created if needed (Learning, Practice, Statistics); previous screen state properly cleaned up"

  - file: "/home/molaco/Documents/japanese/src/types.rs"
    items:
      - type: "enum"
        name: "PracticeMode"
        description: "Practice session mode selector determining character selection and timing behavior"
      - type: "enum_variant"
        name: "PracticeMode::Timed"
        description: "Timed practice mode with countdown timer creating time pressure"
      - type: "enum_variant"
        name: "PracticeMode::Freestyle"
        description: "Freestyle practice without time limit for relaxed learning"
      - type: "enum_variant"
        name: "PracticeMode::Specific(Vec<CharacterId>)"
        description: "Practice specific set of characters provided as CharacterId vector"
      - type: "enum"
        name: "ReviewRating"
        description: "User rating for review item in learning session, maps to SM-2 algorithm quality values"
      - type: "enum_variant"
        name: "ReviewRating::Again"
        description: "Failed recall - schedule review again soon (SM-2 quality 0-1)"
      - type: "enum_variant"
        name: "ReviewRating::Hard"
        description: "Difficult recall - schedule with shorter interval (SM-2 quality 2-3)"
      - type: "enum_variant"
        name: "ReviewRating::Good"
        description: "Correct recall - schedule with normal interval (SM-2 quality 4)"
      - type: "enum_variant"
        name: "ReviewRating::Easy"
        description: "Easy recall - schedule with longer interval (SM-2 quality 5)"
      - type: "struct"
        name: "Point"
        description: "2D point structure for drawing coordinates with f32 x and y fields"
        invariants: "x and y are valid f32 values (not NaN or infinite)"
      - type: "struct"
        name: "Stroke"
        description: "Collection of Point values representing single continuous drawing stroke"
        invariants: "Contains at least one point when completed; points are in chronological order"
      - type: "struct"
        name: "CanvasState"
        description: "Drawing canvas state with completed stroke history and optional current stroke being drawn"
        invariants: "current_stroke is Some only when is_drawing is true; stroke history preserves chronological order"
      - type: "method"
        name: "CanvasState::new"
        description: "Creates empty canvas state with no strokes and no active drawing"
        postconditions: "Returns CanvasState with empty stroke vector, current_stroke None, is_drawing false"
      - type: "method"
        name: "CanvasState::start_stroke"
        description: "Begins new stroke at given point coordinates"
        preconditions: "No stroke currently being drawn (current_stroke is None)"
        postconditions: "Current stroke initialized with starting point; is_drawing set to true"
      - type: "method"
        name: "CanvasState::continue_stroke"
        description: "Adds point to current active stroke"
        preconditions: "Stroke already started (current_stroke is Some and is_drawing is true)"
        postconditions: "Point appended to current stroke point vector"
      - type: "method"
        name: "CanvasState::end_stroke"
        description: "Finalizes current stroke and moves it to completed stroke history"
        preconditions: "Stroke already started (current_stroke is Some)"
        postconditions: "Current stroke moved to stroke history; current_stroke set to None; is_drawing set to false"
      - type: "method"
        name: "CanvasState::clear"
        description: "Removes all strokes from canvas including current stroke"
        postconditions: "All strokes cleared; stroke history empty; current_stroke None; is_drawing false"
      - type: "method"
        name: "CanvasState::undo"
        description: "Removes last completed stroke from history"
        preconditions: "Stroke history not empty"
        postconditions: "Last stroke removed from history vector if present; canvas redrawn without last stroke"
      - type: "method"
        name: "CanvasState::to_bitmap"
        description: "Converts all strokes to bitmap image for character recognition input"
        postconditions: "Returns bitmap representation with strokes rasterized; suitable for recognition engine input"
      - type: "enum"
        name: "SettingKey"
        description: "Application setting identifier enum for all configurable options"
      - type: "enum_variant"
        name: "SettingKey::AnimationSpeed"
        description: "Stroke animation playback speed setting (maps to Float value 0.1-2.0)"
      - type: "enum_variant"
        name: "SettingKey::ShowHints"
        description: "Whether to show character hints during practice (maps to Bool value)"
      - type: "enum_variant"
        name: "SettingKey::DarkMode"
        description: "UI theme selection dark/light mode (maps to Bool value)"
      - type: "enum"
        name: "SettingValue"
        description: "Setting value type wrapper supporting different value types"
      - type: "enum_variant"
        name: "SettingValue::Float(f32)"
        description: "Floating point setting value for numeric settings like animation speed"
      - type: "enum_variant"
        name: "SettingValue::Bool(bool)"
        description: "Boolean setting value for on/off toggles"
      - type: "enum_variant"
        name: "SettingValue::String(String)"
        description: "String setting value for text-based configuration"

formal_verification:
  needed: true
  level: "Basic"
  explanation: |
    State management is the critical foundation of the Elm architecture and requires
    formal verification to ensure correctness. The update() function and state 
    transitions form the control flow backbone - bugs here cascade throughout the
    entire application. While full critical-level verification isn't necessary, basic
    formal verification is warranted because:

    1. State transitions must maintain invariants (no unreachable/invalid states)
    2. The update function must be a total function (handle all Message variants)
    3. Navigation state must form a valid state machine with no deadlocks
    4. Session state ownership transfers during screen transitions must be sound
    5. Shared state access patterns (Arc<RwLock>) must be deadlock-free

    The complexity risk is high and this is a central integration point, making
    verification valuable. However, the domain logic itself isn't safety-critical
    (not medical/financial), so Basic level suffices. Property-based testing can
    supplement formal verification for state transition coverage.

  properties:
    - name: "State Transition Totality"
      formal_statement: "∀s:AppState, ∀m:Message, ∃s':AppState such that update(s,m) = (s', Task)"
      
    - name: "Screen Variant Exhaustiveness"
      formal_statement: "∀screen:Screen, screen ∈ {MainMenu, Learning, Practice, Statistics, Settings, ...} and pattern match on Screen is exhaustive"
      
    - name: "Message Handling Completeness"
      formal_statement: "∀msg:Message, ∃branch in update(state, msg) that handles msg (no unreachable messages)"
      
    - name: "Navigation Invariant"
      formal_statement: "If transition(s, Navigate(screen)) = s', then s'.current_screen = screen ∧ screen state is properly initialized"
      
    - name: "Session State Ownership"
      formal_statement: "When transitioning from Learning(session) to another screen, session data is either persisted or explicitly dropped (no orphaned state)"
      
    - name: "Shared State Safety"
      formal_statement: "All Arc<RwLock<T>> accesses follow acquire-release order: read_lock() or write_lock() always acquired before access, released before await points"
      
    - name: "Update Purity"
      formal_statement: "update(s, m) = (s', task) is pure: same inputs always produce same outputs, no side effects except Task creation"
      
    - name: "State Machine Validity"
      formal_statement: "The screen transition graph is a valid DAG or contains only intentional cycles (e.g., MainMenu ↔ Learning), with no deadlock states"

  strategy:
    - "Use Rust's type system for exhaustiveness checking - ensure all enum variants are handled"
    - "Employ proptest for property-based testing of state transitions (generate random Message sequences, verify invariants hold)"
    - "Implement compile-time checks via type states where possible (e.g., session must exist to enter Learning screen)"
    - "Use static analysis tools (clippy, miri) to detect Arc<RwLock> deadlock patterns"
    - "Create state transition table and verify coverage with test matrix (all Screen × Message combinations)"
    - "Use debug assertions in update() to validate preconditions/postconditions during development"
    - "Model state machine formally using TLA+ or similar for navigation flow verification (optional but recommended)"

tests:
  strategy:
    approach: "unit tests with property-based testing"
    rationale:
      - "State transitions are pure functions making them ideal for unit testing without external dependencies"
      - "Message handling can be tested in isolation by directly invoking update() with different Message variants"
      - "Navigation flows can be verified by chaining message sequences and asserting correct Screen transitions"
      - "Property-based testing ensures state consistency invariants hold across arbitrary message sequences"
      - "Session state initialization and cleanup can be tested deterministically"
      - "Invalid state transitions can be verified to handle gracefully without panics"
      - "Screen-specific state (LearningState, PracticeState) can be validated independently"
  
  implementation:
    file: "/home/molaco/Documents/japanese/tests/state_management_tests.rs"
    location: "create new"
    code: |
      use crate::state::{AppState, Screen, Message, LearningState, PracticeState, StatisticsState};
      use crate::types::{PracticeMode, ReviewRating, Point, CanvasState, SettingKey, SettingValue};
      use crate::application::Application;
      use std::sync::{Arc, RwLock};
      
      fn create_minimal_app_state() -> AppState {
          AppState::new()
      }
      
      #[cfg(test)]
      mod initialization_tests {
          use super::*;
          
          #[test]
          fn test_initial_state_is_main_menu() {
              let state = create_minimal_app_state();
              assert!(matches!(state.current_screen(), Screen::MainMenu));
          }
          
          #[test]
          fn test_initial_state_has_valid_shared_data() {
              let state = create_minimal_app_state();
              assert!(state.progress.read().is_ok());
              assert!(state.settings.read().is_ok());
          }
      }
      
      #[cfg(test)]
      mod navigation_tests {
          use super::*;
          
          #[test]
          fn test_navigate_from_main_menu_to_learning() {
              let mut state = create_minimal_app_state();
              let msg = Message::NavigateToLearning;
              let task = Application::update(&mut state, msg);
              
              assert!(task.is_some());
              assert!(matches!(state.current_screen(), Screen::Learning(_)));
          }
          
          #[test]
          fn test_navigate_from_main_menu_to_practice_freestyle() {
              let mut state = create_minimal_app_state();
              let msg = Message::NavigateToPractice(PracticeMode::Freestyle);
              let task = Application::update(&mut state, msg);
              
              assert!(task.is_some());
              assert!(matches!(state.current_screen(), Screen::Practice(_)));
          }
          
          #[test]
          fn test_navigate_from_main_menu_to_statistics() {
              let mut state = create_minimal_app_state();
              let msg = Message::NavigateToStatistics;
              let task = Application::update(&mut state, msg);
              
              assert!(task.is_some());
              assert!(matches!(state.current_screen(), Screen::Statistics(_)));
          }
          
          #[test]
          fn test_navigate_from_main_menu_to_settings() {
              let mut state = create_minimal_app_state();
              let msg = Message::NavigateToSettings;
              let _task = Application::update(&mut state, msg);
              
              assert!(matches!(state.current_screen(), Screen::Settings));
          }
          
          #[test]
          fn test_navigate_back_to_main_menu_from_learning() {
              let mut state = create_minimal_app_state();
              Application::update(&mut state, Message::NavigateToLearning);
              Application::update(&mut state, Message::NavigateToMainMenu);
              
              assert!(matches!(state.current_screen(), Screen::MainMenu));
          }
          
          #[test]
          fn test_navigate_back_to_main_menu_from_practice() {
              let mut state = create_minimal_app_state();
              Application::update(&mut state, Message::NavigateToPractice(PracticeMode::Freestyle));
              Application::update(&mut state, Message::NavigateToMainMenu);
              
              assert!(matches!(state.current_screen(), Screen::MainMenu));
          }
      }
      
      #[cfg(test)]
      mod learning_session_tests {
          use super::*;
          
          #[test]
          fn test_learning_session_initialization_success() {
              let mut state = create_minimal_app_state();
              let learning_state = LearningState::new().unwrap();
              let msg = Message::LearningSessionStarted(Ok(learning_state));
              let _task = Application::update(&mut state, msg);
              
              match state.current_screen() {
                  Screen::Learning(session) => {
                      assert!(session.current_character().is_some());
                      assert_eq!(session.session_progress().0, 0);
                  }
                  _ => panic!("Expected Learning screen"),
              }
          }
          
          #[test]
          fn test_review_response_updates_state() {
              let mut state = create_minimal_app_state();
              let learning_state = LearningState::new().unwrap();
              state.screen = Screen::Learning(learning_state);
              
              let msg = Message::ReviewResponse(ReviewRating::Good);
              let task = Application::update(&mut state, msg);
              
              assert!(task.is_some());
          }
          
          #[test]
          fn test_next_review_item_advances_queue() {
              let mut state = create_minimal_app_state();
              let mut learning_state = LearningState::new().unwrap();
              let initial_progress = learning_state.session_progress();
              state.screen = Screen::Learning(learning_state);
              
              let msg = Message::NextReviewItem;
              let _task = Application::update(&mut state, msg);
              
              match state.current_screen() {
                  Screen::Learning(session) => {
                      let new_progress = session.session_progress();
                      assert!(new_progress.0 >= initial_progress.0);
                  }
                  _ => panic!("Expected Learning screen"),
              }
          }
          
          #[test]
          fn test_learning_session_complete_returns_to_menu() {
              let mut state = create_minimal_app_state();
              let learning_state = LearningState::new().unwrap();
              state.screen = Screen::Learning(learning_state);
              
              let msg = Message::LearningSessionComplete;
              let _task = Application::update(&mut state, msg);
              
              assert!(matches!(state.current_screen(), Screen::MainMenu));
          }
      }
      
      #[cfg(test)]
      mod practice_session_tests {
          use super::*;
          
          #[test]
          fn test_practice_session_initialization_success() {
              let mut state = create_minimal_app_state();
              let practice_state = PracticeState::new(PracticeMode::Freestyle).unwrap();
              let msg = Message::PracticeSessionStarted(Ok(practice_state));
              let _task = Application::update(&mut state, msg);
              
              match state.current_screen() {
                  Screen::Practice(session) => {
                      assert!(session.current_character().is_some());
                      assert_eq!(session.canvas_state().strokes.len(), 0);
                  }
                  _ => panic!("Expected Practice screen"),
              }
          }
          
          #[test]
          fn test_drawing_stroke_started_updates_canvas() {
              let mut state = create_minimal_app_state();
              let practice_state = PracticeState::new(PracticeMode::Freestyle).unwrap();
              state.screen = Screen::Practice(practice_state);
              
              let point = Point { x: 100.0, y: 100.0 };
              let msg = Message::DrawingStrokeStarted(point);
              let _task = Application::update(&mut state, msg);
              
              match state.current_screen() {
                  Screen::Practice(session) => {
                      assert!(session.canvas_state().current_stroke.is_some());
                  }
                  _ => panic!("Expected Practice screen"),
              }
          }
          
          #[test]
          fn test_drawing_stroke_continued_adds_points() {
              let mut state = create_minimal_app_state();
              let mut practice_state = PracticeState::new(PracticeMode::Freestyle).unwrap();
              practice_state.canvas_state_mut().start_stroke(Point { x: 100.0, y: 100.0 });
              state.screen = Screen::Practice(practice_state);
              
              let point = Point { x: 150.0, y: 150.0 };
              let msg = Message::DrawingStrokeContinued(point);
              let _task = Application::update(&mut state, msg);
              
              match state.current_screen() {
                  Screen::Practice(session) => {
                      let stroke_len = session.canvas_state().current_stroke.as_ref().unwrap().points.len();
                      assert!(stroke_len >= 2);
                  }
                  _ => panic!("Expected Practice screen"),
              }
          }
          
          #[test]
          fn test_drawing_stroke_ended_moves_to_history() {
              let mut state = create_minimal_app_state();
              let mut practice_state = PracticeState::new(PracticeMode::Freestyle).unwrap();
              practice_state.canvas_state_mut().start_stroke(Point { x: 100.0, y: 100.0 });
              state.screen = Screen::Practice(practice_state);
              
              let msg = Message::DrawingStrokeEnded;
              let _task = Application::update(&mut state, msg);
              
              match state.current_screen() {
                  Screen::Practice(session) => {
                      assert!(session.canvas_state().current_stroke.is_none());
                      assert_eq!(session.canvas_state().strokes.len(), 1);
                  }
                  _ => panic!("Expected Practice screen"),
              }
          }
          
          #[test]
          fn test_clear_canvas_removes_all_strokes() {
              let mut state = create_minimal_app_state();
              let practice_state = PracticeState::new(PracticeMode::Freestyle).unwrap();
              state.screen = Screen::Practice(practice_state);
              
              let msg = Message::ClearCanvas;
              let _task = Application::update(&mut state, msg);
              
              match state.current_screen() {
                  Screen::Practice(session) => {
                      assert_eq!(session.canvas_state().strokes.len(), 0);
                      assert!(session.canvas_state().current_stroke.is_none());
                  }
                  _ => panic!("Expected Practice screen"),
              }
          }
          
          #[test]
          fn test_undo_stroke_removes_last_stroke() {
              let mut state = create_minimal_app_state();
              let mut practice_state = PracticeState::new(PracticeMode::Freestyle).unwrap();
              practice_state.canvas_state_mut().start_stroke(Point { x: 100.0, y: 100.0 });
              practice_state.canvas_state_mut().end_stroke();
              state.screen = Screen::Practice(practice_state);
              
              let initial_count = match state.current_screen() {
                  Screen::Practice(session) => session.canvas_state().strokes.len(),
                  _ => 0,
              };
              
              let msg = Message::UndoStroke;
              let _task = Application::update(&mut state, msg);
              
              match state.current_screen() {
                  Screen::Practice(session) => {
                      assert_eq!(session.canvas_state().strokes.len(), initial_count - 1);
                  }
                  _ => panic!("Expected Practice screen"),
              }
          }
          
          #[test]
          fn test_submit_drawing_triggers_recognition() {
              let mut state = create_minimal_app_state();
              let practice_state = PracticeState::new(PracticeMode::Freestyle).unwrap();
              state.screen = Screen::Practice(practice_state);
              
              let msg = Message::SubmitDrawing;
              let task = Application::update(&mut state, msg);
              
              assert!(task.is_some());
          }
      }
      
      #[cfg(test)]
      mod settings_tests {
          use super::*;
          
          #[test]
          fn test_setting_changed_updates_state() {
              let mut state = create_minimal_app_state();
              state.screen = Screen::Settings;
              
              let msg = Message::SettingChanged(SettingKey::AnimationSpeed, SettingValue::Float(1.5));
              let task = Application::update(&mut state, msg);
              
              assert!(task.is_some());
              let settings = state.settings.read().unwrap();
              assert_eq!(settings.get(&SettingKey::AnimationSpeed), Some(&SettingValue::Float(1.5)));
          }
      }
      
      #[cfg(test)]
      mod state_consistency_tests {
          use super::*;
          
          #[test]
          fn test_session_state_preserved_during_temporary_navigation() {
              let mut state = create_minimal_app_state();
              Application::update(&mut state, Message::NavigateToLearning);
              
              let session_started = match state.current_screen() {
                  Screen::Learning(session) => session.clone(),
                  _ => panic!("Expected Learning screen"),
              };
              
              Application::update(&mut state, Message::NavigateToSettings);
              assert!(matches!(state.current_screen(), Screen::Settings));
              
              Application::update(&mut state, Message::NavigateToLearning);
              match state.current_screen() {
                  Screen::Learning(session) => {
                      assert_eq!(session.session_progress(), session_started.session_progress());
                  }
                  _ => panic!("Expected Learning screen"),
              }
          }
          
          #[test]
          fn test_shared_state_persists_across_navigation() {
              let mut state = create_minimal_app_state();
              
              state.settings.write().unwrap().insert(SettingKey::DarkMode, SettingValue::Bool(true));
              
              Application::update(&mut state, Message::NavigateToLearning);
              Application::update(&mut state, Message::NavigateToMainMenu);
              
              let dark_mode_setting = state.settings.read().unwrap().get(&SettingKey::DarkMode).cloned();
              assert_eq!(dark_mode_setting, Some(SettingValue::Bool(true)));
          }
      }
      
      #[cfg(test)]
      mod property_tests {
          use super::*;
          use proptest::prelude::*;
          
          proptest! {
              #[test]
              fn prop_all_screens_reachable_from_main_menu(
                  screen_choice in 0usize..5
              ) {
                  let mut state = create_minimal_app_state();
                  assert!(matches!(state.current_screen(), Screen::MainMenu));
                  
                  let messages = vec![
                      Message::NavigateToLearning,
                      Message::NavigateToPractice(PracticeMode::Freestyle),
                      Message::NavigateToStatistics,
                      Message::NavigateToSettings,
                      Message::NavigateToMainMenu,
                  ];
                  
                  let msg = messages[screen_choice % messages.len()].clone();
                  let _task = Application::update(&mut state, msg);
                  
                  prop_assert!(matches!(
                      state.current_screen(),
                      Screen::MainMenu | Screen::Learning(_) | Screen::Practice(_) | Screen::Statistics(_) | Screen::Settings
                  ));
              }
              
              #[test]
              fn prop_state_transitions_are_deterministic(
                  nav_sequence in prop::collection::vec(0usize..3, 1..10)
              ) {
                  let mut state1 = create_minimal_app_state();
                  let mut state2 = create_minimal_app_state();
                  
                  let messages = vec![
                      Message::NavigateToMainMenu,
                      Message::NavigateToSettings,
                      Message::NavigateToStatistics,
                  ];
                  
                  for &index in &nav_sequence {
                      let msg = messages[index % messages.len()].clone();
                      Application::update(&mut state1, msg.clone());
                      Application::update(&mut state2, msg);
                  }
                  
                  prop_assert_eq!(
                      std::mem::discriminant(state1.current_screen()),
                      std::mem::discriminant(state2.current_screen())
                  );
              }
              
              #[test]
              fn prop_navigation_never_produces_invalid_state(
                  nav_sequence in prop::collection::vec(0usize..5, 1..20)
              ) {
                  let mut state = create_minimal_app_state();
                  
                  let messages = vec![
                      Message::NavigateToMainMenu,
                      Message::NavigateToLearning,
                      Message::NavigateToPractice(PracticeMode::Freestyle),
                      Message::NavigateToStatistics,
                      Message::NavigateToSettings,
                  ];
                  
                  for &index in &nav_sequence {
                      let msg = messages[index % messages.len()].clone();
                      let _task = Application::update(&mut state, msg);
                      
                      prop_assert!(matches!(
                          state.current_screen(),
                          Screen::MainMenu | Screen::Learning(_) | Screen::Practice(_) | Screen::Statistics(_) | Screen::Settings
                      ));
                  }
              }
              
              #[test]
              fn prop_canvas_operations_maintain_consistency(
                  operations in prop::collection::vec(0usize..5, 1..20)
              ) {
                  let mut state = create_minimal_app_state();
                  let practice_state = PracticeState::new(PracticeMode::Freestyle).unwrap();
                  state.screen = Screen::Practice(practice_state);
                  
                  for &op in &operations {
                      let msg = match op % 5 {
                          0 => Message::DrawingStrokeStarted(Point { x: 100.0, y: 100.0 }),
                          1 => Message::DrawingStrokeContinued(Point { x: 150.0, y: 150.0 }),
                          2 => Message::DrawingStrokeEnded,
                          3 => Message::ClearCanvas,
                          4 => Message::UndoStroke,
                          _ => unreachable!(),
                      };
                      
                      let _task = Application::update(&mut state, msg);
                      
                      match state.current_screen() {
                          Screen::Practice(session) => {
                              let canvas = session.canvas_state();
                              prop_assert!(canvas.strokes.len() < 1000);
                              if let Some(ref current) = canvas.current_stroke {
                                  prop_assert!(current.points.len() > 0);
                              }
                          }
                          _ => prop_assert!(false, "Lost practice screen state"),
                      }
                  }
              }
          }
      }
  
  coverage:
    - "Initial state is MainMenu screen"
    - "Initial state has valid shared data structures"
    - "Navigation from MainMenu to Learning screen"
    - "Navigation from MainMenu to Practice screen (Freestyle mode)"
    - "Navigation from MainMenu to Statistics screen"
    - "Navigation from MainMenu to Settings screen"
    - "Navigation back to MainMenu from Learning screen"
    - "Navigation back to MainMenu from Practice screen"
    - "Learning session initialization with success result"
    - "Review response updates learning session state"
    - "Next review item advances review queue"
    - "Learning session complete transitions to MainMenu"
    - "Practice session initialization with success result"
    - "Drawing stroke started updates canvas state"
    - "Drawing stroke continued adds points to current stroke"
    - "Drawing stroke ended moves stroke to history"
    - "Clear canvas removes all strokes and current stroke"
    - "Undo stroke removes last completed stroke"
    - "Submit drawing triggers recognition task"
    - "Setting changed updates settings state and triggers persistence"
    - "Session state preserved during temporary navigation to other screens"
    - "Shared state (settings, progress) persists across all navigation"
    - "Property: All screens reachable from MainMenu"
    - "Property: State transitions are deterministic for same message sequence"
    - "Property: Navigation never produces invalid screen state"
    - "Property: Canvas operations maintain stroke consistency invariants"

dependencies:
  depends_on:
    - task_id: 1
      reason: "Requires application foundation and state/ module structure established in Task 1"

  depended_upon_by:
    - task_id: 7
      reason: "Learning session implementation requires state management framework with Screen::Learning variant and message handling"
    - task_id: 8
      reason: "Practice session implementation requires state management framework with Screen::Practice variant and drawing message handling"
    - task_id: 10
      reason: "Statistics screen implementation requires navigation support and Screen::Statistics variant"

  external:
    - name: "iced::Application"
      type: "trait"
      status: "already exists"
    - name: "iced::Task"
      type: "struct"
      status: "already exists"
    - name: "Arc"
      type: "struct"
      status: "already exists"
    - name: "RwLock"
      type: "struct"
      status: "already exists"
    - name: "Character"
      type: "struct"
      status: "needs implementation"
    - name: "CharacterId"
      type: "type"
      status: "needs implementation"
    - name: "RecognitionResponse"
      type: "struct"
      status: "needs implementation"
    - name: "ProgressData"
      type: "struct"
      status: "needs implementation"
    - name: "OverallStats"
      type: "struct"
      status: "needs implementation"
---
task:
  id: 7
  name: "SM-2 Spaced Repetition Algorithm and Review Queue"

context:
  description: |
    This task implements the SM-2 spaced repetition algorithm, which is the core pedagogical
    engine that makes the learning system effective for long-term vocabulary retention. 
    
    The SM-2 algorithm, developed by Piotr Wozniak for SuperMemo, is a battle-tested approach
    to scheduling card reviews at optimal intervals based on user performance. It tracks three
    key parameters per card: ease factor (starting at 2.5), interval in days, and repetition
    count. When a user reviews a card, they provide a quality rating (0-5 scale) that determines
    how the card's scheduling parameters are updated.
    
    The implementation includes two major components:
    
    1. **SM2Card**: Represents a flashcard with SM-2 scheduling parameters. The review() method
       implements the core algorithm: for quality ratings ≥3 (correct recall), it updates the
       ease factor and calculates the next interval using the SM-2 formula. For quality <3
       (failed recall), it resets the card to the learning state with interval=1 and repetitions=0.
       The ease factor has a floor of 1.3 to prevent cards from becoming impossibly difficult.
    
    2. **ReviewQueue**: Manages three separate queues (new cards, learning cards, and review cards)
       with sophisticated prioritization logic. It implements the proven SRS principle of
       prioritizing learning cards > due reviews > new cards, ensuring users reinforce
       newly-introduced material before moving on. Daily limits prevent cognitive overload.
    
    This architecture enables the learning session (Task 8) to simply call get_next_card() and
    review(), while the queue intelligently handles scheduling, prioritization, and state
    management. The deterministic nature of SM-2 makes it ideal for comprehensive unit testing
    and property-based verification of critical invariants.

  key_points:
    - "SM-2 algorithm is deterministic with well-defined mathematical formulas for ease factor and interval calculation"
    - "Ease factor floor of 1.3 prevents cards from becoming impossibly difficult even after many failures"
    - "First two intervals are fixed (1 day, 6 days) per SM-2 specification; subsequent intervals use ease_factor formula"
    - "Quality rating <3 triggers reset to learning state while still adjusting ease factor based on performance"
    - "Queue prioritization (learning > review > new) follows SRS best practices for optimal retention"
    - "Daily limits for new cards and reviews prevent user overwhelm and maintain sustainable learning pace"
    - "Separation of SM2Card (algorithm) and ReviewQueue (orchestration) enables clean architecture and testability"
    - "Implementation stores review history metadata to enable future algorithm upgrades (e.g., FSRS) without data migration"

files:
  - path: "src/srs/mod.rs"
    description: "Module declaration file exposing sm2, queue, and types submodules for the spaced repetition system"
  - path: "src/srs/sm2.rs"
    description: "Core SM-2 algorithm implementation with SM2Card struct, review() method for calculating ease factor and intervals, and SM2Parameters configuration"
  - path: "src/srs/queue.rs"
    description: "ReviewQueue struct managing card prioritization across new/learning/review queues with get_next_card() method and daily limit enforcement via QueueConfig"
  - path: "src/srs/types.rs"
    description: "Shared type definitions including CardState enum (New, Learning, Review, Relearning) and QualityRating enum (0-5 scale)"

functions:
  - file: "src/srs/types.rs"
    items:
      - type: "enum"
        name: "CardState"
        description: "Represents the current learning state of a flashcard in the spaced repetition system"
        invariants: "Must be one of four states: New, Learning, Review, or Relearning"

      - type: "enum_variant"
        name: "CardState::New"
        description: "Card has never been reviewed by the user"
        postconditions: "Card is eligible for introduction up to daily new card limit"

      - type: "enum_variant"
        name: "CardState::Learning"
        description: "Card is in initial learning phase after first review"
        postconditions: "Card has highest priority in review queue"

      - type: "enum_variant"
        name: "CardState::Review"
        description: "Card has graduated from learning and follows SM-2 interval scheduling"
        preconditions: "Card has been successfully reviewed at least twice with quality >= 3"

      - type: "enum_variant"
        name: "CardState::Relearning"
        description: "Previously learned card that was failed and needs relearning"
        preconditions: "Card was in Review state and received quality rating < 3"

      - type: "enum"
        name: "QualityRating"
        description: "User's quality rating for a card review on standardized 0-5 scale from SM-2 specification"
        invariants: "Must be integer value 0-5 inclusive"

      - type: "enum_variant"
        name: "QualityRating::Blackout"
        description: "Complete failure to recall (quality=0)"
        postconditions: "Triggers reset to learning with interval=1, repetitions=0"

      - type: "enum_variant"
        name: "QualityRating::Barely"
        description: "Incorrect response but barely remembered (quality=1)"
        postconditions: "Triggers reset to learning with interval=1, repetitions=0"

      - type: "enum_variant"
        name: "QualityRating::Incorrect"
        description: "Incorrect response but item seemed familiar (quality=2)"
        postconditions: "Triggers reset to learning with interval=1, repetitions=0"

      - type: "enum_variant"
        name: "QualityRating::Difficult"
        description: "Correct response but difficult recall (quality=3)"
        postconditions: "Progresses card with reduced ease factor"

      - type: "enum_variant"
        name: "QualityRating::Correct"
        description: "Correct response with hesitation (quality=4)"
        postconditions: "Progresses card with unchanged ease factor"

      - type: "enum_variant"
        name: "QualityRating::Perfect"
        description: "Perfect response with immediate recall (quality=5)"
        postconditions: "Progresses card with increased ease factor"

      - type: "method"
        name: "QualityRating::to_u8"
        description: "Converts QualityRating enum to numeric value 0-5"
        postconditions: "Returns u8 value corresponding to rating level"

      - type: "method"
        name: "QualityRating::from_u8"
        description: "Constructs QualityRating from numeric value 0-5"
        preconditions: "Input value must be in range 0-5"
        postconditions: "Returns Some(QualityRating) if valid, None otherwise"

  - file: "src/srs/sm2.rs"
    items:
      - type: "struct"
        name: "SM2Card"
        description: "Represents a flashcard with SM-2 algorithm scheduling parameters including ease factor, interval, repetition count, and next review date"
        invariants: "ease_factor >= 1.3; interval >= 0; repetitions >= 0; next_review_date >= creation_date"

      - type: "struct"
        name: "SM2Parameters"
        description: "Configuration parameters for SM-2 algorithm controlling initial ease factor, minimum ease threshold, and interval calculation"
        invariants: "initial_ease_factor >= min_ease_factor >= 1.3; initial_ease_factor typically 2.5"

      - type: "method"
        name: "SM2Card::new"
        description: "Creates a new SM2Card with default SM-2 parameters: ease_factor=2.5, interval=0, repetitions=0, state=New"
        preconditions: "Valid card_id and content provided"
        postconditions: "Returns SM2Card with ease_factor=2.5, interval=0, repetitions=0, state=New, next_review_date=now"

      - type: "method"
        name: "SM2Card::with_parameters"
        description: "Creates a new SM2Card with custom SM2Parameters instead of defaults"
        preconditions: "Valid card_id, content, and SM2Parameters provided"
        postconditions: "Returns SM2Card initialized with provided parameters"

      - type: "method"
        name: "SM2Card::review"
        description: "Updates card state based on quality rating using SM-2 algorithm; calculates new ease factor, interval, and next review date according to SM-2 specification"
        preconditions: "quality must be valid QualityRating (0-5); current_date is valid DateTime"
        postconditions: "ease_factor updated and bounded to [1.3, inf); interval updated according to SM-2 rules; next_review_date set to current_date + interval; state updated to Learning/Relearning for quality<3 or Review for quality>=3; repetitions incremented for quality>=3 or reset to 0 for quality<3"
        invariants: "ease_factor >= 1.3 after update; next_review_date > current_date; interval matches SM-2 specification"

      - type: "method"
        name: "SM2Card::calculate_ease_factor"
        description: "Calculates new ease factor based on quality rating using SM-2 formula: EF' = max(1.3, EF + (0.1 - (5-q)*(0.08+(5-q)*0.02)))"
        preconditions: "quality in range 0-5; current_ease_factor >= 1.3"
        postconditions: "Returns ease factor >= 1.3 according to SM-2 formula"
        invariants: "Result is always >= 1.3 due to max() constraint"

      - type: "method"
        name: "SM2Card::calculate_interval"
        description: "Calculates next interval in days based on repetition count and ease factor according to SM-2 specification"
        preconditions: "repetitions >= 0; ease_factor >= 1.3"
        postconditions: "Returns interval: 1 day for repetitions=0, 6 days for repetitions=1, previous_interval * ease_factor for repetitions>=2"
        invariants: "First interval always 1 day; second interval always 6 days; subsequent intervals increase monotonically for constant ease_factor"

      - type: "method"
        name: "SM2Card::is_due"
        description: "Checks if card is due for review by comparing current date against next review date"
        preconditions: "current_date is valid DateTime"
        postconditions: "Returns true if current_date >= next_review_date, false otherwise"

      - type: "method"
        name: "SM2Card::reset_to_learning"
        description: "Resets card to learning state when review quality is poor (quality < 3); updates ease factor but resets interval and repetitions"
        preconditions: "Card exists with valid state"
        postconditions: "interval=1, repetitions=0, state=Learning if was New/Learning or Relearning if was Review, ease_factor updated according to quality"

      - type: "method"
        name: "SM2Card::get_state"
        description: "Returns the current CardState of the card"
        postconditions: "Returns current CardState enum value"

      - type: "method"
        name: "SM2Card::get_ease_factor"
        description: "Returns the current ease factor value"
        postconditions: "Returns f32 value >= 1.3"

      - type: "method"
        name: "SM2Card::get_interval"
        description: "Returns the current interval in days"
        postconditions: "Returns u32 value >= 0"

      - type: "method"
        name: "SM2Card::get_repetitions"
        description: "Returns the current repetition count"
        postconditions: "Returns u32 value >= 0"

      - type: "method"
        name: "SM2Card::get_next_review_date"
        description: "Returns the scheduled next review date"
        postconditions: "Returns DateTime representing future review time"

      - type: "constant"
        name: "DEFAULT_EASE_FACTOR"
        description: "Default starting ease factor for new cards: 2.5 per SM-2 specification"

      - type: "constant"
        name: "MIN_EASE_FACTOR"
        description: "Minimum allowed ease factor to prevent cards from becoming impossibly difficult: 1.3 per SM-2 specification"

      - type: "constant"
        name: "FIRST_INTERVAL_DAYS"
        description: "Fixed first interval in days: 1 day per SM-2 specification"

      - type: "constant"
        name: "SECOND_INTERVAL_DAYS"
        description: "Fixed second interval in days: 6 days per SM-2 specification"

  - file: "src/srs/queue.rs"
    items:
      - type: "struct"
        name: "ReviewQueue"
        description: "Manages card queues (new, learning, review) with prioritization logic and daily limits to optimize learning flow"
        invariants: "All cards in queues are unique by card_id; learning_queue contains only Learning/Relearning cards; review_queue contains only Review cards with next_review_date <= today; new_queue contains only New cards; daily counters <= configured limits"

      - type: "struct"
        name: "QueueConfig"
        description: "Configuration for review queue including daily limits for new cards and reviews to prevent cognitive overload"
        invariants: "max_new_cards_per_day >= 0; max_reviews_per_day >= 0; limits are reasonable (typically 20-50 new cards, 100-200 reviews)"

      - type: "struct"
        name: "QueueStatistics"
        description: "Statistics about current queue state including counts per queue type and remaining daily allowance"
        postconditions: "All counts are non-negative; new_cards_remaining = max_new_cards_per_day - new_cards_seen_today"

      - type: "method"
        name: "ReviewQueue::new"
        description: "Creates a new ReviewQueue with specified configuration and empty queues"
        preconditions: "Valid QueueConfig provided with reasonable limits"
        postconditions: "Returns ReviewQueue with empty queues, zero daily counters, and provided config"

      - type: "method"
        name: "ReviewQueue::with_config"
        description: "Alternative constructor allowing custom QueueConfig"
        preconditions: "Valid QueueConfig provided"
        postconditions: "Returns ReviewQueue initialized with custom config"

      - type: "method"
        name: "ReviewQueue::add_card"
        description: "Adds a card to appropriate queue based on its state and due date; prevents duplicates"
        preconditions: "Card is valid SM2Card with valid state"
        postconditions: "Card added to correct queue: new_queue for New state, learning_queue for Learning/Relearning, review_queue for Review if due today; card not added if already present in any queue"
        invariants: "Card appears in at most one queue; queue remains sorted by priority"

      - type: "method"
        name: "ReviewQueue::get_next_card"
        description: "Returns next card to review based on priority rules: learning > due reviews > new cards; respects daily limits"
        preconditions: "Queue is initialized; at least one call to update_due_cards has occurred"
        postconditions: "Returns Some(SM2Card) following priority order (Learning/Relearning first, then Review due today, then New up to daily limit) or None if no cards available or daily limits reached; returned card is removed from its queue"
        invariants: "Priority order strictly enforced: Learning/Relearning cards always returned before Review cards, Review cards always returned before New cards; daily limits respected"

      - type: "method"
        name: "ReviewQueue::return_card"
        description: "Returns a card to the queue after review, placing it in appropriate queue based on updated state and due date"
        preconditions: "Card has been reviewed and state/due date updated via SM2Card::review()"
        postconditions: "Card re-added to correct queue based on new state: learning_queue if still Learning/Relearning and due today, review_queue if Review and due today, removed from queues if not due today"

      - type: "method"
        name: "ReviewQueue::get_statistics"
        description: "Returns current queue statistics including card counts and remaining daily allowance"
        postconditions: "Returns QueueStatistics with accurate counts: new_cards_count, learning_cards_count, review_cards_count, new_cards_seen_today, reviews_done_today, new_cards_remaining, reviews_remaining"

      - type: "method"
        name: "ReviewQueue::reset_daily_limits"
        description: "Resets daily counters for new cards and reviews; typically called at start of new day"
        postconditions: "new_cards_seen_today = 0; reviews_done_today = 0; last_reset_date = current_date"

      - type: "method"
        name: "ReviewQueue::update_due_cards"
        description: "Updates review queue by checking all cards and moving cards that are now due from future reviews to current review queue"
        preconditions: "current_date is valid DateTime"
        postconditions: "All cards with next_review_date <= current_date are in review_queue; cards with next_review_date > current_date remain in future storage"

      - type: "method"
        name: "ReviewQueue::is_empty"
        description: "Checks if all queues are empty or daily limits have been reached"
        postconditions: "Returns true if (learning_queue.is_empty() AND review_queue.is_empty() AND (new_queue.is_empty() OR new_cards_seen_today >= max_new_cards_per_day))"

      - type: "method"
        name: "ReviewQueue::has_learning_cards"
        description: "Checks if learning queue has any cards"
        postconditions: "Returns true if learning_queue is not empty"

      - type: "method"
        name: "ReviewQueue::has_review_cards"
        description: "Checks if review queue has any cards"
        postconditions: "Returns true if review_queue is not empty"

      - type: "method"
        name: "ReviewQueue::has_new_cards"
        description: "Checks if new cards are available considering daily limit"
        postconditions: "Returns true if new_queue is not empty AND new_cards_seen_today < max_new_cards_per_day"

      - type: "method"
        name: "ReviewQueue::clear"
        description: "Removes all cards from all queues; useful for testing or resetting session"
        postconditions: "All queues empty; daily counters unchanged"

      - type: "constant"
        name: "DEFAULT_MAX_NEW_CARDS"
        description: "Default daily limit for new cards: 20 cards per day"

      - type: "constant"
        name: "DEFAULT_MAX_REVIEWS"
        description: "Default daily limit for review cards: 200 cards per day"

  - file: "src/srs/mod.rs"
    items:
      - type: "module_declaration"
        name: "mod sm2"
        description: "Module containing SM-2 algorithm implementation for spaced repetition scheduling"

      - type: "module_declaration"
        name: "mod queue"
        description: "Module containing review queue management system with prioritization logic"

      - type: "module_declaration"
        name: "mod types"
        description: "Module containing common types and enums for SRS system"

      - type: "module_declaration"
        name: "pub use sm2::{SM2Card, SM2Parameters}"
        description: "Re-exports SM-2 algorithm types for external use"

      - type: "module_declaration"
        name: "pub use queue::{ReviewQueue, QueueConfig, QueueStatistics}"
        description: "Re-exports review queue types for external use"

      - type: "module_declaration"
        name: "pub use types::{CardState, QualityRating}"
        description: "Re-exports common SRS types for external use"

formal_verification:
  needed: false
  level: "None"
  explanation: |
    Formal verification is not needed for the SM-2 Spaced Repetition Algorithm implementation for the following reasons:

    1. Property-Based Testing is Sufficient: The task already includes property-based testing which is explicitly designed to verify the exact invariants that formal verification would prove. Properties like "ease factor never falls below 1.3", "intervals increase monotonically for consecutive correct reviews", and "queue prioritization ordering" can be systematically verified through property-based tests with QuickCheck/proptest across thousands of randomly generated inputs.

    2. Deterministic Algorithm with Known Behavior: SM-2 is a well-established, mathematically deterministic algorithm with published specifications. The correctness of the implementation can be verified by comparing outputs against known reference implementations and the published algorithm specification. This is more practical than formal proofs.

    3. Non-Critical Educational Domain: This is educational software for language learning. Incorrect spaced repetition intervals do not pose safety risks, security vulnerabilities, or financial consequences. The worst-case failure mode is suboptimal learning efficiency, which users can easily detect and correct through manual review scheduling.

    4. Comprehensive Test Coverage (20 Unit Tests): The task specifies 20 unit tests covering all algorithm branches, state transitions, and edge cases. Combined with property-based testing for invariants, this provides high confidence in correctness at a fraction of the cost of formal methods.

    5. Observable and Self-Correcting: Users directly observe review scheduling behavior and can provide feedback if intervals seem incorrect. The system maintains review history, making anomalies detectable. Unlike embedded systems or cryptographic code, errors are immediately visible and non-catastrophic.

    6. Mathematical Simplicity: While the algorithm is deterministic, the mathematics (ease factor adjustments, interval calculations) involve simple arithmetic operations that are easily unit-tested. The complexity lies in the state machine (learning/review/new card states), which is well-suited to state-based testing rather than formal verification.

    7. Cost-Benefit Analysis: Formal verification requires formal specification language (e.g., TLA+, Coq, Dafny), significant expert time to write proofs, and maintenance burden when implementation changes. For an educational spaced repetition system, this investment cannot be justified when property-based testing and comprehensive unit tests provide adequate assurance.

    8. Property Testing Covers Critical Invariants: The identified critical properties are all efficiently verifiable through property testing:
       - Ease factor bounds (1.3 ≤ EF) → Test with random quality ratings
       - Interval monotonicity → Test sequences of correct answers
       - Failed card reset behavior → Test quality < 3 inputs
       - Queue ordering invariant → Test with mixed card states
       - Future review dates → Test all review outcomes

    The testing strategy (unit + property-based) already addresses the verification needs comprehensively. Formal verification would add complexity without proportional benefit for this application domain.

tests:
  strategy:
    approach: "unit tests with property-based testing"
    rationale:
      - "SM-2 algorithm is deterministic and mathematical with precise correctness requirements"
      - "Property-based testing verifies critical invariants like ease factor bounds, interval monotonicity, and state transitions across thousands of random inputs"
      - "Queue prioritization logic requires deterministic unit tests to verify correct ordering of learning, review, and new cards"
      - "Edge cases like boundary quality ratings, ease factor floor, and initial state transitions need explicit coverage"
      - "Pure business logic with no external dependencies enables isolated testing without mocking"
      - "Floating-point precision concerns require property tests to verify invariants hold over extended review cycles"

  implementation:
    file: "tests/srs/sm2_tests.rs"
    location: "create new"
    code: |
      //! Comprehensive unit and property-based tests for SM-2 spaced repetition algorithm
      //! 
      //! These tests verify:
      //! 1. SM2Card review() method correctly updates ease factor, interval, and repetitions
      //! 2. All quality ratings (0-5) produce expected state changes
      //! 3. Critical invariants hold: ease_factor >= 1.3, next_review > now, interval monotonicity
      //! 4. ReviewQueue prioritization follows learning > review > new order
      //! 5. Daily limits prevent queue overflow
      //! 6. Failed cards reset correctly while preserving ease factor adjustments
      
      use chrono::{Duration, Utc, DateTime};
      
      #[cfg(test)]
      mod sm2_card_tests {
          use super::*;
          use crate::srs::{SM2Card, CardState, QualityRating};
          
          /// Helper function to create a test card with default parameters
          fn new_test_card(card_id: u32) -> SM2Card {
              SM2Card::new(card_id)
          }
          
          // ========== Initial State Tests ==========
          
          #[test]
          fn test_sm2card_initial_state() {
              let card = new_test_card(1);
              assert_eq!(card.ease_factor, 2.5, "Initial ease factor should be 2.5");
              assert_eq!(card.interval, 0, "Initial interval should be 0");
              assert_eq!(card.repetitions, 0, "Initial repetitions should be 0");
              assert_eq!(card.state, CardState::New, "Initial state should be New");
          }
          
          // ========== Quality Rating Tests (0-5) ==========
          
          #[test]
          fn test_review_quality_5_perfect() {
              let mut card = new_test_card(1);
              let before = Utc::now();
              
              card.review(QualityRating::Perfect);
              
              // Quality 5: EF' = 2.5 + (0.1 - (5-5)*(0.08+(5-5)*0.02)) = 2.5 + 0.1 = 2.6
              assert_eq!(card.ease_factor, 2.6, "Quality 5 should increase EF by 0.1");
              assert_eq!(card.interval, 1, "First interval should be 1 day");
              assert_eq!(card.repetitions, 1, "Repetitions should increment to 1");
              assert!(card.next_review > before, "Next review should be in future");
              assert_eq!(card.state, CardState::Learning, "Should transition to Learning");
          }
          
          #[test]
          fn test_review_quality_4_correct() {
              let mut card = new_test_card(1);
              let before = Utc::now();
              
              card.review(QualityRating::Correct);
              
              // Quality 4: EF' = 2.5 + (0.1 - (5-4)*(0.08+(5-4)*0.02)) = 2.5 + 0.1 - 0.1 = 2.5
              assert_eq!(card.ease_factor, 2.5, "Quality 4 should maintain EF at 2.5");
              assert_eq!(card.interval, 1, "First interval should be 1 day");
              assert_eq!(card.repetitions, 1, "Repetitions should increment to 1");
              assert!(card.next_review > before, "Next review should be in future");
          }
          
          #[test]
          fn test_review_quality_3_difficult() {
              let mut card = new_test_card(1);
              
              card.review(QualityRating::Difficult);
              
              // Quality 3: EF' = 2.5 + (0.1 - (5-3)*(0.08+(5-3)*0.02))
              //                = 2.5 + (0.1 - 2*(0.08+2*0.02))
              //                = 2.5 + (0.1 - 2*0.12) = 2.5 + 0.1 - 0.24 = 2.36
              assert!((card.ease_factor - 2.36).abs() < 0.01, "Quality 3 should decrease EF to ~2.36");
              assert_eq!(card.interval, 1, "First interval should be 1 day");
              assert_eq!(card.repetitions, 1, "Repetitions should increment to 1");
          }
          
          #[test]
          fn test_review_quality_2_incorrect_resets() {
              let mut card = new_test_card(1);
              // Advance card to mature state first
              card.ease_factor = 2.8;
              card.interval = 10;
              card.repetitions = 5;
              card.state = CardState::Review;
              
              let ef_before = card.ease_factor;
              card.review(QualityRating::Incorrect);
              
              // Quality < 3 resets interval and repetitions
              assert_eq!(card.interval, 1, "Failed card should reset interval to 1");
              assert_eq!(card.repetitions, 0, "Failed card should reset repetitions to 0");
              assert!(card.ease_factor < ef_before, "Failed card should decrease ease factor");
              assert!(card.ease_factor >= 1.3, "Ease factor should respect floor of 1.3");
              assert_eq!(card.state, CardState::Relearning, "Should transition to Relearning");
          }
          
          #[test]
          fn test_review_quality_1_barely() {
              let mut card = new_test_card(1);
              card.ease_factor = 2.5;
              
              card.review(QualityRating::Barely);
              
              assert_eq!(card.interval, 1, "Failed card should reset interval to 1");
              assert_eq!(card.repetitions, 0, "Failed card should reset repetitions to 0");
              assert!(card.ease_factor < 2.5, "Quality 1 should decrease ease factor");
              assert!(card.ease_factor >= 1.3, "Ease factor should respect floor");
          }
          
          #[test]
          fn test_review_quality_0_blackout() {
              let mut card = new_test_card(1);
              card.ease_factor = 2.5;
              card.interval = 20;
              card.repetitions = 10;
              
              card.review(QualityRating::Blackout);
              
              assert_eq!(card.interval, 1, "Blackout should reset interval to 1");
              assert_eq!(card.repetitions, 0, "Blackout should reset repetitions to 0");
              assert!(card.ease_factor >= 1.3, "Ease factor should respect floor even after blackout");
          }
          
          // ========== Ease Factor Invariant Tests ==========
          
          #[test]
          fn test_ease_factor_floor_maintained() {
              let mut card = new_test_card(1);
              card.ease_factor = 1.35; // Just above floor
              
              // Multiple poor reviews should not push below floor
              card.review(QualityRating::Blackout);
              assert_eq!(card.ease_factor, 1.3, "Ease factor should hit floor at 1.3");
              
              card.review(QualityRating::Blackout);
              assert_eq!(card.ease_factor, 1.3, "Ease factor should remain at floor");
          }
          
          #[test]
          fn test_ease_factor_never_negative() {
              let mut card = new_test_card(1);
              card.ease_factor = 1.3;
              
              // 100 consecutive blackouts should not make ease factor negative
              for _ in 0..100 {
                  card.review(QualityRating::Blackout);
                  assert!(card.ease_factor >= 1.3, "Ease factor must always be >= 1.3");
              }
          }
          
          // ========== Interval Progression Tests ==========
          
          #[test]
          fn test_first_interval_is_one_day() {
              let mut card = new_test_card(1);
              let now = Utc::now();
              
              card.review(QualityRating::Correct);
              
              assert_eq!(card.interval, 1, "First interval must be 1 day");
              assert_eq!(card.repetitions, 1, "Should be at first repetition");
              
              let expected_date = now + Duration::days(1);
              let diff_seconds = (card.next_review - expected_date).num_seconds().abs();
              assert!(diff_seconds < 2, "Next review should be approximately 1 day from now");
          }
          
          #[test]
          fn test_second_interval_is_six_days() {
              let mut card = new_test_card(1);
              
              card.review(QualityRating::Correct); // First review
              card.review(QualityRating::Correct); // Second review
              
              assert_eq!(card.interval, 6, "Second interval must be 6 days");
              assert_eq!(card.repetitions, 2, "Should be at second repetition");
          }
          
          #[test]
          fn test_subsequent_intervals_use_ease_factor() {
              let mut card = new_test_card(1);
              card.ease_factor = 2.5;
              
              card.review(QualityRating::Correct); // interval = 1
              card.review(QualityRating::Correct); // interval = 6
              card.review(QualityRating::Correct); // interval = 6 * 2.5 = 15
              
              assert_eq!(card.interval, 15, "Third interval should be 6 * 2.5 = 15");
              assert_eq!(card.repetitions, 3, "Should be at third repetition");
          }
          
          #[test]
          fn test_interval_progression_quality_5() {
              let mut card = new_test_card(1);
              
              card.review(QualityRating::Perfect); // EF = 2.6, interval = 1
              assert_eq!(card.interval, 1);
              assert_eq!(card.ease_factor, 2.6);
              
              card.review(QualityRating::Perfect); // EF = 2.7, interval = 6
              assert_eq!(card.interval, 6);
              assert_eq!(card.ease_factor, 2.7);
              
              card.review(QualityRating::Perfect); // EF = 2.8, interval = 6 * 2.7 = 16.2 ≈ 16
              assert!(card.interval >= 16 && card.interval <= 17, "Third interval should be ~16 days");
              assert_eq!(card.ease_factor, 2.8);
          }
          
          #[test]
          fn test_interval_monotonicity_for_successful_reviews() {
              let mut card = new_test_card(1);
              
              let mut previous_interval = 0;
              for _ in 0..10 {
                  card.review(QualityRating::Correct);
                  assert!(card.interval >= previous_interval, 
                      "Intervals should increase monotonically for successful reviews");
                  previous_interval = card.interval;
              }
          }
          
          // ========== Failed Card Reset Tests ==========
          
          #[test]
          fn test_failed_card_resets_but_preserves_ease_adjustment() {
              let mut card = new_test_card(1);
              
              // Build up the card
              card.review(QualityRating::Perfect); // EF = 2.6
              card.review(QualityRating::Perfect); // EF = 2.7
              let ef_before_fail = card.ease_factor;
              
              // Fail the review
              card.review(QualityRating::Incorrect);
              
              assert_eq!(card.interval, 1, "Failed card should reset interval");
              assert_eq!(card.repetitions, 0, "Failed card should reset repetitions");
              assert!(card.ease_factor < ef_before_fail, "Failed review should still adjust ease factor");
              assert!(card.ease_factor >= 1.3, "But should respect floor");
          }
          
          #[test]
          fn test_multiple_failures_continue_adjusting_ease() {
              let mut card = new_test_card(1);
              card.ease_factor = 2.0;
              
              let mut previous_ef = card.ease_factor;
              for _ in 0..5 {
                  card.review(QualityRating::Incorrect);
                  assert!(card.ease_factor <= previous_ef, "Each failure should decrease or maintain ease factor");
                  assert!(card.ease_factor >= 1.3, "Should always respect floor");
                  previous_ef = card.ease_factor;
              }
          }
          
          // ========== Next Review Date Tests ==========
          
          #[test]
          fn test_next_review_always_in_future() {
              let mut card = new_test_card(1);
              
              for quality in [0, 1, 2, 3, 4, 5] {
                  let now = Utc::now();
                  card.review(match quality {
                      0 => QualityRating::Blackout,
                      1 => QualityRating::Barely,
                      2 => QualityRating::Incorrect,
                      3 => QualityRating::Difficult,
                      4 => QualityRating::Correct,
                      5 => QualityRating::Perfect,
                      _ => unreachable!(),
                  });
                  
                  assert!(card.next_review > now, 
                      "Next review must be in future after quality {} review", quality);
              }
          }
          
          #[test]
          fn test_next_review_date_calculation() {
              let mut card = new_test_card(1);
              let before_review = Utc::now();
              
              card.review(QualityRating::Correct);
              
              let expected_next = before_review + Duration::days(card.interval as i64);
              let diff = (card.next_review - expected_next).num_hours().abs();
              assert!(diff < 1, "Next review date should match interval calculation");
          }
          
          // ========== State Transition Tests ==========
          
          #[test]
          fn test_state_transitions_new_to_learning() {
              let mut card = new_test_card(1);
              assert_eq!(card.state, CardState::New);
              
              card.review(QualityRating::Correct);
              assert_eq!(card.state, CardState::Learning);
          }
          
          #[test]
          fn test_state_transitions_learning_to_review() {
              let mut card = new_test_card(1);
              
              card.review(QualityRating::Correct); // New -> Learning
              card.review(QualityRating::Correct); // Learning -> Review (after 2nd successful review)
              
              assert_eq!(card.state, CardState::Review);
          }
          
          #[test]
          fn test_state_transitions_review_to_relearning_on_failure() {
              let mut card = new_test_card(1);
              
              card.review(QualityRating::Correct);
              card.review(QualityRating::Correct);
              assert_eq!(card.state, CardState::Review);
              
              card.review(QualityRating::Incorrect); // Should move to Relearning
              assert_eq!(card.state, CardState::Relearning);
          }
          
          // ========== Edge Case Tests ==========
          
          #[test]
          fn test_extreme_ease_factor_with_perfect_reviews() {
              let mut card = new_test_card(1);
              
              // 50 perfect reviews
              for _ in 0..50 {
                  card.review(QualityRating::Perfect);
              }
              
              // Ease factor should grow but remain reasonable
              assert!(card.ease_factor > 2.5, "Perfect reviews should increase ease factor");
              assert!(card.ease_factor < 10.0, "Ease factor should not grow excessively");
          }
          
          #[test]
          fn test_long_interval_progression() {
              let mut card = new_test_card(1);
              card.ease_factor = 2.5;
              
              // Progress through many reviews
              for _ in 0..20 {
                  card.review(QualityRating::Correct);
              }
              
              assert!(card.interval > 100, "Long review sequence should produce long intervals");
              assert!(card.interval < 10000, "Intervals should remain practical");
          }
          
          #[test]
          fn test_is_due_functionality() {
              let mut card = new_test_card(1);
              let now = Utc::now();
              
              card.next_review = now - Duration::days(1); // Past due
              assert!(card.is_due(now), "Card with past review date should be due");
              
              card.next_review = now + Duration::days(1); // Future
              assert!(!card.is_due(now), "Card with future review date should not be due");
              
              card.next_review = now; // Exactly now
              assert!(card.is_due(now), "Card with current review date should be due");
          }
      }
      
      #[cfg(test)]
      mod review_queue_tests {
          use super::*;
          use crate::srs::{ReviewQueue, QueueConfig, SM2Card, CardState};
          
          /// Helper to create test queue with default config
          fn new_test_queue() -> ReviewQueue {
              let config = QueueConfig {
                  max_new_cards_per_day: 20,
                  max_reviews_per_day: 100,
              };
              ReviewQueue::new(config)
          }
          
          /// Helper to create card in specific state
          fn create_card_with_state(id: u32, state: CardState) -> SM2Card {
              let mut card = SM2Card::new(id);
              card.state = state;
              card
          }
          
          // ========== Queue Initialization Tests ==========
          
          #[test]
          fn test_queue_initialization() {
              let config = QueueConfig {
                  max_new_cards_per_day: 20,
                  max_reviews_per_day: 100,
              };
              let queue = ReviewQueue::new(config);
              
              assert!(queue.is_empty(), "New queue should be empty");
              let stats = queue.get_statistics();
              assert_eq!(stats.new_count, 0);
              assert_eq!(stats.learning_count, 0);
              assert_eq!(stats.review_count, 0);
          }
          
          // ========== Card Addition Tests ==========
          
          #[test]
          fn test_add_new_card() {
              let mut queue = new_test_queue();
              let card = create_card_with_state(1, CardState::New);
              
              queue.add_card(card);
              
              let stats = queue.get_statistics();
              assert_eq!(stats.new_count, 1, "Should have 1 new card");
          }
          
          #[test]
          fn test_add_learning_card() {
              let mut queue = new_test_queue();
              let card = create_card_with_state(1, CardState::Learning);
              
              queue.add_card(card);
              
              let stats = queue.get_statistics();
              assert_eq!(stats.learning_count, 1, "Should have 1 learning card");
          }
          
          #[test]
          fn test_add_review_card() {
              let mut queue = new_test_queue();
              let mut card = create_card_with_state(1, CardState::Review);
              card.next_review = Utc::now() - Duration::days(1); // Make it due
              
              queue.add_card(card);
              
              let stats = queue.get_statistics();
              assert_eq!(stats.review_count, 1, "Should have 1 review card");
          }
          
          // ========== Priority Order Tests ==========
          
          #[test]
          fn test_priority_learning_before_review() {
              let mut queue = new_test_queue();
              
              // Add review card first
              let mut review_card = create_card_with_state(1, CardState::Review);
              review_card.next_review = Utc::now() - Duration::days(1);
              queue.add_card(review_card);
              
              // Add learning card second
              let learning_card = create_card_with_state(2, CardState::Learning);
              queue.add_card(learning_card);
              
              // Learning card should come first
              let next = queue.get_next_card();
              assert!(next.is_some());
              assert_eq!(next.unwrap().card_id, 2, "Learning card should be prioritized");
          }
          
          #[test]
          fn test_priority_review_before_new() {
              let mut queue = new_test_queue();
              
              // Add new card first
              let new_card = create_card_with_state(1, CardState::New);
              queue.add_card(new_card);
              
              // Add due review card
              let mut review_card = create_card_with_state(2, CardState::Review);
              review_card.next_review = Utc::now() - Duration::days(1);
              queue.add_card(review_card);
              
              // Review card should come first
              let next = queue.get_next_card();
              assert!(next.is_some());
              assert_eq!(next.unwrap().card_id, 2, "Review card should be prioritized over new");
          }
          
          #[test]
          fn test_complete_priority_order() {
              let mut queue = new_test_queue();
              
              // Add cards in mixed order
              let new_card = create_card_with_state(1, CardState::New);
              queue.add_card(new_card);
              
              let mut review_card = create_card_with_state(2, CardState::Review);
              review_card.next_review = Utc::now() - Duration::days(1);
              queue.add_card(review_card);
              
              let learning_card = create_card_with_state(3, CardState::Learning);
              queue.add_card(learning_card);
              
              // Should return in priority order: learning, review, new
              assert_eq!(queue.get_next_card().unwrap().card_id, 3, "First should be learning");
              assert_eq!(queue.get_next_card().unwrap().card_id, 2, "Second should be review");
              assert_eq!(queue.get_next_card().unwrap().card_id, 1, "Third should be new");
          }
          
          // ========== Daily Limit Tests ==========
          
          #[test]
          fn test_daily_new_card_limit() {
              let config = QueueConfig {
                  max_new_cards_per_day: 2,
                  max_reviews_per_day: 100,
              };
              let mut queue = ReviewQueue::new(config);
              
              // Add 3 new cards
              for i in 1..=3 {
                  queue.add_card(create_card_with_state(i, CardState::New));
              }
              
              // Should only get 2 cards (daily limit)
              assert!(queue.get_next_card().is_some(), "Should get first new card");
              assert!(queue.get_next_card().is_some(), "Should get second new card");
              assert!(queue.get_next_card().is_none(), "Should hit daily new card limit");
          }
          
          #[test]
          fn test_daily_review_limit() {
              let config = QueueConfig {
                  max_new_cards_per_day: 100,
                  max_reviews_per_day: 2,
              };
              let mut queue = ReviewQueue::new(config);
              
              // Add 3 review cards
              for i in 1..=3 {
                  let mut card = create_card_with_state(i, CardState::Review);
                  card.next_review = Utc::now() - Duration::days(1);
                  queue.add_card(card);
              }
              
              assert!(queue.get_next_card().is_some(), "Should get first review");
              assert!(queue.get_next_card().is_some(), "Should get second review");
              assert!(queue.get_next_card().is_none(), "Should hit daily review limit");
          }
          
          #[test]
          fn test_learning_cards_ignore_limits() {
              let config = QueueConfig {
                  max_new_cards_per_day: 0,
                  max_reviews_per_day: 0,
              };
              let mut queue = ReviewQueue::new(config);
              
              // Add learning card with limits set to 0
              queue.add_card(create_card_with_state(1, CardState::Learning));
              
              // Should still get learning card despite limits
              assert!(queue.get_next_card().is_some(), "Learning cards should bypass daily limits");
          }
          
          // ========== Queue Management Tests ==========
          
          #[test]
          fn test_empty_queue_returns_none() {
              let queue = new_test_queue();
              assert!(queue.get_next_card().is_none(), "Empty queue should return None");
          }
          
          #[test]
          fn test_return_card_to_queue() {
              let mut queue = new_test_queue();
              let mut card = create_card_with_state(1, CardState::Learning);
              
              queue.add_card(card.clone());
              let retrieved = queue.get_next_card().unwrap();
              
              // Review the card and return it
              retrieved.review(QualityRating::Correct);
              queue.return_card(retrieved);
              
              // Should be back in appropriate queue based on new state
              let stats = queue.get_statistics();
              assert!(stats.learning_count > 0 || stats.review_count > 0, "Card should be re-queued");
          }
          
          #[test]
          fn test_reset_daily_limits() {
              let mut queue = new_test_queue();
              
              // Exhaust daily limit
              for i in 1..=20 {
                  queue.add_card(create_card_with_state(i, CardState::New));
              }
              for _ in 0..20 {
                  queue.get_next_card();
              }
              
              // Add another card - should be blocked
              queue.add_card(create_card_with_state(21, CardState::New));
              assert!(queue.get_next_card().is_none(), "Should be at limit");
              
              // Reset limits
              queue.reset_daily_limits();
              
              // Should be able to get card now
              assert!(queue.get_next_card().is_some(), "Should work after reset");
          }
          
          #[test]
          fn test_update_due_cards() {
              let mut queue = new_test_queue();
              
              // Add card that will be due tomorrow
              let mut future_card = create_card_with_state(1, CardState::Review);
              future_card.next_review = Utc::now() + Duration::days(1);
              queue.add_card(future_card);
              
              let stats_before = queue.get_statistics();
              assert_eq!(stats_before.review_count, 0, "Future card should not be in review queue");
              
              // Simulate time passing
              let tomorrow = Utc::now() + Duration::days(1);
              queue.update_due_cards(tomorrow);
              
              let stats_after = queue.get_statistics();
              assert_eq!(stats_after.review_count, 1, "Card should now be due for review");
          }
          
          // ========== Statistics Tests ==========
          
          #[test]
          fn test_queue_statistics_accuracy() {
              let mut queue = new_test_queue();
              
              queue.add_card(create_card_with_state(1, CardState::New));
              queue.add_card(create_card_with_state(2, CardState::New));
              queue.add_card(create_card_with_state(3, CardState::Learning));
              
              let mut review = create_card_with_state(4, CardState::Review);
              review.next_review = Utc::now() - Duration::days(1);
              queue.add_card(review);
              
              let stats = queue.get_statistics();
              assert_eq!(stats.new_count, 2);
              assert_eq!(stats.learning_count, 1);
              assert_eq!(stats.review_count, 1);
              assert_eq!(stats.total_cards, 4);
          }
      }
      
      #[cfg(test)]
      mod sm2_property_tests {
          use super::*;
          use proptest::prelude::*;
          use crate::srs::{SM2Card, QualityRating};
          
          /// Property: Ease factor never falls below 1.3
          proptest! {
              #[test]
              fn prop_ease_factor_floor(quality in 0u8..=5) {
                  let mut card = SM2Card::new(1);
                  
                  // Apply review 100 times with same quality
                  for _ in 0..100 {
                      card.review(match quality {
                          0 => QualityRating::Blackout,
                          1 => QualityRating::Barely,
                          2 => QualityRating::Incorrect,
                          3 => QualityRating::Difficult,
                          4 => QualityRating::Correct,
                          5 => QualityRating::Perfect,
                          _ => unreachable!(),
                      });
                      
                      prop_assert!(card.ease_factor >= 1.3,
                          "Ease factor {} fell below 1.3 floor", card.ease_factor);
                  }
              }
          }
          
          /// Property: Intervals increase monotonically for successful reviews (quality >= 3)
          proptest! {
              #[test]
              fn prop_interval_monotonicity(quality in 3u8..=5, iterations in 5usize..20) {
                  let mut card = SM2Card::new(1);
                  let mut previous_interval = 0;
                  
                  for _ in 0..iterations {
                      card.review(match quality {
                          3 => QualityRating::Difficult,
                          4 => QualityRating::Correct,
                          5 => QualityRating::Perfect,
                          _ => unreachable!(),
                      });
                      
                      prop_assert!(card.interval >= previous_interval,
                          "Interval decreased from {} to {} with quality {}",
                          previous_interval, card.interval, quality);
                      previous_interval = card.interval;
                  }
              }
          }
          
          /// Property: Failed cards (quality < 3) always reset
          proptest! {
              #[test]
              fn prop_failed_review_reset(quality in 0u8..3) {
                  let mut card = SM2Card::new(1);
                  
                  // Build up the card first
                  for _ in 0..5 {
                      card.review(QualityRating::Correct);
                  }
                  
                  // Now fail it
                  card.review(match quality {
                      0 => QualityRating::Blackout,
                      1 => QualityRating::Barely,
                      2 => QualityRating::Incorrect,
                      _ => unreachable!(),
                  });
                  
                  prop_assert_eq!(card.interval, 1, "Failed card should reset interval to 1");
                  prop_assert_eq!(card.repetitions, 0, "Failed card should reset repetitions to 0");
              }
          }
          
          /// Property: Next review date is always in the future
          proptest! {
              #[test]
              fn prop_next_review_in_future(quality in 0u8..=5) {
                  let mut card = SM2Card::new(1);
                  let now = Utc::now();
                  
                  card.review(match quality {
                      0 => QualityRating::Blackout,
                      1 => QualityRating::Barely,
                      2 => QualityRating::Incorrect,
                      3 => QualityRating::Difficult,
                      4 => QualityRating::Correct,
                      5 => QualityRating::Perfect,
                      _ => unreachable!(),
                  });
                  
                  prop_assert!(card.next_review > now,
                      "Next review date must be in future after quality {} review", quality);
              }
          }
          
          /// Property: Ease factor changes directionally based on quality
          proptest! {
              #[test]
              fn prop_ease_factor_directional(quality in 0u8..=5) {
                  let mut card = SM2Card::new(1);
                  card.ease_factor = 2.5;
                  let ef_before = card.ease_factor;
                  
                  card.review(match quality {
                      0 => QualityRating::Blackout,
                      1 => QualityRating::Barely,
                      2 => QualityRating::Incorrect,
                      3 => QualityRating::Difficult,
                      4 => QualityRating::Correct,
                      5 => QualityRating::Perfect,
                      _ => unreachable!(),
                  });
                  
                  match quality {
                      5 => prop_assert!(card.ease_factor > ef_before, "Quality 5 should increase EF"),
                      4 => prop_assert_eq!(card.ease_factor, ef_before, "Quality 4 should maintain EF"),
                      _ => prop_assert!(card.ease_factor <= ef_before, "Quality < 4 should decrease EF"),
                  }
              }
          }
      }

  coverage:
    - "SM2Card initialization with correct default values (ease=2.5, interval=0, reps=0, state=New)"
    - "Review with quality rating 5 (Perfect) increases ease factor by 0.1"
    - "Review with quality rating 4 (Correct) maintains ease factor at initial value"
    - "Review with quality rating 3 (Difficult) decreases ease factor appropriately"
    - "Review with quality rating 2 (Incorrect) resets card to learning state"
    - "Review with quality rating 1 (Barely) resets card with ease factor adjustment"
    - "Review with quality rating 0 (Blackout) resets card completely"
    - "Ease factor floor of 1.3 is maintained across all operations"
    - "Ease factor never becomes negative even after 100+ poor reviews"
    - "First interval is always exactly 1 day"
    - "Second interval is always exactly 6 days"
    - "Subsequent intervals calculated correctly using ease factor formula"
    - "Interval progression with perfect reviews produces expected sequence"
    - "Interval monotonicity holds for consecutive successful reviews"
    - "Failed cards reset interval to 1 and repetitions to 0"
    - "Failed cards preserve ease factor adjustments while resetting progress"
    - "Multiple failures continue adjusting ease factor down to floor"
    - "Next review date is always in the future after any review operation"
    - "Next review date calculation matches interval specification"
    - "State transitions: New → Learning on first successful review"
    - "State transitions: Learning → Review after second successful review"
    - "State transitions: Review → Relearning on failed review"
    - "Extreme ease factor remains reasonable after 50 perfect reviews"
    - "Long interval progression produces practical intervals"
    - "is_due() correctly identifies past due cards"
    - "is_due() correctly identifies future cards as not due"
    - "is_due() handles cards due exactly at current time"
    - "ReviewQueue initialization with empty queues and correct config"
    - "Adding new cards to queue increments new_count"
    - "Adding learning cards to queue increments learning_count"
    - "Adding due review cards to queue increments review_count"
    - "Queue prioritizes learning cards before review cards"
    - "Queue prioritizes review cards before new cards"
    - "Complete priority order: learning > review > new"
    - "Daily new card limit enforcement prevents overflow"
    - "Daily review limit enforcement prevents overflow"
    - "Learning cards bypass daily limits"
    - "Empty queue returns None when get_next_card() called"
    - "return_card() places reviewed card in correct queue based on new state"
    - "reset_daily_limits() allows fetching cards after limit reached"
    - "update_due_cards() moves future cards to review queue when they become due"
    - "Queue statistics accurately reflect card counts in each queue"
    - "Property: Ease factor floor maintained for all quality ratings across 100 reviews"
    - "Property: Intervals increase monotonically for successful reviews (quality >= 3)"
    - "Property: Failed cards (quality < 3) always reset to interval=1, repetitions=0"
    - "Property: Next review date invariant holds for all quality ratings"
    - "Property: Ease factor changes directionally correct based on quality (5 increases, 4 maintains, <4 decreases)"

dependencies:
  depends_on:
    - task_id: 2
      reason: "Needs character database to create flashcards for the spaced repetition system"

  depended_upon_by:
    - task_id: 8
      reason: "Learning session orchestrator uses SM-2 algorithm and ReviewQueue for scheduling and managing review sessions"

  external:
    - name: "chrono::DateTime"
      type: "struct"
      status: "to be imported"
    - name: "chrono::Duration"
      type: "struct"
      status: "to be imported"
    - name: "chrono::Utc"
      type: "module"
      status: "to be imported"
    - name: "proptest::prelude::*"
      type: "module"
      status: "to be imported"
---
task:
  id: 8
  name: "Learning Session and Practice Modes"

context:
  description: |
    Task 8 implements the core learning workflow where users interact with flashcards
    and practice character writing through progressive difficulty levels. This task
    represents the convergence of all previous systems (SM-2 scheduling, stroke animation,
    handwriting recognition, review queues) into cohesive, polished learning experiences.

    The learning session workflow manages the review cycle: presenting cards from the
    review queue, collecting quality ratings (0-5 SM-2 scale), updating card state via
    SM2Card::review(), tracking session statistics, and persisting progress with batched
    database saves. The state machine handles card progression, visual feedback, and
    session completion.

    The practice mode implements four progressive difficulty stages: (1) WatchAnimation
    for passive observation of stroke order, (2) TraceWithGuide with semi-transparent
    overlay assistance, (3) TraceWithoutGuide testing memory retention, and (4) FreeDrawing
    from complete recall. The practice session advances through stages only upon successful
    handwriting recognition, creating optimal learning conditions.

    Both systems prioritize user experience with immediate visual feedback (green check/
    red X), progress indicators, keyboard shortcuts (1-5 for quality ratings, space for
    next card), hint systems for stuck users, and comprehensive session summaries showing
    accuracy, timing, and performance metrics.

    Architectural significance: This task bridges domain logic (SM-2 algorithm, character
    data, stroke animation) with user interaction (UI views, event handling, state
    management), requiring careful orchestration of multiple subsystems while maintaining
    responsive, polished UX. Session state management must handle interruption/resume
    gracefully and ensure data persistence reliability.

  key_points:
    - "LearningSession state machine orchestrates review queue progression, quality rating collection, SM-2 updates, and batched database saves"
    - "PracticeSession implements 4-stage progressive difficulty with unidirectional mode advancement contingent on recognition success"
    - "Session statistics track cards reviewed, accuracy rates, time per card, quality distribution, and session duration with real-time updates"
    - "Batched database saves (every 5-10 cards) optimize performance while ensuring progress persistence and interruption/resume capability"
    - "Visual feedback systems provide immediate user response (green check/red X) with keyboard shortcuts for efficient review flow"
    - "Integration complexity is high: coordinates ReviewQueue, SM2Card, StrokeOrderAnimation, HandwritingCanvas, CharacterCard, and persistence layer"
    - "Practice mode progression requires successful handwriting recognition to advance, with hint system and skip options for stuck users"
    - "Session summary screens provide comprehensive performance analytics with accuracy, timing, quality distribution charts, and motivational messaging"

files:
  - path: "src/session/mod.rs"
    description: "Module declaration exposing LearningSession, PracticeSession, PracticeMode, and SessionStatistics types"
  - path: "src/session/learning_session.rs"
    description: "Core learning session state machine managing review queue progression, card presentation, quality rating collection, and SM-2 state updates"
  - path: "src/session/practice_session.rs"
    description: "Practice mode state machine managing progression through four difficulty levels with stroke animation and recognition validation"
  - path: "src/session/practice_mode.rs"
    description: "Enum defining four practice stages: WatchAnimation, TraceWithGuide, TraceWithoutGuide, FreeDrawing with associated transition logic"
  - path: "src/session/session_statistics.rs"
    description: "Session statistics tracking including cards reviewed, accuracy rates, time per card, and success metrics"
  - path: "src/ui/views/mod.rs"
    description: "Module declaration for session-related UI views"
  - path: "src/ui/views/learning_session_view.rs"
    description: "UI view for learning session displaying flashcards, quality rating buttons (0-5), progress bar, and visual feedback"
  - path: "src/ui/views/practice_session_view.rs"
    description: "UI view for practice mode showing stroke animation, drawing canvas, tracing guides, and mode-specific controls"
  - path: "src/ui/views/session_summary_view.rs"
    description: "Session summary screen displaying statistics, accuracy, total time, cards reviewed, and performance breakdown"
  - path: "src/ui/components/mod.rs"
    description: "Module declaration for session-specific UI components (quality_rating_buttons, session_progress_bar, practice_guide_overlay)"
  - path: "src/ui/components/quality_rating_buttons.rs"
    description: "Quality rating button component (0-5) with keyboard shortcuts and visual states"
  - path: "src/ui/components/session_progress_bar.rs"
    description: "Progress bar component showing cards remaining, current position, and session completion percentage"
  - path: "src/ui/components/practice_guide_overlay.rs"
    description: "Ghost overlay component for tracing modes displaying semi-transparent stroke guides"
  - path: "src/ui/mod.rs"
    description: "UI module root updated to declare views and components submodules"
  - path: "tests/integration/learning_session_test.rs"
    description: "Integration tests for learning session workflow including queue progression, rating collection, and state persistence"
  - path: "tests/integration/practice_session_test.rs"
    description: "Integration tests for practice mode progression, recognition validation, and difficulty advancement"
  - path: "tests/unit/session_statistics_test.rs"
    description: "Unit tests for session statistics calculations and tracking accuracy"

functions:
  - file: "src/session/mod.rs"
    items:
      - type: "module_declaration"
        name: "learning_session"
        description: "Module containing learning session workflow implementation with review queue progression"
      - type: "module_declaration"
        name: "practice_session"
        description: "Module containing practice mode implementation with four-stage progressive difficulty"
      - type: "module_declaration"
        name: "session_statistics"
        description: "Module containing session statistics tracking for progress and accuracy metrics"

  - file: "src/session/learning_session.rs"
    items:
      - type: "struct"
        name: "LearningSession"
        description: "State machine managing review queue progression, flashcard display, quality rating collection, and SM-2 state updates"
        invariants: "current_index <= cards.len(); cards are always from valid review queue; state transitions follow defined state machine"
      - type: "enum"
        name: "SessionState"
        description: "Represents the current state of a learning session in the state machine"
      - type: "enum_variant"
        name: "SessionState::ShowingCard"
        description: "Currently displaying a flashcard to the user, awaiting user action"
      - type: "enum_variant"
        name: "SessionState::AwaitingRating"
        description: "Waiting for user to provide quality rating (0-5) for current card"
      - type: "enum_variant"
        name: "SessionState::ShowingFeedback"
        description: "Displaying visual feedback (green check/red X) after rating submission"
      - type: "enum_variant"
        name: "SessionState::Complete"
        description: "Session has finished all cards in the queue"
      - type: "struct"
        name: "SessionConfig"
        description: "Configuration parameters for a learning session including batch save size and timing"
      - type: "method"
        name: "LearningSession::new"
        description: "Creates a new learning session from a review queue of cards"
        preconditions: "review_queue must contain at least one card; cards must have valid SM2Card state"
        postconditions: "Returns initialized session in ShowingCard state with current_index=0; statistics initialized to zero"
      - type: "method"
        name: "LearningSession::current_card"
        description: "Returns reference to the currently displayed card if session is active"
        preconditions: "Session is not in Complete state"
        postconditions: "Returns Some(&CharacterCard) if cards remain, None otherwise"
      - type: "method"
        name: "LearningSession::submit_rating"
        description: "Submits quality rating for current card, updates SM-2 state via SM2Card::review(), and advances to next card"
        preconditions: "Session is in AwaitingRating state; quality value is 0-5; current_index < cards.len()"
        postconditions: "Card SM-2 state updated; statistics recorded; state transitions to ShowingCard or Complete; triggers batch save if threshold reached"
      - type: "method"
        name: "LearningSession::next_card"
        description: "Advances to the next card in the queue after current card has been rated"
        preconditions: "Current card has been rated and processed"
        postconditions: "current_index incremented; state transitions to ShowingCard if cards remain, Complete otherwise"
      - type: "method"
        name: "LearningSession::skip_card"
        description: "Skips the current card and moves it to the end of the review queue"
        preconditions: "Session is active and showing a card"
        postconditions: "Current card moved to end of queue; next card becomes current; total cards unchanged"
      - type: "method"
        name: "LearningSession::progress"
        description: "Returns current progress as (completed, total) tuple"
        postconditions: "Returns (cards_reviewed, total_cards) where cards_reviewed <= total_cards"
      - type: "method"
        name: "LearningSession::is_complete"
        description: "Returns true if all cards in the queue have been reviewed"
        postconditions: "Returns true iff current_index >= cards.len()"
      - type: "method"
        name: "LearningSession::save_progress"
        description: "Persists session progress to database by saving all reviewed cards with updated SM-2 state"
        preconditions: "Database connection is valid"
        postconditions: "All reviewed cards saved with updated SM-2 state; last_save_index updated to current_index"
      - type: "method"
        name: "LearningSession::total_cards"
        description: "Returns total number of cards in this session"
        postconditions: "Returns usize count of all cards in session queue"
      - type: "method"
        name: "LearningSession::cards_remaining"
        description: "Returns number of cards not yet reviewed"
        postconditions: "Returns total_cards - cards_reviewed"
      - type: "method"
        name: "LearningSession::current_index"
        description: "Returns the current card index in the queue"
        postconditions: "Returns current position (0-based index) in card queue"
      - type: "method"
        name: "LearningSession::state"
        description: "Returns reference to current session state"
        postconditions: "Returns &SessionState representing current state machine state"
      - type: "method"
        name: "LearningSession::statistics"
        description: "Returns reference to session statistics tracker"
        postconditions: "Returns &SessionStatistics with current session metrics"
      - type: "method"
        name: "LearningSession::pause"
        description: "Pauses the session and saves current state for later resumption"
        preconditions: "Session is active (not Complete)"
        postconditions: "State set to Paused; progress saved to database"
      - type: "method"
        name: "LearningSession::resume"
        description: "Resumes a paused session from saved state"
        preconditions: "Session is in Paused state"
        postconditions: "State restored to ShowingCard; current card displayed"
      - type: "method"
        name: "LearningSession::save_state"
        description: "Serializes current session state for persistence"
        postconditions: "Returns SessionSaveState with current index, reviewed cards, and statistics"
      - type: "method"
        name: "LearningSession::from_saved_state"
        description: "Restores a session from previously saved state"
        preconditions: "saved_state contains valid session data with valid card references"
        postconditions: "Returns restored LearningSession at saved progress point"
      - type: "method"
        name: "LearningSession::progress_percentage"
        description: "Calculates session completion percentage"
        postconditions: "Returns f32 between 0.0 and 100.0 representing (cards_reviewed / total_cards) * 100"
      - type: "method"
        name: "LearningSession::set_save_batch_size"
        description: "Configures the batch save interval (default: every 5-10 cards)"
        preconditions: "batch_size > 0"
        postconditions: "Save batch size updated; saves will trigger at multiples of this size"
      - type: "method"
        name: "LearningSession::generate_summary"
        description: "Generates session summary data for summary screen display"
        preconditions: "Session is complete"
        postconditions: "Returns SessionSummary with complete statistics, accuracy, timing, and quality distribution"
      - type: "function"
        name: "should_batch_save"
        description: "Determines if progress should be saved based on cards reviewed count and batch size"
        preconditions: "cards_reviewed >= 0; batch_size > 0"
        postconditions: "Returns true if cards_reviewed is multiple of batch_size"

  - file: "src/session/practice_session.rs"
    items:
      - type: "struct"
        name: "PracticeSession"
        description: "State machine managing practice mode progression through four difficulty levels with handwriting validation"
        invariants: "mode progression is unidirectional (WatchAnimation → TraceWithGuide → TraceWithoutGuide → FreeDrawing); character remains constant within session"
      - type: "enum"
        name: "PracticeMode"
        description: "Four progressive difficulty stages for practicing character writing"
      - type: "enum_variant"
        name: "PracticeMode::WatchAnimation"
        description: "Stage 1: Passive observation of stroke order animation to learn proper stroke sequence"
      - type: "enum_variant"
        name: "PracticeMode::TraceWithGuide"
        description: "Stage 2: User traces character with visible ghost overlay guide for assistance"
      - type: "enum_variant"
        name: "PracticeMode::TraceWithoutGuide"
        description: "Stage 3: User traces character without visual guide, testing memory retention"
      - type: "enum_variant"
        name: "PracticeMode::FreeDrawing"
        description: "Stage 4: User draws character from memory without any guidance or reference"
      - type: "enum"
        name: "PracticeResult"
        description: "Result of a practice attempt including recognition validation outcome"
      - type: "enum_variant"
        name: "PracticeResult::Success"
        description: "Drawing successfully recognized, allows mode progression"
        postconditions: "Contains recognition score >= threshold"
      - type: "enum_variant"
        name: "PracticeResult::Failed"
        description: "Drawing not recognized, user must retry current mode"
        postconditions: "Contains recognition score < threshold and feedback message"
      - type: "struct"
        name: "PracticeConfig"
        description: "Configuration for practice session including recognition thresholds for each mode"
      - type: "method"
        name: "PracticeSession::new"
        description: "Creates a new practice session for a specific character"
        preconditions: "character must have valid stroke order data"
        postconditions: "Session starts in WatchAnimation mode; animation initialized; statistics reset to zero"
      - type: "method"
        name: "PracticeSession::current_mode"
        description: "Returns reference to the current practice mode"
        postconditions: "Returns &PracticeMode representing current difficulty stage"
      - type: "method"
        name: "PracticeSession::submit_drawing"
        description: "Submits user drawing for validation against target character using handwriting recognition"
        preconditions: "Mode is TraceWithGuide, TraceWithoutGuide, or FreeDrawing; drawing contains valid normalized stroke data"
        postconditions: "Returns PracticeResult with recognition score; advances mode on success (score >= threshold); records attempt in statistics"
      - type: "method"
        name: "PracticeSession::advance_mode"
        description: "Progresses to the next difficulty level after successful validation"
        preconditions: "Recognition validation passed for current mode; mode is not FreeDrawing"
        postconditions: "mode advances to next stage (WatchAnimation→TraceWithGuide→TraceWithoutGuide→FreeDrawing); canvas cleared"
      - type: "method"
        name: "PracticeSession::skip_animation"
        description: "Allows user to skip the watch animation phase and proceed to tracing"
        preconditions: "Current mode is WatchAnimation"
        postconditions: "Mode advances to TraceWithGuide; animation stopped"
      - type: "method"
        name: "PracticeSession::request_hint"
        description: "Provides hint by showing one stroke of the character temporarily"
        preconditions: "Mode is not WatchAnimation; hints_used < max_hints"
        postconditions: "Returns Some(HintData) with stroke to display; hints_used incremented; None if max hints reached"
      - type: "method"
        name: "PracticeSession::reset_mode"
        description: "Resets the current practice mode for another attempt without changing difficulty level"
        postconditions: "Canvas cleared; attempt count reset for current mode"
      - type: "method"
        name: "PracticeSession::is_complete"
        description: "Returns true if all practice modes completed successfully"
        postconditions: "Returns true iff FreeDrawing mode completed with successful recognition"
      - type: "method"
        name: "PracticeSession::get_guide_overlay"
        description: "Returns the ghost overlay path for tracing modes if applicable"
        preconditions: "Mode is TraceWithGuide"
        postconditions: "Returns Some(Path) with character outline; None for other modes"
      - type: "method"
        name: "PracticeSession::statistics"
        description: "Returns reference to practice session statistics"
        postconditions: "Returns &PracticeStatistics with attempt counts and accuracy"
      - type: "function"
        name: "validate_drawing"
        description: "Validates user drawing against target character using handwriting recognition with mode-specific threshold"
        preconditions: "drawing contains valid stroke data with normalized coordinates; target_character has valid stroke order data"
        postconditions: "Returns recognition score between 0.0 and 1.0; score >= threshold indicates success"

  - file: "src/session/session_statistics.rs"
    items:
      - type: "struct"
        name: "SessionStatistics"
        description: "Tracks comprehensive statistics for a learning session including timing, accuracy, and quality distribution"
        invariants: "cards_reviewed <= total_cards; all durations are non-negative; quality_ratings sum equals cards_reviewed"
      - type: "struct"
        name: "CardReviewRecord"
        description: "Records details of a single card review including timing, quality rating, and card ID"
      - type: "struct"
        name: "PracticeStatistics"
        description: "Tracks statistics for practice session including attempts, successes, and mode progression"
        invariants: "total_attempts >= successful_attempts; successful_attempts >= 0"
      - type: "struct"
        name: "SessionSummary"
        description: "Summary data for session completion screen with all key metrics"
      - type: "method"
        name: "SessionStatistics::new"
        description: "Initializes empty session statistics tracker"
        preconditions: "total_cards > 0"
        postconditions: "All counters initialized to zero; start_time set to current SystemTime; quality_ratings map initialized empty"
      - type: "method"
        name: "SessionStatistics::record_review"
        description: "Records a card review with quality rating and time spent"
        preconditions: "quality is 0-5 (valid Quality enum variant); duration is positive Duration"
        postconditions: "cards_reviewed incremented; quality_ratings updated; review_records appended; cumulative_time updated"
      - type: "method"
        name: "SessionStatistics::average_time_per_card"
        description: "Calculates average time spent per card in seconds"
        preconditions: "cards_reviewed > 0"
        postconditions: "Returns f64 representing cumulative_time / cards_reviewed in seconds"
      - type: "method"
        name: "SessionStatistics::accuracy_rate"
        description: "Calculates percentage of cards rated as correct (quality >= 4 for Good, Easy, Perfect)"
        preconditions: "cards_reviewed > 0"
        postconditions: "Returns f64 between 0.0 and 100.0 representing percentage of high-quality ratings"
      - type: "method"
        name: "SessionStatistics::session_duration"
        description: "Returns total session duration from start to current time"
        postconditions: "Returns Duration representing elapsed time since session start"
      - type: "method"
        name: "SessionStatistics::complete"
        description: "Marks session as complete and finalizes timing"
        postconditions: "end_time set to current SystemTime; is_complete = true; total duration frozen"
      - type: "method"
        name: "PracticeStatistics::new"
        description: "Initializes empty practice statistics tracker"
        postconditions: "All counters set to zero; attempt_records initialized empty"
      - type: "method"
        name: "PracticeStatistics::record_attempt"
        description: "Records a practice attempt with success/failure and recognition score"
        preconditions: "recognition_score between 0.0 and 1.0"
        postconditions: "total_attempts incremented; successful_attempts incremented if success; attempt_records appended"
      - type: "method"
        name: "PracticeStatistics::accuracy_percentage"
        description: "Calculates practice accuracy as percentage of successful attempts"
        preconditions: "total_attempts > 0"
        postconditions: "Returns f64 between 0.0 and 100.0 representing (successful_attempts / total_attempts) * 100"
      - type: "function"
        name: "calculate_accuracy"
        description: "Helper function to calculate accuracy percentage from success/total counts"
        preconditions: "total > 0"
        postconditions: "Returns f64 percentage between 0.0 and 100.0"
      - type: "function"
        name: "format_session_time"
        description: "Formats session duration as human-readable string (e.g., '5m 32s')"
        preconditions: "duration is valid Duration"
        postconditions: "Returns String with formatted time (hours, minutes, seconds as appropriate)"

  - file: "src/ui/views/learning_session_view.rs"
    items:
      - type: "struct"
        name: "LearningSessionView"
        description: "Main UI component for learning session display with flashcard, progress bar, and rating controls"
      - type: "method"
        name: "LearningSessionView::new"
        description: "Creates a new learning session view widget"
        postconditions: "Returns initialized view component ready for rendering"
      - type: "method"
        name: "LearningSessionView::build"
        description: "Builds complete session view UI with flashcard, progress bar, and controls"
        preconditions: "session state is valid"
        postconditions: "Returns Element tree with all session UI components arranged vertically"
      - type: "function"
        name: "render_flashcard"
        description: "Renders current flashcard with character display and metadata (readings, meaning)"
        preconditions: "card is valid CharacterCard"
        postconditions: "Returns Element with character prominently displayed, readings, and meaning visible"
      - type: "function"
        name: "render_quality_buttons"
        description: "Renders quality rating buttons (0-5) with keyboard shortcuts displayed on each button"
        postconditions: "Returns Element with 6 buttons (Again, Hard, Good, Easy, Perfect, Complete Fail) with keyboard hints (1-5)"
      - type: "function"
        name: "render_progress_bar"
        description: "Renders progress bar showing cards completed vs total with percentage"
        preconditions: "session has valid progress data"
        postconditions: "Returns Element with visual progress bar and 'X of Y cards' label"
      - type: "function"
        name: "render_feedback_overlay"
        description: "Renders visual feedback overlay (green check for correct, red X for incorrect) after rating"
        preconditions: "feedback_type is Some(FeedbackType)"
        postconditions: "Returns Element with animated feedback icon overlaying card; auto-dismisses after 800ms"
      - type: "function"
        name: "handle_quality_rating"
        description: "Handles quality button clicks and keyboard shortcuts (1-5 keys, space for next)"
        preconditions: "quality value is 0-5; session is awaiting rating"
        postconditions: "Emits SessionMessage::SubmitRating event; triggers visual feedback"
      - type: "function"
        name: "handle_skip"
        description: "Handles skip button click to defer current card to end of queue"
        postconditions: "Emits SessionMessage::SkipCard event"

  - file: "src/ui/views/practice_session_view.rs"
    items:
      - type: "struct"
        name: "PracticeSessionView"
        description: "UI component for practice mode with animation player, drawing canvas, and mode-specific controls"
      - type: "method"
        name: "PracticeSessionView::new"
        description: "Creates a new practice session view widget"
        postconditions: "Returns initialized view component with canvas and animation player"
      - type: "method"
        name: "PracticeSessionView::build"
        description: "Builds practice view UI based on current practice mode"
        preconditions: "session state is valid; current_mode is valid PracticeMode"
        postconditions: "Returns Element tree with mode-appropriate UI (animation player, canvas with/without guide, controls)"
      - type: "function"
        name: "render_animation_view"
        description: "Renders stroke animation player for WatchAnimation mode with playback controls"
        preconditions: "session is in WatchAnimation mode; animation data is loaded"
        postconditions: "Returns Element with animation canvas, play/pause button, skip button"
      - type: "function"
        name: "render_trace_view"
        description: "Renders drawing canvas with optional ghost guide overlay for tracing modes"
        preconditions: "session is in TraceWithGuide or TraceWithoutGuide mode"
        postconditions: "Returns Element with handwriting canvas, guide overlay (if TraceWithGuide), submit/clear buttons"
      - type: "function"
        name: "render_free_draw_view"
        description: "Renders drawing canvas without guides for FreeDrawing mode"
        preconditions: "session is in FreeDrawing mode"
        postconditions: "Returns Element with blank handwriting canvas and submit/clear/hint buttons"
      - type: "function"
        name: "render_practice_controls"
        description: "Renders control buttons (submit, clear, hint, skip) based on current mode"
        preconditions: "current mode determines available controls"
        postconditions: "Returns Element with horizontally arranged control buttons; disabled states handled appropriately"
      - type: "function"
        name: "render_mode_indicator"
        description: "Renders indicator showing current practice mode and progress through stages (1/4, 2/4, etc.)"
        postconditions: "Returns Element with mode name and stage progress (e.g., 'Trace With Guide - Stage 2/4')"
      - type: "function"
        name: "handle_drawing_submission"
        description: "Handles submit button to validate drawing and display recognition results"
        preconditions: "canvas has stroke data; mode allows submission"
        postconditions: "Emits PracticeMessage::SubmitDrawing with stroke data; displays recognition feedback"
      - type: "function"
        name: "handle_canvas_clear"
        description: "Handles clear button to reset drawing canvas"
        postconditions: "Emits CanvasMessage::Clear; canvas resets to blank state"
      - type: "function"
        name: "handle_hint_request"
        description: "Handles hint button to show one stroke of character temporarily"
        preconditions: "hints_used < max_hints"
        postconditions: "Emits PracticeMessage::RequestHint; displays hint stroke for 3 seconds"
      - type: "function"
        name: "show_recognition_feedback"
        description: "Displays recognition result with score percentage and success/failure indication"
        preconditions: "recognition_result contains valid score"
        postconditions: "Returns Element with score bar, success/failure message, and next action button"

  - file: "src/ui/views/session_summary_view.rs"
    items:
      - type: "struct"
        name: "SessionSummaryView"
        description: "Summary screen displayed after session completion showing statistics and performance metrics"
      - type: "method"
        name: "SessionSummaryView::new"
        description: "Creates session summary view from completed session statistics"
        preconditions: "statistics is from completed session"
        postconditions: "Returns initialized summary view with all metrics calculated"
      - type: "method"
        name: "SessionSummaryView::build"
        description: "Builds summary view with statistics cards, performance message, and action buttons"
        postconditions: "Returns Element with vertically stacked summary sections and navigation buttons"
      - type: "function"
        name: "render_summary_stats"
        description: "Renders key statistics grid: cards reviewed, accuracy, average time per card, total session duration"
        preconditions: "statistics contains valid data"
        postconditions: "Returns Element with 2x2 grid of statistic cards with icons and values"
      - type: "function"
        name: "render_completion_message"
        description: "Renders congratulatory message based on performance (excellent: >90%, good: >75%, needs practice: <75%)"
        preconditions: "accuracy_rate is calculated"
        postconditions: "Returns Element with appropriate message and emoji/icon based on performance tier"
      - type: "function"
        name: "render_action_buttons"
        description: "Renders buttons for next actions (Start New Session, Return to Menu, Review Mistakes)"
        postconditions: "Returns Element with horizontally arranged action buttons"
      - type: "function"
        name: "render_quality_distribution_chart"
        description: "Renders bar chart or pie chart showing distribution of quality ratings"
        preconditions: "quality_ratings map contains data"
        postconditions: "Returns Element with visual chart displaying rating distribution"

  - file: "src/ui/components/quality_rating_buttons.rs"
    items:
      - type: "struct"
        name: "QualityButtonWidget"
        description: "Reusable widget displaying 6 quality rating buttons (0-5) for SM-2 review responses with keyboard shortcuts"
      - type: "method"
        name: "QualityButtonWidget::new"
        description: "Creates a new quality button widget"
        postconditions: "Returns initialized widget with 6 buttons configured"
      - type: "method"
        name: "QualityButtonWidget::build"
        description: "Builds button layout with labels, keyboard shortcuts, and appropriate spacing"
        postconditions: "Returns Element with horizontally arranged buttons, each showing quality label and keyboard hint"
      - type: "function"
        name: "handle_button_click"
        description: "Handles button click and emits quality rating event to parent component"
        preconditions: "button_index is 0-5"
        postconditions: "Emits Message::QualitySelected with Quality enum variant"
      - type: "constant"
        name: "QUALITY_LABELS"
        description: "Array of button labels: ['Again (0)', 'Hard (1)', 'Good (2)', 'Easy (3)', 'Perfect (4)', 'Complete Fail (5)']"

  - file: "src/ui/components/session_progress_bar.rs"
    items:
      - type: "struct"
        name: "SessionProgressBar"
        description: "Reusable progress bar widget showing session completion percentage with current/total labels"
      - type: "method"
        name: "SessionProgressBar::new"
        description: "Creates a new progress bar widget with initial progress values"
        preconditions: "total > 0; current <= total"
        postconditions: "Returns initialized progress bar at specified progress"
      - type: "method"
        name: "SessionProgressBar::build"
        description: "Builds progress bar with visual fill, percentage label, and count label"
        postconditions: "Returns Element with colored progress bar, percentage text above, 'X of Y' below"
      - type: "method"
        name: "SessionProgressBar::update_progress"
        description: "Updates progress bar with new completion values"
        preconditions: "current <= total"
        postconditions: "Progress bar visual updates to reflect new percentage"

  - file: "src/ui/components/mod.rs"
    items:
      - type: "module_declaration"
        name: "quality_rating_buttons"
        description: "Module containing quality rating button widget for session reviews"
      - type: "module_declaration"
        name: "session_progress_bar"
        description: "Module containing session progress bar widget"

  - file: "src/ui/views/mod.rs"
    items:
      - type: "module_declaration"
        name: "learning_session_view"
        description: "Module containing learning session view implementation"
      - type: "module_declaration"
        name: "practice_session_view"
        description: "Module containing practice session view implementation"
      - type: "module_declaration"
        name: "session_summary_view"
        description: "Module containing session summary screen implementation"

formal_verification:
  needed: false
  level: "None"
  explanation: |
    Formal verification is not required for Task 8 (Learning Session and Practice Modes) for the following reasons:

    1. **UI-Driven State Machine**: This task implements user-facing session workflows
       (learning flashcards, practice drawing) with state transitions driven by user
       interactions and UI events. The correctness criteria are primarily behavioral
       and ergonomic rather than mathematical. State machine correctness is effectively
       verified through integration testing that exercises all transition paths.

    2. **No Safety-Critical Operations**: While session state must be managed correctly,
       there are no safety-critical operations. Data loss from session interruption is
       mitigated through explicit pause/resume and batched saves. Incorrect state
       transitions would degrade UX but not cause system failures or irreversible errors.

    3. **Delegated Complexity**: The mathematically complex algorithms (SM-2 scheduling,
       handwriting recognition, stroke animation) are handled by their respective modules
       (Tasks 4, 5, 7). This task primarily orchestrates these components, making its
       logic more suitable for behavioral testing than formal verification.

    4. **Testable Properties via Integration Tests**: The critical properties identified
       in acceptance criteria are all effectively testable through integration tests:
       - Session progression through queued cards: Integration test with mock queue
       - Quality ratings update card state: Unit test on SM2Card integration
       - Practice mode 4-stage progression: State machine integration test
       - Statistics accuracy: Unit tests with known inputs
       - Database persistence: Integration test with mock DB

    5. **Recoverable State**: The design includes explicit state persistence (batched
       saves, pause/resume functionality). Any state inconsistencies can be recovered
       by restarting from the last checkpoint. This is a soft real-time system with
       soft deadlines - performance issues degrade UX but don't cause failures.

    6. **Statistical Properties**: Session statistics (average quality, time per card)
       involve simple arithmetic that can be thoroughly tested with property-based tests
       to verify invariants (e.g., total_time >= sum of card_times) without formal proofs.

    The 18 planned integration tests provide comprehensive coverage of state transitions,
    user flows, and edge cases. Property-based testing can verify statistical invariants.
    This approach provides better value than formal verification for this UI-orchestration
    component where correctness is behavioral rather than mathematical.

tests:
  strategy:
    approach: "integration (state machines span multiple screens and user interactions)"
    rationale:
      - "LearningSession and PracticeSession are complex state machines requiring integration testing across multiple subsystems"
      - "Session progression involves SM-2 algorithm, review queue, database persistence, and UI state transitions"
      - "Practice mode state machine has 4 stages with complex transition rules requiring end-to-end validation"
      - "Session statistics and progress tracking must be verified across complete workflows"
      - "Integration testing ensures correct coordination between animation, canvas, recognition, and database components"
      - "Critical risk factors: complexity_risk=high, integration_risk=high justify comprehensive integration approach"

  implementation:
    file: "tests/session_tests.rs"
    location: "create new"
    code: |
      #[cfg(test)]
      mod learning_session_tests {
          use super::*;
          use crate::models::card::SM2Card;
          use crate::scheduler::review_queue::ReviewQueue;
          use crate::sessions::{LearningSession, SessionStatistics};
          use std::time::Instant;

          // ========== Helper Functions ==========

          fn create_test_cards(count: usize) -> Vec<SM2Card> {
              (0..count)
                  .map(|i| {
                      SM2Card::new(
                          format!("card_{}", i),
                          format!("あ{}", i),
                          2.5,
                          0,
                          0,
                      )
                  })
                  .collect()
          }

          fn create_test_session(card_count: usize) -> LearningSession {
              let cards = create_test_cards(card_count);
              let queue = ReviewQueue::from_cards(cards);
              LearningSession {
                  queue,
                  current_card: None,
                  card_index: 0,
                  total_cards: card_count,
                  session_history: Vec::new(),
                  session_start: Instant::now(),
              }
          }

          // ========== Unit Tests: Session Initialization ==========

          #[test]
          fn test_learning_session_initialization() {
              // Verify session initializes with correct state
              let session = create_test_session(10);
              
              assert_eq!(session.card_index, 0);
              assert_eq!(session.total_cards, 10);
              assert!(session.current_card.is_none());
              assert!(session.session_history.is_empty());
          }

          #[test]
          fn test_learning_session_empty_queue() {
              // Verify session handles empty queue gracefully
              let queue = ReviewQueue::new();
              let session = LearningSession {
                  queue,
                  current_card: None,
                  card_index: 0,
                  total_cards: 0,
                  session_history: Vec::new(),
                  session_start: Instant::now(),
              };

              assert_eq!(session.total_cards, 0);
              assert!(session.current_card.is_none());
          }

          // ========== Integration Tests: Session Progression ==========

          #[test]
          fn test_session_progresses_through_all_cards() {
              // Verify session presents all queued cards in order
              let mut session = create_test_session(5);
              
              // Pull first card
              session.current_card = session.queue.get_next_card();
              assert!(session.current_card.is_some());
              assert_eq!(session.card_index, 0);

              // Progress through all cards
              for i in 1..5 {
                  // Submit rating
                  if let Some(card) = &mut session.current_card {
                      card.review(4); // Good rating
                      session.session_history.push(ReviewResult {
                          card_id: card.id.clone(),
                          quality: 4,
                          timestamp: chrono::Utc::now(),
                      });
                  }

                  // Get next card
                  session.card_index = i;
                  session.current_card = session.queue.get_next_card();
                  
                  if i < 4 {
                      assert!(session.current_card.is_some(), "Card {} should exist", i);
                  } else {
                      assert!(session.current_card.is_none(), "Session should complete after all cards");
                  }
              }

              assert_eq!(session.session_history.len(), 4);
          }

          #[test]
          fn test_quality_rating_updates_card_state() {
              // Verify quality ratings (0-5) correctly update SM-2 state
              let mut session = create_test_session(1);
              session.current_card = session.queue.get_next_card();

              if let Some(card) = &mut session.current_card {
                  let initial_ease = card.ease_factor;
                  let initial_interval = card.interval;

                  // Submit quality rating 4 (good)
                  card.review(4);

                  assert!(card.ease_factor >= initial_ease, "Ease factor should increase or stay same for quality 4");
                  assert!(card.interval > initial_interval, "Interval should increase after successful review");
                  assert_eq!(card.repetitions, 1, "Repetition count should increment");
              } else {
                  panic!("Expected card to be present");
              }
          }

          #[test]
          fn test_quality_rating_all_levels() {
              // Test all quality levels 0-5 update card state correctly
              let quality_levels = [0, 1, 2, 3, 4, 5];

              for quality in quality_levels {
                  let mut card = SM2Card::new("test".to_string(), "あ".to_string(), 2.5, 0, 0);
                  card.review(quality);

                  if quality < 3 {
                      // Failed review should reset
                      assert_eq!(card.repetitions, 0, "Quality {} should reset repetitions", quality);
                      assert_eq!(card.interval, 1, "Quality {} should reset interval to 1", quality);
                  } else {
                      // Successful review should progress
                      assert!(card.repetitions > 0, "Quality {} should increment repetitions", quality);
                      assert!(card.interval > 0, "Quality {} should set positive interval", quality);
                  }
              }
          }

          // ========== Integration Tests: Session Statistics ==========

          #[test]
          fn test_session_statistics_accuracy() {
              // Verify session statistics accurately reflect review history
              let mut session = create_test_session(10);
              
              let reviews = vec![
                  (4, true),  // Good - correct
                  (5, true),  // Perfect - correct
                  (2, false), // Incorrect
                  (4, true),  // Good - correct
                  (3, true),  // Hard but correct
                  (1, false), // Barely - incorrect
                  (4, true),  // Good - correct
                  (4, true),  // Good - correct
              ];

              for (quality, _) in &reviews {
                  session.session_history.push(ReviewResult {
                      card_id: format!("card_{}", session.session_history.len()),
                      quality: *quality,
                      timestamp: chrono::Utc::now(),
                  });
              }

              let stats = SessionStatistics::from_history(&session.session_history);
              
              let correct_count = reviews.iter().filter(|(_, c)| *c).count();
              let expected_accuracy = (correct_count as f32 / reviews.len() as f32) * 100.0;
              
              assert_eq!(stats.cards_reviewed, 8);
              assert!((stats.accuracy - expected_accuracy).abs() < 0.01, 
                      "Expected accuracy {:.2}%, got {:.2}%", expected_accuracy, stats.accuracy);
          }

          #[test]
          fn test_session_tracks_time_correctly() {
              // Verify session tracks elapsed time
              use std::thread;
              use std::time::Duration;

              let session = create_test_session(5);
              let start = session.session_start;
              
              thread::sleep(Duration::from_millis(100));
              
              let elapsed = start.elapsed();
              assert!(elapsed >= Duration::from_millis(100), "Elapsed time should be at least 100ms");
          }

          // ========== Integration Tests: Database Persistence ==========

          #[test]
          fn test_session_progress_saves_to_database() {
              // Verify progress saves to database correctly
              use crate::persistence::AppDatabase;
              use tempfile::TempDir;

              let temp_dir = TempDir::new().unwrap();
              let db = AppDatabase::new(temp_dir.path()).unwrap();
              
              let mut session = create_test_session(3);
              session.current_card = session.queue.get_next_card();

              // Review card and save
              if let Some(card) = &mut session.current_card {
                  card.review(4);
                  db.save_card_progress(card).unwrap();

                  // Reload from database
                  let loaded_card = db.load_card_progress(&card.id).unwrap();
                  assert_eq!(loaded_card.interval, card.interval);
                  assert_eq!(loaded_card.ease_factor, card.ease_factor);
                  assert_eq!(loaded_card.repetitions, card.repetitions);
              }
          }

          #[test]
          fn test_session_batched_saves() {
              // Verify batched saves occur efficiently (not every card)
              use crate::persistence::AppDatabase;
              use tempfile::TempDir;

              let temp_dir = TempDir::new().unwrap();
              let db = AppDatabase::new(temp_dir.path()).unwrap();
              
              let mut session = create_test_session(15);
              let mut save_count = 0;
              let batch_size = 5;

              for i in 0..15 {
                  session.current_card = session.queue.get_next_card();
                  
                  if let Some(card) = &mut session.current_card {
                      card.review(4);
                      session.session_history.push(ReviewResult {
                          card_id: card.id.clone(),
                          quality: 4,
                          timestamp: chrono::Utc::now(),
                      });

                      // Batch save every 5 cards
                      if (i + 1) % batch_size == 0 {
                          db.save_card_progress(card).unwrap();
                          save_count += 1;
                      }
                  }
              }

              assert_eq!(save_count, 3, "Should have 3 batched saves for 15 cards");
          }

          // ========== Integration Tests: Session Interruption/Resume ==========

          #[test]
          fn test_session_can_be_interrupted_and_resumed() {
              // Verify session state can be saved and restored
              let mut session = create_test_session(10);
              
              // Progress through some cards
              for _ in 0..3 {
                  session.current_card = session.queue.get_next_card();
                  if let Some(card) = &mut session.current_card {
                      card.review(4);
                      session.session_history.push(ReviewResult {
                          card_id: card.id.clone(),
                          quality: 4,
                          timestamp: chrono::Utc::now(),
                      });
                  }
                  session.card_index += 1;
              }

              // Save session state
              let saved_index = session.card_index;
              let saved_history_len = session.session_history.len();

              // Simulate resume - verify state preserved
              assert_eq!(saved_index, 3);
              assert_eq!(saved_history_len, 3);
              
              // Continue session
              session.current_card = session.queue.get_next_card();
              assert!(session.current_card.is_some(), "Session should be able to continue");
          }

          // ========== Edge Cases ==========

          #[test]
          fn test_empty_queue_completes_immediately() {
              // Verify empty review queue completes gracefully
              let mut session = create_test_session(0);
              session.current_card = session.queue.get_next_card();
              
              assert!(session.current_card.is_none());
              assert_eq!(session.total_cards, 0);
          }

          #[test]
          fn test_invalid_quality_rating_handled() {
              // Verify invalid quality ratings are handled safely
              let mut card = SM2Card::new("test".to_string(), "あ".to_string(), 2.5, 0, 0);
              
              // Quality ratings should be clamped to 0-5 range
              // This test verifies the system doesn't panic on invalid input
              for invalid_quality in [6, 7, 100] {
                  let clamped = invalid_quality.min(5);
                  card.review(clamped);
                  assert!(card.ease_factor >= 1.3, "Ease factor should stay within valid bounds");
              }
          }
      }

      #[cfg(test)]
      mod practice_session_tests {
          use super::*;
          use crate::models::character::CharData;
          use crate::sessions::{PracticeSession, PracticeMode};
          use crate::ui::canvas::DrawingState;
          use crate::ui::animation::StrokeOrderAnimation;

          // ========== Helper Functions ==========

          fn create_test_char_data() -> CharData {
              CharData {
                  character: 'あ',
                  unicode: "U+3042".to_string(),
                  romanization: "a".to_string(),
                  stroke_count: 3,
                  strokes: vec![
                      vec![(0.1, 0.2), (0.3, 0.4)],
                      vec![(0.5, 0.1), (0.6, 0.8)],
                      vec![(0.2, 0.7), (0.8, 0.9)],
                  ],
                  frequency_rank: 1,
              }
          }

          fn create_test_practice_session() -> PracticeSession {
              let char_data = create_test_char_data();
              PracticeSession {
                  character: 'あ',
                  char_data: char_data.clone(),
                  mode: PracticeMode::WatchAnimation,
                  animation_state: StrokeOrderAnimation::new(char_data.strokes.clone()),
                  drawing_state: DrawingState::new(),
                  attempts: 0,
              }
          }

          // ========== Unit Tests: Practice Mode State Machine ==========

          #[test]
          fn test_practice_mode_initialization() {
              // Verify practice session starts in WatchAnimation mode
              let session = create_test_practice_session();
              
              assert!(matches!(session.mode, PracticeMode::WatchAnimation));
              assert_eq!(session.attempts, 0);
              assert_eq!(session.character, 'あ');
          }

          #[test]
          fn test_practice_mode_progression() {
              // Verify practice mode progresses through all 4 stages on success
              let mut session = create_test_practice_session();
              
              assert!(matches!(session.mode, PracticeMode::WatchAnimation));

              // Advance to TraceWithGuide
              session.mode = PracticeMode::TraceWithGuide;
              assert!(matches!(session.mode, PracticeMode::TraceWithGuide));

              // Advance to TraceWithoutGuide
              session.mode = PracticeMode::TraceWithoutGuide;
              assert!(matches!(session.mode, PracticeMode::TraceWithoutGuide));

              // Advance to FreeDrawing
              session.mode = PracticeMode::FreeDrawing;
              assert!(matches!(session.mode, PracticeMode::FreeDrawing));
          }

          #[test]
          fn test_practice_mode_only_advances_on_success() {
              // Verify mode doesn't advance without successful recognition
              let mut session = create_test_practice_session();
              session.mode = PracticeMode::TraceWithGuide;
              
              let initial_mode = session.mode;
              
              // Failed recognition should not advance mode
              session.attempts += 1;
              
              // Mode should remain the same until recognition succeeds
              assert!(matches!(session.mode, PracticeMode::TraceWithGuide));
              assert_eq!(session.attempts, 1);
          }

          // ========== Integration Tests: Stroke Animation ==========

          #[test]
          fn test_watch_mode_plays_animation() {
              // Verify stroke animation plays smoothly in watch mode
              let session = create_test_practice_session();
              
              assert!(matches!(session.mode, PracticeMode::WatchAnimation));
              assert!(session.animation_state.is_initialized());
              assert_eq!(session.animation_state.stroke_count(), 3);
          }

          #[test]
          fn test_animation_can_be_skipped() {
              // Verify user can skip animation and proceed to tracing
              let mut session = create_test_practice_session();
              
              assert!(matches!(session.mode, PracticeMode::WatchAnimation));
              
              // Skip animation
              session.mode = PracticeMode::TraceWithGuide;
              
              assert!(matches!(session.mode, PracticeMode::TraceWithGuide));
          }

          // ========== Integration Tests: Tracing Modes ==========

          #[test]
          fn test_trace_with_guide_shows_overlay() {
              // Verify tracing guide overlays correctly in trace modes
              let session = create_test_practice_session();
              
              // In TraceWithGuide mode, guide should be visible
              let guide_visible = matches!(session.mode, PracticeMode::TraceWithGuide);
              
              // Guide visibility depends on mode
              assert!(guide_visible || matches!(session.mode, PracticeMode::WatchAnimation));
          }

          #[test]
          fn test_trace_without_guide_hides_overlay() {
              // Verify guide is hidden in trace-without-guide mode
              let mut session = create_test_practice_session();
              session.mode = PracticeMode::TraceWithoutGuide;
              
              let guide_visible = matches!(session.mode, PracticeMode::TraceWithGuide);
              assert!(!guide_visible, "Guide should be hidden in TraceWithoutGuide mode");
          }

          // ========== Integration Tests: Free Drawing Validation ==========

          #[test]
          fn test_free_drawing_validates_without_guides() {
              // Verify free drawing mode validates without guides
              let mut session = create_test_practice_session();
              session.mode = PracticeMode::FreeDrawing;
              
              assert!(matches!(session.mode, PracticeMode::FreeDrawing));
              
              // Simulate drawing
              session.drawing_state.start_stroke(iced::Point::new(10.0, 10.0));
              session.drawing_state.add_point(iced::Point::new(20.0, 20.0));
              session.drawing_state.complete_stroke();
              
              assert!(session.drawing_state.completed_strokes.len() > 0);
          }

          // ========== Integration Tests: Recognition Integration ==========

          #[test]
          fn test_drawing_submission_triggers_recognition() {
              // Verify drawing submission triggers recognition system
              let mut session = create_test_practice_session();
              session.mode = PracticeMode::FreeDrawing;
              
              // Draw some strokes
              session.drawing_state.start_stroke(iced::Point::new(10.0, 10.0));
              session.drawing_state.add_point(iced::Point::new(50.0, 50.0));
              session.drawing_state.complete_stroke();
              
              // Export strokes for recognition
              let strokes = session.drawing_state.export_stroke_data((200.0, 200.0));
              
              assert!(!strokes.is_empty(), "Should have exportable stroke data");
              assert_eq!(strokes.len(), 1, "Should have 1 completed stroke");
          }

          // ========== Integration Tests: Session Summary ==========

          #[test]
          fn test_session_summary_displays_statistics() {
              // Verify session summary displays accurate statistics
              let mut session = create_test_practice_session();
              session.attempts = 5;
              
              // Simulate progression through modes
              session.mode = PracticeMode::FreeDrawing;
              
              let summary = PracticeSessionSummary {
                  character: session.character,
                  total_attempts: session.attempts,
                  modes_completed: 4,
                  success: true,
              };
              
              assert_eq!(summary.total_attempts, 5);
              assert_eq!(summary.modes_completed, 4);
              assert!(summary.success);
          }

          // ========== Edge Cases ==========

          #[test]
          fn test_practice_session_with_invalid_character_data() {
              // Verify practice session handles invalid character data gracefully
              let char_data = CharData {
                  character: 'あ',
                  unicode: "U+3042".to_string(),
                  romanization: "a".to_string(),
                  stroke_count: 0,
                  strokes: vec![],
                  frequency_rank: 1,
              };
              
              // Should not panic, but animation may be disabled
              let session = PracticeSession {
                  character: 'あ',
                  char_data,
                  mode: PracticeMode::WatchAnimation,
                  animation_state: StrokeOrderAnimation::new(vec![]),
                  drawing_state: DrawingState::new(),
                  attempts: 0,
              };
              
              assert_eq!(session.animation_state.stroke_count(), 0);
          }

          #[test]
          fn test_excessive_attempts_tracked() {
              // Verify system tracks excessive failed attempts
              let mut session = create_test_practice_session();
              session.mode = PracticeMode::TraceWithGuide;
              
              for _ in 0..10 {
                  session.attempts += 1;
              }
              
              assert_eq!(session.attempts, 10);
          }
      }

      #[derive(Debug)]
      struct PracticeSessionSummary {
          character: char,
          total_attempts: u32,
          modes_completed: u32,
          success: bool,
      }

      #[derive(Debug)]
      struct ReviewResult{
          card_id: String,
          quality: u8,
          timestamp: chrono::DateTime<chrono::Utc>,
      }

  coverage:
    - "Learning session initialization with correct state"
    - "Learning session handles empty queue gracefully"
    - "Session progresses through all queued cards in order"
    - "Quality ratings (0-5) update SM-2 card state correctly"
    - "Quality rating 0-2 resets card to learning state"
    - "Quality rating 3-5 progresses card with interval increase"
    - "Session statistics accurately calculate accuracy percentage"
    - "Session tracks elapsed time correctly"
    - "Session progress saves to database reliably"
    - "Batched database saves occur every N cards (not every card)"
    - "Session can be interrupted and state preserved"
    - "Session can be resumed from saved state"
    - "Empty queue completes session immediately"
    - "Invalid quality ratings handled safely (clamped to 0-5)"
    - "Practice session initializes in WatchAnimation mode"
    - "Practice mode progresses through all 4 stages"
    - "Practice mode only advances on successful recognition"
    - "Watch mode plays stroke animation smoothly"
    - "Animation can be skipped to proceed to tracing"
    - "TraceWithGuide mode displays guide overlay"
    - "TraceWithoutGuide mode hides guide overlay"
    - "FreeDrawing mode validates without any guides"
    - "Drawing submission exports stroke data for recognition"
    - "Recognition system integrates with practice workflow"
    - "Session summary displays accurate statistics"
    - "Practice session handles invalid character data gracefully"
    - "System tracks excessive failed attempts"

dependencies:
  depends_on:
    - task_id: 2
      reason: "Requires character data structures and stroke order information for flashcard display and practice mode"
    - task_id: 3
      reason: "Uses CharacterCard widget componentfor flashcard rendering in learning session view"
    - task_id: 4
      reason: "Integrates StrokeOrderAnimation for watch mode in practice session (passive observation stage)"
    - task_id: 5
      reason: "Uses HandwritingCanvas for drawing modes in practice session (tracing and free drawing stages)"
    - task_id: 6
      reason: "Requires state management framework to coordinate session state across UI and domain logic"
    - task_id: 7
      reason: "Depends on SM2Card::review() for quality rating updates and ReviewQueue for card selection"

  depended_upon_by:
    - task_id: 10
      reason: "Statistics tracking system (Task 10) consumes session statistics data for analytics and progress visualization"
    - task_id: 11
      reason: "Persistence layer (Task 11) saves session state for interruption/resume and batched card updates"

  external:
    - name: "chrono"
      type: "crate"
      status: "to be imported"
    - name: "iced"
      type: "crate"
      status: "already exists"
    - name: "CharData"
      type: "struct"
      status: "already exists"
    - name: "SM2Card"
      type: "struct"
      status: "already exists"
    - name: "ReviewQueue"
      type: "struct"
      status: "already exists"
    - name: "StrokeOrderAnimation"
      type: "struct"
      status: "already exists"
    - name: "HandwritingCanvas"
      type: "struct"
      status: "already exists"
    - name: "CharacterCard"
      type: "struct"
      status: "already exists"
---
task:
  id: 9
  name: "Character Recognition Integration"

context:
  description: |
    This task implements the character recognition system that validates user-drawn
    characters against expected forms in the Japanese character learning application.
    The recognition pipeline accepts raw stroke data from the handwriting canvas,
    normalizes and preprocesses the strokes to ensure consistent formatting, integrates
    with an external recognition engine (hanzi_lookup or similar) via FFI/WASM,
    and validates the results against the expected character with configurable
    confidence thresholds.
    
    Recognition is architecturally significant because it provides the objective
    assessment mechanism for practice mode, enabling learners to receive immediate
    feedback on their handwriting accuracy. The system must balance accuracy with
    usability—too strict and users become frustrated; too lenient and incorrect
    forms are reinforced. The normalization layer makes recognition resolution-
    independent, allowing the same engine to work across different screen sizes
    and input devices.
    
    The challenge lies in handling the inherent variability of handwriting while
    maintaining low false positive rates. The system addresses this through multi-
    stage preprocessing (normalization, resampling, smoothing), threshold-based
    validation (top-N with minimum confidence), and helpful feedback generation
    that guides users toward correct forms without discouragement.

  key_points:
    - "Stroke normalization to 0-1 coordinate range ensures resolution independence and consistent recognition across devices"
    - "Recognition validation uses top-N matching with confidence thresholds (top 3, >70% confidence by default) to balance accuracy with usability"
    - "Integration with external recognition library via FFI/WASM introduces platform-specific complexity that requires careful error handling"
    - "False positive rate (<5% target) must be empirically validated through testing with diverse handwriting samples"
    - "Stroke count validation provides fast, simple error detection before expensive recognition calls"
    - "Feedback generation must be constructive and educational, not discouraging, to maintain learner engagement"
    - "Performance requirement (<200ms) necessitates efficient normalization and potential caching strategies"
    - "Recognition engine may not fully support kana characters (most focus on kanji), requiring fallback strategies or custom model training"

files:
  - path: "src/recognition/mod.rs"
    description: "Main recognition module that exports normalization, recognition engine interface, validation functionality, and high-level API functions"
  - path: "src/recognition/normalize.rs"
    description: "Stroke normalization functions including coordinate scaling to 0-1 range, resampling to consistent point density, and smoothing for noise reduction"
  - path: "src/recognition/engine.rs"
    description: "Recognition engine interface and FFI/WASM wrapper for external recognition library (hanzi_lookup or similar), handles platform-specific bindings"
  - path: "src/recognition/validator.rs"
    description: "Validation logic to check recognition results against expected characters with confidence thresholding and stroke count validation"
  - path: "src/recognition/feedback.rs"
    description: "Feedback generation for incorrect recognition attempts, including error type detection and improvement suggestions"
  - path: "tests/recognition_tests.rs"
    description: "Integration tests for recognition pipeline including normalization, recognition, validation with sample stroke data, and false positive rate testing"

functions:
  - file: "src/recognition/mod.rs"
    items:
      - type: "module_declaration"
        name: "pub mod normalize"
        description: "Module containing stroke normalization functions for coordinate scaling, resampling, and smoothing"
      
      - type: "module_declaration"
        name: "pub mod engine"
        description: "Module containing recognition engine interface and FFI/WASM wrapper for external library"
      
      - type: "module_declaration"
        name: "pub mod validator"
        description: "Module containing validation logic for checking recognition results against expected characters"
      
      - type: "module_declaration"
        name: "pub mod feedback"
        description: "Module containing feedback generation for incorrect recognition attempts"
      
      - type: "struct"
        name: "RecognitionPipeline"
        description: "Orchestrates the full recognition workflow from raw strokes to validation result, combining normalization, recognition, and validation steps"
        invariants: "Engine must be initialized before processing requests"
      
      - type: "method"
        name: "RecognitionPipeline::new"
        description: "Creates a new recognition pipeline with specified configuration, initializing the recognition engine"
        preconditions: "Recognition library is available and configuration is valid"
        postconditions: "Returns initialized pipeline ready to process recognition requests"
      
      - type: "method"
        name: "RecognitionPipeline::process"
        description: "Performs complete recognition pipeline: normalize strokes, recognize character, validate against expected, generate feedback if needed"
        preconditions: "Pipeline initialized, raw strokes non-empty, expected character valid"
        postconditions: "Returns ValidationResult with success status and feedback, completes in <200ms"
        invariants: "Stroke order and count preserved through normalization"
      
      - type: "function"
        name: "recognize_character"
        description: "High-level convenience API function that creates pipeline and performs full recognition workflow"
        preconditions: "Raw strokes from canvas available, expected character known"
        postconditions: "Returns validation result with feedback, completes in <200ms"
        invariants: "Thread-safe, can be called concurrently from multiple sessions"

  - file: "src/recognition/normalize.rs"
    items:
      - type: "struct"
        name: "NormalizedStroke"
        description: "Represents a single stroke normalized to 0-1 coordinate range with consistent point density"
        invariants: "All point coordinates are in range [0.0, 1.0]; points vector is non-empty"
      
      - type: "struct"
        name: "Point"
        description: "Represents a 2D point with x and y coordinates"
        invariants: "Coordinates are finite floating-point values"
      
      - type: "struct"
        name: "BoundingBox"
        description: "Rectangular bounding box defined by min and max corners"
        invariants: "min.x <= max.x and min.y <= max.y"
      
      - type: "struct"
        name: "NormalizationConfig"
        description: "Configuration parameters for stroke normalization including resampling point count and smoothing window size"
        invariants: "resample_points >= 2 if enabled; smoothing_window >= 3 and odd if enabled"
      
      - type: "method"
        name: "NormalizationConfig::default"
        description: "Creates default normalization configuration with sensible defaults (32 points, 5-point smoothing window)"
        postconditions: "Returns valid configuration ready for use"
      
      - type: "function"
        name: "normalize_strokes"
        description: "Normalizes collection of raw strokes to unit square (0-1 range) while preserving relative positions, stroke order, and stroke direction"
        preconditions: "Input strokes vector is non-empty; each stroke contains at least one point"
        postconditions: "All output coordinates in [0.0, 1.0] range; stroke count and order preserved; relative positioning maintained"
        invariants: "Bounding box encompasses all strokes; aspect ratio preserved or square-normalized based on config"
      
      - type: "function"
        name: "normalize_stroke"
        description: "Normalizes a single stroke to 0-1 coordinate range"
        preconditions: "Input stroke is non-empty"
        postconditions: "All coordinates in [0.0, 1.0] range; point count preserved unless resampling enabled"
      
      - type: "function"
        name: "compute_bounding_box"
        description: "Computes the minimum axis-aligned bounding box containing all points in all strokes"
        preconditions: "At least one stroke with at least one point exists"
        postconditions: "Returns BoundingBox with min.x <= max.x and min.y <= max.y; box contains all input points"
        invariants: "Returned box is minimal (no smaller box exists that contains all points)"
      
      - type: "function"
        name: "scale_to_unit_square"
        description: "Scales stroke coordinates from original bounding box to 0-1 range using linear transformation"
        preconditions: "Bounding box has non-zero width and height (no degenerate cases)"
        postconditions: "All output coordinates in [0.0, 1.0] range; points at bounding box edges map to 0.0 or 1.0"
        invariants: "Relative distances between points scaled proportionally"
      
      - type: "function"
        name: "resample_stroke"
        description: "Resamples a stroke to have exactly target_points evenly-spaced points along its path using linear interpolation"
        preconditions: "Stroke has at least 2 points; target_points >= 2"
        postconditions: "Output stroke has exactly target_points points; points lie on original stroke path; spacing is approximately uniform"
        invariants: "First and last points match original stroke endpoints"
      
      - type: "function"
        name: "smooth_stroke"
        description: "Applies moving average smoothing filter to reduce noise in stroke points while preserving overall shape"
        preconditions: "Stroke has at least 3 points; window size is odd and >= 3"
        postconditions: "Output stroke has same number of points; high-frequency noise reduced; overall shape preserved"
        invariants: "Endpoints may be handled specially to avoid boundary artifacts"
      
      - type: "function"
        name: "stroke_length"
        description: "Computes total Euclidean path length of a stroke by summing distances between consecutive points"
        preconditions: "Stroke is non-empty"
        postconditions: "Returns non-negative path length; returns 0.0 for single-point stroke"
      
      - type: "function"
        name: "point_distance"
        description: "Computes Euclidean distance between two points"
        postconditions: "Returns non-negative distance value"

  - file: "src/recognition/engine.rs"
    items:
      - type: "struct"
        name: "RecognitionEngine"
        description: "Interface to external character recognition library (hanzi_lookup or similar), handles FFI or WASM calls"
        invariants: "Engine is initialized before use; recognition library resources are managed properly"
      
      - type: "struct"
        name: "RecognitionResult"
        description: "Single candidate character match with its confidence score and optional metadata"
        invariants: "confidence is in range [0.0, 1.0]; character is valid Unicode"
      
      - type: "struct"
        name: "RecognitionCandidate"
        description: "Alias for RecognitionResult representing one possible character interpretation"
        invariants: "Same as RecognitionResult"
      
      - type: "struct"
        name: "RecognitionConfig"
        description: "Configuration for recognition engine including model path, confidence thresholds, top-N result count, and timeout"
        invariants: "top_n >= 1; min_confidence in [0.0, 1.0]; timeout > 0"
      
      - type: "method"
        name: "RecognitionConfig::default"
        description: "Creates default recognition configuration (top_n=5, min_confidence=0.3, timeout=200ms)"
        postconditions: "Returns valid configuration with sensible defaults for Japanese character recognition"
      
      - type: "method"
        name: "RecognitionEngine::new"
        description: "Creates and initializes a new RecognitionEngine instance, loading recognition library and models"
        preconditions: "Recognition library is available on system; model files exist if specified in config"
        postconditions: "Engine is initialized and ready to accept recognition requests; returns Err if initialization fails"
        invariants: "Engine owns recognition library resources and manages their lifecycle"
      
      - type: "method"
        name: "RecognitionEngine::recognize"
        description: "Performs character recognition on normalized strokes, returning top-N ranked candidate matches sorted by confidence"
        preconditions: "Engine is initialized; strokes are normalized to [0.0, 1.0] range; strokes vector is non-empty"
        postconditions: "Returns Vec<RecognitionResult> sorted by confidence descending; length <= top_n; completes within timeout; empty Vec if no matches found"
        invariants: "Results are deterministic for same input strokes; confidence scores sum to <= 1.0 if probability-based"
      
      - type: "method"
        name: "RecognitionEngine::recognize_with_hint"
        description: "Performs recognition with a stroke count hint to improve accuracy by filtering or boosting candidates"
        preconditions: "Engine initialized; strokes normalized; expected_stroke_count >= 1"
        postconditions: "Returns results filtered or re-ranked based on stroke count; may have higher accuracy for characters matching hint"
      
      - type: "function"
        name: "format_strokes_for_engine"
        description: "Converts normalized strokes from application format to the specific format expected by recognition library"
        preconditions: "Strokes are normalized to [0.0, 1.0] range"
        postconditions: "Returns data structure compatible with recognition library input format (e.g., flattened array, JSON, protobuf)"
      
      - type: "trait"
        name: "RecognitionEngineInterface"
        description: "Trait defining the interface for character recognition engines, allowing multiple implementations (FFI, WASM, mock)"
      
      - type: "trait_impl"
        name: "RecognitionEngineInterface for RecognitionEngine"
        description: "Implements the recognition interface for the primary FFI/WASM-based engine"

  - file: "src/recognition/validator.rs"
    items:
      - type: "struct"
        name: "ValidationResult"
        description: "Result of validating recognition against expected character, includes success status, confidence score, and feedback"
        invariants: "feedback is Some when success is false; confidence in [0.0, 1.0] if Some"
      
      - type: "struct"
        name: "ValidationConfig"
        description: "Configuration for validation logic including confidence threshold, top-N count, strict mode flag, and stroke count tolerance"
        invariants: "min_confidence in [0.0, 1.0];top_n >= 1; stroke_count_tolerance >= 0"
      
      - type: "method"
        name: "ValidationConfig::default"
        description: "Creates default validation configuration (top_n=3, min_confidence=0.7, strict_mode=false)"
        postconditions: "Returns configuration tuned for good UX balance between accuracy and usability"
      
      - type: "method"
        name: "ValidationResult::success"
        description: "Creates a successful validation result"
        postconditions: "Returns ValidationResult with success=true and confidence score"
      
      - type: "method"
        name: "ValidationResult::failure"
        description: "Creates a failed validation result with feedback"
        postconditions: "Returns ValidationResult with success=false and FeedbackMessage"
      
      - type: "function"
        name: "validate_recognition"
        description: "Checks if expected character appears in top-N recognition results with sufficient confidence, applying validation rules"
        preconditions: "Recognition results are sorted by confidence descending; expected character is valid"
        postconditions: "Returns ValidationResult with success=true if expected char in top-N with confidence >= threshold; else success=false with feedback"
        invariants: "Validation is deterministic for same inputs"
      
      - type: "function"
        name: "check_stroke_count"
        description: "Validates that the number of strokes matches the expected count for the character (with tolerance)"
        preconditions: "Expected character exists in stroke count database or character data"
        postconditions: "Returns true if stroke count matches within tolerance, false otherwise"
      
      - type: "function"
        name: "get_expected_stroke_count"
        description: "Retrieves the canonical stroke count for a given character from character database"
        preconditions: "Character is valid Japanese character (hiragana, katakana, or kanji)"
        postconditions: "Returns Some(count) if known, None if character not in database"
      
      - type: "function"
        name: "compute_false_positive_rate"
        description: "Computes false positive rate on a labeled test dataset for threshold tuning and quality assessment"
        preconditions: "Test dataset contains labeled stroke samples with ground truth characters"
        postconditions: "Returns false positive rate as percentage in [0.0, 100.0]; rate should be < 5% for good UX"

  - file: "src/recognition/feedback.rs"
    items:
      - type: "struct"
        name: "FeedbackMessage"
        description: "Structured feedback message containing error type, human-readable description, and actionable improvement hints"
        invariants: "description is non-empty; suggestions contains 1-3 items"
      
      - type: "enum"
        name: "ErrorType"
        description: "Categories of recognition errors to provide targeted feedback"
      
      - type: "enum_variant"
        name: "ErrorType::StrokeCount"
        description: "Wrong number of strokes drawn (most common beginner error)"
      
      - type: "enum_variant"
        name: "ErrorType::StrokeOrder"
        description: "Strokes drawn in incorrect order (affects recognition accuracy)"
      
      - type: "enum_variant"
        name: "ErrorType::StrokeShape"
        description: "Stroke shapes don't match expected character form"
      
      - type: "enum_variant"
        name: "ErrorType::LowConfidence"
        description: "Character recognized but confidence below threshold (ambiguous handwriting)"
      
      - type: "enum_variant"
        name: "ErrorType::NotRecognized"
        description: "No matching character found (completely unrecognized input)"
      
      - type: "method"
        name: "FeedbackMessage::new"
        description: "Creates a new feedback message with error type, description, and suggestions"
        postconditions: "Returns complete feedback message ready for display"
      
      - type: "function"
        name: "generate_feedback"
        description: "Generates helpful, encouraging feedback message based on recognition failure mode and context"
        preconditions: "Recognition was attempted and validation failed; have access to recognition results and expected character"
        postconditions: "Returns actionable FeedbackMessage with 1-3 concrete improvement suggestions"
        invariants: "Feedback is constructive and educational, not discouraging"
      
      - type: "function"
        name: "detect_error_type"
        description: "Analyzes recognition results, actual strokes, and expected character to determine most likely error cause"
        preconditions: "Recognition results available (may be empty); expected character known; stroke count available"
        postconditions: "Returns most likely ErrorType based on heuristic analysis"
      
      - type: "function"
        name: "suggest_improvement"
        description: "Provides 1-3 specific, actionable improvement suggestions based on detected error type"
        preconditions: "Error type has been detected via detect_error_type"
        postconditions: "Returns Vec<String> with 1-3 concrete suggestions (e.g., 'Try using 3 strokes instead of 4')"
      
      - type: "function"
        name: "format_stroke_count_hint"
        description: "Formats a helpful hint about the correct stroke count for the character"
        preconditions: "Expected stroke count is known"
        postconditions: "Returns formatted string like 'This character uses 3 strokes'"

formal_verification:
  needed: false
  level: "None"
  explanation: |
    Formal verification is not required for the character recognition integration task despite some mathematical properties that could theoretically benefit from formal reasoning. The decision is based on the following factors:

    1. Explicit Task Specification: The task explicitly states formal_verification: false, recognizing that full formal verification is impractical for this component. The task correctly identifies integration testing as the primary verification strategy.

    2. External Library Integration Challenges: The recognition system integrates with external FFI/WASM libraries for character matching. Formal verification across FFI boundaries is extremely complex and often infeasible, as the external library's behavior cannot be formally verified within the application's proof system.

    3. Heuristic-Based Validation Logic: The validation system uses confidence thresholds (<200ms response time, <5% false positive rate) that are inherently empirical rather than formally provable. These thresholds must be tuned through experimentation with real handwriting data, not proven through formal methods.

    4. Normalization Properties Can Be Tested: While stroke normalization (coordinate scaling, resampling, smoothing) has mathematical properties, these are straightforward transformations that can be thoroughly validated through:
       - Property-based testing for coordinate bounds (ensuring normalized values stay in [0,1] range)
       - Unit tests for relative position preservation
       - Integration tests with real stroke data

    5. High Integration and Testing Risk: The task's risk assessment identifies "high" complexity, integration, and testing risk. The primary concerns (library kana support, FFI brittleness, threshold tuning) are practical engineering challenges that formal verification cannot address. These require empirical testing with actual data.

    6. Cost-Benefit Analysis: The complexity of formally verifying coordinate transformations, FFI interactions, and threshold-based decision logic would be extraordinarily high. The testing strategy already outlined (integration testing with real handwriting data, validation of critical properties through empirical testing) provides far better ROI for ensuring system correctness.

    7. Appropriate Alternative: Property-based testing is more suitable than formal verification for this task. Properties like "normalization preserves relative stroke positions" can be tested across thousands of random inputs without the overhead of formal proof systems.

    The task correctly identifies that integration testing with real handwriting data is the appropriate verification strategy, focusing on empirical validation of recognition accuracy, response time, and false positive rates rather than formal mathematical proofs.

tests:
  strategy:
    approach: "mixed (unit + integration + property-based)"
    rationale:
      - "Unit tests verify individual components (normalization, coordinate transformation, resampling) in isolation with predictable inputs"
      - "Integration tests validate end-to-end recognition pipeline with real stroke data and external library interaction"
      - "Property-based tests ensure normalization invariants hold across arbitrary input ranges (coordinates always in [0,1], stroke counts preserved)"
      - "Recognition accuracy and performance require integration testing with sample datasets to verify <200ms latency requirement"
      - "Validation logic needs both unit tests (threshold checking, top-N matching) and integration tests (real recognition results)"
      - "False positive rate measurement requires statistical testing across diverse test cases to meet <5% acceptance criteria"
      - "Feedback generation needs unit tests for different error scenarios to ensure helpful user guidance"
      - "Mixed approach provides comprehensive coverage: deterministic behavior via unit tests, invariant preservation via property tests, real-world behavior via integration tests"

  implementation:
    file: "tests/recognition_tests.rs"
    location: "create new"
    code: |
      #[cfg(test)]
      mod tests {
          use japanese::recognition::*;
          use japanese::recognition::normalize::*;
          use japanese::recognition::engine::*;
          use japanese::recognition::validator::*;
          use japanese::recognition::feedback::*;
          use approx::assert_relative_eq;
          
          // ========== Stroke Normalization Tests ==========
          
          #[test]
          fn test_normalize_single_stroke_to_unit_square() {
              // Stroke with coordinates in pixel space (100x100 to 300x300)
              let stroke = vec![
                  Point { x: 100.0, y: 100.0 },
                  Point { x: 200.0, y: 200.0 },
                  Point { x: 300.0, y: 300.0 },
              ];
              
              let normalized = normalize_stroke(&stroke);
              
              // All coordinates should be in [0, 1] range
              assert_relative_eq!(normalized[0].x, 0.0, epsilon = 0.001);
              assert_relative_eq!(normalized[0].y, 0.0, epsilon = 0.001);
              assert_relative_eq!(normalized[1].x, 0.5, epsilon = 0.001);
              assert_relative_eq!(normalized[1].y, 0.5, epsilon = 0.001);
              assert_relative_eq!(normalized[2].x, 1.0, epsilon = 0.001);
              assert_relative_eq!(normalized[2].y, 1.0, epsilon = 0.001);
          }
          
          #[test]
          fn test_normalize_multiple_strokes_preserves_relative_positions() {
              let strokes = vec![
                  vec![Point { x: 0.0, y: 0.0 }, Point { x: 100.0, y: 0.0 }],
                  vec![Point { x: 0.0, y: 100.0 }, Point { x: 100.0, y: 100.0 }],
              ];
              
              let normalized = normalize_strokes(&strokes);
              
              // Verify bounding box encompasses all strokes
              assert!(normalized.iter().all(|stroke| {
                  stroke.iter().all(|p| p.x >= 0.0 && p.x <= 1.0 && p.y >= 0.0 && p.y <= 1.0)
              }));
              
              // Verify relative positions preserved (second stroke should be below first)
              assert!(normalized[1][0].y > normalized[0][0].y);
          }
          
          #[test]
          fn test_normalize_preserves_stroke_order() {
              let strokes = vec![
                  vec![Point { x: 0.0, y: 0.0 }, Point { x: 50.0, y: 50.0 }],
                  vec![Point { x: 100.0, y: 0.0 }, Point { x: 150.0, y: 50.0 }],
                  vec![Point { x: 0.0, y: 100.0 }, Point { x: 50.0, y: 150.0 }],
              ];
              
              let normalized = normalize_strokes(&strokes);
              
              assert_eq!(normalized.len(), 3);
              assert_eq!(normalized[0].len(), 2);
              assert_eq!(normalized[1].len(), 2);
              assert_eq!(normalized[2].len(), 2);
          }
          
          #[test]
          fn test_normalize_empty_stroke_returns_empty() {
              let stroke: Vec<Point> = vec![];
              let normalized = normalize_stroke(&stroke);
              assert!(normalized.is_empty());
          }
          
          #[test]
          fn test_normalize_single_point_stroke() {
              let stroke = vec![Point { x: 150.0, y: 200.0 }];
              let normalized = normalize_stroke(&stroke);
              
              // Single point should map to valid position in unit square
              assert_eq!(normalized.len(), 1);
              assert!(normalized[0].x >= 0.0 && normalized[0].x <= 1.0);
              assert!(normalized[0].y >= 0.0 && normalized[0].y <= 1.0);
          }
          
          #[test]
          fn test_compute_bounding_box_single_stroke() {
              let strokes = vec![
                  vec![
                      Point { x: 100.0, y: 50.0 },
                      Point { x: 200.0, y: 150.0 },
                      Point { x: 150.0, y: 200.0 },
                  ],
              ];
              
              let bbox = compute_bounding_box(&strokes);
              
              assert_relative_eq!(bbox.min_x, 100.0, epsilon = 0.001);
              assert_relative_eq!(bbox.max_x, 200.0, epsilon = 0.001);
              assert_relative_eq!(bbox.min_y, 50.0, epsilon = 0.001);
              assert_relative_eq!(bbox.max_y, 200.0, epsilon = 0.001);
          }
          
          #[test]
          fn test_compute_bounding_box_multiple_strokes() {
              let strokes = vec![
                  vec![Point { x: 0.0, y: 0.0 }, Point { x: 100.0, y: 100.0 }],
                  vec![Point { x: 50.0, y: 150.0 }, Point { x: 200.0, y: 50.0 }],
              ];
              
              let bbox = compute_bounding_box(&strokes);
              
              assert_relative_eq!(bbox.min_x, 0.0, epsilon = 0.001);
              assert_relative_eq!(bbox.max_x, 200.0, epsilon = 0.001);
              assert_relative_eq!(bbox.min_y, 0.0, epsilon = 0.001);
              assert_relative_eq!(bbox.max_y, 150.0, epsilon = 0.001);
          }
          
          // ========== Stroke Resampling Tests ==========
          
          #[test]
          fn test_resample_stroke_to_fixed_count() {
              let stroke = vec![
                  Point { x: 0.0, y: 0.0 },
                  Point { x: 0.25, y: 0.25 },
                  Point { x: 0.5, y: 0.5 },
                  Point { x: 0.75, y: 0.75 },
                  Point { x: 1.0, y: 1.0 },
              ];
              
              let resampled = resample_stroke(&stroke, 32);
              
              assert_eq!(resampled.len(), 32);
              // First and last points should be preserved
              assert_relative_eq!(resampled[0].x, 0.0, epsilon = 0.001);
              assert_relative_eq!(resampled[0].y, 0.0, epsilon = 0.001);
              assert_relative_eq!(resampled[31].x, 1.0, epsilon = 0.001);
              assert_relative_eq!(resampled[31].y, 1.0, epsilon = 0.001);
          }
          
          #[test]
          fn test_resample_preserves_general_shape() {
              // L-shaped stroke
              let stroke = vec![
                  Point { x: 0.0, y: 0.0 },
                  Point { x: 0.0, y: 0.5 },
                  Point { x: 0.0, y: 1.0 },
                  Point { x: 0.5, y: 1.0 },
                  Point { x: 1.0, y: 1.0 },
              ];
              
              let resampled = resample_stroke(&stroke, 16);
              
              // Check that resampled points still follow L-shape
              // Early points should have x ≈ 0
              assert!(resampled[0..8].iter().all(|p| p.x < 0.3));
              // Later points should have y ≈ 1.0
              assert!(resampled[8..16].iter().all(|p| p.y > 0.7));
          }
          
          #[test]
          fn test_resample_handles_two_point_stroke() {
              let stroke = vec![
                  Point { x: 0.0, y: 0.0 },
                  Point { x: 1.0, y: 1.0 },
              ];
              
              let resampled = resample_stroke(&stroke, 10);
              
              assert_eq!(resampled.len(), 10);
              // Points should be evenly distributed along line
              for (i, point) in resampled.iter().enumerate() {
                  let expected_val = i as f64 / 9.0;
                  assert_relative_eq!(point.x, expected_val, epsilon = 0.001);
                  assert_relative_eq!(point.y, expected_val, epsilon = 0.001);
              }
          }
          
          // ========== Stroke Smoothing Tests ==========
          
          #[test]
          fn test_smooth_stroke_reduces_noise() {
              // Noisy zigzag stroke
              let stroke = vec![
                  Point { x: 0.0, y: 0.0 },
                  Point { x: 0.1, y: 0.05 },
                  Point { x: 0.09, y: 0.1 },
                  Point { x: 0.2, y: 0.15 },
                  Point { x: 0.19, y: 0.2 },
              ];
              
              let smoothed = smooth_stroke(&stroke, 3);
              
              // Smoothed stroke should have same or fewer points
              assert!(smoothed.len() > 0);
              // Middle point should be averaged with neighbors
              assert!(smoothed[2].x > stroke[2].x && smoothed[2].x < stroke[3].x);
          }
          
          #[test]
          fn test_smooth_stroke_preserves_endpoints() {
              let stroke = vec![
                  Point { x: 0.0, y: 0.0 },
                  Point { x: 0.5, y: 0.5 },
                  Point { x: 1.0, y: 1.0 },
              ];
              
              let smoothed = smooth_stroke(&stroke, 3);
              
              // Endpoints should remain close to original
              assert_relative_eq!(smoothed.first().unwrap().x, 0.0, epsilon = 0.1);
              assert_relative_eq!(smoothed.first().unwrap().y, 0.0, epsilon = 0.1);
              assert_relative_eq!(smoothed.last().unwrap().x, 1.0, epsilon = 0.1);
              assert_relative_eq!(smoothed.last().unwrap().y, 1.0, epsilon = 0.1);
          }
          
          // ========== Recognition Interface Tests ==========
          
          #[test]
          fn test_recognition_engine_initialization() {
              let config = RecognitionConfig::default();
              let engine = RecognitionEngine::new(config);
              
              assert!(engine.is_ok(), "Recognition engine should initialize successfully");
          }
          
          #[test]
          fn test_recognition_returns_candidates() {
              let strokes = vec![
                  vec![Point { x: 0.2, y: 0.1 }, Point { x: 0.8, y: 0.9 }],
                  vec![Point { x: 0.8, y: 0.1 }, Point { x: 0.2, y: 0.9 }],
              ];
              
              let candidates = recognize_character(&strokes);
              
              assert!(candidates.len() > 0, "Recognition should return at least one candidate");
              assert!(candidates.len() <= 10, "Should limit to top N candidates");
              
              // Verify candidates are sorted by confidence (descending)
              for i in 1..candidates.len() {
                  assert!(candidates[i-1].confidence >= candidates[i].confidence);
              }
          }
          
          #[test]
          fn test_recognition_candidates_have_valid_confidence() {
              let strokes = vec![
                  vec![Point { x: 0.0, y: 0.0 }, Point { x: 1.0, y: 1.0 }],
              ];
              
              let candidates = recognize_character(&strokes);
              
              for candidate in candidates {
                  assert!(candidate.confidence >= 0.0 && candidate.confidence <= 1.0,
                      "Confidence must be in [0.0, 1.0] range");
                  assert!(!candidate.character.is_empty(), "Character should not be empty");
              }
          }
          
          #[test]
          fn test_recognition_empty_strokes_returns_empty() {
              let strokes: Vec<Vec<Point>> = vec![];
              let candidates = recognize_character(&strokes);
              assert!(candidates.is_empty(), "Empty input should return empty results");
          }
          
          #[test]
          fn test_format_strokes_for_engine() {
              let strokes = vec![
                  vec![Point { x: 0.0, y: 0.0 }, Point { x: 0.5, y: 0.5 }],
              ];
              
              let formatted = format_strokes_for_engine(&strokes);
              
              // Verify formatted data is valid and non-empty
              assert!(!formatted.is_empty());
          }
          
          // ========== Validation Tests ==========
          
          #[test]
          fn test_validate_exact_match_in_top_result() {
              let candidates = vec![
                  RecognitionResult { character: "あ".to_string(), confidence: 0.95 },
                  RecognitionResult { character: "お".to_string(), confidence: 0.75 },
                  RecognitionResult { character: "ん".to_string(), confidence: 0.60 },
              ];
              
              let config = ValidationConfig {
                  top_n: 3,
                  confidence_threshold: 0.7,
                  strict_mode: false,
              };
              
              let result = validate_recognition(&candidates, "あ", &config);
              
              assert!(result.is_match);
              assert_eq!(result.matched_character, Some("あ".to_string()));
              assert_eq!(result.rank, Some(0));
              assert_relative_eq!(result.confidence, 0.95, epsilon = 0.001);
          }
          
          #[test]
          fn test_validate_match_in_top_n() {
              let candidates = vec![
                  RecognitionResult { character: "お".to_string(), confidence: 0.85 },
                  RecognitionResult { character: "あ".to_string(), confidence: 0.82 },
                  RecognitionResult { character: "ん".to_string(), confidence: 0.60 },
              ];
              
              let config = ValidationConfig {
                  top_n: 3,
                  confidence_threshold: 0.7,
                  strict_mode: false,
              };
              
              let result = validate_recognition(&candidates, "あ", &config);
              
              assert!(result.is_match);
              assert_eq!(result.rank, Some(1));
              assert_relative_eq!(result.confidence, 0.82, epsilon = 0.001);
          }
          
          #[test]
          fn test_validate_fails_below_confidence_threshold() {
              let candidates = vec![
                  RecognitionResult { character: "お".to_string(), confidence: 0.85 },
                  RecognitionResult { character: "あ".to_string(), confidence: 0.65 },
                  RecognitionResult { character: "ん".to_string(), confidence: 0.60 },
              ];
              
              let config = ValidationConfig {
                  top_n: 3,
                  confidence_threshold: 0.7,
                  strict_mode: false,
              };
              
              let result = validate_recognition(&candidates, "あ", &config);
              
              assert!(!result.is_match, "Should fail when confidence below threshold");
              assert_eq!(result.matched_character, None);
          }
          
          #[test]
          fn test_validate_fails_outside_top_n() {
              let candidates = vec![
                  RecognitionResult { character: "お".to_string(), confidence: 0.85 },
                  RecognitionResult { character: "か".to_string(), confidence: 0.82 },
                  RecognitionResult { character: "き".to_string(), confidence: 0.80 },
                  RecognitionResult { character: "あ".to_string(), confidence: 0.75 },
              ];
              
              let config = ValidationConfig {
                  top_n: 3,
                  confidence_threshold: 0.7,
                  strict_mode: false,
              };
              
              let result = validate_recognition(&candidates, "あ", &config);
              
              assert!(!result.is_match, "Should fail when match outside top-N");
          }
          
          #[test]
          fn test_validate_no_candidates_returns_no_match() {
              let candidates: Vec<RecognitionResult> = vec![];
              
              let config = ValidationConfig::default();
              let result = validate_recognition(&candidates, "あ", &config);
              
              assert!(!result.is_match);
              assert_eq!(result.matched_character, None);
              assert_eq!(result.rank, None);
          }
          
          #[test]
          fn test_check_stroke_count_validation() {
              // "あ" has 3 strokes
              let strokes = vec![
                  vec![Point { x: 0.5, y: 0.1 }, Point { x: 0.5, y: 0.3 }],
                  vec![Point { x: 0.2, y: 0.4 }, Point { x: 0.8, y: 0.4 }],
                  vec![Point { x: 0.7, y: 0.3 }, Point { x: 0.3, y: 0.9 }],
              ];
              
              let valid = check_stroke_count(&strokes, "あ");
              assert!(valid, "Stroke count should match for 'あ' (3 strokes)");
          }
          
          #[test]
          fn test_check_stroke_count_mismatch() {
              // "あ" has 3 strokes, but providing only 2
              let strokes = vec![
                  vec![Point { x: 0.5, y: 0.1 }, Point { x: 0.5, y: 0.3 }],
                  vec![Point { x: 0.2, y: 0.4 }, Point { x: 0.8, y: 0.4 }],
              ];
              
              let valid = check_stroke_count(&strokes, "あ");
              assert!(!valid, "Stroke count should not match (2 vs 3)");
          }
          
          // ========== Feedback Generation Tests ==========
          
          #[test]
          fn test_feedback_for_wrong_character() {
              let candidates = vec![
                  RecognitionResult { character: "お".to_string(), confidence: 0.90 },
              ];
              let expected = "あ";
              
              let feedback = generate_feedback(&candidates, expected, 3);
              
              assert!(feedback.message.contains("お"), "Feedback should mention recognized character");
              assert!(feedback.message.contains("あ"), "Feedback should mention expected character");
              assert!(
                  feedback.message.contains("recognized") || feedback.message.contains("looks like"),
                  "Feedback should explain the mismatch"
              );
              assert_eq!(feedback.error_type, ErrorType::NotRecognized);
          }
          
          #[test]
          fn test_feedback_includes_stroke_count_hint() {
              let candidates = vec![];
              let expected = "あ";
              let stroke_count = 2;
              let expected_stroke_count = 3;
              
              let feedback = generate_feedback_with_stroke_hint(
                  &candidates, 
                  expected, 
                  stroke_count,
                  expected_stroke_count
              );
              
              assert!(feedback.message.contains("stroke"), "Feedback should mention stroke count");
              assert_eq!(feedback.error_type, ErrorType::StrokeCount);
              assert!(feedback.suggestions.len() > 0, "Should provide improvement suggestions");
          }
          
          #[test]
          fn test_feedback_for_close_match() {
              let candidates = vec![
                  RecognitionResult { character: "あ".to_string(), confidence: 0.68 },
              ];
              let expected = "あ";
              
              let config = ValidationConfig {
                  confidence_threshold: 0.7,
                  ..Default::default()
              };
              
              let feedback = generate_feedback_for_low_confidence(&candidates, expected, &config);
              
              assert!(
                  feedback.message.contains("close") || feedback.message.contains("almost"),
                  "Feedback should encourage close attempt"
              );
              assert_eq!(feedback.error_type, ErrorType::LowConfidence);
          }
          
          #[test]
          fn test_detect_error_type_stroke_count() {
              let strokes = vec![vec![Point { x: 0.0, y: 0.0 }]];
              let candidates = vec![];
              let expected = "あ"; // 3 strokes
              
              let error_type = detect_error_type(&strokes, &candidates, expected);
              
              assert_eq!(error_type, ErrorType::StrokeCount);
          }
          
          #[test]
          fn test_detect_error_type_not_recognized() {
              let strokes = vec![
                  vec![Point { x: 0.0, y: 0.0 }],
                  vec![Point { x: 0.5, y: 0.5 }],
                  vec![Point { x: 1.0, y: 1.0 }],
              ];
              let candidates = vec![
                  RecognitionResult { character: "お".to_string(), confidence: 0.90 },
              ];
              let expected = "あ";
              
              let error_type = detect_error_type(&strokes, &candidates, expected);
              
              assert_eq!(error_type, ErrorType::NotRecognized);
          }
          
          #[test]
          fn test_suggest_improvement_stroke_count() {
              let suggestions = suggest_improvement(&ErrorType::StrokeCount);
              
              assert!(suggestions.len() >= 1, "Should provide at least one suggestion");
              assert!(suggestions.iter().any(|s| s.to_lowercase().contains("stroke")));
          }
          
          // ========== Performance Tests ==========
          
          #[test]
          fn test_recognition_completes_within_time_limit() {
              use std::time::Instant;
              
              let strokes = vec![
                  vec![
                      Point { x: 0.1, y: 0.1 },
                      Point { x: 0.5, y: 0.5 },
                      Point { x: 0.9, y: 0.9 },
                  ],
                  vec![
                      Point { x: 0.2, y: 0.3 },
                      Point { x: 0.8, y: 0.7 },
                  ],
              ];
              
              let start = Instant::now();
              let _candidates = recognize_character(&strokes);
              let duration = start.elapsed();
              
              assert!(
                  duration.as_millis() < 200, 
                  "Recognition took {}ms, expected <200ms", 
                  duration.as_millis()
              );
          }
          
          #[test]
          fn test_normalization_performance() {
              use std::time::Instant;
              
              // Create large stroke set
              let mut strokes = Vec::new();
              for _ in 0..10 {
                  let mut stroke = Vec::new();
                  for j in 0..100 {
                      stroke.push(Point { x: j as f64, y: j as f64 });
                  }
                  strokes.push(stroke);
              }
              
              let start = Instant::now();
              let _normalized = normalize_strokes(&strokes);
              let duration = start.elapsed();
              
              assert!(
                  duration.as_millis() < 50,
                  "Normalization took {}ms, expected <50ms",
                  duration.as_millis()
              );
          }
          
          // ========== Integration Tests ==========
          
          #[test]
          fn test_end_to_end_recognition_pipeline() {
              // Raw stroke data in pixel coordinates
              let raw_strokes = vec![
                  vec![
                      Point { x: 100.0, y: 50.0 },
                      Point { x: 150.0, y: 100.0 },
                      Point { x: 200.0, y: 150.0 },
                  ],
                  vec![
                      Point { x: 200.0, y: 50.0 },
                      Point { x: 150.0, y: 100.0 },
                      Point { x: 100.0, y: 150.0 },
                  ],
              ];
              
              // Step 1: Normalize
              let normalized = normalize_strokes(&raw_strokes);
              assert!(normalized.iter().all(|s| s.iter().all(|p| 
                  p.x >= 0.0 && p.x <= 1.0 && p.y >= 0.0 && p.y <= 1.0
              )));
              
              // Step 2: Resample
              let resampled: Vec<Vec<Point>> = normalized
                  .iter()
                  .map(|stroke| resample_stroke(stroke, 32))
                  .collect();
              assert!(resampled.iter().all(|s| s.len() == 32));
              
              // Step 3: Smooth
              let smoothed: Vec<Vec<Point>> = resampled
                  .iter()
                  .map(|stroke| smooth_stroke(stroke, 3))
                  .collect();
              
              // Step 4: Recognize
              let candidates = recognize_character(&smoothed);
              
              // Should return valid results
              assert!(candidates.len() > 0, "Pipeline should produce recognition results");
              assert!(candidates.iter().all(|c| !c.character.is_empty()));
              assert!(candidates.iter().all(|c| c.confidence >= 0.0 && c.confidence <= 1.0));
          }
          
          #[test]
          fn test_recognition_with_real_hiragana_data() {
              // Sample stroke data for "あ" (a) - simplified approximation
              let a_strokes = vec![
                  // First stroke: horizontal at top
                  vec![
                      Point { x: 0.5, y: 0.1 },
                      Point { x: 0.5, y: 0.3 },
                  ],
                  // Second stroke: horizontal in middle
                  vec![
                      Point { x: 0.2, y: 0.4 },
                      Point { x: 0.8, y: 0.4 },
                  ],
                  // Third stroke: curve from top-right to bottom-left
                  vec![
                      Point { x: 0.7, y: 0.3 },
                      Point { x: 0.7, y: 0.6 },
                      Point { x: 0.5, y: 0.8 },
                      Point { x: 0.3, y: 0.9 },
                  ],
              ];
              
              let candidates = recognize_character(&a_strokes);
              
              // May not always match in unit tests without real recognition engine,
              // but should not crash and should return valid data structure
              assert!(candidates.len() >= 0);
              
              // If candidates are returned, validate structure
              if !candidates.is_empty() {
                  assert!(candidates[0].confidence >= 0.0 && candidates[0].confidence <= 1.0);
                  assert!(!candidates[0].character.is_empty());
              }
          }
          
          #[test]
          fn test_full_validation_workflow() {
              let raw_strokes = vec![
                  vec![Point { x: 100.0, y: 100.0 }, Point { x: 200.0, y: 200.0 }],
              ];
              
              // Full pipeline
              let pipeline = RecognitionPipeline::new(RecognitionConfig::default()).unwrap();
              let result = pipeline.recognize_and_validate(&raw_strokes, "あ");
              
              // Result should be valid regardless of match
              assert!(result.validation_result.confidence >= 0.0);
              
              if !result.validation_result.is_match {
                  assert!(result.feedback.is_some(), "Failed match should provide feedback");
              }
          }
      }
      
      #[cfg(test)]
      mod property_tests {
          use super::*;
          use japanese::recognition::*;
          use proptest::prelude::*;
          
          // Generate arbitrary points within reasonable bounds
          fn point_strategy() -> impl Strategy<Value = Point> {
              (0.0f64..1000.0, 0.0f64..1000.0)
                  .prop_map(|(x, y)| Point { x, y })
          }
          
          fn stroke_strategy() -> impl Strategy<Value = Vec<Point>> {
              prop::collection::vec(point_strategy(), 1..50)
          }
          
          fn strokes_strategy() -> impl Strategy<Value = Vec<Vec<Point>>> {
              prop::collection::vec(stroke_strategy(), 1..10)
          }
          
          proptest! {
              #[test]
              fn prop_normalize_always_produces_unit_range(strokes in strokes_strategy()) {
                  let normalized = normalize_strokes(&strokes);
                  
                  for stroke in normalized.iter() {
                      for point in stroke.iter() {
                          prop_assert!(point.x >= 0.0 && point.x <= 1.0,
                              "X coordinate {} not in [0,1]", point.x);
                          prop_assert!(point.y >= 0.0 && point.y <= 1.0,
                              "Y coordinate {} not in [0,1]", point.y);
                      }
                  }
              }
              
              #[test]
              fn prop_normalize_preserves_stroke_count(strokes in strokes_strategy()) {
                  let normalized = normalize_strokes(&strokes);
                  prop_assert_eq!(normalized.len(), strokes.len(),
                      "Stroke count should be preserved");
              }
              
              #[test]
              fn prop_normalize_preserves_point_count_per_stroke(strokes in strokes_strategy()) {
                  let normalized = normalize_strokes(&strokes);
                  
                  for (original, norm) in strokes.iter().zip(normalized.iter()) {
                      prop_assert_eq!(norm.len(), original.len(),
                          "Point count per stroke should be preserved");
                  }
              }
              
              #[test]
              fn prop_resample_produces_exact_count(stroke in stroke_strategy(), count in 5usize..100) {
                  if stroke.len() < 2 {
                      return Ok(());
                  }
                  
                  let resampled = resample_stroke(&stroke, count);
                  prop_assert_eq!(resampled.len(), count,
                      "Resampled stroke should have exactly {} points", count);
              }
              
              #[test]
              fn prop_smooth_preserves_endpoints(stroke in stroke_strategy()) {
                  if stroke.len() < 3 {
                      return Ok(());
                  }
                  
                  let smoothed = smooth_stroke(&stroke, 3);
                  
                  if !smoothed.is_empty() && !stroke.is_empty() {
                      // First and last points should be close to originals
                      let epsilon = 0.5;
                      prop_assert!((smoothed[0].x - stroke[0].x).abs() < epsilon,
                          "First point X should be preserved within {}", epsilon);
                      prop_assert!((smoothed[0].y - stroke[0].y).abs() < epsilon,
                          "First point Y should be preserved within {}", epsilon);
                      
                      let last_idx = smoothed.len() - 1;
                      let orig_last_idx = stroke.len() - 1;
                      prop_assert!((smoothed[last_idx].x - stroke[orig_last_idx].x).abs() < epsilon,
                          "Last point X should be preserved within {}", epsilon);
                      prop_assert!((smoothed[last_idx].y - stroke[orig_last_idx].y).abs() < epsilon,
                          "Last point Y should be preserved within {}", epsilon);
                  }
              }
              
              #[test]
              fn prop_recognition_candidates_sorted_by_confidence(strokes in strokes_strategy()) {
                  let candidates = recognize_character(&strokes);
                  
                  for i in 1..candidates.len() {
                      prop_assert!(candidates[i-1].confidence >= candidates[i].confidence,
                          "Candidates should be sorted by confidence (descending)");
                  }
              }
              
              #[test]
              fn prop_validation_consistent_with_candidate_list(
                  confidence in 0.5f64..1.0,
                  rank in 0usize..5
              ) {
                  let mut candidates = vec![];
                  for i in 0..=rank {
                      candidates.push(RecognitionResult {
                          character: format!("char{}", i),
                          confidence: confidence - (i as f64 * 0.05),
                      });
                  }
                  
                  let expected = format!("char{}", rank);
                  let config = ValidationConfig {
                      top_n: rank + 1,
                      confidence_threshold: 0.5,
                      strict_mode: false,
                  };
                  
                  let result = validate_recognition(&candidates, &expected, &config);
                  
                  if candidates[rank].confidence >= 0.5 {
                      prop_assert!(result.is_match,
                          "Should match when character in top-N with sufficient confidence");
                      prop_assert_eq!(result.rank, Some(rank),
                          "Rank should match position in candidate list");
                  }
              }
              
              #[test]
              fn prop_normalization_is_deterministic(strokes in strokes_strategy()) {
                  let normalized1 = normalize_strokes(&strokes);
                  let normalized2 = normalize_strokes(&strokes);
                  
                  prop_assert_eq!(normalized1.len(), normalized2.len());
                  
                  for (s1, s2) in normalized1.iter().zip(normalized2.iter()) {
                      prop_assert_eq!(s1.len(), s2.len());
                      for (p1, p2) in s1.iter().zip(s2.iter()) {
                          prop_assert!((p1.x - p2.x).abs() < 0.0001,
                              "Normalization should be deterministic");
                          prop_assert!((p1.y - p2.y).abs() < 0.0001,
                              "Normalization should be deterministic");
                      }
                  }
              }
          }
      }

  coverage:
    - "Stroke normalization to unit square (0-1 range) for single stroke"
    - "Stroke normalization to unit square for multiple strokes"
    - "Normalization preserves relative positions of multiple strokes"
    - "Normalization preserves stroke order and point count per stroke"
    - "Normalization handles edge cases (empty stroke, single point stroke)"
    - "Bounding box computation for single stroke encompasses all points"
    - "Bounding box computation for multiple strokes encompasses all strokes"
    - "Stroke resampling to fixed point count (32 points)"
    - "Resampling preserves first and last points (endpoints)"
    - "Resampling preserves general shape (L-shape test)"
    - "Resampling handles two-point strokes with even distribution"
    - "Stroke smoothing reduces noise in zigzag patterns"
    - "Smoothing preserves stroke endpoints within tolerance"
    - "Recognition engine initializes successfully"
    - "Recognition returns ranked candidates with top-N limit"
    - "Recognition candidates sorted by confidence (descending order)"
    - "Recognition candidates have valid confidence scores [0.0, 1.0]"
    - "Recognition handles empty stroke input gracefully"
    - "Stroke format conversion for recognition engine"
    - "Validation identifies exact matches in top position (rank 0)"
    - "Validation identifies matches within top-N results"
    - "Validation respects confidence threshold (rejects below threshold)"
    - "Validation respects top-N limit (rejects outside limit)"
    - "Validation handles empty candidate list"
    - "Stroke count validation matches expected count"
    - "Stroke count validation detects mismatches"
    - "Feedback generation for wrong character recognition"
    - "Feedback includes stroke count hints when applicable"
    - "Feedback distinguishes close matches (low confidence) from wrong attempts"
    - "Error type detection identifies stroke count errors"
    - "Error type detection identifies not-recognized errors"
    - "Improvement suggestions provided for stroke count errors"
    - "Recognition completes within 200ms performance requirement"
    - "Normalization completes within 50ms for large stroke sets"
    - "End-to-end pipeline (normalize → resample → smooth → recognize) integration"
    - "Integration with real hiragana stroke data (character 'あ')"
    - "Full validation workflow with feedback generation"
    - "Property: normalization always produces coordinates in [0,1] range"
    - "Property: normalization preserves stroke count"
    - "Property: normalization preserves point count per stroke"
    - "Property: resampling produces exact requested point count"
    - "Property: smoothing preserves endpoints within tolerance"
    - "Property: recognition candidates always sorted by confidence"
    - "Property: validation results consistent with candidate rankings"
    - "Property: normalization is deterministic (repeated calls produce same output)"

dependencies:
  depends_on:
    - task_id: 5
      reason: "Requires stroke data format and types from HandwritingCanvas component for receiving raw drawing input"

  depended_upon_by:
    - task_id: 8
      reason: "PracticeSession uses recognition validation to provide immediate feedback and track learning progress"

  external:
    - name: "hanzi_lookup"
      type: "crate"
      status: "to be imported"
    - name: "Point"
      type: "struct"
      status: "needs implementation"
    - name: "StrokeData"
      type: "struct"
      status: "already exists"
---
task:
  id: 10
  name: "Statistics and Progress Visualization"

context:
  description: |
    Task 10 implements comprehensive statistics tracking and visualization for user progress
    in the spaced repetition flashcard system. This task creates the gamification and motivation
    layer that encourages consistent study habits through visible progress metrics, achievement
    unlocks, and streak tracking.

    The statistics system aggregates review data from learning sessions into meaningful metrics
    including accuracy rates, study streaks, cards mastered, and time-series daily/weekly data.
    These metrics are displayed in an engaging statistics screen with visual indicators like
    flame emojis for streaks, progress bars for card status distribution, and achievement badges.

    Architecturally, this task sits at the intersection of the learning session (Task 8), the
    navigation framework (Task 6), and the persistence layer (Task 11). The Statistics struct
    acts as a data aggregator that incrementally updates during review sessions and provides
    efficient time-series queries using BTreeMap for date-indexed data.

    The achievement system provides milestone-based gamification (first review, 7/30/100-day
    streaks, review count thresholds, accuracy goals, cards mastered) that creates a sense of
    accomplishment and encourages habit formation. Streak tracking leverages consecutive day
    detection to motivate daily practice.

  key_points:
    - "Statistics struct uses BTreeMap<NaiveDate, DayStats> for efficient date range queries in time-series data"
    - "Streak calculation tracks consecutive days in study_days HashSet with timezone-aware day boundary handling"
    - "Card maturity stages (new/learning/mature) based on SM-2 interval thresholds (21 days for mature)"
    - "Achievement system provides discrete milestone unlocks with celebratory UI feedback"
    - "Statistics update incrementally during sessions and batch persist at session end for performance"
    - "Daily/weekly aggregations enable future analytics and trend visualizations"
    - "Mathematical invariants ensure data integrity: accuracy ∈ [0, 100], correct ≤ total, longest_streak ≥ current_streak"
    - "Gamification elements (streaks, achievements) significantly boost user motivation and retention"

files:
  - path: "src/statistics.rs"
    description: "Core Statistics struct with metrics aggregation (total_reviews, correct_reviews, accuracy calculation), streak calculation using HashSet of study dates, time-series data storage in BTreeMap for daily/weekly stats, and card status counting (new/learning/mature based on SM-2 intervals)"

  - path: "src/achievements.rs"
    description: "Achievement system module defining Achievement enum variants (FirstReview, Streak7Days, Streak30Days, Streak100Days, Cards100Mastered, Cards500Mastered, Reviews1000, PerfectDay) and AchievementTracker struct for checking unlock conditions and tracking unlocked achievements"

  - path: "src/ui/statistics_screen.rs"
    description: "Statistics screen UI component implementing StatsScreen struct with view rendering for progress visualizations, accuracy sections, streak displays with flame emoji, card status breakdowns, daily history charts, achievement grid, and time spent formatting"

  - path: "src/lib.rs"
    description: "Library root module - add declarations for statistics and achievements modules to expose them throughout the application"

  - path: "src/ui/mod.rs"
    description: "UI module root - add declaration for statistics_screen submodule to expose the statistics UI component"

  - path: "src/learning.rs"
    description: "Update LearningSession struct to integrate statistics updates after each review by adding update_statistics and finalize_statistics methods that record review results, update accuracy metrics, and maintain streak data"

  - path: "tests/statistics_tests.rs"
    description: "Comprehensive unit tests for Statistics struct covering accuracy calculations (zero reviews, all correct, partial correct), streak logic (consecutive days, broken streaks, month boundaries), time-series aggregation (daily stats, weekly rollups), and card status counting with property-based tests for invariants"

  - path: "tests/achievements_tests.rs"
    description: "Unit tests for achievement system verifying unlock conditions for each achievement type (milestone thresholds, streak requirements, perfect day criteria) and AchievementTracker behavior (no duplicates, proper unlock detection, all achievements enumeration)"

functions:
  - file: "src/statistics.rs"
    items:
      - type: "module_declaration"
        name: "statistics"
        description: "Core module for statistics tracking, aggregation, and time-series data management"

      - type: "struct"
        name: "Statistics"
        description: "Aggregates review data into accuracy rates, streaks, card status counts, and time-series data using BTreeMap for efficient date range queries"
        invariants: "total_reviews >= correct_reviews; current_streak >= 0; longest_streak >= current_streak; all card counts >= 0"

      - type: "struct"
        name: "DayStats"
        description: "Daily statistics aggregation containing review counts, accuracy, and time spent for a single day"
        invariants: "total_reviews >= correct_reviews; time_spent_seconds >= 0; date is valid"

      - type: "struct"
        name: "WeekStats"
        description: "Weekly statistics aggregation summing daily stats over 7-day period"
        invariants: "total_reviews >= correct_reviews; equals sum of constituent DayStats"

      - type: "enum"
        name: "CardStatus"
        description: "Represents card maturity stages based on SM-2 interval thresholds"

      - type: "enum_variant"
        name: "CardStatus::New"
        description: "Card has never been reviewed (no review history)"

      - type: "enum_variant"
        name: "CardStatus::Learning"
        description: "Card has been reviewed but interval is less than 21 days"

      - type: "enum_variant"
        name: "CardStatus::Mature"
        description: "Card has interval of 21 days or greater (mature threshold)"

      - type: "struct"
        name: "CardStatusCounts"
        description: "Tracks count of cards grouped by their maturity status"
        invariants: "new_count >= 0; learning_count >= 0; mature_count >= 0"

      - type: "method"
        name: "Statistics::new"
        description: "Creates new Statistics instance with zero values and empty collections"
        postconditions: "Returns Statistics with total_reviews=0, correct_reviews=0, empty study_days HashSet, empty daily_stats BTreeMap"

      - type: "method"
        name: "Statistics::record_review"
        description: "Records a single review result, updating total/correct counts and daily stats"
        preconditions: "date is valid; time_spent_seconds >= 0"
        postconditions: "total_reviews incremented; correct_reviews incremented if correct; daily_stats updated for date; study_days contains date"

      - type: "method"
        name: "Statistics::accuracy_rate"
        description: "Calculates overall accuracy as percentage (correct/total * 100)"
        postconditions: "Returns f64 between 0.0 and 100.0; returns 0.0 if total_reviews is 0"
        invariants: "Result is always between 0.0 and 100.0 inclusive"

      - type: "method"
        name: "Statistics::update_streak"
        description: "Updates current and longest streaks based on study_days set"
        preconditions: "study_days contains valid dates"
        postconditions: "current_streak reflects consecutive days ending at most recent study day; longest_streak updated if current exceeds it"
        invariants: "longest_streak >= current_streak"

      - type: "method"
        name: "Statistics::calculate_streak"
        description: "Calculates current streak from study_days by counting consecutive days backward from today or most recent study day"
        postconditions: "Returns u32 representing consecutive study days"

      - type: "method"
        name: "Statistics::add_day_stats"
        description: "Adds or updates DayStats entry for a specific date in daily_stats BTreeMap"
        preconditions: "date is valid; day_stats has valid counts"
        postconditions: "daily_stats contains entry for date with given day_stats"

      - type: "method"
        name: "Statistics::get_day_stats"
        description: "Retrieves DayStats for a specific date from daily_stats BTreeMap"
        preconditions: "date is valid"
        postconditions: "Returns Option<&DayStats>, Some if date exists in daily_stats"

      - type: "method"
        name: "Statistics::get_week_stats"
        description: "Aggregates daily statistics for a 7-day week starting from given date"
        preconditions: "start_date is valid"
        postconditions: "Returns WeekStats summing all DayStats for 7 days starting at start_date"

      - type: "method"
        name: "Statistics::get_date_range_stats"
        description: "Retrieves daily stats for a date range using BTreeMap efficient range query"
        preconditions: "start_date <= end_date; both dates valid"
        postconditions: "Returns iterator or Vec of (NaiveDate, DayStats) tuples in chronological order"

      - type: "method"
        name: "Statistics::cards_by_status"
        description: "Counts cards grouped by maturity status (new/learning/mature) based on SM-2 intervals"
        preconditions: "cards slice with valid review data and intervals"
        postconditions: "Returns CardStatusCounts with accurate counts for each status"

      - type: "method"
        name: "Statistics::total_time_spent"
        description: "Returns total study time across all reviews in seconds"
        postconditions: "Returns non-negative u32 or u64 duration"

      - type: "method"
        name: "Statistics::total_cards"
        description: "Returns sum of new_count + learning_count + mature_count from card status counts"
        postconditions: "Returns non-negative count of total cards"

      - type: "trait_impl"
        name: "impl Default for Statistics"
        description: "Provides default initialization for Statistics struct"

      - type: "method"
        name: "DayStats::new"
        description: "Creates new DayStats for a specific date with zero counts"
        preconditions: "date is valid"
        postconditions: "Returns DayStats with total_reviews=0, correct_reviews=0, time_spent_seconds=0 for given date"

      - type: "method"
        name: "DayStats::record_review"
        description: "Records a review result in this day's statistics"
        preconditions: "time_spent >= 0"
        postconditions: "total_reviews incremented; correct_reviews incremented if correct; time_spent_seconds increased"

      - type: "method"
        name: "DayStats::accuracy_rate"
        description: "Calculates accuracy percentage for this day"
        postconditions: "Returns f64 between 0.0 and 100.0; returns 0.0 if total_reviews is 0"

      - type: "method"
        name: "WeekStats::new"
        description: "Creates new WeekStats with zero counts"
        postconditions: "Returns WeekStats with all counts initialized to zero"

      - type: "method"
        name: "WeekStats::add_day"
        description: "Adds a DayStats to this week's aggregated totals"
        preconditions: "day_stats is valid"
        postconditions: "All counters incremented by corresponding day_stats values"

      - type: "method"
        name: "WeekStats::accuracy_rate"
        description: "Calculates accuracy percentage for the week"
        postconditions: "Returns f64 between 0.0 and 100.0"

      - type: "function"
        name: "calculate_streak_from_dates"
        description: "Helper function to calculate consecutive day streak from HashSet of study dates"
        preconditions: "study_dates contains valid NaiveDate entries"
        postconditions: "Returns (current_streak, longest_streak) tuple with both >= 0"
        invariants: "longest_streak >= current_streak"

      - type: "function"
        name: "determine_card_status"
        description: "Determines CardStatus based on card's review count and current SM-2 interval"
        preconditions: "card has valid review history and interval"
        postconditions: "Returns New if never reviewed, Learning if interval < 21, Mature if interval >= 21"

      - type: "function"
        name: "get_today_date"
        description: "Gets current date normalized to midnight in local timezone for day boundary calculations"
        postconditions: "Returns NaiveDate representing today at 00:00:00 local time"

      - type: "constant"
        name: "MATURE_INTERVAL_DAYS"
        description: "Threshold interval in days (21) for card to be considered mature"

  - file: "src/achievements.rs"
    items:
      - type: "module_declaration"
        name: "achievements"
        description: "Achievement system module for milestone tracking and gamification"

      - type: "enum"
        name: "Achievement"
        description: "Represents different achievement types with unlock criteria and display info"

      - type: "enum_variant"
        name: "Achievement::FirstReview"
        description: "Unlocked after completing first review (total_reviews >= 1)"

      - type: "enum_variant"
        name: "Achievement::Streak7Days"
        description: "Unlocked after maintaining 7-day consecutive study streak"

      - type: "enum_variant"
        name: "Achievement::Streak30Days"
        description: "Unlocked after maintaining 30-day consecutive study streak"

      - type: "enum_variant"
        name: "Achievement::Streak100Days"
        description: "Unlocked after maintaining 100-day consecutive study streak"

      - type: "enum_variant"
        name: "Achievement::Reviews100"
        description: "Unlocked after completing 100 total reviews"

      - type: "enum_variant"
        name: "Achievement::Reviews500"
        description: "Unlocked after completing 500 total reviews"

      - type: "enum_variant"
        name: "Achievement::Reviews1000"
        description: "Unlocked after completing 1000 total reviews"

      - type: "enum_variant"
        name: "Achievement::Cards100Mastered"
        description: "Unlocked after 100 cards reach mature status"

      - type: "enum_variant"
        name: "Achievement::Cards500Mastered"
        description: "Unlocked after 500 cards reach mature status"

      - type: "enum_variant"
        name: "Achievement::Accuracy90Percent"
        description: "Unlocked after achieving 90% accuracy with at least 100 reviews"

      - type: "enum_variant"
        name: "Achievement::PerfectDay"
        description: "Unlocked after achieving 100% accuracy in a single day with at least 10 reviews"

      - type: "struct"
        name: "AchievementTracker"
        description: "Tracks unlocked achievements and checks for new unlocks based on statistics"
        invariants: "unlocked_achievements contains no duplicates; once unlocked, achievements remain unlocked"

      - type: "method"
        name: "Achievement::title"
        description: "Returns human-readable title string for the achievement"
        postconditions: "Returns non-empty &str with achievement title"

      - type: "method"
        name: "Achievement::description"
        description: "Returns description string explaining how to unlock the achievement"
        postconditions: "Returns non-empty &str with unlock criteria description"

      - type: "method"
        name: "Achievement::icon"
        description: "Returns emoji/icon string representing the achievement"
        postconditions: "Returns &str with emoji character (e.g., '🔥', '🏆', '⭐')"

      - type: "method"
        name: "Achievement::criteria_met"
        description: "Checks if given statistics satisfy this achievement's unlock condition"
        preconditions: "statistics contains valid data"
        postconditions: "Returns true if unlock criteria met, false otherwise"

      - type: "method"
        name: "AchievementTracker::new"
        description: "Creates new AchievementTracker with empty unlocked achievements set"
        postconditions: "Returns tracker with no unlocked achievements"

      - type: "method"
        name: "AchievementTracker::check_and_unlock"
        description: "Checks statistics against all achievement criteria and unlocks newly earned achievements"
        preconditions: "statistics is valid and up-to-date"
        postconditions: "Returns Vec<Achievement> of newly unlocked achievements; unlocked_achievements updated"

      - type: "method"
        name: "AchievementTracker::is_unlocked"
        description: "Checks if a specific achievement has been unlocked"
        postconditions: "Returns true if achievement is in unlocked_achievements"

      - type: "method"
        name: "AchievementTracker::unlock"
        description: "Manually unlocks a specific achievement (adds to unlocked set)"
        postconditions: "Achievement added to unlocked_achievements if not already present; returns true if newly unlocked"

      - type: "method"
        name: "AchievementTracker::unlocked_count"
        description: "Returns the number of unlocked achievements"
        postconditions: "Returns non-negative usize count"

      - type: "method"
        name: "AchievementTracker::all_achievements"
        description: "Returns vector of all possible Achievement variants"
        postconditions: "Returns Vec<Achievement> containing all achievement types"

      - type: "trait_impl"
        name: "impl Display for Achievement"
        description: "Provides Display formatting for Achievement enum"

      - type: "trait_impl"
        name: "impl PartialEq for Achievement"
        description: "Enables equality comparison for Achievement enum"

      - type: "trait_impl"
        name: "impl Eq for Achievement"
        description: "Implements Eq marker trait for Achievement enum"

      - type: "trait_impl"
        name: "impl Hash for Achievement"
        description: "Enables Achievement to be used in HashSet"

  - file: "src/ui/statistics_screen.rs"
    items:
      - type: "module_declaration"
        name: "statistics_screen"
        description: "UI module for statistics visualization screen with metrics and progress displays"

      - type: "struct"
        name: "StatisticsScreen"
        description: "Screen component displaying statistics, achievements, and progress visualizations"

      - type: "enum"
        name: "StatisticsMessage"
        description: "Messages for statistics screen user interactions"

      - type: "enum_variant"
        name: "StatisticsMessage::BackPressed"
        description: "User pressed back button to return to previous screen"

      - type: "enum_variant"
        name: "StatisticsMessage::TimeRangeChanged"
        description: "User changed time range filter (week, month, all-time) for statistics display"

      - type: "enum_variant"
        name: "StatisticsMessage::RefreshStats"
        description: "User requested manual statistics refresh"

      - type: "method"
        name: "StatisticsScreen::new"
        description: "Creates new statistics screen with given statistics and achievement data"
        preconditions: "statistics and achievements are valid"
        postconditions: "Returns initialized StatisticsScreen"

      - type: "method"
        name: "StatisticsScreen::view"
        description: "Renders the statistics screen UI with all metrics, charts, and achievements"
        postconditions: "Returns iced Element displaying complete statistics UI"

      - type: "method"
        name: "StatisticsScreen::update"
        description: "Handles messages and updates screen state"
        preconditions: "message is valid"
        postconditions: "Screen state updated according to message; returns Command if navigation needed"

      - type: "function"
        name: "render_accuracy_section"
        description: "Renders accuracy percentage card with visual styling and color coding"
        preconditions: "statistics contains accuracy data"
        postconditions: "Returns Element displaying accuracy rate with percentage formatting"

      - type: "function"
        name: "render_streak_section"
        description: "Renders current and longest streak card with flame emoji indicators"
        preconditions: "statistics contains streak data"
        postconditions: "Returns Element displaying current streak and longest streak with 🔥 emoji"

      - type: "function"
        name: "render_cards_status_section"
        description: "Renders card distribution by status (new/learning/mature) with counts and visual bars"
        preconditions: "statistics contains card status counts"
        postconditions: "Returns Element displaying card status breakdown"

      - type: "function"
        name: "render_daily_history"
        description: "Renders daily review history as list or simple bar chart for recent days"
        preconditions: "statistics contains daily_stats data"
        postconditions: "Returns Element displaying recent daily review counts and accuracy"

      - type: "function"
        name: "render_achievements_section"
        description: "Renders unlocked and locked achievements with icons and titles in grid layout"
        preconditions: "achievements tracker data is available"
        postconditions: "Returns Element displaying achievement grid with locked achievements grayed out"

      - type: "function"
        name: "render_time_spent_section"
        description: "Renders total study time with human-readable formatting"
        preconditions: "statistics contains total_study_time_seconds"
        postconditions: "Returns Element displaying formatted time (e.g., '5h 30m')"

      - type: "function"
        name: "render_achievement_card"
        description: "Renders individual achievement card with icon, title, description, and lock status"
        preconditions: "achievement is valid; unlocked status is known"
        postconditions: "Returns Element displaying achievement with appropriate styling"

      - type: "function"
        name: "render_achievement_unlock_animation"
        description: "Renders celebratory animation overlay when new achievement is unlocked"
        preconditions: "achievement was just unlocked"
        postconditions: "Returns Element with animation (confetti, fade-in, etc.)"

      - type: "function"
        name: "format_duration"
        description: "Formats seconds into human-readable duration string (hours, minutes)"
        preconditions: "seconds >= 0"
        postconditions: "Returns String formatted as 'Xh Ym' or 'Ym' or 'Xs'"

      - type: "function"
        name: "format_percentage"
        description: "Formats f64 percentage to string with one decimal place"
        preconditions: "percentage is between 0.0 and 100.0"
        postconditions: "Returns String formatted as 'XX.X%'"

      - type: "function"
        name: "format_streak_text"
        description: "Formats streak count with flame emoji and appropriate text"
        preconditions: "streak >= 0"
        postconditions: "Returns String like '🔥 7 day streak' with proper pluralization"

      - type: "function"
        name: "accuracy_color"
        description: "Returns color for accuracy display based on percentage (green for high, yellow for medium, red for low)"
        preconditions: "accuracy is between 0.0 and 100.0"
        postconditions: "Returns iced Color value for visual feedback"

  - file: "src/ui/mod.rs"
    items:
      - type: "module_declaration"
        name: "statistics_screen"
        description: "Exposes statistics_screen module from ui package"

  - file: "src/lib.rs"
    items:
      - type: "module_declaration"
        name: "statistics"
        description: "Declares statistics module in library root"

      - type: "module_declaration"
        name: "achievements"
        description: "Declares achievements module in library root"

  - file: "src/learning.rs"
    items:
      - type: "method"
        name: "LearningSession::update_statistics"
        description: "Updates statistics struct after each card review during learning session"
        preconditions: "statistics is mutable reference; review_result is valid; card_id is valid"
        postconditions: "statistics.total_reviews incremented; statistics.correct_reviews incremented if correct; daily_stats updated; streak updated if new day"

      - type: "method"
        name: "LearningSession::finalize_statistics"
        description: "Finalizes statistics at end of session and returns updated Statistics struct"
        postconditions: "Returns updated Statistics ready for persistence"

      - type: "method"
        name: "LearningSession::check_achievements"
        description: "Checks for newly unlocked achievements after statistics update"
        preconditions: "statistics and achievement_tracker are valid"
        postconditions: "Returns Vec<Achievement> of newly unlocked achievements; shows celebration UI for unlocks"

formal_verification:
  needed: false
  level: "None"
  explanation: |
    Formal verification is NOT needed for Task 10 (Statistics and Progress Visualization) for the following reasons:

    1. Simple Deterministic Calculations: The statistics system performs straightforward arithmetic operations:
       - Accuracy = correct_reviews / total_reviews * 100
       - Streak counting via consecutive date checking
       - Time aggregation (summing durations)
       - Card status classification based on interval thresholds
       These are simple, well-understood mathematical operations that don't require formal proofs.

    2. No Safety-Critical Requirements: Statistics visualization is NOT safety-critical. Incorrect calculations would display misleading progress metrics but would NOT cause:
       - Data corruption or loss
       - System failures or crashes
       - Security vulnerabilities
       - Harm to users
       The worst-case scenario is showing incorrect progress data, which is easily detectable and correctable.

    3. Observable and Testable: All statistics are directly observable in the UI, making bugs immediately detectable:
       - Users can verify accuracy percentages match their performance
       - Streak counts are visible and can be manually verified
       - Achievement unlocks are discrete events that users notice
       - Property-based testing can verify mathematical invariants across all input ranges

    4. No Complex State Machines or Concurrency: Unlike Task 6 (State Management) which requires formal verification due to complex state transitions and Arc<RwLock> concurrency, statistics calculations are:
       - Pure functions with no side effects
       - Single-threaded aggregations
       - No race conditions or deadlock risks
       - Deterministic outputs for given inputs

    5. Adequate Alternative Verification: The task specification already includes comprehensive property-based testing that provides mathematical guarantees:
       - Property: accuracy always between 0.0 and 100.0
       - Property: correct_reviews <= total_reviews
       - Property: current_streak <= total_study_days
       - Property: longest_streak >= current_streak
       - Property: study_time always non-negative
       These properties, verified across random input sequences via proptest, provide sufficient confidence without formal proofs.

    6. Cost-Benefit Analysis: The effort required for formal verification (creating formal specifications, writing proofs in Coq/Lean, maintaining proof code) would FAR EXCEED the benefits given:
       - Low complexity (simple arithmetic)
       - Low risk (non-critical visualization)
       - High testability (property-based tests cover invariants)
       - Observable outputs (users see results immediately)

    Conclusion: Property-based testing (proptest) combined with comprehensive unit tests provides SUFFICIENT verification for this task.

tests:
  strategy:
    approach: "mixed (unit tests + property-based testing)"
    rationale:
      - "Unit tests verify specific statistical calculations (accuracy, streak logic, aggregations)with known inputs and expected outputs to ensure deterministic correctness"
      - "Property-based tests ensure mathematical invariants hold across all possible inputs (accuracy 0-100%, counts non-negative, longest >= current streak, etc.)"
      - "Statistics are deterministic calculations making them ideal for comprehensive testing without formal verification overhead"
      - "Streak calculations involve date logic requiring property testing to cover edge cases like month/year boundaries, timezone transitions, and leap years"
      - "Achievement unlock conditions tested exhaustively with parameterized tests to verify all milestone thresholds trigger correctly"
      - "Time-series aggregation correctness verified through sum/count invariants ensuring daily totals match global statistics"

  implementation:
    file: "tests/statistics_tests.rs"
    location: "create new"
    code: |
      //! Comprehensive tests for Statistics and Progress Visualization (Task 10)
      //! 
      //! This module tests all critical properties of the statistics system including:
      //! - Accuracy calculations
      //! - Streak tracking and resets
      //! - Achievement unlock conditions
      //! - Time-series aggregations
      //! - Date boundary handling
      //! - Mathematical invariants

      use chrono::{NaiveDate, Duration};
      use std::collections::{BTreeMap, HashSet};

      // Import from src/statistics.rs and src/achievements.rs when implemented
      // For now, using mock structures for specification

      #[derive(Debug, Clone, PartialEq)]
      struct Statistics {
          total_reviews: u32,
          correct_reviews: u32,
          current_streak: u32,
          longest_streak: u32,
          cards_new: u32,
          cards_learning: u32,
          cards_mature: u32,
          study_days: HashSet<NaiveDate>,
          daily_stats: BTreeMap<NaiveDate, DayStats>,
          total_study_time_seconds: u32,
          achievements_unlocked: HashSet<Achievement>,
      }

      #[derive(Debug, Clone, PartialEq)]
      struct DayStats {
          date: NaiveDate,
          total_reviews: u32,
          correct_reviews: u32,
          study_time_seconds: u32,
      }

      #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
      enum Achievement {
          FirstReview,
          Streak7,
          Streak30,
          Streak100,
          Reviews100,
          Reviews500,
          Reviews1000,
          Accuracy90,
          PerfectDay,
          Cards100Mastered,
          Cards500Mastered,
      }

      impl Statistics {
          fn new() -> Self {
              Self {
                  total_reviews: 0,
                  correct_reviews: 0,
                  current_streak: 0,
                  longest_streak: 0,
                  cards_new: 0,
                  cards_learning: 0,
                  cards_mature: 0,
                  study_days: HashSet::new(),
                  daily_stats: BTreeMap::new(),
                  total_study_time_seconds: 0,
                  achievements_unlocked: HashSet::new(),
              }
          }

          fn accuracy_rate(&self) -> f64 {
              if self.total_reviews == 0 {
                  0.0
              } else {
                  (self.correct_reviews as f64 / self.total_reviews as f64) * 100.0
              }
          }

          fn record_review(&mut self, date: NaiveDate, correct: bool, time_seconds: u32) {
              self.total_reviews += 1;
              if correct {
                  self.correct_reviews += 1;
              }
              self.total_study_time_seconds += time_seconds;

              let day_stats = self.daily_stats.entry(date).or_insert_with(|| DayStats::new(date));
              day_stats.total_reviews += 1;
              if correct {
                  day_stats.correct_reviews += 1;
              }
              day_stats.study_time_seconds += time_seconds;

              self.record_study_day(date);
          }

          fn record_study_day(&mut self, date: NaiveDate) {
              if !self.study_days.contains(&date) {
                  self.study_days.insert(date);
                  self.update_streak(date);
              }
          }

          fn update_streak(&mut self, new_date: NaiveDate) {
              self.current_streak = self.calculate_streak_up_to(new_date);
              if self.current_streak > self.longest_streak {
                  self.longest_streak = self.current_streak;
              }
          }

          fn calculate_streak_up_to(&self, end_date: NaiveDate) -> u32 {
              let mut streak = 0;
              let mut current_date = end_date;
              
              loop {
                  if self.study_days.contains(&current_date) {
                      streak += 1;
                      current_date = current_date - Duration::days(1);
                  } else {
                      break;
                  }
              }
              
              streak
          }

          fn total_cards(&self) -> u32 {
              self.cards_new + self.cards_learning + self.cards_mature
          }

          fn average_review_time_seconds(&self) -> u32 {
              if self.total_reviews == 0 {
                  0
              } else {
                  self.total_study_time_seconds / self.total_reviews
              }
          }

          fn check_achievements(&mut self) {
              if self.total_reviews >= 1 {
                  self.achievements_unlocked.insert(Achievement::FirstReview);
              }
              if self.current_streak >= 7 {
                  self.achievements_unlocked.insert(Achievement::Streak7);
              }
              if self.current_streak >= 30 {
                  self.achievements_unlocked.insert(Achievement::Streak30);
              }
              if self.current_streak >= 100 {
                  self.achievements_unlocked.insert(Achievement::Streak100);
              }
              if self.total_reviews >= 100 {
                  self.achievements_unlocked.insert(Achievement::Reviews100);
              }
              if self.total_reviews >= 500 {
                  self.achievements_unlocked.insert(Achievement::Reviews500);
              }
              if self.total_reviews >= 1000 {
                  self.achievements_unlocked.insert(Achievement::Reviews1000);
              }
              if self.total_reviews >= 100 && self.accuracy_rate() >= 90.0 {
                  self.achievements_unlocked.insert(Achievement::Accuracy90);
              }
              if self.cards_mature >= 100 {
                  self.achievements_unlocked.insert(Achievement::Cards100Mastered);
              }
              if self.cards_mature >= 500 {
                  self.achievements_unlocked.insert(Achievement::Cards500Mastered);
              }
              for day_stats in self.daily_stats.values() {
                  if day_stats.total_reviews >= 10 && day_stats.accuracy_rate() == 100.0 {
                      self.achievements_unlocked.insert(Achievement::PerfectDay);
                      break;
                  }
              }
          }

          fn update_card_status(&mut self, interval_days: u32) {
              if interval_days == 0 {
                  self.cards_new += 1;
              } else if interval_days < 21 {
                  self.cards_learning += 1;
              } else {
                  self.cards_mature += 1;
              }
          }
      }

      impl DayStats {
          fn new(date: NaiveDate) -> Self {
              Self {
                  date,
                  total_reviews: 0,
                  correct_reviews: 0,
                  study_time_seconds: 0,
              }
          }

          fn accuracy_rate(&self) -> f64 {
              if self.total_reviews == 0 {
                  0.0
              } else {
                  (self.correct_reviews as f64 / self.total_reviews as f64) * 100.0
              }
          }
      }

      #[cfg(test)]
      mod unit_tests {
          use super::*;

          #[test]
          fn test_accuracy_calculation_zero_reviews() {
              let stats = Statistics::new();
              assert_eq!(stats.accuracy_rate(), 0.0);
          }

          #[test]
          fn test_accuracy_calculation_all_correct() {
              let mut stats = Statistics::new();
              stats.total_reviews = 10;
              stats.correct_reviews = 10;
              assert_eq!(stats.accuracy_rate(), 100.0);
          }

          #[test]
          fn test_streak_increments_consecutive_days() {
              let mut stats = Statistics::new();
              stats.record_study_day(NaiveDate::from_ymd_opt(2024, 1, 1).unwrap());
              assert_eq!(stats.current_streak, 1);
              stats.record_study_day(NaiveDate::from_ymd_opt(2024, 1, 2).unwrap());
              assert_eq!(stats.current_streak, 2);
          }

          #[test]
          fn test_streak_resets_on_skip() {
              let mut stats = Statistics::new();
              stats.record_study_day(NaiveDate::from_ymd_opt(2024, 1, 1).unwrap());
              stats.record_study_day(NaiveDate::from_ymd_opt(2024, 1, 2).unwrap());
              stats.record_study_day(NaiveDate::from_ymd_opt(2024, 1, 4).unwrap());
              assert_eq!(stats.current_streak, 1);
          }

          #[test]
          fn test_achievement_unlock_first_review() {
              let mut stats = Statistics::new();
              stats.total_reviews = 1;
              stats.check_achievements();
              assert!(stats.achievements_unlocked.contains(&Achievement::FirstReview));
          }

          #[test]
          fn test_cards_mature_threshold_21_days() {
              let mut stats = Statistics::new();
              stats.update_card_status(20);
              assert_eq!(stats.cards_learning, 1);
              stats.update_card_status(21);
              assert_eq!(stats.cards_mature, 1);
          }
      }

      #[cfg(test)]
      mod property_tests {
          use super::*;
          use proptest::prelude::*;

          proptest! {
              #[test]
              fn prop_accuracy_always_between_0_and_100(
                  total in 1u32..1000,
                  correct in 0u32..1000
              ) {
                  let correct = correct.min(total);
                  let mut stats = Statistics::new();
                  stats.total_reviews = total;
                  stats.correct_reviews = correct;
                  let accuracy = stats.accuracy_rate();
                  prop_assert!(accuracy >= 0.0 && accuracy <= 100.0);
              }

              #[test]
              fn prop_longest_streak_never_less_than_current(
                  days in prop::collection::vec(1i32..365i32, 1..50)
              ) {
                  let mut stats = Statistics::new();
                  let base = NaiveDate::from_ymd_opt(2024, 1, 1).unwrap();
                  for day in days {
                      stats.record_study_day(base + Duration::days(day as i64));
                  }
                  prop_assert!(stats.longest_streak >= stats.current_streak);
              }
          }
      }

  coverage:
    - "Accuracy calculation returns 0% with zero reviews"
    - "Accuracy calculation returns 100% when all reviews correct"
    - "Accuracy calculation computes correct percentage for partial correct"
    - "Streak increments by 1 for consecutive study days"
    - "Streak resets to 1 when a day is skipped"
    - "Longest streak tracks maximum consecutive days"
    - "Longest streak persists after current streak is broken"
    - "Same day multiple reviews don't duplicate streak count"
    - "Daily stats aggregate reviews, correct count, and time per day"
    - "Multiple days maintain separate DayStats entries"
    - "Total reviews equals sum of all daily review counts"
    - "Cards with interval >= 21 days classified as mature"
    - "Cards with interval < 21 days classified as learning"
    - "Achievement unlocks at milestone thresholds (first review, 100 reviews, 7-day streak, etc.)"
    - "Achievement PerfectDay requires 10+ reviews with 100% accuracy in a day"
    - "Total study time accumulates across all reviews"
    - "Streak continues correctly across month boundaries"
    - "Streak continues correctly across year boundaries"
    - "Streak handles leap year correctly"
    - "BTreeMap enables efficient date range queries"
    - "Property: Accuracy always between 0.0 and 100.0"
    - "Property: Total reviews equals sum of daily reviews"
    - "Property: Current streak never exceeds total study days"
    - "Property: Longest streak always >= current streak"
    - "Property: Correct reviews never exceeds total reviews"
    - "Property: Study time always non-negative"
    - "Property: Card counts always non-negative"

dependencies:
  depends_on:
    - task_id: 6
      reason: "Requires navigation framework for statistics screen routing and state management"

  depended_upon_by:
    - task_id: 11
      reason: "Database layer must persist Statistics struct and achievement data"

  external:
    - name: "chrono::NaiveDate"
      type: "struct"
      status: "to be imported"
    - name: "chrono::Duration"
      type: "struct"
      status: "to be imported"
    - name: "std::collections::BTreeMap"
      type: "struct"
      status: "to be imported"
    - name: "std::collections::HashSet"
      type: "struct"
      status: "to be imported"
    - name: "iced::Element"
      type: "struct"
      status: "to be imported"
    - name: "iced::Color"
      type: "struct"
      status: "to be imported"
    - name: "LearningSession"
      type: "struct"
      status: "already exists"
    - name: "Card"
      type: "struct"
      status: "already exists"
---
task:
  id: 11
  name: "Local Persistence and Database Layer"

context:
  description: |
    This task implements a robust local data persistence layer using the redb embedded database
    to store all critical application data including user progress, flashcard state, review history,
    settings, and statistics. The persistence layer serves as the foundation for data integrity
    and user trust in the application.
    
    The architectural significance is paramount: without reliable persistence, users lose their
    learning progress, which destroys motivation and trust. An embedded database like redb provides
    ACID (Atomicity, Consistency, Isolation, Durability) transactional guarantees without requiring
    external database services, making the application self-contained and portable.
    
    The implementation wraps redb in a type-safe AppDatabase interface that handles serialization
    (using bincode for efficiency), manages transactions, resolves platform-appropriate file paths,
    and provides backup/restore capabilities for disaster recovery. The layer must handle concurrent
    access safely, survive application crashes without data loss, and enable data portability.
    
    This task enables the Learning Session (Task 8) to persist user progress and provides the
    foundation for Statistics tracking (Task 9). It depends on data structures from Task 2 (core
    data models) and Task 7 (SM2Card spaced repetition structure).

  key_points:
    - "redb provides ACID guarantees without external dependencies - embedded database is ideal for desktop applications"
    - "Platform-independent path resolution using directories crate ensures correct data location on Linux/Windows/macOS"
    - "Bincode serialization for storage efficiency and speed; JSON export for human-readable backups"
    - "Batch operations minimize write transaction overhead - critical for session save performance"
    - "Read transactions are cheap and non-blocking; write transactions are exclusive and must be minimized"
    - "Backup/restore functionality is essential for disaster recovery and user data portability"
    - "Database compaction strategy needed for long-term use to reclaim space from deleted records"
    - "Transaction atomicity ensures all-or-nothing semantics - prevents partial state corruption"

files:
  - path: "src/persistence/mod.rs"
    description: "Persistence module root that declares and exports database, schema, crud, and backup submodules"
  
  - path: "src/persistence/database.rs"
    description: "Defines AppDatabase struct wrapping redb::Database with initialization, connection management, and transaction helpers"
  
  - path: "src/persistence/schema.rs"
    description: "Defines redb TableDefinition constants for cards, reviews, settings, and statistics tables with typed key-value pairs"
  
  - path: "src/persistence/crud.rs"
    description: "Implements CRUD operations (save_card, load_card, update_card, delete_card, etc.) for all data types with serialization using bincode"
  
  - path: "src/persistence/batch.rs"
    description: "Provides batch operation functions (save_cards_batch, save_reviews_batch) for efficient multi-record writes in single transaction"
  
  - path: "src/persistence/backup.rs"
    description: "Implements export_to_json and import_from_json functions for database backup and restore with human-readable JSON format"
  
  - path: "tests/persistence_tests.rs"
    description: "Integration tests for database operations verifying ACID properties, data integrity, serialization, backup/restore, and concurrent access"

functions:
  - file: "src/persistence/mod.rs"
    items:
      - type: "module_declaration"
        name: "database"
        description: "Database connection management and core AppDatabase wrapper"

      - type: "module_declaration"
        name: "schema"
        description: "redb table definitions and serializable data structures"

      - type: "module_declaration"
        name: "crud"
        description: "CRUD operations for cards, reviews, settings, and statistics"

      - type: "module_declaration"
        name: "batch"
        description: "Batch operation implementations for efficient multi-record transactions"

      - type: "module_declaration"
        name: "backup"
        description: "Database backup and restore functionality"

      - type: "module_declaration"
        name: "error"
        description: "Database error types and conversions"

  - file: "src/persistence/database.rs"
    items:
      - type: "struct"
        name: "AppDatabase"
        description: "Wrapper around redb::Database providing type-safe, transactional operations for all persistent data with connection management and table initialization"
        invariants: "Database connection remains valid throughout lifetime; all operations are ACID-compliant; tables are initialized on creation"

      - type: "method"
        name: "AppDatabase::new"
        description: "Creates or opens the database at the platform-appropriate path, initializing all required tables"
        preconditions: "File system access available; parent directory exists or can be created"
        postconditions: "Database file exists and is ready for operations; all tables initialized; directory structure created if needed"

      - type: "method"
        name: "AppDatabase::open"
        description: "Opens an existing database at a specific path without creating a new one"
        preconditions: "Database file exists at given path and is valid redb format"
        postconditions: "Database connection established and validated; tables accessible"

      - type: "method"
        name: "AppDatabase::default_db_path"
        description: "Returns the platform-appropriate path for the database file using directories crate (XDG on Linux, AppData on Windows, Application Support on macOS)"
        postconditions: "Returns PathBuf to data directory; creates directory structure if needed"

      - type: "method"
        name: "AppDatabase::close"
        description: "Explicitly closes the database connection and flushes pending writes to disk"
        postconditions: "All pending transactions committed; database file closed cleanly; resources released"

      - type: "method"
        name: "AppDatabase::begin_read"
        description: "Begins a read transaction for querying database contents without blocking other reads"
        postconditions: "Returns redb ReadTransaction; transaction is non-blocking; provides snapshot isolation"

      - type: "method"
        name: "AppDatabase::begin_write"
        description: "Begins a write transaction with exclusive access for modifying database contents"
        preconditions: "No other write transaction is active"
        postconditions: "Returns redb WriteTransaction; exclusive access granted; blocks other writes until commit/abort"

  - file: "src/persistence/schema.rs"
    items:
      - type: "constant"
        name: "CARDS_TABLE"
        description: "TableDefinition<&str, &[u8]> for cards storage mapping CardId (String) to serialized SM2Card (bincode)"

      - type: "constant"
        name: "REVIEWS_TABLE"
        description: "TableDefinition<(&str, u64), &[u8]> for review history mapping (CardId, Timestamp) composite key to serialized ReviewRecord"

      - type: "constant"
        name: "SETTINGS_TABLE"
        description: "TableDefinition<&str, &[u8]> for application settings mapping String key to serialized value (generic via bincode)"

      - type: "constant"
        name: "STATISTICS_TABLE"
        description: "TableDefinition<&str, &[u8]> for statistics data mapping String key to serialized StatisticsData"

      - type: "struct"
        name: "ReviewRecord"
        description: "Serializable record of a single review event with timestamp, quality rating, interval changes, and easiness factor changes for statistics tracking"

      - type: "struct"
        name: "StatisticsData"
        description: "Serializable aggregate statistics data including total reviews, cards learned, study time, average quality, and streak information"

      - type: "struct"
        name: "AppSettings"
        description: "Serializable application settings structure for user preferences including cards per session, sound, theme, and backup settings"

  - file: "src/persistence/crud.rs"
    items:
      - type: "method"
        name: "AppDatabase::save_card"
        description: "Saves a single SM2Card to the database in a write transaction using bincode serialization"
        preconditions: "Card has valid non-empty CardId; card data is serializable"
        postconditions: "Card persisted to disk with ACID guarantees; previous version overwritten if exists"

      - type: "method"
        name: "AppDatabase::load_card"
        description: "Loads a single card by CardId from the database and deserializes from bincode"
        preconditions: "CardId is valid non-empty string"
        postconditions: "Returns Result<SM2Card, DatabaseError>; Ok(card) if exists and deserializable, Err otherwise"

      - type: "method"
        name: "AppDatabase::delete_card"
        description: "Removes a card from the database by CardId in a write transaction"
        preconditions: "CardId is valid"
        postconditions: "Card no longer exists in database; associated reviews optionally deleted based on cascade parameter"

      - type: "method"
        name: "AppDatabase::load_all_cards"
        description: "Loads all cards from the database into a Vec by iterating the CARDS_TABLE"
        postconditions: "Returns Result<Vec<SM2Card>, DatabaseError>; empty Vec if no cards exist; all valid cards deserialized"

      - type: "method"
        name: "AppDatabase::save_review"
        description: "Saves a ReviewRecord to the review history table with composite key (CardId, Timestamp)"
        preconditions: "ReviewRecord has valid non-empty CardId and valid timestamp"
        postconditions: "Review persisted with composite key; can be queried by card ID or timestamp range"

      - type: "method"
        name: "AppDatabase::load_reviews_for_card"
        description: "Loads all review history for a specific card by CardId, ordered chronologically"
        preconditions: "CardId is valid non-empty string"
        postconditions: "Returns Result<Vec<ReviewRecord>, DatabaseError> in chronological order (oldest to newest)"

      - type: "method"
        name: "AppDatabase::load_reviews_in_range"
        description: "Loads reviews within a timestamp range for statistics calculation"
        preconditions: "Start timestamp <= end timestamp; both are valid"
        postconditions: "Returns Result<Vec<ReviewRecord>, DatabaseError> within inclusive range, sorted by timestamp"

      - type: "method"
        name: "AppDatabase::save_setting"
        description: "Persists a single setting key-value pair using generic serialization via bincode"
        preconditions: "Key is non-empty string; value is serializable type"
        postconditions: "Setting persisted to SETTINGS_TABLE; previous value overwritten if exists"

      - type: "method"
        name: "AppDatabase::load_setting"
        description: "Loads a setting by key, deserializing to specified type parameter T"
        preconditions: "Type parameter T matches serialized type; key is non-empty"
        postconditions: "Returns Result<Option<T>, DatabaseError>; Some(value) if exists and deserializable, None if key not found, Err on deserialization failure"

      - type: "method"
        name: "AppDatabase::save_statistics"
        description: "Persists StatisticsData under a given key (typically date-based for historical tracking)"
        preconditions: "StatisticsData is valid and serializable; key is non-empty"
        postconditions: "Statistics persisted to STATISTICS_TABLE"

      - type: "method"
        name: "AppDatabase::load_statistics"
        description: "Loads StatisticsData by key for display or analysis"
        preconditions: "Key is non-empty string"
        postconditions: "Returns Result<Option<StatisticsData>, DatabaseError>; Some if exists, None otherwise"

  - file: "src/persistence/batch.rs"
    items:
      - type: "method"
        name: "AppDatabase::save_cards_batch"
        description: "Saves multiple cards in a single write transaction for efficiency, achieving <100ms for 50 cards"
        preconditions: "All cards have valid non-empty CardIds; all cards are serializable"
        postconditions: "All cards persisted atomically in single transaction; transaction fails completely if any card invalid; no partial writes"

      - type: "method"
        name: "AppDatabase::save_reviews_batch"
        description: "Saves multiple ReviewRecords in a single write transaction for session end efficiency"
        preconditions: "All ReviewRecords have valid CardIds and timestamps"
        postconditions: "All reviews persisted atomically; complete transaction rollback on any failure"

      - type: "method"
        name: "AppDatabase::update_cards_batch"
        description: "Updates multiple existing cards in a single transaction (for session progress saves)"
        preconditions: "All cards exist in database; all have valid CardIds"
        postconditions: "All cards updated atomically with new state (intervals, easiness factors, due dates)"

  - file: "src/persistence/backup.rs"
    items:
      - type: "struct"
        name: "DatabaseBackup"
        description: "Serializable container for entire database contents including cards, reviews, settings, and statistics in portable JSON or bincode format"

      - type: "struct"
        name: "BackupMetadata"
        description: "Metadata for a backup file including path, timestamp, size, and format (JSON or bincode)"

      - type: "method"
        name: "AppDatabase::export_to_json"
        description: "Exports entire database to a JSON file for human-readable backup with pretty-printing"
        preconditions: "Output path is writable; parent directory exists or can be created"
        postconditions: "JSON file created with all database contents; file is valid JSON; includes version information for compatibility"

      - type: "method"
        name: "AppDatabase::export_to_bincode"
        description: "Exports entire database to bincode format for compact, fast backup"
        preconditions: "Output path is writable"
        postconditions: "Bincode file created with all database contents; optionally compressed with gzip"

      - type: "method"
        name: "AppDatabase::import_from_json"
        description: "Imports database from JSON backup file, replacing current data after validation"
        preconditions: "JSON file exists and is valid DatabaseBackup format; database is writable; version compatible"
        postconditions: "Database contents replaced with imported data in atomic transaction; old data completely replaced"

      - type: "method"
        name: "AppDatabase::import_from_bincode"
        description: "Imports database from bincode backup file with decompression if needed"
        preconditions: "Bincode file exists and is valid DatabaseBackup format; version compatible"
        postconditions: "Database contents replaced with imported data; old data overwritten"

      - type: "method"
        name: "AppDatabase::create_backup"
        description: "Creates a timestamped backup in the standard platform-appropriate backup directory (e.g., backups/japanese_flashcards_20250308_143022.json)"
        postconditions: "Backup file created with ISO 8601 timestamp in filename; returns PathBuf to backup file"

      - type: "method"
        name: "AppDatabase::list_backups"
        description: "Lists all available backups in the backup directory with metadata (timestamp, size, format)"
        postconditions: "Returns Result<Vec<BackupMetadata>, DatabaseError> sorted by timestamp descending (newest first)"

      - type: "method"
        name: "AppDatabase::restore_from_backup"
        description: "Restores database from a specific backup file, creating safety backup of current state first"
        preconditions: "Backup file exists and is valid; backup format is compatible"
        postconditions: "Database restored to backup state; current data backed up to safety backup before replacement; returns path to safety backup"

  - file: "src/persistence/error.rs"
    items:
      - type: "enum"
        name: "DatabaseError"
        description: "Comprehensive error type for database operations including IO errors, serialization failures, corruption detection, not found errors, and version incompatibility"

      - type: "enum_variant"
        name: "DatabaseError::IoError"
        description: "Wraps std::io::Error for file system operations"

      - type: "enum_variant"
        name: "DatabaseError::SerializationError"
        description: "Wraps bincode::Error for serialization/deserialization failures"

      - type: "enum_variant"
        name: "DatabaseError::RedbError"
        description: "Wraps redb::Error for database-level errors"

      - type: "enum_variant"
        name: "DatabaseError::NotFound"
        description: "Entity not found error with entity type and ID (e.g., Card not found: card_123)"

      - type: "enum_variant"
        name: "DatabaseError::CorruptedData"
        description: "Data corruption detected during deserialization with details"

      - type: "enum_variant"
        name: "DatabaseError::InvalidKey"
        description: "Invalid or empty key provided for operation"

      - type: "enum_variant"
        name: "DatabaseError::VersionMismatch"
        description: "Backup file version incompatible with current database schema"

      - type: "trait_impl"
        name: "std::fmt::Display for DatabaseError"
        description: "Human-readable error messages for database errors with context"

      - type: "trait_impl"
        name: "std::error::Error for DatabaseError"
        description: "Standard Error trait implementation enabling error chain propagation"

      - type: "trait_impl"
        name: "From<redb::Error> for DatabaseError"
        description: "Automatic conversion from redb errors to DatabaseError::RedbError variant"

      - type: "trait_impl"
        name: "From<bincode::Error> for DatabaseError"
        description: "Automatic conversion from bincode errors to DatabaseError::SerializationError variant"

      - type: "trait_impl"
        name: "From<std::io::Error> for DatabaseError"
        description: "Automatic conversion from IO errors to DatabaseError::IoError variant"

      - type: "trait_impl"
        name: "From<serde_json::Error> for DatabaseError"
        description: "Automatic conversion from JSON errors during backup/restore"

formal_verification:
  needed: false
  level: "None"
  explanation: |
    Formal verification is not required for the Local Persistence and Database Layer for several
    critical reasons:

    1. **ACID Guarantees Delegated to redb**: The core correctness properties (Atomicity, 
       Consistency, Isolation, Durability) are provided by the underlying redb embedded database
       library, which has been tested and verified by its maintainers. The application code serves
       as a type-safe wrapper that delegates transactional safety to redb.

    2. **Empirically Testable Properties**: All key correctness requirements are directly observable
       and verifiable through comprehensive integration and concurrency testing:
       - Data persistence across application restarts (integration tests)
       - Transaction atomicity with rollback scenarios (integration tests)
       - Non-blocking concurrent reads (concurrency tests)
       - Properly serialized writes (race condition tests)
       - Backup/restore data fidelity (roundtrip tests)

    3. **Limited Algorithmic Complexity**: The persistence layer primarily performs CRUD operations
       with straightforward serialization/deserialization using bincode. There are no complex
       algorithms or subtle invariants that would benefit from formal verification.

    4. **Appropriate Risk Mitigation**: The task's risk mitigation strategy is comprehensive without
       formal verification: backup/restore for disaster recovery, transactional safety from redb,
       comprehensive integration tests, and batch operations to minimize conflicts.

    5. **Cost-Benefit Analysis Unfavorable**: Formal verification would require formal specification
       of redb's ACID guarantees (external dependency), proofs of serialization semantics, and
       verification of concurrent access patterns - substantial effort with minimal marginal benefit
       over the comprehensive testing strategy already planned (15 integration tests).

    6. **Rust's Type System Provides Lightweight Verification**: The type-safe API wrapper already
       prevents many error classes at compile time through type safety, ownership preventing data
       races, Result types enforcing error handling, and lifetime annotations preventing
       use-after-free.

    The combination of delegated ACID guarantees from redb, comprehensive testing, Rust's type
    system safety, and backup/restore functionality provides adequate assurance of correctness
    without the substantial cost of formal verification.

tests:
  strategy:
    approach: "mixed (unit + integration + concurrency + property-based)"
    rationale:
      - "Database operations require integration tests with actual redb instances to verify ACID properties and persistence across application restarts"
      - "Unit tests validate serialization/deserialization logic independently, ensuring data integrity without database overhead"
      - "Concurrency tests verify thread-safety of read/write operations and proper transaction isolation in multi-threaded scenarios"
      - "Performance tests validate batch operation efficiency meets the acceptance criteria of <100ms for 50 cards"
      - "Property-based tests ensure serialization round-trips preserve all data fields correctly across diverse inputs"
      - "Integration tests verify platform-specific path resolution works correctly on Linux/Windows/macOS"
      - "Backup/restore tests ensure data portability and disaster recovery functionality with complete fidelity"
      - "Error handling tests verify graceful degradation when encountering corrupted data or I/O failures"

  implementation:
    file: "tests/persistence_tests.rs"
    location: "create new"
    code: |
      //! Comprehensive integration and unit tests for the persistence layer
      //! Tests cover database initialization, CRUD operations, ACID properties,
      //! concurrency, backup/restore, and platform-specific behavior.

      use std::collections::HashSet;
      use std::sync::Arc;
      use std::thread;
      use std::time::{Duration, Instant};
      use tempfile::TempDir;
      use serde::{Deserialize, Serialize};
      use chrono::{DateTime, Utc};

      // Test data structures - in production imported from actual modules
      #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
      struct SM2Card {
          id: String,
          front: String,
          back: String,
          easiness_factor: f64,
          interval: u32,
          repetitions: u32,
          due_date: DateTime<Utc>,
      }

      #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
      struct ReviewRecord {
          card_id: String,
          timestamp: DateTime<Utc>,
          quality: u8,
          interval_before: u32,
          interval_after: u32,
          easiness_before: f64,
          easiness_after: f64,
      }

      // Helper functions for test data generation
      fn create_test_db() -> (AppDatabase, TempDir) {
          let temp_dir = TempDir::new().expect("Failed to create temp directory");
          let db_path = temp_dir.path().join("test.db");
          let db = AppDatabase::new(&db_path).expect("Failed to create database");
          (db, temp_dir)
      }

      fn create_sample_card(id: &str) -> SM2Card {
          SM2Card {
              id: id.to_string(),
              front: format!("Front {}", id),
              back: format!("Back {}", id),
              easiness_factor: 2.5,
              interval: 0,
              repetitions: 0,
              due_date: Utc::now(),
          }
      }

      fn create_sample_cards(count: usize) -> Vec<SM2Card> {
          (0..count).map(|i| create_sample_card(&format!("card_{}", i))).collect()
      }

      // ============================================================================
      // UNIT TESTS: Serialization/Deserialization
      // ============================================================================

      #[cfg(test)]
      mod serialization_tests {
          use super::*;

          #[test]
          fn test_bincode_card_serialization_roundtrip() {
              let card = create_sample_card("test_card");
              let encoded = bincode::serialize(&card).expect("Failed to serialize card");
              let decoded: SM2Card = bincode::deserialize(&encoded).expect("Failed to deserialize card");
              
              assert_eq!(decoded.id, card.id);
              assert_eq!(decoded.front, card.front);
              assert_eq!(decoded.back, card.back);
              assert_eq!(decoded.easiness_factor, card.easiness_factor);
          }

          #[test]
          fn test_serialization_with_special_characters() {
              let card = SM2Card {
                  id: "test".to_string(),
                  front: "あ".to_string(),  // Hiragana
                  back: "ア".to_string(),   // Katakana
                  easiness_factor: 2.5,
                  interval: 0,
                  repetitions: 0,
                  due_date: Utc::now(),
              };
              
              let encoded = bincode::serialize(&card).expect("Failed to serialize");
              let decoded: SM2Card = bincode::deserialize(&encoded).expect("Failed to deserialize");
              
              assert_eq!(decoded.front, "あ");
              assert_eq!(decoded.back, "ア");
          }
      }

      // ============================================================================
      // INTEGRATION TESTS: Card CRUD Operations
      // ============================================================================

      #[cfg(test)]
      mod card_operations_tests {
          use super::*;

          #[test]
          fn test_save_and_load_single_card() {
              let (db, _temp) = create_test_db();
              let card = create_sample_card("test_card");
              
              db.save_card(&card).expect("Failed to save card");
              let loaded = db.load_card(&card.id).expect("Failed to load card");
              
              assert_eq!(loaded.id, card.id);
              assert_eq!(loaded.front, card.front);
          }

          #[test]
          fn test_delete_card() {
              let (db, _temp) = create_test_db();
              let card = create_sample_card("card_to_delete");
              
              db.save_card(&card).expect("Failed to save card");
              db.delete_card(&card.id).expect("Failed to delete card");
              assert!(db.load_card(&card.id).is_err(), "Card should not exist after deletion");
          }
      }

      // ============================================================================
      // INTEGRATION TESTS: Batch Operations and Performance
      // ============================================================================

      #[cfg(test)]
      mod batch_operations_tests {
          use super::*;

          #[test]
          fn test_batch_save_50_cards_under_100ms() {
              let (db, _temp) = create_test_db();
              let cards = create_sample_cards(50);
              
              let start = Instant::now();
              db.save_cards_batch(&cards).expect("Failed to save cards batch");
              let duration = start.elapsed();
              
              assert!(
                  duration < Duration::from_millis(100),
                  "Batch save of 50 cards took {:?}, expected <100ms",
                  duration
              );
          }
      }

      // ============================================================================
      // INTEGRATION TESTS: Data Persistence Across Restarts
      // ============================================================================

      #[cfg(test)]
      mod persistence_tests {
          use super::*;

          #[test]
          fn test_card_data_survives_database_restart() {
              let temp_dir = TempDir::new().expect("Failed to create temp dir");
              let db_path = temp_dir.path().join("test.db");
              let card = create_sample_card("persistent_card");
              
              {
                  let db = AppDatabase::new(&db_path).expect("Failed to create database");
                  db.save_card(&card).expect("Failed to save card");
              }
              
              {
                  let db = AppDatabase::new(&db_path).expect("Failed to reopen database");
                  let loaded = db.load_card(&card.id).expect("Failed to load card after restart");
                  assert_eq!(loaded.id, card.id);
              }
          }
      }

      // ============================================================================
      // CONCURRENCY TESTS: Thread-Safety and Transaction Isolation
      // ============================================================================

      #[cfg(test)]
      mod concurrency_tests {
          use super::*;

          #[test]
          fn test_concurrent_reads_dont_block() {
              let (db, _temp) = create_test_db();
              let cards = create_sample_cards(10);
              
              for card in &cards {
                  db.save_card(card).expect("Failed to save card");
              }
              
              let db = Arc::new(db);
              let handles: Vec<_> = (0..10).map(|i| {
                  let db_clone = Arc::clone(&db);
                  let card_id = format!("card_{}", i);
                  
                  thread::spawn(move || {
                      db_clone.load_card(&card_id).expect("Failed to load card")
                  })
              }).collect();
              
              let results: Vec<_> = handles.into_iter()
                  .map(|h| h.join().expect("Thread panicked"))
                  .collect();
              
              assert_eq!(results.len(), 10);
          }
      }

      // ============================================================================
      // PROPERTY-BASED TESTS
      // ============================================================================

      #[cfg(test)]
      mod property_tests {
          use super::*;
          use proptest::prelude::*;

          proptest! {
              #[test]
              fn test_card_serialization_roundtrip_preserves_all_fields(
                  id in "[a-z0-9_]{1,50}",
                  front in ".{1,100}",
                  back in ".{1,100}",
              ) {
                  let card = SM2Card {
                      id: id.clone(),
                      front: front.clone(),
                      back: back.clone(),
                      easiness_factor: 2.5,
                      interval: 0,
                      repetitions: 0,
                      due_date: Utc::now(),
                  };
                  
                  let encoded = bincode::serialize(&card).unwrap();
                  let decoded: SM2Card = bincode::deserialize(&encoded).unwrap();
                  
                  prop_assert_eq!(decoded.id, id);
                  prop_assert_eq!(decoded.front, front);
              }
          }
      }

  coverage:
    - "Database initialization creates file and tables correctly"
    - "Database opens existing files without corruption"
    - "Parent directories are created automatically when needed"
    - "Single card save and load with complete data integrity"
    - "Card update replaces existing data correctly"
    - "Loading non-existent card returns appropriate error"
    - "Card deletion removes data completely from database"
    - "Batch save of 50 cards completes in under 100ms (performance requirement)"
    - "Batch save persists all cards correctly"
    - "Batch operations are atomic - all-or-nothing on error"
    - "Review history save and load with accurate timestamps"
    - "Multiple reviews for single card load in chronological order"
    - "Settings stored and loaded with all fields preserved"
    - "Statistics data saves and loads with precision maintained"
    - "Card data survives database close and reopen (persistence)"
    - "Review history persists across application restart"
    - "Settings survive database restart"
    - "Statistics data survives restart"
    - "Concurrent reads don't block each other (non-blocking reads)"
    - "Concurrent writes serialize correctly without data loss"
    - "Concurrent read/write operations don't corrupt database"
    - "Export to JSON produces valid, parseable JSON file"
    - "JSON backup/restore roundtrip preserves all data types"
    - "Bincode backup/restore roundtrip preserves data"
    - "Import from corrupted JSON handled gracefully"
    - "Default database path follows platform conventions (Linux/Windows/macOS)"
    - "Corrupted data handled without application crash"
    - "Very long strings serialized and loaded correctly"
    - "Database compaction preserves all data without loss"
    - "Bincode serialization roundtrip preserves all card fields (property-based)"

dependencies:
  depends_on:
    - task_id: 2
      reason: "Needs data structures defined to persist (Card, CardSet, etc.)"
    - task_id: 7
      reason: "Needs SM2Card structure with spaced repetition fields to persist learning progress"

  depended_upon_by:
    - task_id: 8
      reason: "Learning session needs persistence to save user progress, review history, and session state"
    - task_id: 9
      reason: "Statistics tracking requires persistence to store and retrieve historical statistics data"
    - task_id: 10
      reason: "Settings management uses persistence to store and load user preferences"

  external:
    - name: "redb"
      type: "crate"
      status: "to be imported"
    - name: "bincode"
      type: "crate"
      status: "to be imported"
    - name: "serde"
      type: "crate"
      status: "already exists"
    - name: "directories"
      type: "crate"
      status: "to be imported"
    - name: "chrono"
      type: "crate"
      status: "to be imported"
    - name: "serde_json"
      type: "crate"
      status: "to be imported"
---
task:
  id: 12
  name: "Visual Feedback and Animation Polish"

context:
  description: |
    This task implements a comprehensive visual feedback and animation system that provides
    immediate, clear feedback to users during their learning sessions. The system includes
    animated responses for correct/incorrect answers, progress indicators for session tracking,
    achievement celebration popups, and polished micro-interactions throughout the UI.
    
    Visual feedback is crucial for effective learning applications. Research shows that immediate,
    clear feedback significantly improves learning outcomes and user engagement. By providing
    both visual (color, icons, animations) and kinetic (shake, bounce) feedback, the application
    reinforces learning while maintaining accessibility standards.
    
    The implementation follows modern UI/UX principles with smooth 60fps animations, WCAG AA
    compliant colors, and support for reduced motion preferences. All animations use carefully
    chosen easing curves: EaseOutElastic for playful feedback moments and EaseOutCubic for
    smooth, professional progress indicators.
    
    Architecturally, this task creates reusable animation components that integrate with the
    iced GUI framework established in Task 1 and respond to messages from the message system
    in Task 6. The components are designed to be composable, configurable, and accessible.

  key_points:
    - "Immediate visual feedback (200-500ms) reinforces learning by confirming correct responses and highlighting errors"
    - "All animations must maintain 60fps performance without blocking the UI thread"
    - "WCAG AA accessibility compliance requires 4.5:1 contrast ratios and support for prefers-reduced-motion"
    - "Animation state machines must properly cleanup and avoid memory leaks in long sessions"
    - "Shake effects use damped oscillation to avoid motion sickness while providing clear error feedback"
    - "Achievement celebrations can be longer (1-2s) as they are rewarding moments, not interruptions"
    - "Color alone is insufficient for accessibility - all feedback combines color, icon, and motion"
    - "Progress indicators must update smoothly to maintain perception of system responsiveness"

files:
  - path: "src/ui/feedback.rs"
    description: "Core feedback animation system with FeedbackAnimation enum and animation state management"
  - path: "src/ui/effects.rs"
    description: "Visual effects implementation including shake, flash, and particle effects"
  - path: "src/ui/progress.rs"
    description: "Progress indicator components including circular progress and linear progress bars"
  - path: "src/ui/achievement_popup.rs"
    description: "Achievement celebration popup with slide-in and fade animations"
  - path: "src/ui/colors.rs"
    description: "Color palette module defining feedback states (success, error, warning, info) with WCAG AA compliant colors"
  - path: "src/ui/animations.rs"
    description: "Animation utilities including easing functions, timing, and animation state helpers"
  - path: "src/ui/accessibility.rs"
    description: "Accessibility features module including motion preference detection and animation adjustment"
  - path: "src/ui/mod.rs"
    description: "UI module declaration file, updated to export new feedback and animation modules"

functions:
  - file: "src/ui/feedback.rs"
    items:
      - type: "module_declaration"
        name: "ui::feedback"
        description: "Module containing visual feedback and animation components"
      
      - type: "enum"
        name: "FeedbackType"
        description: "Represents the type of feedback to display (Correct, Incorrect, Partial)"
      
      - type: "struct"
        name: "FeedbackAnimation"
        description: "Manages animated visual feedback for user responses"
        invariants: "Animation progress remains between 0.0 and 1.0"
      
      - type: "method"
        name: "FeedbackAnimation::new"
        description: "Creates a new feedback animation with specified type and duration"
        postconditions: "Returns FeedbackAnimation with progress at 0.0"
      
      - type: "method"
        name: "FeedbackAnimation::update"
        description: "Updates animation state based on elapsed time"
        preconditions: "Delta time must be non-negative"
        postconditions: "Progress advances toward 1.0, returns true when complete"
      
      - type: "method"
        name: "FeedbackAnimation::view"
        description: "Renders the feedback animation as an iced Element"
      
      - type: "method"
        name: "FeedbackAnimation::color"
        description: "Returns the appropriate color for the current feedback type"
        postconditions: "Returns color meeting WCAG AA contrast requirements"
      
      - type: "struct"
        name: "ShakeEffect"
        description: "Implements oscillating shake animation with decay for error feedback"
        invariants: "Offset decays to zero over animation duration"
      
      - type: "method"
        name: "ShakeEffect::new"
        description: "Creates a new shake effect with specified amplitude and duration"
        postconditions: "Returns ShakeEffect with initial offset at 0.0"
      
      - type: "method"
        name: "ShakeEffect::update"
        description: "Updates shake position using damped sine wave"
        preconditions: "Delta time must be non-negative"
        postconditions: "Returns current x-offset, converges to 0.0 when complete"
      
      - type: "method"
        name: "ShakeEffect::is_complete"
        description: "Returns true when shake animation has finished"
        postconditions: "Returns true only when amplitude has decayed below threshold"
      
      - type: "function"
        name: "shake_offset"
        description: "Calculates shake offset using damped sine wave formula"
        preconditions: "Progress must be between 0.0 and 1.0"
        postconditions: "Returns offset value that decays toward zero"

  - file: "src/ui/progress.rs"
    items:
      - type: "module_declaration"
        name: "ui::progress"
        description: "Module containing progress indicator components"
      
      - type: "struct"
        name: "ProgressCircle"
        description: "Circular progress indicator for session completion"
        invariants: "Progress value clamped between 0.0 and 1.0"
      
      - type: "method"
        name: "ProgressCircle::new"
        description: "Creates a new progress circle with initial progress value"
        preconditions: "Progress should be between 0.0 and 1.0"
        postconditions: "Returns ProgressCircle with clamped progress value"
      
      - type: "method"
        name: "ProgressCircle::set_progress"
        description: "Updates the progress value with smooth interpolation"
        preconditions: "New progress should be between 0.0 and 1.0"
        postconditions: "Progress value updated and clamped"
      
      - type: "method"
        name: "ProgressCircle::view"
        description: "Renders the progress circle as an iced Element"
        postconditions: "Returns circular arc from 0 to progress * 360 degrees"
      
      - type: "function"
        name: "draw_progress_arc"
        description: "Helper function to draw partial circular arc using canvas primitives"
        preconditions: "Progress must be between 0.0 and 1.0, radius must be positive"
        postconditions: "Draws arc with smooth antialiasing"

  - file: "src/ui/achievement_popup.rs"
    items:
      - type: "module_declaration"
        name: "ui::achievement_popup"
        description: "Module for achievement celebration animations"
      
      - type: "struct"
        name: "AchievementPopup"
        description: "Animated popup that displays when achievements are unlocked"
        invariants: "Auto-dismisses after display duration completes"
      
      - type: "method"
        name: "AchievementPopup::new"
        description: "Creates a new achievement popup with title, description, and icon"
        postconditions: "Returns popup with animation progress at 0.0"
      
      - type: "method"
        name: "AchievementPopup::update"
        description: "Updates animation state and handles auto-dismiss timing"
        preconditions: "Delta time must be non-negative"
        postconditions: "Returns true when popup should be dismissed"
      
      - type: "method"
        name: "AchievementPopup::view"
        description: "Renders the animated popup with slide-in and fade effects"
        postconditions: "Applies translation and opacity based on animation progress"
      
      - type: "function"
        name: "slide_in_easing"
        description: "Easing function for slide-in animation using ease-out-elastic"
        preconditions: "Progress must be between 0.0 and 1.0"
        postconditions: "Returns eased value with elastic bounce effect"

  - file: "src/ui/colors.rs"
    items:
      - type: "module_declaration"
        name: "ui::colors"
        description: "Module defining color palette for feedback states"
      
      - type: "constant"
        name: "COLOR_SUCCESS"
        description: "Green color for correct answers (WCAG AA compliant)"
      
      - type: "constant"
        name: "COLOR_ERROR"
        description: "Red color for incorrect answers (WCAG AA compliant)"
      
      - type: "constant"
        name: "COLOR_PARTIAL"
        description: "Yellow/orange color for partial credit (WCAG AA compliant)"
      
      - type: "constant"
        name: "COLOR_PROGRESS"
        description: "Blue color for progress indicators"
      
      - type: "constant"
        name: "COLOR_ACHIEVEMENT"
        description: "Gold color for achievement celebrations"
      
      - type: "function"
        name: "feedback_color"
        description: "Returns appropriate color for given feedback type"
        preconditions: "FeedbackType must be valid enum variant"
        postconditions: "Returns WCAG AA compliant color"

  - file: "src/ui/animations.rs"
    items:
      - type: "module_declaration"
        name: "ui::animations"
        description: "Core animation utilities and easing functions"
      
      - type: "enum"
        name: "EasingCurve"
        description: "Enum defining different easing curve types (Linear, EaseIn, EaseOut, EaseInOut, EaseOutElastic, EaseOutCubic)"
      
      - type: "function"
        name: "apply_easing"
        description: "Applies the specified easing curve to a linear progress value"
        preconditions: "Progress must be between 0.0 and 1.0"
        postconditions: "Returns eased value between 0.0 and 1.0"
        invariants: "Monotonically increasing (output grows as progress grows)"
      
      - type: "function"
        name: "ease_out_elastic"
        description: "Elastic easing function with overshoot and bounce back"
        preconditions: "t must be between 0.0 and 1.0"
        postconditions: "Returns value that overshoots 1.0 then settles"
      
      - type: "function"
        name: "ease_out_cubic"
        description: "Cubic easing function for smooth deceleration"
        preconditions: "t must be between 0.0 and 1.0"
        postconditions: "Returns smoothly eased value"
      
      - type: "struct"
        name: "AnimationState"
        description: "Tracks animation timing and progress"
        invariants: "Progress remains between 0.0 and 1.0"
      
      - type: "method"
        name: "AnimationState::new"
        description: "Creates a new animation state with specified duration"
        preconditions: "Duration must be positive"
        postconditions: "Returns state with elapsed time at 0.0"
      
      - type: "method"
        name: "AnimationState::advance"
        description: "Advances animation by delta time and returns current progress"
        preconditions: "Delta must be non-negative"
        postconditions: "Elapsed time increases, progress clamped to 1.0 when complete"
      
      - type: "method"
        name: "AnimationState::is_complete"
        description: "Returns true when animation has reached its duration"
        postconditions: "Returns true iff progress >= 1.0"
      
      - type: "constant"
        name: "FEEDBACK_DURATION_MS"
        description: "Standard duration for feedback animations (300ms)"
      
      - type: "constant"
        name: "SHAKE_DURATION_MS"
        description: "Duration for shake effect (400ms)"
      
      - type: "constant"
        name: "ACHIEVEMENT_DURATION_MS"
        description: "Duration for achievement popup display (3000ms)"

  - file: "src/ui/effects.rs"
    items:
      - type: "function"
        name: "checkmark_icon"
        description: "Renders a checkmark icon for correct feedback"
        postconditions: "Returns iced Element with checkmark graphic"
      
      - type: "function"
        name: "x_icon"
        description: "Renders an X icon for incorrect feedback"
        postconditions: "Returns iced Element with X graphic"
      
      - type: "function"
        name: "achievement_icon"
        description: "Renders trophy/star icon for achievement unlocks"
        preconditions: "Icon name must be valid achievement icon identifier"
        postconditions: "Returns iced Element with achievement icon"

  - file: "src/ui/accessibility.rs"
    items:
      - type: "module_declaration"
        name: "ui::accessibility"
        description: "Accessibility utilities for animations"
      
      - type: "function"
        name: "should_reduce_motion"
        description: "Checks system preference for reduced motion"
        postconditions: "Returns true if user prefers reduced motion"
      
      - type: "function"
        name: "apply_motion_preference"
        description: "Adjusts animation duration based on motion preference"
        preconditions: "Duration must be positive"
        postconditions: "Returns reduced duration if motion should be reduced, otherwise original"
      
      - type: "function"
        name: "ensure_contrast"
        description: "Verifies color contrast meets WCAG AA requirements"
        preconditions: "Foreground and background colors must be valid RGB"
        postconditions: "Returns true if contrast ratio >= 4.5:1"

  - file: "src/ui/mod.rs"
    items:
      - type: "module_declaration"
        name: "feedback"
        description: "Exposes feedback module containing FeedbackAnimation and ShakeEffect"
      
      - type: "module_declaration"
        name: "effects"
        description: "Exposes effects module with visual micro-interactions"
      
      - type: "module_declaration"
        name: "progress"
        description: "Exposes progress module containing ProgressCircle"
      
      - type: "module_declaration"
        name: "achievement_popup"
        description: "Exposes achievement_popup module containing AchievementPopup"
      
      - type: "module_declaration"
        name: "colors"
        description: "Exposes colors module containing color palette constants"
      
      - type: "module_declaration"
        name: "animations"
        description: "Exposes animations module containing easing functions and animation state"
      
      - type: "module_declaration"
        name: "accessibility"
        description: "Exposes accessibility utilities module"

formal_verification:
  needed: false
  level: "None"
  explanation: |
    Formal verification is not needed for this visual feedback and animation task for the following reasons:
    
    1. Non-critical UI code: This task implements visual feedback elements (animations, progress indicators, shake effects) that are presentational rather than safety-critical. Animation failures do not compromise data integrity, security, or core application functionality.
    
    2. Testing strategy is appropriate: The task already specifies integration testing as the primary verification method, which is the correct approach for animation quality, timing, and visual rendering. Integration tests can verify that animations trigger correctly, complete without errors, and meet timing requirements.
    
    3. Limited mathematical complexity: While there are timing calculations and easing curves involved, these are standard animation patterns that are better validated through integration tests and visual inspection rather than formal proofs. The complexity does not justify formal verification overhead.
    
    4. WCAG compliance: Color contrast requirements can be validated through automated accessibility testing tools and unit tests, not formal verification.
    
    5. State machine simplicity: Animation state transitions (start → running → complete) are straightforward and can be adequately tested through conventional unit and integration tests.
    
    6. Cost-benefit analysis: The effort required for formal verification (writing formal specifications, proofs, invariants) would far exceed the value gained, especially when visual inspection and integration testing are more effective for this domain.
    
    The identified critical properties (timing bounds, contrast requirements, position restoration, progress rendering) are all testable through conventional methods without requiring formal proofs.

tests:
  strategy:
    approach: "mixed (unit + integration + property-based)"
    rationale:
      - "Animation timing and state transitions require unit tests for deterministic verification"
      - "Integration tests verify animations trigger correctly from user interactions and complete without errors"
      - "Visual aspects (colors, contrast, rendering) need property-based tests for accessibility compliance"
      - "Motion effects and frame timing require integration tests with the iced runtime"
      - "Reduced motion accessibility requires dedicated test coverage"
      - "Animation completion callbacks and state cleanup need unit verification"
      - "Property-based tests ensure mathematical invariants hold across all input ranges"

  implementation:
    file: "tests/ui/feedback_tests.rs"
    location: "create new"
    code: |
      #[cfg(test)]
      mod tests {
          use super::*;
          use iced::Color;
          use std::time::Duration;

          // ============================================
          // Unit Tests: FeedbackAnimation State Machine
          // ============================================

          #[test]
          fn test_feedback_animation_correct_state() {
              // Verify correct feedback uses green color and checkmark
              let feedback = FeedbackAnimation::Correct;
              assert_eq!(feedback.color(), Color::from_rgb(0.0, 0.8, 0.0));
              assert_eq!(feedback.icon(), FeedbackIcon::Checkmark);
              assert_eq!(feedback.duration(), Duration::from_millis(300));
          }

          #[test]
          fn test_feedback_animation_incorrect_state() {
              // Verify incorrect feedback uses red color and X icon
              let feedback = FeedbackAnimation::Incorrect;
              assert_eq!(feedback.color(), Color::from_rgb(0.9, 0.0, 0.0));
              assert_eq!(feedback.icon(), FeedbackIcon::Cross);
              assert_eq!(feedback.duration(), Duration::from_millis(400));
          }

          #[test]
          fn test_feedback_animation_partial_state() {
              // Verify partial feedback uses amber color and partial icon
              let feedback = FeedbackAnimation::Partial;
              assert_eq!(feedback.color(), Color::from_rgb(1.0, 0.7, 0.0));
              assert_eq!(feedback.icon(), FeedbackIcon::PartialCheck);
              assert_eq!(feedback.duration(), Duration::from_millis(350));
          }

          // ============================================
          // Unit Tests: Shake Effect Calculations
          // ============================================

          #[test]
          fn test_shake_effect_starts_at_zero() {
              // Shake should start at center position (0.0)
              let shake = ShakeEffect::new(10.0, Duration::from_millis(400));
              assert_eq!(shake.offset_at(Duration::ZERO), 0.0);
          }

          #[test]
          fn test_shake_effect_returns_to_zero() {
              // Shake must return to center at completion
              let shake = ShakeEffect::new(10.0, Duration::from_millis(400));
              let final_offset = shake.offset_at(Duration::from_millis(400));
              assert!(final_offset.abs() < 0.01, "Shake should return to center, got {}", final_offset);
          }

          #[test]
          fn test_shake_effect_amplitude_decay() {
              // Verify amplitude decays over time to avoid motion sickness
              let shake = ShakeEffect::new(15.0, Duration::from_millis(500));
              let offset_early = shake.offset_at(Duration::from_millis(50)).abs();
              let offset_mid = shake.offset_at(Duration::from_millis(250)).abs();
              let offset_late = shake.offset_at(Duration::from_millis(450)).abs();
              
              assert!(offset_early > offset_late, "Amplitude should decay");
              assert!(offset_mid > offset_late, "Decay should be continuous");
          }

          #[test]
          fn test_shake_effect_oscillation() {
              // Verify shake oscillates (changes direction)
              let shake = ShakeEffect::new(10.0, Duration::from_millis(400));
              let offset_25 = shake.offset_at(Duration::from_millis(100));
              let offset_50 = shake.offset_at(Duration::from_millis(200));
              
              // At different times, offset should have different signs (oscillation)
              assert_ne!(offset_25.signum(), offset_50.signum(), "Shake should oscillate");
          }

          #[test]
          fn test_shake_effect_respects_max_amplitude() {
              // No offset should exceed initial amplitude
              let max_amplitude = 12.0;
              let shake = ShakeEffect::new(max_amplitude, Duration::from_millis(400));
              
              for millis in (0..=400).step_by(10) {
                  let offset = shake.offset_at(Duration::from_millis(millis));
                  assert!(offset.abs() <= max_amplitude + 0.1, 
                          "Offset {} exceeds max amplitude {} at {}ms", 
                          offset, max_amplitude, millis);
              }
          }

          // ============================================
          // Unit Tests: Progress Circle Rendering
          // ============================================

          #[test]
          fn test_progress_circle_at_zero() {
              // Progress circle at 0% should render correctly
              let progress = ProgressCircle::new(0.0, 50.0);
              assert_eq!(progress.arc_angle(), 0.0);
              assert_eq!(progress.percentage(), 0.0);
          }

          #[test]
          fn test_progress_circle_at_fifty_percent() {
              // Progress circle at 50% should render half arc
              let progress = ProgressCircle::new(0.5, 50.0);
              assert!((progress.arc_angle() - std::f32::consts::PI).abs() < 0.01);
              assert_eq!(progress.percentage(), 50.0);
          }

          #[test]
          fn test_progress_circle_at_one_hundred() {
              // Progress circle at 100% should render full circle
              let progress = ProgressCircle::new(1.0, 50.0);
              assert!((progress.arc_angle() - 2.0 * std::f32::consts::PI).abs() < 0.01);
              assert_eq!(progress.percentage(), 100.0);
          }

          #[test]
          fn test_progress_circle_clamps_invalid_values() {
              // Progress should clamp values outside [0, 1] range
              let progress_negative = ProgressCircle::new(-0.5, 50.0);
              assert_eq!(progress_negative.percentage(), 0.0);
              
              let progress_over = ProgressCircle::new(1.5, 50.0);
              assert_eq!(progress_over.percentage(), 100.0);
          }

          #[test]
          fn test_progress_circle_smooth_updates() {
              // Verify smooth interpolation between progress values
              let progress1 = ProgressCircle::new(0.25, 50.0);
              let progress2 = ProgressCircle::new(0.26, 50.0);
              
              let angle_diff = (progress2.arc_angle() - progress1.arc_angle()).abs();
              assert!(angle_diff < 0.1, "Progress updates should be smooth");
          }

          // ============================================
          // Unit Tests: Achievement Popup State
          // ============================================

          #[test]
          fn test_achievement_popup_initial_state() {
              // Achievement popup should start hidden/inactive
              let popup = AchievementPopup::new();
              assert!(!popup.is_visible());
              assert_eq!(popup.opacity_at(Duration::ZERO), 0.0);
          }

          #[test]
          fn test_achievement_popup_show() {
              // Show should trigger animation and make popup visible
              let mut popup = AchievementPopup::new();
              popup.show(Achievement::FirstReview, Duration::from_millis(2000));
              
              assert!(popup.is_visible());
              assert!(popup.is_animating());
          }

          #[test]
          fn test_achievement_popup_fade_in() {
              // Opacity should increase during fade-in
              let mut popup = AchievementPopup::new();
              popup.show(Achievement::FirstReview, Duration::from_millis(1500));
              
              let opacity_start = popup.opacity_at(Duration::ZERO);
              let opacity_mid = popup.opacity_at(Duration::from_millis(200));
              let opacity_end = popup.opacity_at(Duration::from_millis(500));
              
              assert!(opacity_start < opacity_mid);
              assert!(opacity_mid < opacity_end);
              assert!((opacity_end - 1.0).abs() < 0.01, "Should reach full opacity");
          }

          #[test]
          fn test_achievement_popup_auto_dismiss() {
              // Popup should auto-dismiss after display duration
              let mut popup = AchievementPopup::new();
              let display_duration = Duration::from_millis(2000);
              popup.show(Achievement::FirstReview, display_duration);
              
              // Before auto-dismiss time
              popup.update(Duration::from_millis(1500));
              assert!(popup.is_visible());
              
              // After auto-dismiss time
              popup.update(Duration::from_millis(2500));
              assert!(!popup.is_visible());
          }

          #[test]
          fn test_achievement_popup_slide_animation() {
              // Verify slide-in from top animation
              let mut popup = AchievementPopup::new();
              popup.show(Achievement::FirstReview, Duration::from_millis(2000));
              
              let y_start = popup.y_offset_at(Duration::ZERO);
              let y_mid = popup.y_offset_at(Duration::from_millis(250));
              let y_end = popup.y_offset_at(Duration::from_millis(500));
              
              assert!(y_start < 0.0, "Should start above viewport");
              assert!(y_mid > y_start, "Should move down");
              assert!((y_end - 0.0).abs() < 1.0, "Should reach final position");
          }

          // ============================================
          // Unit Tests: Color Palette Accessibility
          // ============================================

          #[test]
          fn test_feedback_colors_meet_wcag_contrast() {
              // Verify all feedback colors meet WCAG AA contrast (4.5:1) on white background
              let white = Color::WHITE;
              
              let correct_color = FeedbackAnimation::Correct.color();
              assert!(calculate_contrast_ratio(correct_color, white) >= 4.5);
              
              let incorrect_color = FeedbackAnimation::Incorrect.color();
              assert!(calculate_contrast_ratio(incorrect_color, white) >= 4.5);
              
              let partial_color = FeedbackAnimation::Partial.color();
              assert!(calculate_contrast_ratio(partial_color, white) >= 4.5);
          }

          #[test]
          fn test_feedback_colors_distinct() {
              // Colors should be distinguishable for colorblind users
              let correct = FeedbackAnimation::Correct.color();
              let incorrect = FeedbackAnimation::Incorrect.color();
              let partial = FeedbackAnimation::Partial.color();
              
              assert!(color_distance(correct, incorrect) > 100.0);
              assert!(color_distance(correct, partial) > 100.0);
              assert!(color_distance(incorrect, partial) > 100.0);
          }

          // ============================================
          // Unit Tests: Reduced Motion Support
          // ============================================

          #[test]
          fn test_reduced_motion_disables_shake() {
              // Shake effect should be disabled when prefers-reduced-motion is set
              let shake = ShakeEffect::new_with_preferences(10.0, Duration::from_millis(400), true);
              
              // With reduced motion, offset should always be 0
              for millis in (0..=400).step_by(50) {
                  let offset = shake.offset_at(Duration::from_millis(millis));
                  assert_eq!(offset, 0.0, "Shake should be disabled with reduced motion");
              }
          }

          #[test]
          fn test_reduced_motion_simplifies_achievement_animation() {
              // Achievement animation should be simpler with reduced motion
              let mut popup = AchievementPopup::new_with_preferences(true);
              popup.show(Achievement::FirstReview, Duration::from_millis(2000));
              
              // Should fade in without slide animation
              let y_offset = popup.y_offset_at(Duration::from_millis(100));
              assert_eq!(y_offset, 0.0, "No slide animation with reduced motion");
          }

          // ============================================
          // Integration Tests: Animation Timing
          // ============================================

          #[test]
          fn test_feedback_animation_completes_in_time() {
              // Verify feedback animations complete within expected duration
              let feedback = FeedbackAnimation::Correct;
              let duration = feedback.duration();
              
              let mut state = AnimationState::new(feedback);
              state.start();
              
              // Update to completion time
              state.update(duration);
              assert!(state.is_complete());
          }

          #[test]
          fn test_animation_state_cleanup() {
              // Verify animation state is properly cleaned up after completion
              let mut state = AnimationState::new(FeedbackAnimation::Correct);
              state.start();
              state.update(Duration::from_millis(500));
              
              assert!(state.is_complete());
              state.reset();
              assert!(!state.is_running());
              assert!(!state.is_complete());
          }

          #[test]
          fn test_multiple_animations_dont_interfere() {
              // Multiple concurrent animations should not interfere
              let shake = ShakeEffect::new(10.0, Duration::from_millis(400));
              let mut popup = AchievementPopup::new();
              popup.show(Achievement::FirstReview, Duration::from_millis(2000));
              
              let time = Duration::from_millis(200);
              let shake_offset = shake.offset_at(time);
              let popup_opacity = popup.opacity_at(time);
              
              // Both should have valid values
              assert!(shake_offset.abs() > 0.0);
              assert!(popup_opacity > 0.0);
          }

          // ============================================
          // Helper Functions for Tests
          // ============================================

          fn calculate_contrast_ratio(color1: Color, color2: Color) -> f32 {
              // Simplified WCAG contrast ratio calculation
              let l1 = relative_luminance(color1);
              let l2 = relative_luminance(color2);
              
              let lighter = l1.max(l2);
              let darker = l1.min(l2);
              
              (lighter + 0.05) / (darker + 0.05)
          }

          fn relative_luminance(color: Color) -> f32 {
              // Simplified relative luminance calculation
              0.2126 * color.r + 0.7152 * color.g + 0.0722 * color.b
          }

          fn color_distance(color1: Color, color2: Color) -> f32 {
              // Euclidean distance in RGB space
              let dr = color1.r - color2.r;
              let dg = color1.g - color2.g;
              let db = color1.b - color2.b;
              
              ((dr * dr + dg * dg + db * db) * 255.0 * 255.0).sqrt()
          }
      }

      // ============================================
      // Property-Based Tests for Animation Properties
      // ============================================

      #[cfg(test)]
      mod property_tests {
          use super::*;
          use proptest::prelude::*;

          proptest! {
              #[test]
              fn prop_shake_always_returns_to_center(
                  amplitude in 1.0f32..50.0,
                  duration_ms in 100u64..1000
              ) {
                  let shake = ShakeEffect::new(amplitude, Duration::from_millis(duration_ms));
                  let final_offset = shake.offset_at(Duration::from_millis(duration_ms));
                  prop_assert!(final_offset.abs() < 0.1);
              }

              #[test]
              fn prop_progress_circle_monotonic(
                  progress1 in 0.0f32..1.0,
                  progress2 in 0.0f32..1.0
              ) {
                  let circle1 = ProgressCircle::new(progress1, 50.0);
                  let circle2 = ProgressCircle::new(progress2, 50.0);
                  
                  if progress1 < progress2 {
                      prop_assert!(circle1.arc_angle() < circle2.arc_angle());
                  }
              }

              #[test]
              fn prop_animation_duration_positive(
                  feedback in prop_oneof![
                      Just(FeedbackAnimation::Correct),
                      Just(FeedbackAnimation::Incorrect),
                      Just(FeedbackAnimation::Partial)
                  ]
              ) {
                  let duration = feedback.duration();
                  prop_assert!(duration.as_millis() > 0);
                  prop_assert!(duration.as_millis() <= 1000);
              }

              #[test]
              fn prop_achievement_opacity_bounded(
                  elapsed_ms in 0u64..5000
              ) {
                  let mut popup = AchievementPopup::new();
                  popup.show(Achievement::FirstReview, Duration::from_millis(2000));
                  
                  let opacity = popup.opacity_at(Duration::from_millis(elapsed_ms));
                  prop_assert!(opacity >= 0.0 && opacity <= 1.0);
              }

              #[test]
              fn prop_shake_amplitude_bounded(
                  max_amplitude in 1.0f32..100.0,
                  duration_ms in 100u64..1000,
                  elapsed_ms in 0u64..1000
              ) {
                  let shake = ShakeEffect::new(max_amplitude, Duration::from_millis(duration_ms));
                  let offset = shake.offset_at(Duration::from_millis(elapsed_ms));
                  prop_assert!(offset.abs() <= max_amplitude + 0.5);
              }
          }
      }

  coverage:
    - "Correct feedback uses green color and checkmark icon"
    - "Incorrect feedback uses red color and X icon"
    - "Partial feedback uses amber color and partial check icon"
    - "Feedback animation durations are within acceptable range (200-500ms)"
    - "ShakeEffect starts at center position (offset 0.0)"
    - "ShakeEffect returns to center at completion"
    - "ShakeEffect amplitude decays over time to avoid motion sickness"
    - "ShakeEffect oscillates (changes direction) during animation"
    - "ShakeEffect respects maximum amplitude bounds"
    - "ProgressCircle renders correctly at 0% completion"
    - "ProgressCircle renders correctly at 50% completion"
    - "ProgressCircle renders correctly at 100% completion"
    - "ProgressCircle clamps invalid progress values to [0, 1] range"
    - "ProgressCircle updates smoothly between values"
    - "AchievementPopup starts in hidden/inactive state"
    - "AchievementPopup becomes visible when shown"
    - "AchievementPopup fades in smoothly over time"
    - "AchievementPopup auto-dismisses after display duration"
    - "AchievementPopup slides in from top during animation"
    - "All feedback colors meet WCAG AA contrast ratio (4.5:1)"
    - "Feedback colors are sufficiently distinct for colorblind users"
    - "Reduced motion preference disables shake effect"
    - "Reduced motion preference simplifies achievement animation"
    - "Feedback animations complete within expected duration"
    - "Animation state is properly cleaned up after completion"
    - "Multiple concurrent animations do not interfere with each other"
    - "Shake effect always returns to center regardless of amplitude or duration (property)"
    - "Progress circle angle increases monotonically with progress (property)"
    - "Animation durations are always positive and reasonable (property)"
    - "Achievement popup opacity remains bounded [0, 1] at all times (property)"
    - "Shake offset never exceeds maximum amplitude (property)"

dependencies:
  depends_on:
    - task_id: 1
      reason: "Requires iced framework foundation including Application trait, Element types, Color types, and canvas primitives for rendering animations"
    - task_id: 6
      reason: "Requires message system to receive triggers for feedback animations (correct/incorrect answers) and achievement unlocks from learning/practice sessions"

  depended_upon_by:
    - task_id: 8
      reason: "Learning Session uses FeedbackAnimation and ProgressCircle to provide visual feedback during character reviews"
    - task_id: 10
      reason: "Practice Session uses FeedbackAnimation for immediate feedback during recognition practice"
    - task_id: 11
      reason: "Statistics and Achievements system triggers AchievementPopup when users unlock new achievements"

  external:
    - name: "iced"
      type: "crate"
      status: "already exists"
    - name: "iced::Color"
      type: "struct"
      status: "already exists"
    - name: "iced::Element"
      type: "struct"
      status: "already exists"
    - name: "iced::widget::canvas"
      type: "module"
      status: "already exists"
    - name: "std::time::Duration"
      type: "struct"
      status: "already exists"
    - name: "Message"
      type: "enum"
      status: "needs implementation"
    - name: "Achievement"
      type: "enum"
      status: "needs implementation"
---
task:
  id: 13
  name: "UI/UX Polish and Accessibility"

context:
  description: |
    Task 13 applies comprehensive UI/UX polish to the Japanese kanji learning application,
    transforming it from a functional prototype into a professional, accessible application
    that meets WCAG 2.1 Level AA standards. This task implements a complete design system
    including WCAG-compliant color palette, consistent typography scale, responsive layouts,
    keyboard navigation, and screen reader support.
    
    The implementation goes beyond visual aesthetics to ensure the application is usable by
    people with disabilities, including those who navigate via keyboard only, use screen
    readers, have visual impairments requiring high contrast, or interact via touch on mobile
    devices. This task establishes the foundation for a professional user experience that
    reduces cognitive load, builds trust, and enables effective learning.
    
    Architecturally, this task introduces shared design system modules (theme, typography,
    spacing, accessibility) that will be consumed by all UI components throughout the
    application. It implements a keyboard event handling system that routes shortcuts to
    appropriate screens, and establishes a responsive layout system that adapts to different
    screen sizes using breakpoints.
    
    The accessibility features implemented here are both an ethical imperative and legal
    requirement in many jurisdictions. Beyond compliance, good UX design benefits all users
    by reducing friction, providing multiple interaction modalities, and creating a polished
    experience that encourages continued use and learning.

  key_points:
    - "Implements WCAG 2.1 Level AA compliance: 4.5:1 contrast for normal text, 3:1 for large text and UI components, 48x48px minimum touch targets, keyboard accessibility for all functions"
    - "Establishes centralized design system with color palette module, typography scale, 8px-based spacing grid, and accessibility utilities consumed by all UI components"
    - "Creates keyboard navigation system with shortcuts for quality ratings (1-5), card navigation (Space), cancellation (Escape), focus management (Tab), and list navigation (arrows)"
    - "Implements responsive layout system using breakpoints (Mobile 320-640px, Tablet 641-1024px, Desktop 1025-1440px, Wide 1441px+) that adapts column counts, spacing, and font sizes"
    - "Provides screen reader support through ARIA labels, role attributes, live regions for status updates, and descriptive labels for all interactive elements"
    - "Includes automated testing for measurable accessibility properties and comprehensive manual testing checklist for assistive technology verification"
    - "Applies consistent visual hierarchy through typography scale (H1 32-36px, H2 24-28px, H3 20-22px, body 16-18px, minimum 12px) with 1.5 line height for readability"
    - "Ensures focus indicators are always visible (2px minimum border) and distinct from default borders for keyboard navigation clarity"

files:
  - path: "src/ui/theme.rs"
    description: "WCAG-compliant color palette module with documented contrast ratios and theme constants for consistent visual design"
  
  - path: "src/ui/typography.rs"
    description: "Typography scale module defining consistent font sizes, weights, line heights, and text styles throughout the application"
  
  - path: "src/ui/spacing.rs"
    description: "Spacing constants and utilities based on 8px grid system for consistent visual rhythm and layout"
  
  - path: "src/ui/accessibility.rs"
    description: "Accessibility utilities including focus indicators, ARIA-like helpers, and screen reader support functions"
  
  - path: "src/ui/layout.rs"
    description: "Responsive layout utilities and containers that adapt to window size with breakpoint system"
  
  - path: "src/input/keyboard.rs"
    description: "Keyboard shortcut handlers, key mapping system, and navigation logic for keyboard accessibility"
  
  - path: "src/input/mod.rs"
    description: "Input module root declaring keyboard submodule for centralized input handling"
  
  - path: "src/ui/components/button.rs"
    description: "Accessible button component enforcing minimum 48x48px touch target sizing and proper contrast"
  
  - path: "src/ui/components/text_input.rs"
    description: "Enhanced text input component with keyboard navigation, focus management, and accessible labels"
  
  - path: "src/ui/components/rating.rs"
    description: "Quality rating buttons component (1-5) with keyboard shortcuts and accessible labels"
  
  - path: "src/ui/components/mod.rs"
    description: "Components module root declaring button, text_input, rating, and other accessible component submodules"
  
  - path: "src/ui/screens/practice_screen.rs"
    description: "Updated practice screen with responsive layouts, keyboard shortcuts, and accessibility features applied"
  
  - path: "src/ui/screens/review_screen.rs"
    description: "Updated review screen with accessible controls, responsive design, and keyboard navigation"
  
  - path: "src/ui/screens/deck_list_screen.rs"
    description: "Updated deck list screen with keyboard navigation and touch-friendly target sizes"
  
  - path: "src/ui/screens/settings_screen.rs"
    description: "Updated settings screen with accessible form controls and responsive layout"
  
  - path: "src/ui/screens/help_screen.rs"
    description: "Help screen documenting keyboard shortcuts and accessibility features for users"
  
  - path: "src/ui/screens/mod.rs"
    description: "Screens module root declaring all screen submodules including practice, review, deck_list, settings, and help"
  
  - path: "src/ui/app.rs"
    description: "Application root updated with keyboard event subscriptions, theme management, and window resize handling"
  
  - path: "src/ui/mod.rs"
    description: "UI module root updated to expose theme, typography, spacing, accessibility, layout, components, and screens modules"
  
  - path: "src/main.rs"
    description: "Application entry point updated to initialize theme and keyboard event subscriptions"
  
  - path: "tests/accessibility_tests.rs"
    description: "Integration tests verifying WCAG contrast ratios, minimum touch target sizes, and color palette compliance"
  
  - path: "tests/keyboard_navigation_tests.rs"
    description: "Tests for keyboard shortcut functionality, focus management, and navigation flow"
  
  - path: "Cargo.toml"
    description: "Project manifest updated to include proptest dev-dependency for property-based accessibility testing"

functions:
  - file: "src/ui/theme.rs"
    items:
      - type: "module_declaration"
        name: "ui::theme"
        description: "Module containing WCAG-compliant color palette, typography scale, spacing constants, and theme definitions"
      
      - type: "struct"
        name: "ColorPalette"
        description: "Defines the application color scheme with WCAG AA-compliant colors meeting 4.5:1 contrast ratio for normal text"
        invariants: "All color combinations meet 4.5:1 contrast ratio for normal text; all RGB values are in 0.0-1.0 range"
      
      - type: "constant"
        name: "ColorPalette::TEXT_PRIMARY"
        description: "Primary text color with 4.5:1+ contrast on background (typically dark gray #212121 on white)"
      
      - type: "constant"
        name: "ColorPalette::TEXT_SECONDARY"
        description: "Secondary text color with 4.5:1+ contrast on background (typically medium gray #616161 on white)"
      
      - type: "constant"
        name: "ColorPalette::TEXT_DISABLED"
        description: "Disabled text color, may have lower contrast but clearly indicates disabled state"
      
      - type: "constant"
        name: "ColorPalette::BACKGROUND_PRIMARY"
        description: "Primary background color (typically white #FFFFFF)"
      
      - type: "constant"
        name: "ColorPalette::BACKGROUND_SECONDARY"
        description: "Secondary background color for cards and panels (typically light gray #F5F5F5)"
      
      - type: "constant"
        name: "ColorPalette::BUTTON_PRIMARY_BG"
        description: "Primary button background color with sufficient contrast to button text"
      
      - type: "constant"
        name: "ColorPalette::BUTTON_PRIMARY_TEXT"
        description: "Primary button text color with 4.5:1+ contrast on button background"
      
      - type: "constant"
        name: "ColorPalette::BUTTON_SECONDARY_BG"
        description: "Secondary button background color"
      
      - type: "constant"
        name: "ColorPalette::BUTTON_SECONDARY_TEXT"
        description: "Secondary button text color with 4.5:1+ contrast"
      
      - type: "constant"
        name: "ColorPalette::SUCCESS_COLOR"
        description: "Success feedback color (green) with 4.5:1+ contrast on white background"
      
      - type: "constant"
        name: "ColorPalette::ERROR_COLOR"
        description: "Error feedback color (red) with 4.5:1+ contrast on white background"
      
      - type: "constant"
        name: "ColorPalette::WARNING_COLOR"
        description: "Warning feedback color (orange/yellow) with 4.5:1+ contrast on white background"
      
      - type: "constant"
        name: "ColorPalette::INFO_COLOR"
        description: "Info feedback color (blue) with 4.5:1+ contrast on white background"
      
      - type: "constant"
        name: "ColorPalette::FOCUS_INDICATOR"
        description: "Focus indicator border color with 3:1+ contrast ratio for visibility"
      
      - type: "constant"
        name: "ColorPalette::BORDER_DEFAULT"
        description: "Default border color for UI elements"
      
      - type: "constant"
        name: "ColorPalette::BORDER_HOVER"
        description: "Border color on hover state"
      
      - type: "method"
        name: "ColorPalette::default"
        description: "Returns default color palette with all WCAG AA compliant colors"
        postconditions: "All colors meet minimum contrast requirements"
      
      - type: "method"
        name: "ColorPalette::all_colors"
        description: "Returns iterator over all named colors in palette for validation"
        postconditions: "Returns Vec of (name, Color) tuples"
      
      - type: "struct"
        name: "Typography"
        description: "Defines consistent font sizes, weights, line heights, and text styles"
        invariants: "All font sizes >= 12px; body text >= 16px; line height >= 1.5"
      
      - type: "constant"
        name: "Typography::H1_SIZE"
        description: "Heading 1 font size in pixels (typically 32-36px)"
      
      - type: "constant"
        name: "Typography::H2_SIZE"
        description: "Heading 2 font size in pixels (typically 24-28px)"
      
      - type: "constant"
        name: "Typography::H3_SIZE"
        description: "Heading 3 font size in pixels (typically 20-22px)"
      
      - type: "constant"
        name: "Typography::BODY_SIZE"
        description: "Body text font size in pixels (16-18px for optimal readability)"
      
      - type: "constant"
        name: "Typography::SECONDARY_SIZE"
        description: "Secondary text font size in pixels (14px minimum)"
      
      - type: "constant"
        name: "Typography::MINIMUM_SIZE"
        description: "Minimum allowed font size (12px absolute minimum)"
      
      - type: "constant"
        name: "Typography::BODY_LINE_HEIGHT"
        description: "Line height for body text (1.5 minimum per WCAG)"
      
      - type: "constant"
        name: "Typography::HEADING_LINE_HEIGHT"
        description: "Line height for headings (typically 1.2-1.3)"
      
      - type: "constant"
        name: "Typography::BODY_LETTER_SPACING"
        description: "Letter spacing for body text in pixels"
      
      - type: "constant"
        name: "Typography::HEADING_LETTER_SPACING"
        description: "Letter spacing for headings in pixels"
      
      - type: "method"
        name: "Typography::default"
        description: "Returns default typography scale with WCAG-compliant sizes"
        postconditions: "All sizes meet minimum requirements; hierarchy is logical"
      
      - type: "struct"
        name: "Spacing"
        description: "Defines consistent spacing units based on 8px grid system"
        invariants: "All spacing values are multiples of 8"
      
      - type: "constant"
        name: "Spacing::BASE_UNIT"
        description: "Base spacing unit (8px) for grid system"
      
      - type: "constant"
        name: "Spacing::XS"
        description: "Extra small spacing (8px = 1 unit)"
      
      - type: "constant"
        name: "Spacing::SM"
        description: "Small spacing (16px = 2 units)"
      
      - type: "constant"
        name: "Spacing::MD"
        description: "Medium spacing (24px = 3 units)"
      
      - type: "constant"
        name: "Spacing::LG"
        description: "Large spacing (32px = 4 units)"
      
      - type: "constant"
        name: "Spacing::XL"
        description: "Extra large spacing (48px = 6 units)"
      
      - type: "constant"
        name: "Spacing::XXL"
        description: "Extra extra large spacing (64px = 8 units)"
      
      - type: "method"
        name: "Spacing::default"
        description: "Returns default spacing scale based on 8px grid"
        postconditions: "All values are multiples of 8"
      
      - type: "method"
        name: "Spacing::custom"
        description: "Creates custom spacing value, rounded to nearest multiple of 8"
        preconditions: "Input value is positive"
        postconditions: "Returns value rounded to nearest multiple of 8"
      
      - type: "constant"
        name: "MIN_TOUCH_TARGET_SIZE"
        description: "Minimum touch target size constant (48px) per WCAG AA"
      
      - type: "constant"
        name: "MIN_CONTRAST_RATIO"
        description: "Minimum WCAG AA contrast ratio (4.5:1) for normal text"
      
      - type: "constant"
        name: "MIN_LARGE_TEXT_CONTRAST"
        description: "Minimum WCAG AA contrast ratio (3:1) for large text (18px+ or 14px+ bold)"
      
      - type: "constant"
        name: "MIN_FOCUS_BORDER_WIDTH"
        description: "Minimum focus indicator border width (2px) for visibility"
      
      - type: "struct"
        name: "Theme"
        description: "Complete theme combining color palette, typography, and spacing"
      
      - type: "method"
        name: "Theme::default"
        description: "Returns default application theme with all accessibility settings"
        postconditions: "Theme meets WCAG 2.1 Level AA standards"
      
      - type: "method"
        name: "Theme::colors"
        description: "Returns reference to color palette"
        postconditions: "Returns ColorPalette reference"
      
      - type: "method"
        name: "Theme::typography"
        description: "Returns reference to typography settings"
        postconditions: "Returns Typography reference"
      
      - type: "method"
        name: "Theme::spacing"
        description: "Returns reference to spacing settings"
        postconditions: "Returns Spacing reference"
      
      - type: "struct"
        name: "ContrastChecker"
        description: "Utility for calculating and validating WCAG contrast ratios"
      
      - type: "function"
        name: "ContrastChecker::calculate_contrast"
        description: "Calculates WCAG contrast ratio between two colors"
        preconditions: "Valid RGB color values (0.0-1.0)"
        postconditions: "Returns contrast ratio between 1.0 and 21.0"
      
      - type: "function"
        name: "ContrastChecker::relative_luminance"
        description: "Calculates relative luminance of a color per WCAG formula"
        preconditions: "Valid RGB color values (0.0-1.0)"
        postconditions: "Returns luminance value between 0.0 and 1.0"
      
      - type: "function"
        name: "ContrastChecker::meets_wcag_aa"
        description: "Checks if contrast ratio meets WCAG AA standard (4.5:1 or 3:1 for large text)"
        preconditions: "Valid contrast ratio"
        postconditions: "Returns true if meets WCAG AA"
      
      - type: "function"
        name: "ContrastChecker::meets_wcag_aaa"
        description: "Checks if contrast ratio meets WCAG AAA standard (7:1 or 4.5:1 for large text)"
        preconditions: "Valid contrast ratio"
        postconditions: "Returns true if meets WCAG AAA"

  - file: "src/ui/typography.rs"
    items:
      - type: "module_declaration"
        name: "ui::typography"
        description: "Module defining text styles and typography utilities"
      
      - type: "struct"
        name: "TextStyle"
        description: "Complete text style definition including size, weight, color, and spacing"
      
      - type: "method"
        name: "TextStyle::heading1"
        description: "Creates H1 heading style"
        postconditions: "Returns TextStyle with H1 size and appropriate weight"
      
      - type: "method"
        name: "TextStyle::heading2"
        description: "Creates H2 heading style"
        postconditions: "Returns TextStyle with H2 size and appropriate weight"
      
      - type: "method"
        name: "TextStyle::heading3"
        description: "Creates H3 heading style"
        postconditions: "Returns TextStyle with H3 size and appropriate weight"
      
      - type: "method"
        name: "TextStyle::body"
        description: "Creates body text style"
        postconditions: "Returns TextStyle with body size (16-18px) and normal weight"
      
      - type: "method"
        name: "TextStyle::secondary"
        description: "Creates secondary text style"
        postconditions: "Returns TextStyle with secondary size (14px) and reduced opacity"
      
      - type: "method"
        name: "TextStyle::caption"
        description: "Creates caption text style"
        postconditions: "Returns TextStyle with minimum size (12px)"
      
      - type: "method"
        name: "TextStyle::with_color"
        description: "Sets text color"
        preconditions: "Valid Color provided"
        postconditions: "Returns TextStyle with specified color"
      
      - type: "method"
        name: "TextStyle::with_weight"
        description: "Sets font weight"
        preconditions: "Valid font weight"
        postconditions: "Returns TextStyle with specified weight"

  - file: "src/ui/spacing.rs"
    items:
      - type: "module_declaration"
        name: "ui::spacing"
        description: "Module providing spacing utilities and grid system helpers"
      
      - type: "function"
        name: "grid_unit"
        description: "Returns spacing for N grid units (N * 8px)"
        preconditions: "n is positive"
        postconditions: "Returns n * 8"
      
      - type: "function"
        name: "responsive_spacing"
        description: "Returns spacing scaled for current breakpoint"
        preconditions: "Valid breakpoint"
        postconditions: "Returns spacing appropriate for screen size"

  - file: "src/ui/accessibility.rs"
    items:
      - type: "module_declaration"
        name: "ui::accessibility"
        description: "Module providing accessibility utilities including focus indicators and ARIA-like helpers"
      
      - type: "struct"
        name: "FocusIndicator"
        description: "Visual focus indicator for keyboard navigation"
        invariants: "Border width >= 2px; high contrast color"
      
      - type: "constant"
        name: "FocusIndicator::BORDER_WIDTH"
        description: "Focus indicator border width (2px minimum)"
      
      - type: "constant"
        name: "FocusIndicator::BORDER_COLOR"
        description: "Focus indicator color with high contrast"
      
      - type: "method"
        name: "FocusIndicator::default"
        description: "Returns default focus indicator style"
        postconditions: "Focus indicator meets WCAG visibility requirements"
      
      - type: "method"
        name: "FocusIndicator::apply"
        description: "Applies focus indicator style to a widget"
        preconditions: "Valid widget"
        postconditions: "Widget has visible focus indicator"
      
      - type: "struct"
        name: "AriaLabel"
        description: "ARIA-like label information for screen readers"
      
      - type: "method"
        name: "AriaLabel::new"
        description: "Creates new ARIA label"
        preconditions: "Label text is non-empty"
        postconditions: "Returns AriaLabel with specified text"
      
      - type: "method"
        name: "AriaLabel::with_description"
        description: "Adds detailed description to ARIA label"
        preconditions: "Description text provided"
        postconditions: "Label includes both name and description"
      
      - type: "function"
        name: "ensure_touch_target_size"
        description: "Ensures widget meets minimum touch target size (48x48px) by adding padding if needed"
        preconditions: "Widget size provided"
        postconditions: "Returns size >= 48x48px"
      
      - type: "function"
        name: "add_screen_reader_label"
        description: "Adds ARIA label or description to widget for screen readers"
        preconditions: "Widget and label text provided"
        postconditions: "Widget has screen reader accessible name"
      
      - type: "struct"
        name: "MotionPreference"
        description: "Tracks user's motion preference for reduced motion support"
      
      - type: "method"
        name: "MotionPreference::should_reduce_motion"
        description: "Checks if animations should be reduced or disabled"
        postconditions: "Returns true if user prefers reduced motion"
      
      - type: "method"
        name: "MotionPreference::from_system"
        description: "Reads motion preference from system settings"
        postconditions: "Returns MotionPreference based on OS settings"

  - file: "src/input/keyboard.rs"
    items:
      - type: "module_declaration"
        name: "input::keyboard"
        description: "Module handling keyboard shortcuts and navigation logic"
      
      - type: "enum"
        name: "KeyboardAction"
        description: "Represents all keyboard-triggered actions in the application"
      
      - type: "enum_variant"
        name: "KeyboardAction::RateQuality1"
        description: "Rate current card with quality 1 (Again)"
      
      - type: "enum_variant"
        name: "KeyboardAction::RateQuality2"
        description: "Rate current card with quality 2 (Hard)"
      
      - type: "enum_variant"
        name: "KeyboardAction::RateQuality3"
        description: "Rate current card with quality 3 (Good)"
      
      - type: "enum_variant"
        name: "KeyboardAction::RateQuality4"
        description: "Rate current card with quality 4 (Easy)"
      
      - type: "enum_variant"
        name: "KeyboardAction::RateQuality5"
        description: "Rate current card with quality 5 (Perfect)"
      
      - type: "enum_variant"
        name: "KeyboardAction::NextCard"
        description: "Move to next card (Space key)"
      
      - type: "enum_variant"
        name: "KeyboardAction::ShowAnswer"
        description: "Reveal answer on current card"
      
      - type: "enum_variant"
        name: "KeyboardAction::Cancel"
        description: "Cancel current operation or go back (Escape key)"
      
      - type: "enum_variant"
        name: "KeyboardAction::Undo"
        description: "Undo last action (Ctrl+Z)"
      
      - type: "enum_variant"
        name: "KeyboardAction::Clear"
        description: "Clear drawing canvas (Ctrl+Backspace)"
      
      - type: "enum_variant"
        name: "KeyboardAction::FocusNext"
        description: "Move focus to next element (Tab)"
      
      - type: "enum_variant"
        name: "KeyboardAction::FocusPrevious"
        description: "Move focus to previous element (Shift+Tab)"
      
      - type: "enum_variant"
        name: "KeyboardAction::ActivateFocused"
        description: "Activate currently focused element (Enter)"
      
      - type: "enum_variant"
        name: "KeyboardAction::NavigateUp"
        description: "Navigate up in list (Up Arrow)"
      
      - type: "enum_variant"
        name: "KeyboardAction::NavigateDown"
        description: "Navigate down in list (Down Arrow)"
      
      - type: "enum_variant"
        name: "KeyboardAction::NavigateLeft"
        description: "Navigate left (Left Arrow)"
      
      - type: "enum_variant"
        name: "KeyboardAction::NavigateRight"
        description: "Navigate right (Right Arrow)"
      
      - type: "struct"
        name: "KeyboardHandler"
        description: "Handles keyboard event processing and shortcut management"
      
      - type: "method"
        name: "KeyboardHandler::new"
        description: "Creates new keyboard handler with default shortcuts registered"
        postconditions: "All standard shortcuts are registered"
      
      - type: "method"
        name: "KeyboardHandler::handle_key_press"
        description: "Processes keyboard event and returns corresponding action"
        preconditions: "Valid KeyCode and Modifiers from iced"
        postconditions: "Returns Some(KeyboardAction) if shortcut matched, None otherwise"
      
      - type: "method"
        name: "KeyboardHandler::register_shortcut"
        description: "Registers a new keyboard shortcut for an action"
        preconditions: "Shortcut not already registered"
        postconditions: "Shortcut added to mapping"
      
      - type: "method"
        name: "KeyboardHandler::get_all_shortcuts"
        description: "Returns list of all registered shortcuts with descriptions"
        postconditions: "Returns Vec of KeyboardShortcut structs"
      
      - type: "struct"
        name: "KeyboardShortcut"
        description: "Represents a keyboard shortcut with key, modifiers, action, and description"
      
      - type: "method"
        name: "KeyboardShortcut::new"
        description: "Creates new keyboard shortcut"
        preconditions: "Valid KeyCode, Modifiers, action, and description"
        postconditions: "Returns initialized KeyboardShortcut"
      
      - type: "method"
        name: "KeyboardShortcut::display_string"
        description: "Returns human-readable shortcut representation (e.g., 'Ctrl+Z')"
        postconditions: "Returns formatted string for display in UI"
      
      - type: "function"
        name: "format_key_combination"
        description: "Formats key and modifiers into readable string"
        preconditions: "Valid KeyCode and Modifiers"
        postconditions: "Returns formatted string (e.g., 'Ctrl+Shift+A')"

  - file: "src/input/mod.rs"
    items:
      - type: "module_declaration"
        name: "keyboard"
        description: "Export keyboard module"

  - file: "src/ui/components/button.rs"
    items:
      - type: "method"
        name: "Button::accessible"
        description: "Creates accessible button with proper sizing (48x48px minimum) and contrast"
        preconditions: "Label text provided"
        postconditions: "Button meets WCAG AA standards and minimum touch target size"
      
      - type: "method"
        name: "Button::with_keyboard_shortcut"
        description: "Adds keyboard shortcut hint to button display"
        preconditions: "Valid shortcut string provided"
        postconditions: "Button shows shortcut hint in UI (e.g., '(Space)')"
      
      - type: "method"
        name: "Button::with_aria_label"
        description: "Adds ARIA label for screen readers"
        preconditions: "Label text provided"
        postconditions: "Button has screen reader accessible name"
      
      - type: "method"
        name: "Button::primary"
        description: "Creates primary action button with appropriate styling"
        postconditions: "Returns button with primary color scheme meeting contrast requirements"
      
      - type: "method"
        name: "Button::secondary"
        description: "Creates secondary action button with appropriate styling"
        postconditions: "Returns button with secondary color scheme meeting contrast requirements"
      
      - type: "method"
        name: "Button::icon_only"
        description: "Creates icon-only button with ensured touch target size"
        preconditions: "Icon and ARIA label provided"
        postconditions: "Button is 48x48px minimum with accessible label"

  - file: "src/ui/components/text_input.rs"
    items:
      - type: "method"
        name: "TextInput::accessible"
        description: "Creates accessible text input with proper labels and ARIA attributes"
        preconditions: "Label text provided"
        postconditions: "Input has visible label and screen reader accessible name"
      
      - type: "method"
        name: "TextInput::with_error_message"
        description: "Adds error message with proper ARIA invalid state"
        preconditions: "Error message text provided"
        postconditions: "Error displayed and announced to screen readers"
      
      - type: "method"
        name: "TextInput::with_placeholder"
        description: "Adds placeholder text that doesn't interfere with label"
        preconditions: "Placeholder text provided"
        postconditions: "Placeholder visible but doesn't replace label"

  - file: "src/ui/components/rating.rs"
    items:
      - type: "struct"
        name: "RatingButtons"
        description: "Quality rating button component (1-5) with keyboard shortcuts"
      
      - type: "method"
        name: "RatingButtons::new"
        description: "Creates rating buttons component"
        postconditions: "Returns component with 5 rating buttons"
      
      - type: "method"
        name: "RatingButtons::with_keyboard_shortcuts"
        description: "Enables keyboard shortcuts (1-5) for quality ratings"
        postconditions: "Number keys 1-5 trigger corresponding rating; shortcuts displayed on buttons"
      
      - type: "method"
        name: "RatingButtons::accessible_labels"
        description: "Adds screen reader labels to each rating button"
        postconditions: "Each button has descriptive label (e.g., '1 - Again', '3 - Good')"
      
      - type: "method"
        name: "RatingButtons::view"
        description: "Renders rating buttons with accessibility features"
        postconditions: "Returns Element with properly sized and labeled buttons"

  - file: "src/ui/layout.rs"
    items:
      - type: "module_declaration"
        name: "ui::layout"
        description: "Module providing responsive layout utilities and breakpoint system"
      
      - type: "enum"
        name: "Breakpoint"
        description: "Defines responsive breakpoints for different screen sizes"
      
      - type: "enum_variant"
        name: "Breakpoint::Mobile"
        description: "Mobile phones (320-640px)"
      
      - type: "enum_variant"
        name: "Breakpoint::Tablet"
        description: "Tablets (641-1024px)"
      
      - type: "enum_variant"
        name: "Breakpoint::Desktop"
        description: "Desktop screens (1025-1440px)"
      
      - type: "enum_variant"
        name: "Breakpoint::Wide"
        description: "Wide screens (1441px+)"
      
      - type: "struct"
        name: "ResponsiveLayout"
        description: "Layout configuration that adapts to window size"
      
      - type: "method"
        name: "ResponsiveLayout::new"
        description: "Creates new responsive layout manager"
        postconditions: "Returns initialized layout with default settings"
      
      - type: "method"
        name: "ResponsiveLayout::compute_for_width"
        description: "Computes layout configuration for given window width"
        preconditions: "Width is positive"
        postconditions: "Returns layout config appropriate for breakpoint"
      
      - type: "method"
        name: "ResponsiveLayout::get_breakpoint"
        description: "Determines current breakpoint based on window width"
        preconditions: "Valid window width provided"
        postconditions: "Returns appropriate Breakpoint variant"
      
      - type: "function"
        name: "responsive_column_count"
        description: "Returns appropriate column count for current breakpoint"
        preconditions: "Valid breakpoint"
        postconditions: "Returns 1-4 columns based on breakpoint"
      
      - type: "function"
        name: "responsive_padding"
        description: "Returns appropriate padding for current breakpoint"
        preconditions: "Valid breakpoint"
        postconditions: "Returns padding scaled to screen size"
      
      - type: "function"
        name: "responsive_font_scale"
        description: "Returns font size scaling factor for breakpoint"
        preconditions: "Valid breakpoint"
        postconditions: "Returns scale factor 0.8-1.2"

  - file: "src/ui/screens/practice_screen.rs"
    items:
      - type: "method"
        name: "PracticeScreen::handle_keyboard_event"
        description: "Handles keyboard shortcuts for practice screen (Clear, Undo, etc.)"
        preconditions: "Valid keyboard event from iced"
        postconditions: "Returns Message for corresponding action or None"
      
      - type: "method"
        name: "PracticeScreen::update_responsive_layout"
        description: "Updates layout based on current window size"
        preconditions: "Valid window dimensions"
        postconditions: "Layout optimized for current breakpoint"
      
      - type: "method"
        name: "PracticeScreen::apply_accessibility_features"
        description: "Applies focus indicators and touch target sizing"
        postconditions: "All interactive elements meet accessibility standards"

  - file: "src/ui/screens/review_screen.rs"
    items:
      - type: "method"
        name: "ReviewScreen::handle_keyboard_event"
        description: "Handles keyboard shortcuts for review screen (1-5 ratings, Space, etc.)"
        preconditions: "Valid keyboard event"
        postconditions: "Returns Message for corresponding action or None"
      
      - type: "method"
        name: "ReviewScreen::update_responsive_layout"
        description: "Updates layout based on current window size"
        preconditions: "Valid window dimensions"
        postconditions: "Layout optimized for current breakpoint"
      
      - type: "method"
        name: "ReviewScreen::apply_accessibility_features"
        description: "Applies focus indicators and accessible button labels"
        postconditions: "All controls meet accessibility standards"

  - file: "src/ui/screens/deck_list_screen.rs"
    items:
      - type: "method"
        name: "DeckListScreen::handle_keyboard_event"
        description: "Handles keyboard shortcuts for deck list (arrow keys, Enter, etc.)"
        preconditions: "Valid keyboard event"
        postconditions: "Returns Message for corresponding action or None"
      
      - type: "method"
        name: "DeckListScreen::update_responsive_layout"
        description: "Updates grid layout based on window size"
        preconditions: "Valid window dimensions"
        postconditions: "Grid columns adjust to breakpoint (1-4 columns)"

  - file: "src/ui/screens/settings_screen.rs"
    items:
      - type: "method"
        name: "SettingsScreen::handle_keyboard_event"
        description: "Handles keyboard navigation in settings"
        preconditions: "Valid keyboard event"
        postconditions: "Returns Message for corresponding action or None"
      
      - type: "method"
        name: "SettingsScreen::update_responsive_layout"
        description: "Updates form layout based on window size"
        preconditions: "Valid window dimensions"
        postconditions: "Form adapts to screen width"

  - file: "src/ui/screens/help_screen.rs"
    items:
      - type: "struct"
        name: "HelpScreen"
        description: "Help screen documenting keyboard shortcuts and accessibility features"
      
      - type: "method"
        name: "HelpScreen::new"
        description: "Creates new help screen"
        postconditions: "Returns initialized help screen with all documentation"
      
      - type: "method"
        name: "HelpScreen::view"
        description: "Renders help screen with keyboard shortcuts table"
        postconditions: "Returns Element displaying all shortcuts organized by category"
      
      - type: "function"
        name: "render_shortcuts_table"
        description: "Renders table of keyboard shortcuts"
        postconditions: "Returns formatted table with shortcut key, description columns"
      
      - type: "function"
        name: "render_accessibility_info"
        description: "Renders accessibility features information"
        postconditions: "Returns formatted accessibility documentation"

  - file: "src/ui/app.rs"
    items:
      - type: "method"
        name: "App::subscription"
        description: "Subscribes to keyboard events for global shortcuts"
        postconditions: "Returns subscription to keyboard event stream"
      
      - type: "method"
        name: "App::update_keyboard_event"
        description: "Routes keyboard events to appropriate screen handler"
        preconditions: "Valid keyboard event from subscription"
        postconditions: "Event processed and state updated if action matched"
      
      - type: "method"
        name: "App::update_theme"
        description: "Updates application theme with accessibility settings"
        preconditions: "Valid theme configuration"
        postconditions: "All UI components use new theme"
      
      - type: "method"
        name: "App::update_window_size"
        description: "Updates responsive layouts when window resizes"
        preconditions: "Valid window dimensions"
        postconditions: "All screens update their responsive layouts"

  - file: "src/ui/mod.rs"
    items:
      - type: "module_declaration"
        name: "theme"
        description: "Export theme module"
      
      - type: "module_declaration"
        name: "typography"
        description: "Export typography module"
      
      - type: "module_declaration"
        name: "spacing"
        description: "Export spacing module"
      
      - type: "module_declaration"
        name: "accessibility"
        description: "Export accessibility module"
      
      - type: "module_declaration"
        name: "layout"
        description: "Export layout module"

  - file: "tests/accessibility_tests.rs"
    items:
      - type: "function"
        name: "test_primary_text_meets_wcag_aa_contrast"
        description: "Verifies primary text meets 4.5:1 contrast ratio"
        postconditions: "Primary text contrast >= 4.5"
      
      - type: "function"
        name: "test_secondary_text_meets_wcag_aa_contrast"
        description: "Verifies secondary text meets 4.5:1 contrast ratio"
        postconditions: "Secondary text contrast >= 4.5"
      
      - type: "function"
        name: "test_button_text_meets_wcag_aa_contrast"
        description: "Verifies button text meets 4.5:1 contrast ratio"
        postconditions: "Button text contrast >= 4.5"
      
      - type: "function"
        name: "test_error_text_meets_wcag_aa_contrast"
        description: "Verifies error text meets 4.5:1 contrast ratio"
        postconditions: "Error text contrast >= 4.5"
      
      - type: "function"
        name: "test_success_text_meets_wcag_aa_contrast"
        description: "Verifies success text meets 4.5:1 contrast ratio"
        postconditions: "Success text contrast >= 4.5"
      
      - type: "function"
        name: "test_large_text_meets_wcag_aa_contrast"
        description: "Verifies large text (headings) meets 3:1 contrast ratio"
        postconditions: "Heading contrast >= 3.0"
      
      - type: "function"
        name: "test_focus_indicator_meets_wcag_contrast"
        description: "Verifies focus indicator meets 3:1 contrast ratio"
        postconditions: "Focus indicator contrast >= 3.0"
      
      - type: "function"
        name: "test_all_palette_colors_are_valid_rgb"
        description: "Verifies all colors have valid RGB values (0.0-1.0)"
        postconditions: "All color components in valid range"
      
      - type: "function"
        name: "test_primary_button_meets_minimum_touch_target"
        description: "Verifies primary buttons are at least 48x48px"
        postconditions: "Button width and height >= 48px"
      
      - type: "function"
        name: "test_icon_button_meets_minimum_touch_target"
        description: "Verifies icon buttons are at least 48x48px"
        postconditions: "Icon button size >= 48x48px"
      
      - type: "function"
        name: "test_quality_rating_buttons_meet_touch_target"
        description: "Verifies quality rating buttons are at least 48x48px"
        postconditions: "Rating buttons >= 48x48px"
      
      - type: "function"
        name: "test_minimum_font_sizes_meet_legibility_standards"
        description: "Verifies font sizes meet minimum standards (body >= 16px, secondary >= 14px, min >= 12px)"
        postconditions: "All font sizes meet minimum requirements"
      
      - type: "function"
        name: "test_heading_hierarchy_is_logical"
        description: "Verifies heading sizes follow logical hierarchy (H1 > H2 > H3 > body)"
        postconditions: "Heading sizes decrease in order"
      
      - type: "function"
        name: "test_line_height_meets_wcag_recommendations"
        description: "Verifies line height is at least 1.5 for body text"
        postconditions: "Body line height >= 1.5"
      
      - type: "function"
        name: "test_quality_shortcuts_1_through_5_registered"
        description: "Verifies keyboard shortcuts 1-5 are registered for quality ratings"
        postconditions: "All 5 quality shortcuts present"
      
      - type: "function"
        name: "test_space_key_triggers_next_card"
        description: "Verifies Space key triggers next card action"
        postconditions: "Space produces NextCard message"
      
      - type: "function"
        name: "test_escape_key_cancels_or_goes_back"
        description: "Verifies Escape key triggers cancel/back action"
        postconditions: "Escape produces Cancel message"
      
      - type: "function"
        name: "test_tab_navigation_cycles_through_elements"
        description: "Verifies Tab and Shift+Tab navigate focus"
        postconditions: "Tab moves focus forward, Shift+Tab backward"
      
      - type: "function"
        name: "test_enter_key_activates_focused_element"
        description: "Verifies Enter key activates focused element"
        postconditions: "Enter produces activation message"
      
      - type: "function"
        name: "test_arrow_keys_navigate_lists"
        description: "Verifies Up/Down arrow keys navigate lists"
        postconditions: "Arrow keys produce navigation messages"
      
      - type: "function"
        name: "test_all_shortcuts_have_descriptions"
        description: "Verifies all keyboard shortcuts have human-readable descriptions"
        postconditions: "No shortcut has empty description"
      
      - type: "function"
        name: "test_focus_border_width_meets_minimum"
        description: "Verifies focus indicator border is at least 2px wide"
        postconditions: "Focus border width >= 2px"
      
      - type: "function"
        name: "test_layout_adapts_to_narrow_width"
        description: "Verifies layout uses mobile breakpoint at 400px width"
        postconditions: "Breakpoint is Mobile for narrow width"
      
      - type: "function"
        name: "test_layout_adapts_to_wide_width"
        description: "Verifies layout uses desktop breakpoint at 1200px width"
        postconditions: "Breakpoint is Desktop for wide width"
      
      - type: "function"
        name: "test_spacing_uses_8px_base_unit"
        description: "Verifies all spacing values are multiples of 8px"
        postconditions: "All spacing % 8 == 0"
      
      - type: "function"
        name: "test_spacing_scale_is_progressive"
        description: "Verifies spacing scale increases progressively (xs < sm < md < lg < xl)"
        postconditions: "Each spacing level larger than previous"
      
      - type: "function"
        name: "test_all_buttons_have_aria_labels"
        description: "Verifies all interactive elements have ARIA labels"
        postconditions: "No element has empty label"
      
      - type: "function"
        name: "test_icon_only_buttons_have_descriptive_labels"
        description: "Verifies icon buttons have descriptive labels (not just 'icon')"
        postconditions: "Labels describe action, not appearance"
      
      - type: "function"
        name: "prop_contrast_calculation_is_commutative"
        description: "Property test: contrast(A,B) == contrast(B,A)"
        postconditions: "Contrast calculation order-independent"
      
      - type: "function"
        name: "prop_contrast_ratio_always_positive"
        description: "Property test: contrast ratio is always positive"
        postconditions: "All contrast ratios > 0"
      
      - type: "function"
        name: "prop_contrast_ratio_bounded"
        description: "Property test: contrast ratio is between 1:1 and 21:1"
        postconditions: "All contrast ratios in [1.0, 21.0]"
      
      - type: "function"
        name: "prop_touch_target_scaling_maintains_minimum"
        description: "Property test: scaled buttons maintain 48px minimum"
        postconditions: "Scaled buttons never below minimum size"

formal_verification:
  needed: false
  level: "None"
  explanation: |
    Formal verification is not needed for UI/UX Polish and Accessibility work for the following reasons:

    1. WCAG Compliance is Empirical, Not Provable: Accessibility requirements like contrast ratios (4.5:1 for WCAG AA) 
       and touch target sizes (48x48px minimum) are measurable properties validated through empirical testing with 
       automated tools (axe, Lighthouse, WAVE) and manual verification, not formal proofs. The correct approach is 
       automated accessibility testing integrated into CI/CD pipelines.

    2. UI/UX is Perceptual and User-Centered: Polish aspects like typography scales, responsive layouts, and visual 
       consistency are evaluated through user testing, design review, and visual regression testing. These are subjective 
       quality attributes that cannot be formally verified - they require human judgment and usability testing.

    3. Platform-Specific Implementation Details: Screen reader support, keyboard navigation, and touch interactions 
       depend on platform-specific APIs and assistive technology behavior that varies across operating systems and 
       devices. Verification requires real-world testing on actual platforms, not mathematical proofs.

    4. Contrast Ratio is Simple Arithmetic: While contrast ratio calculation (luminance formula per WCAG 2.1) involves 
       mathematical operations, these are straightforward arithmetic operations easily validated with unit tests. The 
       complexity does not warrant formal verification - automated accessibility scanners already provide this validation.

    5. Property-Based Testing is More Appropriate: For properties like "all interactive elements are 48x48px or larger," 
       property-based testing that scans the UI tree and measures actual rendered dimensions is far more practical and 
       reliable than attempting to prove this formally about UI code.

    6. Cost-Benefit Analysis: Formal verification tools and expertise would be enormously expensive for UI work that 
       changes frequently based on user feedback and design iterations. The verification would become outdated with 
       every design change. Standard accessibility testing tools provide better ROI.

    The appropriate verification strategy for accessibility is:
    - Automated accessibility testing (axe-core, pa11y, Lighthouse)
    - Manual testing with screen readers (NVDA, JAWS, VoiceOver)
    - Keyboard navigation testing
    - Visual regression testing
    - User testing with people who use assistive technologies
    - Contrast ratio validation with automated tools

    These empirical approaches provide stronger accessibility guarantees than formal verification could for UI/UX work.

tests:
  strategy:
    approach: "mixed (unit tests + integration tests + property-based tests + manual verification)"
    rationale:
      - "Unit tests verify quantifiable accessibility properties like contrast ratios, dimensions, and color values with precise assertions"
      - "Integration tests validate keyboard event handling pipeline and focus management across component interactions"
      - "Property-based tests ensure contrast calculations and touch target scaling maintain invariants across all possible color/size inputs"
      - "Manual verification checklist required for screen reader compatibility since assistive technology behavior cannot be automated"
      - "Automated tests catch regressions in measurable WCAG criteria while manual tests validate real-world usability with assistive devices"

  implementation:
    file: "tests/accessibility_tests.rs"
    location: "create new"
    code: |
      //! Comprehensive accessibility tests for Task 13: UI/UX Polish and Accessibility
      //!
      //! This test suite validates WCAG 2.1 Level AA compliance including:
      //! - 4.5:1 contrast ratio for normal text
      //! - 3:1 contrast ratio for large text and UI components
      //! - 48x48px minimum touch targets
      //! - Keyboard accessibility for all functionality
      //! - Typography scale meeting legibility standards
      //! - Responsive layout adaptation
      //! - Screen reader label presence
      
      #[cfg(test)]
      mod accessibility_tests {
          use super::*;
      
          mod color_contrast_tests {
              use crate::ui::theme::{ColorPalette, ContrastChecker, MIN_CONTRAST_RATIO};
              use iced::Color;
      
              #[test]
              fn test_primary_text_meets_wcag_aa_contrast() {
                  let palette = ColorPalette::default();
                  let contrast = ContrastChecker::calculate_contrast(
                      palette.text_primary,
                      palette.background_primary
                  );
                  assert!(
                      contrast >= 4.5,
                      "Primary text contrast {:.2} does not meet WCAG AA (4.5:1) - CRITICAL",
                      contrast
                  );
              }
      
              #[test]
              fn test_secondary_text_meets_wcag_aa_contrast() {
                  let palette = ColorPalette::default();
                  let contrast = ContrastChecker::calculate_contrast(
                      palette.text_secondary,
                      palette.background_primary
                  );
                  assert!(
                      contrast >= 4.5,
                      "Secondary text contrast {:.2} does not meet WCAG AA (4.5:1)",
                      contrast
                  );
              }
      
              #[test]
              fn test_button_text_meets_wcag_aa_contrast() {
                  let palette = ColorPalette::default();
                  let contrast = ContrastChecker::calculate_contrast(
                      palette.button_text,
                      palette.button_background
                  );
                  assert!(
                      contrast >= 4.5,
                      "Button text contrast {:.2} does not meet WCAG AA (4.5:1)",
                      contrast
                  );
              }
      
              #[test]
              fn test_error_text_meets_wcag_aa_contrast() {
                  let palette = ColorPalette::default();
                  let contrast = ContrastChecker::calculate_contrast(
                      palette.error_text,
                      palette.background_primary
                  );
                  assert!(
                      contrast >= 4.5,
                      "Error text contrast {:.2} does not meet WCAG AA (4.5:1) - accessibility critical",
                      contrast
                  );
              }
      
              #[test]
              fn test_success_text_meets_wcag_aa_contrast() {
                  let palette = ColorPalette::default();
                  let contrast = ContrastChecker::calculate_contrast(
                      palette.success_text,
                      palette.background_primary
                  );
                  assert!(
                      contrast >= 4.5,
                      "Success text contrast {:.2} does not meet WCAG AA (4.5:1)",
                      contrast
                  );
              }
      
              #[test]
              fn test_large_text_meets_wcag_aa_contrast() {
                  // Large text (18px+ or 14px+ bold) requires 3:1 minimum
                  let palette = ColorPalette::default();
                  let contrast = ContrastChecker::calculate_contrast(
                      palette.heading_text,
                      palette.background_primary
                  );
                  assert!(
                      contrast >= 3.0,
                      "Large text contrast {:.2} does not meet WCAG AA (3:1)",
                      contrast
                  );
              }
      
              #[test]
              fn test_focus_indicator_meets_wcag_contrast() {
                  let palette = ColorPalette::default();
                  let contrast = ContrastChecker::calculate_contrast(
                      palette.focus_indicator,
                      palette.background_primary
                  );
                  assert!(
                      contrast >= 3.0,
                      "Focus indicator contrast {:.2} does not meet WCAG (3:1) - keyboard nav critical",
                      contrast
                  );
              }
      
              #[test]
              fn test_disabled_text_has_sufficient_contrast() {
                  // Disabled text should still be perceivable
                  let palette = ColorPalette::default();
                  let contrast = ContrastChecker::calculate_contrast(
                      palette.text_disabled,
                      palette.background_primary
                  );
                  assert!(
                      contrast >= 3.0,
                      "Disabled text contrast {:.2} too low for perception",
                      contrast
                  );
              }
      
              #[test]
              fn test_all_palette_colors_are_valid_rgb() {
                  let palette = ColorPalette::default();
                  for (name, color) in palette.all_colors() {
                      assert!(color.r <= 1.0 && color.r >= 0.0, "{} red channel out of range [0,1]", name);
                      assert!(color.g <= 1.0 && color.g >= 0.0, "{} green channel out of range [0,1]", name);
                      assert!(color.b <= 1.0 && color.b >= 0.0, "{} blue channel out of range [0,1]", name);
                      assert!(color.a <= 1.0 && color.a >= 0.0, "{} alpha channel out of range [0,1]", name);
                  }
              }
      
              #[test]
              fn test_contrast_checker_calculates_correctly() {
                  // Test with known values: pure white on pure black should be 21:1
                  let white = Color::from_rgb(1.0, 1.0, 1.0);
                  let black = Color::from_rgb(0.0, 0.0, 0.0);
                  let contrast = ContrastChecker::calculate_contrast(white, black);
                  
                  assert!(
                      (contrast - 21.0).abs() < 0.1,
                      "White on black should be 21:1, got {:.2}",
                      contrast
                  );
              }
      
              #[test]
              fn test_contrast_checker_handles_identical_colors() {
                  // Same color should have 1:1 contrast
                  let color = Color::from_rgb(0.5, 0.5, 0.5);
                  let contrast = ContrastChecker::calculate_contrast(color, color);
                  
                  assert!(
                      (contrast - 1.0).abs() < 0.01,
                      "Identical colors should have 1:1 contrast, got {:.2}",
                      contrast
                  );
              }
          }
      
          mod touch_target_tests {
              use crate::ui::components::{Button, IconButton, TouchTargetValidator};
              use crate::ui::theme::MIN_TOUCH_TARGET_SIZE;
      
              #[test]
              fn test_min_touch_target_constant_value() {
                  assert_eq!(
                      MIN_TOUCH_TARGET_SIZE, 48,
                      "WCAG minimum touch target should be 48px"
                  );
              }
      
              #[test]
              fn test_primary_button_meets_minimum_touch_target() {
                  let button = Button::primary("Submit");
                  let size = button.minimum_size();
                  assert!(
                      size.width >= MIN_TOUCH_TARGET_SIZE,
                      "Primary button width {} below minimum {}px",
                      size.width,
                      MIN_TOUCH_TARGET_SIZE
                  );
                  assert!(
                      size.height >= MIN_TOUCH_TARGET_SIZE,
                      "Primary button height {} below minimum {}px",
                      size.height,
                      MIN_TOUCH_TARGET_SIZE
                  );
              }
      
              #[test]
              fn test_secondary_button_meets_minimum_touch_target() {
                  let button = Button::secondary("Cancel");
                  let size = button.minimum_size();
                  assert!(
                      size.width >= MIN_TOUCH_TARGET_SIZE && size.height >= MIN_TOUCH_TARGET_SIZE,
                      "Secondary button {}x{} below minimum {}x{}",
                      size.width, size.height, MIN_TOUCH_TARGET_SIZE, MIN_TOUCH_TARGET_SIZE
                  );
              }
      
              #[test]
              fn test_icon_button_meets_minimum_touch_target() {
                  let button = IconButton::new("settings");
                  let size = button.minimum_size();
                  assert!(
                      size.width >= MIN_TOUCH_TARGET_SIZE && size.height >= MIN_TOUCH_TARGET_SIZE,
                      "Icon button {}x{} below minimum {}x{} - critical for accessibility",
                      size.width, size.height, MIN_TOUCH_TARGET_SIZE, MIN_TOUCH_TARGET_SIZE
                  );
              }
      
              #[test]
              fn test_quality_rating_buttons_meet_touch_target() {
                  // Test all 5 quality ratings (1-5)
                  for quality in 1..=5 {
                      let button = Button::quality_rating(quality);
                      let size = button.minimum_size();
                      assert!(
                          size.width >= MIN_TOUCH_TARGET_SIZE && size.height >= MIN_TOUCH_TARGET_SIZE,
                          "Quality {} rating button {}x{} too small",
                          quality, size.width, size.height
                      );
                  }
              }
      
              #[test]
              fn test_close_button_meets_touch_target() {
                  let button = IconButton::close();
                  let size = button.minimum_size();
                  assert!(
                      size.width >= MIN_TOUCH_TARGET_SIZE,
                      "Close button width {} below minimum",
                      size.width
                  );
                  assert!(
                      size.height >= MIN_TOUCH_TARGET_SIZE,
                      "Close button height {} below minimum",
                      size.height
                  );
              }
      
              #[test]
              fn test_text_input_meets_touch_target_height() {
                  use crate::ui::components::TextInput;
                  
                  let input = TextInput::new("placeholder");
                  let size = input.minimum_size();
                  assert!(
                      size.height >= MIN_TOUCH_TARGET_SIZE,
                      "Text input height {} below minimum for touch",
                      size.height
                  );
              }
      
              #[test]
              fn test_checkbox_meets_touch_target() {
                  use crate::ui::components::Checkbox;
                  
                  let checkbox = Checkbox::new(false, "Option");
                  let size = checkbox.minimum_size();
                  assert!(
                      size.width >= MIN_TOUCH_TARGET_SIZE && size.height >= MIN_TOUCH_TARGET_SIZE,
                      "Checkbox {}x{} too small for reliable touch",
                      size.width, size.height
                  );
              }
      
              #[test]
              fn test_all_interactive_elements_validated() {
                  let validator = TouchTargetValidator::new();
                  let elements = validator.collect_interactive_elements();
                  
                  assert!(
                      !elements.is_empty(),
                      "Should find interactive elements to validate"
                  );
                  
                  for element in elements {
                      let size = element.computed_size();
                      assert!(
                          size.width >= MIN_TOUCH_TARGET_SIZE && size.height >= MIN_TOUCH_TARGET_SIZE,
                          "Element '{}' fails touch target: {}x{}",
                          element.name(), size.width, size.height
                      );
                  }
              }
          }
      
          mod typography_tests {
              use crate::ui::theme::Typography;
      
              #[test]
              fn test_body_text_meets_minimum_size() {
                  let typo = Typography::default();
                  assert!(
                      typo.body_size >= 16.0,
                      "Body text {} below recommended 16px minimum",
                      typo.body_size
                  );
              }
      
              #[test]
              fn test_secondary_text_meets_minimum_size() {
                  let typo = Typography::default();
                  assert!(
                      typo.secondary_size >= 14.0,
                      "Secondary text {} below recommended 14px minimum",
                      typo.secondary_size
                  );
              }
      
              #[test]
              fn test_absolute_minimum_text_size() {
                  let typo = Typography::default();
                  assert!(
                      typo.minimum_size >= 12.0,
                      "Minimum text {} below absolute 12px floor - may be illegible",
                      typo.minimum_size
                  );
              }
      
              #[test]
              fn test_heading_hierarchy_is_logical() {
                  let typo = Typography::default();
                  
                  assert!(typo.h1_size > typo.h2_size, "H1 ({}) should be larger than H2 ({})", typo.h1_size, typo.h2_size);
                  assert!(typo.h2_size > typo.h3_size, "H2 ({}) should be larger than H3 ({})", typo.h2_size, typo.h3_size);
                  assert!(typo.h3_size > typo.body_size, "H3 ({}) should be larger than body ({})", typo.h3_size, typo.body_size);
              }
      
              #[test]
              fn test_line_height_meets_wcag_recommendations() {
                  let typo = Typography::default();
                  assert!(
                      typo.body_line_height >= 1.5,
                      "Body line height {} below WCAG 1.5 recommendation - impacts readability",
                      typo.body_line_height
                  );
              }
      
              #[test]
              fn test_heading_line_height_is_reasonable() {
                  let typo = Typography::default();
                  assert!(
                      typo.heading_line_height >= 1.2,
                      "Heading line height {} too tight",
                      typo.heading_line_height
                  );
              }
      
              #[test]
              fn test_letter_spacing_is_non_negative() {
                  let typo = Typography::default();
                  assert!(
                      typo.body_letter_spacing >= 0.0,
                      "Negative letter spacing {} reduces readability",
                      typo.body_letter_spacing
                  );
              }
      
              #[test]
              fn test_font_weights_are_valid() {
                  use crate::ui::theme::FontWeight;
                  let typo = Typography::default();
                  
                  // Font weights should be multiples of 100 between 100-900
                  assert!(typo.regular_weight >= 100 && typo.regular_weight <= 900);
                  assert!(typo.bold_weight >= 100 && typo.bold_weight <= 900);
                  assert!(typo.bold_weight > typo.regular_weight, "Bold should be heavier than regular");
              }
          }
      
          mod keyboard_navigation_tests {
              use crate::ui::keyboard::{KeyboardHandler, KeyboardShortcut};
              use iced::keyboard::{KeyCode, Modifiers};
              use crate::Message;
      
              #[test]
              fn test_quality_shortcuts_1_through_5_registered() {
                  let handler = KeyboardHandler::new();
                  
                  for quality in 1..=5 {
                      let key = match quality {
                          1 => KeyCode::Key1,
                          2 => KeyCode::Key2,
                          3 => KeyCode::Key3,
                          4 => KeyCode::Key4,
                          5 => KeyCode::Key5,
                          _ => unreachable!(),
                      };
                      
                      let result = handler.handle_key_press(key, Modifiers::empty());
                      assert!(
                          result.is_some(),
                          "Quality shortcut {} not registered - keyboard-only users cannot rate",
                          quality
                      );
                      
                      if let Some(Message::RateCard(q)) = result {
                          assert_eq!(q, quality, "Shortcut {} returned wrong quality {}", quality, q);
                      }
                  }
              }
      
              #[test]
              fn test_space_key_triggers_next_card() {
                  let handler = KeyboardHandler::new();
                  let result = handler.handle_key_press(KeyCode::Space, Modifiers::empty());
                  
                  assert!(result.is_some(), "Space key should trigger next card");
                  match result {
                      Some(Message::NextCard) => {},
                      _ => panic!("Space key should produce NextCard message, got {:?}", result),
                  }
              }
      
              #[test]
              fn test_escape_key_cancels_or_goes_back() {
                  let handler = KeyboardHandler::new();
                  let result = handler.handle_key_press(KeyCode::Escape, Modifiers::empty());
                  
                  assert!(
                      result.is_some(),
                      "Escape key should trigger cancel/back - critical for keyboard navigation"
                  );
              }
      
              #[test]
              fn test_tab_navigation_forward() {
                  let handler = KeyboardHandler::new();
                  let result = handler.handle_key_press(KeyCode::Tab, Modifiers::empty());
                  
                  assert!(
                      result.is_some(),
                      "Tab should move focus forward - required for keyboard navigation"
                  );
              }
      
              #[test]
              fn test_shift_tab_navigation_backward() {
                  let handler = KeyboardHandler::new();
                  let result = handler.handle_key_press(KeyCode::Tab, Modifiers::SHIFT);
                  
                  assert!(
                      result.is_some(),
                      "Shift+Tab should move focus backward"
                  );
              }
      
              #[test]
              fn test_enter_key_activates_focused_element() {
                  let handler = KeyboardHandler::new();
                  let result = handler.handle_key_press(KeyCode::Enter, Modifiers::empty());
                  
                  assert!(
                      result.is_some(),
                      "Enter should activate focused element - core keyboard interaction"
                  );
              }
      
              #[test]
              fn test_arrow_keys_navigate_lists() {
                  let handler = KeyboardHandler::new();
                  
                  let up = handler.handle_key_press(KeyCode::Up, Modifiers::empty());
                  let down = handler.handle_key_press(KeyCode::Down, Modifiers::empty());
                  let left = handler.handle_key_press(KeyCode::Left, Modifiers::empty());
                  let right = handler.handle_key_press(KeyCode::Right, Modifiers::empty());
                  
                  assert!(up.is_some(), "Up arrow should navigate");
                  assert!(down.is_some(), "Down arrow should navigate");
                  assert!(left.is_some() || right.is_some(), "Horizontal arrows should navigate");
              }
      
              #[test]
              fn test_all_shortcuts_have_descriptions() {
                  let handler = KeyboardHandler::new();
                  let shortcuts = handler.get_all_shortcuts();
                  
                  assert!(!shortcuts.is_empty(), "Should have registered shortcuts");
                  
                  for shortcut in shortcuts {
                      assert!(
                          !shortcut.description.is_empty(),
                          "Shortcut {:?} missing description for help screen",
                          shortcut.key
                      );
                      assert!(
                          shortcut.description.len() >= 5,
                          "Shortcut {:?} description too short: '{}'",
                          shortcut.key, shortcut.description
                      );
                  }
              }
      
              #[test]
              fn test_no_shortcut_conflicts() {
                  let handler = KeyboardHandler::new();
                  let shortcuts = handler.get_all_shortcuts();
                  
                  let mut seen = std::collections::HashSet::new();
                  for shortcut in shortcuts {
                      let key_combo = (shortcut.key, shortcut.modifiers);
                      assert!(
                          seen.insert(key_combo),
                          "Duplicate keyboard shortcut: {:?}+{:?}",
                          shortcut.modifiers, shortcut.key
                      );
                  }
              }
      
              #[test]
              fn test_help_key_shows_shortcuts() {
                  let handler = KeyboardHandler::new();
                  let result = handler.handle_key_press(KeyCode::F1, Modifiers::empty());
                  
                  assert!(
                      result.is_some(),
                      "F1 or ? should show keyboard shortcuts help"
                  );
              }
          }
      
          mod focus_indicator_tests {
              use crate::ui::theme::{FocusIndicator, BorderStyle};
      
              #[test]
              fn test_focus_border_width_meets_minimum() {
                  let indicator = FocusIndicator::default();
                  assert!(
                      indicator.border_width >= 2.0,
                      "Focus border {} below 2px minimum - may be invisible",
                      indicator.border_width
                  );
              }
      
              #[test]
              fn test_focus_indicator_is_visible_style() {
                  let indicator = FocusIndicator::default();
                  assert!(
                      indicator.style != BorderStyle::Hidden,
                      "Focus indicator must be visible for keyboard navigation"
                  );
              }
      
              #[test]
              fn test_focus_indicator_distinct_from_default_borders() {
                  let focus = FocusIndicator::default();
                  let normal = BorderStyle::default();
                  
                  assert_ne!(
                      focus.color, normal.color,
                      "Focus indicator must be visually distinct"
                  );
              }
      
              #[test]
              fn test_focus_indicator_has_animation() {
                  let indicator = FocusIndicator::default();
                  assert!(
                      indicator.animation_enabled,
                      "Focus animation improves visibility"
                  );
              }
          }
      
          mod responsive_layout_tests {
              use crate::ui::layout::{ResponsiveLayout, BreakPoint};
      
              #[test]
              fn test_mobile_breakpoint_at_narrow_width() {
                  let layout = ResponsiveLayout::new();
                  let mobile = layout.compute_for_width(320);
                  
                  assert_eq!(
                      mobile.breakpoint,
                      BreakPoint::Mobile,
                      "320px should use mobile layout"
                  );
              }
      
              #[test]
              fn test_tablet_breakpoint_at_medium_width() {
                  let layout = ResponsiveLayout::new();
                  let tablet = layout.compute_for_width(768);
                  
                  assert_eq!(
                      tablet.breakpoint,
                      BreakPoint::Tablet,
                      "768px should use tablet layout"
                  );
              }
      
              #[test]
              fn test_desktop_breakpoint_at_wide_width() {
                  let layout = ResponsiveLayout::new();
                  let desktop = layout.compute_for_width(1200);
                  
                  assert_eq!(
                      desktop.breakpoint,
                      BreakPoint::Desktop,
                      "1200px should use desktop layout"
                  );
              }
      
              #[test]
              fn test_text_wraps_at_narrow_widths() {
                  let layout = ResponsiveLayout::new();
                  let narrow = layout.compute_for_width(320);
                  
                  assert!(
                      narrow.text_wrap_enabled,
                      "Text must wrap at narrow widths to prevent horizontal scrolling"
                  );
              }
      
              #[test]
              fn test_spacing_scales_with_screen_size() {
                  let layout = ResponsiveLayout::new();
                  
                  let mobile_spacing = layout.compute_for_width(320).base_spacing;
                  let desktop_spacing = layout.compute_for_width(1920).base_spacing;
                  
                  assert!(
                      desktop_spacing >= mobile_spacing,
                      "Desktop spacing should be equal or greater than mobile"
                  );
              }
      
              #[test]
              fn test_column_count_adapts_to_width() {
                  let layout = ResponsiveLayout::new();
                  
                  let mobile_cols = layout.compute_for_width(320).columns;
                  let desktop_cols = layout.compute_for_width(1920).columns;
                  
                  assert!(mobile_cols <= 2, "Mobile should have 1-2 columns");
                  assert!(desktop_cols >= 2, "Desktop should have 2+ columns");
              }
          }
      
          mod spacing_consistency_tests {
              use crate::ui::theme::Spacing;
      
              #[test]
              fn test_spacing_uses_8px_base_unit() {
                  let spacing = Spacing::default();
                  assert_eq!(spacing.base_unit, 8, "Base unit must be 8px for consistent rhythm");
              }
      
              #[test]
              fn test_all_spacing_values_are_multiples_of_8() {
                  let spacing = Spacing::default();
                  
                  assert_eq!(spacing.xs % 8, 0, "XS spacing {} not multiple of 8", spacing.xs);
                  assert_eq!(spacing.sm % 8, 0, "SM spacing {} not multiple of 8", spacing.sm);
                  assert_eq!(spacing.md % 8, 0, "MD spacing {} not multiple of 8", spacing.md);
                  assert_eq!(spacing.lg % 8, 0, "LG spacing {} not multiple of 8", spacing.lg);
                  assert_eq!(spacing.xl % 8, 0, "XL spacing {} not multiple of 8", spacing.xl);
              }
      
              #[test]
              fn test_spacing_scale_is_progressive() {
                  let spacing = Spacing::default();
                  
                  assert!(spacing.xs < spacing.sm, "xs {} should be less than sm {}", spacing.xs, spacing.sm);
                  assert!(spacing.sm < spacing.md, "sm {} should be less than md {}", spacing.sm, spacing.md);
                  assert!(spacing.md < spacing.lg, "md {} should be less than lg {}", spacing.md, spacing.lg);
                  assert!(spacing.lg < spacing.xl, "lg {} should be less than xl {}", spacing.lg, spacing.xl);
              }
      
              #[test]
              fn test_spacing_values_are_reasonable() {
                  let spacing = Spacing::default();
                  
                  assert!(spacing.xs >= 4, "XS spacing too small");
                  assert!(spacing.xl <= 64, "XL spacing unreasonably large");
              }
          }
      
          mod screen_reader_tests {
              use crate::ui::accessibility::AriaLabel;
      
              #[test]
              fn test_all_buttons_have_aria_labels() {
                  let labels = AriaLabel::collect_all_interactive_elements();
                  
                  for element in labels {
                      assert!(
                          !element.label.is_empty(),
                          "Element '{}' missing ARIA label - screen reader cannot announce",
                          element.id
                      );
                  }
              }
      
              #[test]
              fn test_icon_only_buttons_have_descriptive_labels() {
                  let icon_buttons = AriaLabel::collect_icon_buttons();
                  
                  for button in icon_buttons {
                      assert!(
                          button.label.len() > 3,
                          "Icon button '{}' has insufficient label: '{}'",
                          button.id, button.label
                      );
                      assert!(
                          !button.label.to_lowercase().contains("icon"),
                          "Label '{}' should describe action, not say 'icon'",
                          button.label
                      );
                      assert!(
                          !button.label.to_lowercase().contains("button"),
                          "Label '{}' shouldn't redundantly say 'button'",
                          button.label
                      );
                  }
              }
      
              #[test]
              fn test_form_inputs_have_associated_labels() {
                  let inputs = AriaLabel::collect_form_inputs();
                  
                  for input in inputs {
                      assert!(
                          input.has_label || input.has_aria_label,
                          "Input '{}' missing label - screen reader users cannot identify purpose",
                          input.id
                      );
                  }
              }
      
              #[test]
              fn test_images_have_alt_text() {
                  let images = AriaLabel::collect_images();
                  
                  for image in images {
                      if !image.is_decorative {
                          assert!(
                              !image.alt_text.is_empty(),
                              "Informative image '{}' missing alt text",
                              image.src
                          );
                      }
                  }
              }
      
              #[test]
              fn test_error_messages_are_announced() {
                  use crate::ui::components::ErrorMessage;
                  
                  let error = ErrorMessage::new("Invalid input");
                  assert!(
                      error.has_aria_role(),
                      "Error messages must have role='alert' for screen reader announcement"
                  );
              }
      
              #[test]
              fn test_status_updates_are_announced() {
                  use crate::ui::components::StatusMessage;
                  
                  let status = StatusMessage::new("Card saved");
                  assert!(
                      status.has_aria_live(),
                      "Status updates need aria-live for screen reader announcement"
                  );
              }
          }
      }
      
      #[cfg(test)]
      mod property_based_accessibility_tests {
          use proptest::prelude::*;
          use crate::ui::theme::ContrastChecker;
          use iced::Color;
      
          proptest! {
              #[test]
              fn prop_contrast_calculation_is_commutative(
                  r1 in 0.0f32..=1.0f32,
                  g1 in 0.0f32..=1.0f32,
                  b1 in 0.0f32..=1.0f32,
                  r2 in 0.0f32..=1.0f32,
                  g2 in 0.0f32..=1.0f32,
                  b2 in 0.0f32..=1.0f32,
              ) {
                  let color1 = Color::from_rgb(r1, g1, b1);
                  let color2 = Color::from_rgb(r2, g2, b2);
                  
                  let contrast_a = ContrastChecker::calculate_contrast(color1, color2);
                  let contrast_b = ContrastChecker::calculate_contrast(color2, color1);
                  
                  prop_assert!(
                      (contrast_a - contrast_b).abs() < 0.01,
                      "Contrast should be commutative: {} vs {}",
                      contrast_a, contrast_b
                  );
              }
      
              #[test]
              fn prop_contrast_ratio_always_positive(
                  r1 in 0.0f32..=1.0f32,
                  g1 in 0.0f32..=1.0f32,
                  b1 in 0.0f32..=1.0f32,
                  r2 in 0.0f32..=1.0f32,
                  g2 in 0.0f32..=1.0f32,
                  b2 in 0.0f32..=1.0f32,
              ) {
                  let color1 = Color::from_rgb(r1, g1, b1);
                  let color2 = Color::from_rgb(r2, g2, b2);
                  
                  let contrast = ContrastChecker::calculate_contrast(color1, color2);
                  prop_assert!(contrast > 0.0, "Contrast must be positive: {}", contrast);
              }
      
              #[test]
              fn prop_contrast_ratio_bounded(
                  r1 in 0.0f32..=1.0f32,
                  g1 in 0.0f32..=1.0f32,
                  b1 in 0.0f32..=1.0f32,
                  r2 in 0.0f32..=1.0f32,
                  g2 in 0.0f32..=1.0f32,
                  b2 in 0.0f32..=1.0f32,
              ) {
                  let color1 = Color::from_rgb(r1, g1, b1);
                  let color2 = Color::from_rgb(r2, g2, b2);
                  
                  let contrast = ContrastChecker::calculate_contrast(color1, color2);
                  
                  prop_assert!(
                      contrast >= 1.0 && contrast <= 21.0,
                      "Contrast {} outside valid range [1, 21]",
                      contrast
                  );
              }
      
              #[test]
              fn prop_touch_target_scaling_maintains_minimum(
                  width in 48u16..200u16,
                  height in 48u16..200u16,
                  scale in 0.5f32..2.0f32,
              ) {
                  use crate::ui::components::Button;
                  
                  let button = Button::with_size(width, height);
                  let scaled = button.scale(scale);
                  
                  let final_size = scaled.computed_size();
                  prop_assert!(
                      final_size.width >= 48 && final_size.height >= 48,
                      "Scaled button {}x{} below minimum after {}x scaling",
                      final_size.width, final_size.height, scale
                  );
              }
      
              #[test]
              fn prop_font_size_scaling_preserves_minimum(
                  base_size in 12.0f32..24.0f32,
                  scale_factor in 0.5f32..2.0f32,
              ) {
                  use crate::ui::theme::Typography;
                  
                  let scaled_size = Typography::scale_font_size(base_size, scale_factor);
                  prop_assert!(
                      scaled_size >= 12.0,
                      "Scaled font {} below 12px minimum",
                      scaled_size
                  );
              }
      
              #[test]
              fn prop_spacing_maintains_8px_grid(
                  multiplier in 1u16..16u16,
              ) {
                  use crate::ui::theme::Spacing;
                  
                  let spacing = Spacing::from_multiplier(multiplier);
                  prop_assert!(
                      spacing % 8 == 0,
                      "Spacing {} not multiple of 8px",
                      spacing
                  );
              }
          }
      }
      
      // Manual verification checklist - these require human testing with assistive technology
      #[cfg(test)]
      mod manual_verification_checklist {
          //! # Manual Accessibility Testing Checklist
          //! 
          //! These tests cannot be automated and require manual verification with actual assistive technologies.
          //! 
          //! ## Screen Reader Testing
          //! 
          //! Test with platform-specific screen readers:
          //! - [ ] Windows: NVDA (free) or JAWS (commercial)
          //! - [ ] macOS: VoiceOver (built-in, Cmd+F5)
          //! - [ ] Linux: Orca
          //! 
          //! ### Verification Points:
          //! - [ ] All interactive elements are announced with descriptive names
          //! - [ ] Button purpose is clear from announcement alone
          //! - [ ] Form inputs announce their labels and current values
          //! - [ ] Error messages are announced immediately when they appear
          //! - [ ] Status updates (card saved, deck created) are announced
          //! - [ ] Quality rating buttons announce which rating (1-5)
          //! - [ ] Card content (front/back) is readable by screen reader
          //! - [ ] Keyboard focus position is announced when moving between elements
          //! 
          //! ## Keyboard-Only Navigation Testing
          //! 
          //! Test without using mouse/trackpad:
          //! - [ ] Tab key cycles through all interactive elements in logical order
          //! - [ ] Shift+Tab cycles backward through elements
          //! - [ ] Enter/Space activates buttons
          //! - [ ] Escape closes dialogs and returns to previous screen
          //! - [ ] Arrow keys navigate through lists and menus
          //! - [ ] Number keys 1-5 trigger quality ratings
          //! - [ ] Space bar advances to next card
          //! - [ ] All functionality accessible without mouse
          //! - [ ] Focus indicator is always visible on focused element
          //! - [ ] No keyboard traps (can always escape from any element)
          //! 
          //! ## High Contrast Mode Testing
          //! 
          //! - [ ] Windows: Settings > Ease of Access > High Contrast
          //! - [ ] macOS: System Preferences > Accessibility > Display > Increase Contrast
          //! 
          //! ### Verification Points:
          //! - [ ] All text remains readable in high contrast mode
          //! - [ ] Focus indicators remain visible
          //! - [ ] Buttons and interactive elements are distinguishable
          //! - [ ] Images with text are still perceivable
          //! 
          //! ## Color Blindness Simulation Testing
          //! 
          //! Use simulator tools:
          //! - [ ] Coblis Color Blindness Simulator (https://www.color-blindness.com/coblis-color-blindness-simulator/)
          //! - [ ] Browser extension: "Colorblindly"
          //! 
          //! Test with simulation types:
          //! - [ ] Protanopia (red-blind)
          //! - [ ] Deuteranopia (green-blind)
          //! - [ ] Tritanopia (blue-blind)
          //! 
          //! ### Verification Points:
          //! - [ ] Correct/incorrect feedback distinguishable without color
          //! - [ ] Icons/patterns supplement color coding
          //! - [ ] Text labels clarify status (not just color)
          //! - [ ] All interactive elements remain distinguishable
          //! 
          //! ## Font Scaling Testing
          //! 
          //! Test at different zoom levels:
          //! - [ ] 100% (baseline)
          //! - [ ] 125% (common for high-DPI displays)
          //! - [ ] 150%
          //! - [ ] 200% (WCAG requirement: support up to 200%)
          //! 
          //! ### Verification Points:
          //! - [ ] All text remains readable at 200% zoom
          //! - [ ] No horizontal scrolling required
          //! - [ ] Touch targets remain adequate size
          //! - [ ] Layout adapts appropriately
          //! - [ ] No overlapping content
          //! 
          //! ## Responsive Layout Testing
          //! 
          //! Test at different viewport sizes:
          //! - [ ] 320px width (smallest mobile)
          //! - [ ] 375px width (iPhone SE)
          //! - [ ] 768px width (tablet portrait)
          //! - [ ] 1024px width (tablet landscape)
          //! - [ ] 1920px width (desktop)
          //! 
          //! ### Verification Points:
          //! - [ ] Content is readable at all sizes
          //! - [ ] Touch targets remain 48x48px minimum on mobile
          //! - [ ] Navigation is accessible on narrow screens
          //! - [ ] Text wraps appropriately, no horizontal scrolling
          //! - [ ] Images scale appropriately
          //! - [ ] Spacing remains consistent across breakpoints
          //! 
          //! ## Touch/Pointer Testing (if available)
          //! 
          //! - [ ] All interactive elements easy to tap on touchscreen
          //! - [ ] No accidental taps on adjacent elements
          //! - [ ] Drag gestures work (if implemented)
          //! - [ ] Hover states don't prevent interaction on touch devices
          //! 
          //! ## Report Template
          //! 
          //!
---
task:
  id: 14
  name: "Testing, Documentation, and Release Preparation"

context:
  description: |
    Task 14 represents the final phase of the Japanese character learning application development,
    transforming a working prototype into a production-ready, professionally packaged product.
    This comprehensive task encompasses four critical dimensions: quality assurance through
    exhaustive testing, user enablement through documentation, performance validation through
    benchmarking, and distribution preparation through multi-platform packaging.
    
    The testing dimension establishes confidence in code correctness and reliability through
    three complementary testing strategies. Integration tests verify complete end-to-end workflows,
    ensuring that learning sessions, practice modes, database operations, and UI transitions work
    seamlessly together. Property-based tests mathematically validate algorithmic invariants in
    the SM-2 spaced repetition algorithm, statistics calculations, and stroke recognition system,
    exploring large input spaces to catch edge cases that unit tests miss. Performance benchmarks
    measure critical paths—animation rendering, database operations, and character recognition—
    establishing baseline metrics and preventing performance regressions.
    
    The documentation dimension enables users to successfully adopt and utilize the application
    by providing clear, accessible guides covering installation, feature usage, and troubleshooting.
    User-facing documentation explains practice modes, spaced repetition concepts, and application
    workflows without requiring technical knowledge, reducing support burden and improving user
    experience.
    
    The build optimization dimension configures release profiles for maximum performance and
    minimal binary size through link-time optimization (LTO), aggressive optimization levels,
    and symbol stripping. These configurations produce fast, efficient binaries suitable for
    distribution without debug overhead.
    
    The packaging dimension creates platform-specific distribution artifacts that provide smooth
    installation experiences on Linux (AppImage and .deb packages), macOS (.app bundles with code
    signing), and Windows (MSI installers). Professional packaging with proper metadata, icons,
    and file associations ensures the application integrates seamlessly with each operating system.
    
    The CI/CD dimension automates the entire testing and release pipeline, running tests on every
    commit, generating coverage reports, building release artifacts, and creating GitHub releases
    with attached distribution packages. This automation ensures consistent quality and streamlines
    the release process.
    
    This task's architectural significance lies in establishing the foundation for long-term
    maintainability and user adoption. Comprehensive test coverage enables confident refactoring
    and feature additions. Performance benchmarks catch regressions before they reach users.
    Professional documentation reduces friction in user onboarding. Multi-platform packaging
    maximizes potential user base. Together, these elements elevate the application from a
    functional prototype to a polished, distributable product ready for public release.

  key_points:
    - "Achieves >80% test coverage through unit, integration, and property-based tests covering all 13 previous tasks"
    - "Uses temporary test databases isolated from production data to ensure reproducible, safe test execution"
    - "Implements property-based testing with proptest for SM-2 algorithm, statistics, and stroke recognition to validate mathematical invariants"
    - "Establishes performance benchmarks with criterion: 60fps animation rendering, <100ms database batch saves, <200ms recognition latency"
    - "Creates comprehensive user documentation (installation, getting started, features, troubleshooting) separate from technical documentation"
    - "Configures Cargo release profile with opt-level=3, lto=true, strip=true for optimized production binaries"
    - "Implements platform-specific packaging: AppImage and .deb for Linux, .app bundle with code signing for macOS, MSI installer for Windows"
    - "Establishes CI/CD pipeline with GitHub Actions for automated testing, benchmarking, coverage reporting, and release builds"
    - "Includes smoke tests, accessibility tests, and performance tests to ensure quality across multiple dimensions"
    - "Tests concurrent database access and transaction atomicity to ensure data safety"
    - "Validates all UI state transitions and keyboard navigation for complete workflow coverage"
    - "Implements test utilities and fixtures for reusable test infrastructure reducing duplication"

files:
  - path: "/home/molaco/Documents/japanese/tests/integration_tests.rs"
    description: "Integration tests for complete learning workflows and practice modes"
  - path: "/home/molaco/Documents/japanese/tests/sm2_tests.rs"
    description: "Property-based tests for SM-2 algorithm correctness and edge cases"
  - path: "/home/molaco/Documents/japanese/tests/statistics_tests.rs"
    description: "Property-based tests for statistics calculations and aggregations"
  - path: "/home/molaco/Documents/japanese/tests/database_tests.rs"
    description: "Integration tests for database operations with temporary test databases"
  - path: "/home/molaco/Documents/japanese/tests/test_utils.rs"
    description: "Shared utilities and helpers for integration tests"
  - path: "/home/molaco/Documents/japanese/tests/fixtures/mod.rs"
    description: "Test fixtures and sample data for integration tests"
  - path: "/home/molaco/Documents/japanese/benches/animation_benchmarks.rs"
    description: "Performance benchmarks for animation rendering and frame rate"
  - path: "/home/molaco/Documents/japanese/benches/database_benchmarks.rs"
    description: "Performance benchmarks for database operations and batch saves"
  - path: "/home/molaco/Documents/japanese/benches/recognition_benchmarks.rs"
    description: "Performance benchmarks for character recognition latency"
  - path: "/home/molaco/Documents/japanese/docs/user_manual.md"
    description: "Comprehensive user manual with Getting Started, Features, and Troubleshooting sections"
  - path: "/home/molaco/Documents/japanese/docs/installation.md"
    description: "Installation instructions for all supported platforms"
  - path: "/home/molaco/Documents/japanese/docs/getting_started.md"
    description: "Quick start guide for new users"
  - path: "/home/molaco/Documents/japanese/docs/features.md"
    description: "Detailed feature documentation with screenshots and examples"
  - path: "/home/molaco/Documents/japanese/docs/troubleshooting.md"
    description: "Common issues and their solutions"
  - path: "/home/molaco/Documents/japanese/Cargo.toml"
    description: "Updated with release profile configuration and build optimization settings"
  - path: "/home/molaco/Documents/japanese/.github/workflows/ci.yml"
    description: "GitHub Actions CI/CD pipeline for automated testing and builds"
  - path: "/home/molaco/Documents/japanese/.github/workflows/release.yml"
    description: "GitHub Actions workflow for automated release builds and distribution"
  - path: "/home/molaco/Documents/japanese/build/linux/AppImage.yml"
    description: "AppImage configuration for Linux distribution"
  - path: "/home/molaco/Documents/japanese/build/linux/debian/control"
    description: "Debian package control file for .deb distribution"
  - path: "/home/molaco/Documents/japanese/build/macos/Info.plist"
    description: "macOS application bundle property list configuration"
  - path: "/home/molaco/Documents/japanese/build/macos/bundle.sh"
    description: "Script to create macOS .app bundle"
  - path: "/home/molaco/Documents/japanese/build/windows/wix_config.wxs"
    description: "WiX Toolset configuration for Windows MSI installer"
  - path: "/home/molaco/Documents/japanese/build/windows/build.bat"
    description: "Windows build script for creating MSI installer"
  - path: "/home/molaco/Documents/japanese/scripts/test_coverage.sh"
    description: "Script to generate test coverage reports"
  - path: "/home/molaco/Documents/japanese/scripts/build_all_platforms.sh"
    description: "Script to build release packages for all platforms"

functions:
  - file: "tests/integration/learning_session_tests.rs"
    items:
      - type: "function"
        name: "test_complete_learning_session_workflow"
        description: "Integration test for complete learning session from start to completion, including character selection, review, quality rating, and progress persistence"
        preconditions: "Test database initialized with character data"
        postconditions: "All session state transitions verified, progress saved to database"

      - type: "function"
        name: "test_learning_session_queue_progression"
        description: "Verifies review queue processes cards in correct priority order (learning > due reviews > new cards)"
        postconditions: "Cards presented in expected priority sequence"

      - type: "function"
        name: "test_sm2_scheduling_integration"
        description: "Tests SM-2 algorithm integration with learning session, verifying interval updates and ease factor calculations"
        postconditions: "Card intervals update according to SM-2 specification"

      - type: "function"
        name: "test_session_interruption_and_resume"
        description: "Verifies learning session can be interrupted and resumed without data loss"
        postconditions: "Session state fully restored after interruption"

      - type: "function"
        name: "test_daily_limits_enforcement"
        description: "Tests that daily new card limits are enforced correctly during learning session"
        postconditions: "Session respects configured daily limits"

      - type: "function"
        name: "test_session_statistics_tracking"
        description: "Verifies session tracks accuracy, time per card, and review counts correctly"
        postconditions: "Statistics accurately reflect session activity"

  - file: "tests/integration/practice_mode_tests.rs"
    items:
      - type: "function"
        name: "test_practice_mode_progression"
        description: "Tests progression through all practice modes: watch animation, trace with guide, trace without guide, free drawing"
        postconditions: "All practice stages complete in sequence"

      - type: "function"
        name: "test_animation_playback_workflow"
        description: "Verifies stroke order animation plays smoothly and completes all strokes in sequence"
        postconditions: "Animation completes without frame drops"

      - type: "function"
        name: "test_tracing_with_guide_validation"
        description: "Tests user input validation when tracing with visual guide overlay"
        postconditions: "Stroke validation provides accurate feedback"

      - type: "function"
        name: "test_free_drawing_recognition"
        description: "Verifies character recognition works correctly in free drawing mode without guides"
        postconditions: "Recognition accurately identifies user input"

      - type: "function"
        name: "test_practice_feedback_display"
        description: "Tests visual feedback animations for correct and incorrect attempts"
        postconditions: "Feedback animations trigger appropriately"

      - type: "function"
        name: "test_practice_mode_skip_functionality"
        description: "Verifies skip and hint options work correctly when user is stuck"
        postconditions: "Skip/hint actions transition state correctly"

  - file: "tests/integration/database_operations_tests.rs"
    items:
      - type: "function"
        name: "test_card_state_persistence"
        description: "Verifies SM2Card state saves and loads correctly from database"
        postconditions: "Card state survives application restart"

      - type: "function"
        name: "test_review_history_persistence"
        description: "Tests review history records persist accurately with timestamps and results"
        postconditions: "Review history complete and chronologically ordered"

      - type: "function"
        name: "test_statistics_persistence"
        description: "Verifies statistics data saves and loads correctly"
        postconditions: "All statistics metrics restored accurately"

      - type: "function"
        name: "test_batch_save_operations"
        description: "Tests batch saving of multiple card updates in single transaction"
        preconditions: "Multiple cards with updated state"
        postconditions: "All updates committed atomically, operation completes in <100ms"

      - type: "function"
        name: "test_database_transaction_atomicity"
        description: "Verifies database transactions are atomic (all-or-nothing)"
        postconditions: "Failed transactions leave database unchanged"

      - type: "function"
        name: "test_concurrent_database_access"
        description: "Tests database handles concurrent read/write operations safely"
        postconditions: "No data corruption or deadlocks occur"

      - type: "function"
        name: "test_database_backup_and_restore"
        description: "Verifies export/import functionality produces identical data"
        postconditions: "Restored database matches original exactly"

  - file: "tests/integration/ui_navigation_tests.rs"
    items:
      - type: "function"
        name: "test_screen_navigation_flow"
        description: "Tests navigation between all application screens (menu, learning, practice, statistics)"
        postconditions: "All screen transitions work correctly"

      - type: "function"
        name: "test_keyboard_shortcuts_integration"
        description: "Verifies keyboard shortcuts work across all screens (1-5 for quality, space for next, escape for back)"
        postconditions: "All keyboard shortcuts trigger correct actions"

      - type: "function"
        name: "test_back_navigation_state_preservation"
        description: "Tests that navigating back preserves previous screen state"
        postconditions: "Previous screen state fully restored"

      - type: "function"
        name: "test_session_end_navigation"
        description: "Verifies navigation from session summary to menu or next session"
        postconditions: "Session ends cleanly with correct state transitions"

  - file: "tests/property/sm2_algorithm_tests.rs"
    items:
      - type: "function"
        name: "prop_ease_factor_bounded"
        description: "Property test verifying ease factor never falls below 1.3 for any quality rating sequence"
        invariants: "Ease factor >= 1.3 for all possible inputs"

      - type: "function"
        name: "prop_intervals_monotonic_increasing"
        description: "Property test ensuring intervals increase monotonically for consecutive correct reviews"
        invariants: "interval[n+1] > interval[n] when quality >= 3"

      - type: "function"
        name: "prop_failed_cards_reset"
        description: "Property test verifying cards with quality < 3 reset to learning state"
        postconditions: "interval=1, repetitions=0 after failure"

      - type: "function"
        name: "prop_next_review_in_future"
        description: "Property test ensuring next review date is always in the future"
        invariants: "next_review_date > current_date"

      - type: "function"
        name: "prop_quality_rating_handling"
        description: "Property test verifying all quality ratings 0-5 handled correctly without panic"
        postconditions: "No panics for any valid quality rating"

  - file: "tests/property/statistics_tests.rs"
    items:
      - type: "function"
        name: "prop_accuracy_calculation"
        description: "Property test verifying accuracy calculation is always correct/total"
        invariants: "accuracy = correct_count / total_count, 0.0 <= accuracy <= 1.0"

      - type: "function"
        name: "prop_streak_increment"
        description: "Property test ensuring streak increments correctly for consecutive practice days"
        invariants: "streak increments by 1 for each consecutive day"

      - type: "function"
        name: "prop_streak_reset"
        description: "Property test verifying streak resets when day is skipped"
        postconditions: "streak = 0 after gap in practice days"

      - type: "function"
        name: "prop_statistics_accumulation"
        description: "Property test ensuring statistics accumulate correctly over multiple sessions"
        invariants: "total reviews = sum of all session reviews"

  - file: "tests/property/animation_tests.rs"
    items:
      - type: "function"
        name: "prop_partial_path_continuity"
        description: "Property test verifying partial path rendering maintains stroke continuity"
        invariants: "No gaps in rendered stroke paths"

      - type: "function"
        name: "prop_animation_timing_consistency"
        description: "Property test ensuring animation timing is consistent across different stroke counts"
        invariants: "per-stroke timing remains constant"

      - type: "function"
        name: "prop_animation_completion"
        description: "Property test verifying all strokes animate to completion"
        postconditions: "All strokes reach 100% progress"

  - file: "benches/animation_benchmark.rs"
    items:
      - type: "function"
        name: "bench_stroke_animation_rendering"
        description: "Benchmarks stroke animation rendering performance to ensure 60fps target"
        postconditions: "Animation frame time < 16.67ms (60fps)"

      - type: "function"
        name: "bench_partial_path_calculation"
        description: "Benchmarks partial path calculation for animation interpolation"
        postconditions: "Path calculation completes in <5ms"

      - type: "function"
        name: "bench_bezier_curve_rendering"
        description: "Benchmarks Bezier curve tessellation and rendering"
        postconditions: "Curve rendering time acceptable for real-time animation"

  - file: "benches/database_benchmark.rs"
    items:
      - type: "function"
        name: "bench_single_card_save"
        description: "Benchmarks saving single card state to database"
        postconditions: "Save operation completes in <10ms"

      - type: "function"
        name: "bench_batch_card_save"
        description: "Benchmarks batch saving of 50 cards in single transaction"
        postconditions: "Batch save completes in <100ms"

      - type: "function"
        name: "bench_card_lookup"
        description: "Benchmarks character card lookup from database"
        postconditions: "Lookup completes in <1ms"

      - type: "function"
        name: "bench_review_history_query"
        description: "Benchmarks querying review history for statistics"
        postconditions: "Query completes in <50ms"

  - file: "benches/recognition_benchmark.rs"
    items:
      - type: "function"
        name: "bench_stroke_normalization"
        description: "Benchmarks stroke coordinate normalization"
        postconditions: "Normalization completes in <5ms"

      - type: "function"
        name: "bench_recognition_latency"
        description: "Benchmarks end-to-end character recognition latency"
        postconditions: "Recognition completes in <200ms"

      - type: "function"
        name: "bench_stroke_validation"
        description: "Benchmarks stroke order validation against reference"
        postconditions: "Validation completes in <100ms"

  - file: "tests/common/mod.rs"
    items:
      - type: "function"
        name: "create_temp_database"
        description: "Creates temporary test database with sample character data"
        postconditions: "Returns initialized test database path"

      - type: "function"
        name: "setup_test_environment"
        description: "Initializes complete test environment with database, character data, and mock user"
        postconditions: "Test environment ready for integration tests"

      - type: "function"
        name: "mock_user_input_strokes"
        description: "Generates mock stroke data for testing recognition and validation"
        postconditions: "Returns realistic stroke sequences for test characters"

      - type: "function"
        name: "simulate_learning_session"
        description: "Simulates complete learning session with automated responses"
        postconditions: "Session completes with generated review data"

      - type: "function"
        name: "load_test_fixtures"
        description: "Loads test fixtures from tests/fixtures/ directory"
        postconditions: "Returns test data structures for specific scenarios"

      - type: "function"
        name: "assert_animation_smooth"
        description: "Helper assertion to verify animation frame timing is consistent"
        postconditions: "Fails if animation has frame drops or stuttering"

      - type: "function"
        name: "cleanup_test_data"
        description: "Cleans up temporary test files and databases"
        postconditions: "All test artifacts removed"

  - file: "tests/fixtures/mod.rs"
    items:
      - type: "constant"
        name: "SAMPLE_HIRAGANA_STROKES"
        description: "Pre-recorded stroke sequences for all hiragana characters"

      - type: "constant"
        name: "SAMPLE_KATAKANA_STROKES"
        description: "Pre-recorded stroke sequences for all katakana characters"

      - type: "function"
        name: "load_character_image"
        description: "Loads test image file for character recognition testing"
        postconditions: "Returns image buffer for recognition input"

  - file: "Cargo.toml"
    items:
      - type: "constant"
        name: "dev-dependencies"
        description: "Test framework dependencies: criterion, proptest, insta, tempfile, assert_cmd"

      - type: "constant"
        name: "profile.release"
        description: "Release build configuration with LTO, opt-level=3, strip=true"

      - type: "constant"
        name: "profile.bench"
        description: "Benchmark profile configuration for performance testing"

  - file: "docs/USER_MANUAL.md"
    items:
      - type: "module_declaration"
        name: "user_documentation"
        description: "Comprehensive user manual covering getting started, features, practice modes, and troubleshooting"

  - file: "docs/DEVELOPER_GUIDE.md"
    items:
      - type: "module_declaration"
        name: "developer_documentation"
        description: "Developer documentation covering architecture, testing strategy, and contribution guidelines"

  - file: "docs/API_REFERENCE.md"
    items:
      - type: "module_declaration"
        name: "api_documentation"
        description: "Generated API documentation for public interfaces and modules"

  - file: ".github/workflows/ci.yml"
    items:
      - type: "module_declaration"
        name: "continuous_integration"
        description: "GitHub Actions workflow for automated testing, benchmarking, and coverage reporting"

  - file: ".github/workflows/release.yml"
    items:
      - type: "module_declaration"
        name: "release_pipeline"
        description: "Automated release pipeline for building platform-specific distributions"

  - file: "scripts/build_release.sh"
    items:
      - type: "function"
        name: "build_release_binaries"
        description: "Shell script to build optimized release binaries for all platforms"
        postconditions: "Produces Linux, macOS, and Windows release artifacts"

  - file: "scripts/package_linux.sh"
    items:
      - type: "function"
        name: "create_appimage"
        description: "Creates AppImage distribution for Linux"
        postconditions: "AppImage file created with embedded dependencies"

      - type: "function"
        name: "create_deb_package"
        description: "Creates Debian package for Ubuntu/Debian systems"
        postconditions: "DEB package created with correct metadata"

  - file: "scripts/package_macos.sh"
    items:
      - type: "function"
        name: "create_app_bundle"
        description: "Creates macOS .app bundle with proper structure and code signing"
        postconditions: "Signed and notarized macOS application bundle"

  - file: "scripts/package_windows.sh"
    items:
      - type: "function"
        name: "create_msi_installer"
        description: "Creates Windows MSI installer using WiX toolset"
        postconditions: "Signed Windows installer package"

  - file: "tests/smoke_tests.rs"
    items:
      - type: "function"
        name: "test_application_launches"
        description: "Smoke test verifying application starts without crashing"
        postconditions: "Application window opens successfully"

      - type: "function"
        name: "test_database_initialization"
        description: "Smoke test for database initialization on first run"
        postconditions: "Database file created with correct schema"

      - type: "function"
        name: "test_font_loading"
        description: "Smoke test verifying Japanese font loads correctly"
        postconditions: "Font available for text rendering"

      - type: "function"
        name: "test_character_data_loading"
        description: "Smoke test for character database loading"
        postconditions: "All 92 characters (hiragana + katakana) loaded"

  - file: "tests/accessibility_tests.rs"
    items:
      - type: "function"
        name: "test_keyboard_navigation_complete"
        description: "Tests all functionality accessible via keyboard without mouse"
        postconditions: "All features operable keyboard-only"

      - type: "function"
        name: "test_color_contrast_compliance"
        description: "Verifies all color combinations meet WCAG AA contrast requirements"
        postconditions: "All text has minimum 4.5:1 contrast ratio"

      - type: "function"
        name: "test_touch_target_sizes"
        description: "Verifies all interactive elements meet 48x48px minimum touch target size"
        postconditions: "All buttons and controls properly sized"

      - type: "function"
        name: "test_focus_indicators"
        description: "Tests that focus indicators are visible for all interactive elements"
        postconditions: "Focus indicators have minimum 2px visible border"

  - file: "tests/performance_tests.rs"
    items:
      - type: "function"
        name: "test_animation_frame_rate"
        description: "Verifies stroke animation maintains 60fps during playback"
        postconditions: "No frame drops detected during animation"

      - type: "function"
        name: "test_recognition_response_time"
        description: "Tests character recognition completes within 200ms"
        postconditions: "Recognition latency under threshold"

      - type: "function"
        name: "test_database_batch_performance"
        description: "Verifies batch database operations meet performance targets"
        postconditions: "50-card batch save completes in <100ms"

      - type: "function"
        name: "test_memory_usage"
        description: "Tests application memory usage remains reasonable during extended sessions"
        postconditions: "Memory usage stable, no leaks detected"

  - file: "README.md"
    items:
      - type: "module_declaration"
        name: "project_readme"
        description: "Project overview, installation instructions, quick start guide, and links to documentation"

  - file: "CONTRIBUTING.md"
    items:
      - type: "module_declaration"
        name: "contribution_guidelines"
        description: "Guidelines for contributing code, tests, and documentation to the project"

  - file: "CHANGELOG.md"
    items:
      - type: "module_declaration"
        name: "changelog"
        description: "Version history with release notes documenting features, fixes, and breaking changes"

formal_verification:
  needed: false
  level: "None"
  explanation: |
    Formal verification is not needed for Task 14: Testing, Documentation, and Release Preparation.
    This is a meta-task focused on quality assurance, documentation, and distribution rather than
    implementing critical algorithms or safety-critical functionality.
    
    Key reasons formal verification is inappropriate:
    
    1. Meta-Infrastructure Task: The task adds testing infrastructure (integration tests, property-based
       tests, benchmarks), documentation (user manuals, guides), build configurations (CI/CD, packaging),
       and distribution artifacts. None of these are candidates for formal verification as they don't
       contain algorithmic logic requiring correctness proofs.
    
    2. Testing Tests Makes No Sense: The integration tests and property-based tests are themselves
       verification tools that test other code. Attempting to formally verify test code creates a
       recursive verification problem with no practical benefit. Tests are validated empirically by
       running them and verifying they catch actual bugs.
    
    3. Documentation Cannot Be Formally Verified: User-facing documentation describes features and
       usage patterns. These are human-readable artifacts that cannot be subjected to formal proof
       systems. Documentation quality is assessed through user feedback and clarity, not mathematical
       correctness.
    
    4. Declarative Configuration Not Algorithmic: Build configurations (Cargo.toml profiles, CI/CD
       workflows, packaging manifests) are declarative specifications, not executable algorithms.
       They are validated by successful builds and deployments, not formal proofs.
    
    5. Property Tests Already Provide Verification: The task includes property-based tests for
       critical algorithms (SM-2, statistics, recognition). These tests explore large input spaces
       and verify invariants probabilistically, providing high confidence without formal proof.
       Property testing is the appropriate verification strategy for these components.
    
    6. Performance Benchmarks Are Empirical: Benchmarks measure actual execution time and throughput.
       These are empirical measurements that establish performance baselines, not formal guarantees.
       Performance cannot be formally verified in the traditional sense; it must be measured.
    
    7. All Critical Algorithms Already Implemented: The SM-2 algorithm (Task 7), recognition system
       (Task 9), and statistics calculations (Task 10) were implemented and their verification
       decisions made in previous tasks. This task only tests and packages existing functionality.
    
    8. Low Risk Profile: Testing infrastructure errors affect development workflow, not end-user
       safety. Documentation errors are easily corrected. Packaging errors prevent installation but
       don't compromise system integrity. None of these risks warrant formal verification's cost.
    
    9. Observable Failures: Test failures, documentation gaps, and packaging errors are immediately
       observable during the development and release process. Issues are caught before reaching users
       through standard QA practices.
    
    The appropriate validation approach is comprehensive conventional testing: integration tests
    verify end-to-end workflows, property-based tests ensure mathematical properties hold across
    input ranges, benchmarks catch performance regressions, and manual VM testing validates
    distribution packages. This multi-layered testing strategy provides sufficient confidence for
    production release at a fraction of the cost of formal verification.

tests:
  strategy:
    approach: "mixed: unit, integration, property-based, and performance"
    rationale:
      - "Unit tests verify individual components (SM-2 algorithm, statistics calculations, stroke recognition) in isolation with deterministic inputs"
      - "Integration tests ensure complete workflows function correctly end-to-end including database persistence, UI state transitions, and multi-component interactions"
      - "Property-based tests validate algorithmic invariants (SM-2 monotonicity, statistics consistency) across randomized input spaces to catch edge cases"
      - "Performance benchmarks measure animation rendering (60fps target), database operations (<100ms save target), and recognition speed to prevent regressions"
      - "Temporary test databases isolate test data from production, ensuring reproducible test runs and preventing data corruption"

  implementation:
    file: "/home/molaco/Documents/japanese/tests/comprehensive_tests.rs"
    location: "create new"
    code: |
      #[cfg(test)]
      mod unit_tests {
          use super::*;
          use std::path::PathBuf;
          use tempfile::TempDir;
          
          // SM-2 Algorithm Tests
          #[test]
          fn test_sm2_initial_card() {
              let card = FlashCard::new("一".to_string(), "one".to_string());
              assert_eq!(card.repetitions, 0);
              assert_eq!(card.easiness_factor, 2.5);
              assert_eq!(card.interval, 0);
          }
          
          #[test]
          fn test_sm2_quality_5_increases_interval() {
              let mut card = FlashCard::new("一".to_string(), "one".to_string());
              card.update_sm2(5);
              assert_eq!(card.repetitions, 1);
              assert_eq!(card.interval, 1);
              assert!(card.easiness_factor >= 2.5);
          }
          
          #[test]
          fn test_sm2_quality_4_maintains_progress() {
              let mut card = FlashCard::new("一".to_string(), "one".to_string());
              card.update_sm2(4);
              assert_eq!(card.repetitions, 1);
              assert_eq!(card.interval, 1);
              assert_eq!(card.easiness_factor, 2.5);
          }
          
          #[test]
          fn test_sm2_quality_3_resets() {
              let mut card = FlashCard::new("一".to_string(), "one".to_string());
              card.repetitions = 3;
              card.interval = 10;
              card.update_sm2(3);
              assert_eq!(card.repetitions, 0);
              assert_eq!(card.interval, 1);
          }
          
          #[test]
          fn test_sm2_quality_below_3_resets() {
              let mut card = FlashCard::new("一".to_string(), "one".to_string());
              card.repetitions = 5;
              card.interval = 20;
              card.easiness_factor = 2.8;
              card.update_sm2(1);
              assert_eq!(card.repetitions, 0);
              assert_eq!(card.interval, 1);
              assert!(card.easiness_factor < 2.8);
          }
          
          #[test]
          fn test_sm2_easiness_factor_floor() {
              let mut card = FlashCard::new("一".to_string(), "one".to_string());
              for _ in 0..20 {
                  card.update_sm2(0);
              }
              assert!(card.easiness_factor >= 1.3);
          }
          
          #[test]
          fn test_sm2_progressive_intervals() {
              let mut card = FlashCard::new("一".to_string(), "one".to_string());
              card.update_sm2(5);
              let interval1 = card.interval;
              card.update_sm2(5);
              let interval2 = card.interval;
              card.update_sm2(5);
              let interval3 = card.interval;
              assert!(interval2 > interval1);
              assert!(interval3 > interval2);
          }
          
          // Statistics Tests
          #[test]
          fn test_statistics_initial_state() {
              let stats = Statistics::new();
              assert_eq!(stats.cards_studied_today, 0);
              assert_eq!(stats.total_reviews, 0);
              assert_eq!(stats.correct_reviews, 0);
              assert_eq!(stats.accuracy_rate(), 0.0);
          }
          
          #[test]
          fn test_statistics_accuracy_calculation() {
              let mut stats = Statistics::new();
              stats.total_reviews = 100;
              stats.correct_reviews = 85;
              assert_eq!(stats.accuracy_rate(), 85.0);
          }
          
          #[test]
          fn test_statistics_accuracy_zero_reviews() {
              let stats = Statistics::new();
              assert_eq!(stats.accuracy_rate(), 0.0);
          }
          
          #[test]
          fn test_statistics_increment_correct() {
              let mut stats = Statistics::new();
              stats.record_review(true);
              assert_eq!(stats.total_reviews, 1);
              assert_eq!(stats.correct_reviews, 1);
              assert_eq!(stats.cards_studied_today, 1);
          }
          
          #[test]
          fn test_statistics_increment_incorrect() {
              let mut stats = Statistics::new();
              stats.record_review(false);
              assert_eq!(stats.total_reviews, 1);
              assert_eq!(stats.correct_reviews, 0);
              assert_eq!(stats.cards_studied_today, 1);
          }
          
          #[test]
          fn test_statistics_streak_tracking() {
              let mut stats = Statistics::new();
              stats.record_review(true);
              stats.record_review(true);
              stats.record_review(true);
              assert_eq!(stats.current_streak, 3);
              stats.record_review(false);
              assert_eq!(stats.current_streak, 0);
          }
          
          #[test]
          fn test_statistics_longest_streak() {
              let mut stats = Statistics::new();
              stats.record_review(true);
              stats.record_review(true);
              stats.record_review(true);
              assert_eq!(stats.longest_streak, 3);
              stats.record_review(false);
              stats.record_review(true);
              assert_eq!(stats.longest_streak, 3);
              assert_eq!(stats.current_streak, 1);
          }
          
          // Stroke Recognition Tests
          #[test]
          fn test_stroke_point_creation() {
              let point = StrokePoint::new(100.0, 150.0);
              assert_eq!(point.x, 100.0);
              assert_eq!(point.y, 150.0);
          }
          
          #[test]
          fn test_stroke_distance_calculation() {
              let p1 = StrokePoint::new(0.0, 0.0);
              let p2 = StrokePoint::new(3.0, 4.0);
              let dist = p1.distance(&p2);
              assert!((dist - 5.0).abs() < 0.001);
          }
          
          #[test]
          fn test_stroke_normalize_empty() {
              let stroke = Stroke::new();
              let normalized = stroke.normalize();
              assert_eq!(normalized.points.len(), 0);
          }
          
          #[test]
          fn test_stroke_normalize_single_point() {
              let mut stroke = Stroke::new();
              stroke.add_point(100.0, 100.0);
              let normalized = stroke.normalize();
              assert_eq!(normalized.points.len(), 1);
          }
          
          #[test]
          fn test_stroke_normalize_scale() {
              let mut stroke = Stroke::new();
              stroke.add_point(0.0, 0.0);
              stroke.add_point(200.0, 200.0);
              let normalized = stroke.normalize();
              assert!(normalized.points.iter().all(|p| p.x >= 0.0 && p.x <= 1.0));
              assert!(normalized.points.iter().all(|p| p.y >= 0.0 && p.y <= 1.0));
          }
          
          #[test]
          fn test_stroke_comparison_identical() {
              let mut stroke1 = Stroke::new();
              stroke1.add_point(0.0, 0.0);
              stroke1.add_point(50.0, 50.0);
              stroke1.add_point(100.0, 100.0);
              
              let mut stroke2 = Stroke::new();
              stroke2.add_point(0.0, 0.0);
              stroke2.add_point(50.0, 50.0);
              stroke2.add_point(100.0, 100.0);

              let similarity = stroke1.compare(&stroke2);
              assert!(similarity > 0.95);
          }
          
          #[test]
          fn test_stroke_comparison_different() {
              let mut stroke1 = Stroke::new();
              stroke1.add_point(0.0, 0.0);
              stroke1.add_point(100.0, 0.0);
              
              let mut stroke2 = Stroke::new();
              stroke2.add_point(0.0, 0.0);
              stroke2.add_point(0.0, 100.0);
              
              let similarity = stroke1.compare(&stroke2);
              assert!(similarity < 0.5);
          }
          
          // Database Helper Tests
          fn setup_test_db() -> (TempDir, PathBuf) {
              let temp_dir = TempDir::new().unwrap();
              let db_path = temp_dir.path().join("test.db");
              (temp_dir, db_path)
          }
          
          #[test]
          fn test_database_create() {
              let (_temp, db_path) = setup_test_db();
              let db = Database::new(&db_path).unwrap();
              assert!(db_path.exists());
          }
          
          #[test]
          fn test_database_save_load_card() {
              let (_temp, db_path) = setup_test_db();
              let mut db = Database::new(&db_path).unwrap();
              
              let card = FlashCard::new("一".to_string(), "one".to_string());
              db.save_card(&card).unwrap();
              
              let loaded = db.load_card("一").unwrap();
              assert_eq!(loaded.character, "一");
              assert_eq!(loaded.meaning, "one");
          }
          
          #[test]
          fn test_database_save_load_multiple_cards() {
              let (_temp, db_path) = setup_test_db();
              let mut db = Database::new(&db_path).unwrap();
              
              let card1 = FlashCard::new("一".to_string(), "one".to_string());
              let card2 = FlashCard::new("二".to_string(), "two".to_string());
              
              db.save_card(&card1).unwrap();
              db.save_card(&card2).unwrap();
              
              let cards = db.load_all_cards().unwrap();
              assert_eq!(cards.len(), 2);
          }
          
          #[test]
          fn test_database_update_card() {
              let (_temp, db_path) = setup_test_db();
              let mut db = Database::new(&db_path).unwrap();
              
              let mut card = FlashCard::new("一".to_string(), "one".to_string());
              db.save_card(&card).unwrap();
              
              card.update_sm2(5);
              db.save_card(&card).unwrap();
              
              let loaded = db.load_card("一").unwrap();
              assert_eq!(loaded.repetitions, 1);
              assert_eq!(loaded.interval, 1);
          }
          
          #[test]
          fn test_database_save_load_statistics() {
              let (_temp, db_path) = setup_test_db();
              let mut db = Database::new(&db_path).unwrap();
              
              let mut stats = Statistics::new();
              stats.record_review(true);
              stats.record_review(true);
              stats.record_review(false);
              
              db.save_statistics(&stats).unwrap();
              let loaded = db.load_statistics().unwrap();
              
              assert_eq!(loaded.total_reviews, 3);
              assert_eq!(loaded.correct_reviews, 2);
          }
          
          #[test]
          fn test_database_backup_restore() {
              let (_temp, db_path) = setup_test_db();
              let mut db = Database::new(&db_path).unwrap();
              
              let card = FlashCard::new("一".to_string(), "one".to_string());
              db.save_card(&card).unwrap();
              
              let backup_path = db_path.parent().unwrap().join("backup.db");
              db.backup(&backup_path).unwrap();
              
              assert!(backup_path.exists());
              let backup_db = Database::new(&backup_path).unwrap();
              let loaded = backup_db.load_card("一").unwrap();
              assert_eq!(loaded.character, "一");
          }
          
          #[test]
          fn test_database_performance_save() {
              let (_temp, db_path) = setup_test_db();
              let mut db = Database::new(&db_path).unwrap();
              
              let card = FlashCard::new("一".to_string(), "one".to_string());
              
              let start = std::time::Instant::now();
              db.save_card(&card).unwrap();
              let duration = start.elapsed();
              
              assert!(duration.as_millis() < 100, "Save took {}ms", duration.as_millis());
          }
          
          // Settings Tests
          #[test]
          fn test_settings_default() {
              let settings = Settings::default();
              assert_eq!(settings.practice_mode, PracticeMode::Both);
              assert_eq!(settings.cards_per_session, 20);
              assert!(settings.show_hints);
          }
          
          #[test]
          fn test_settings_save_load() {
              let (_temp, db_path) = setup_test_db();
              let mut db = Database::new(&db_path).unwrap();
              
              let mut settings = Settings::default();
              settings.practice_mode = PracticeMode::Writing;
              settings.cards_per_session = 30;
              
              db.save_settings(&settings).unwrap();
              let loaded = db.load_settings().unwrap();
              
              assert_eq!(loaded.practice_mode, PracticeMode::Writing);
              assert_eq!(loaded.cards_per_session, 30);
          }
      }
      
      #[cfg(test)]
      mod integration_tests {
          use super::*;
          use tempfile::TempDir;
          use std::path::PathBuf;
          
          fn setup_app() -> (TempDir, Application) {
              let temp_dir = TempDir::new().unwrap();
              let db_path = temp_dir.path().join("test.db");
              let app = Application::new(&db_path).unwrap();
              (temp_dir, app)
          }
          
          #[test]
          fn test_complete_learning_session_new_character() {
              let (_temp, mut app) = setup_app();
              
              // Add new character
              app.add_character("一", "one", vec![/* stroke data */]);
              
              // Start learning session
              app.start_session(SessionType::Learning);
              assert_eq!(app.state, AppState::Learning);
              
              // Get first card
              let card = app.get_current_card().unwrap();
              assert_eq!(card.character, "一");
              assert_eq!(card.repetitions, 0);
              
              // Submit correct answer
              app.submit_answer(Quality::Perfect);
              
              // Verify card updated
              let updated = app.get_card("一").unwrap();
              assert_eq!(updated.repetitions, 1);
              assert_eq!(updated.interval, 1);
              
              // Verify statistics
              let stats = app.get_statistics();
              assert_eq!(stats.cards_studied_today, 1);
              assert_eq!(stats.total_reviews, 1);
              assert_eq!(stats.correct_reviews, 1);
          }
          
          #[test]
          fn test_complete_practice_session_writing_mode() {
              let (_temp, mut app) = setup_app();
              
              // Setup: Add characters and set mode
              app.add_character("一", "one", vec![]);
              app.add_character("二", "two", vec![]);
              app.settings.practice_mode = PracticeMode::Writing;
              
              // Start practice session
              app.start_session(SessionType::Practice);
              assert_eq!(app.state, AppState::Practice);
              
              // Practice first card
              let card1 = app.get_current_card().unwrap();
              app.draw_stroke(vec![(0.0, 0.0), (100.0, 0.0)]);
              app.submit_drawing();
              
              // Verify recognition feedback
              assert!(app.has_feedback());
              
              // Continue to next card
              app.next_card();
              let card2 = app.get_current_card().unwrap();
              assert_ne!(card1.character, card2.character);
              
              // Complete session
              app.submit_answer(Quality::Good);
              
              // Verify session completion
              let stats = app.get_statistics();
              assert!(stats.cards_studied_today >= 2);
          }
          
          #[test]
          fn test_complete_practice_session_recognition_mode() {
              let (_temp, mut app) = setup_app();
              
              app.add_character("一", "one", vec![]);
              app.settings.practice_mode = PracticeMode::Recognition;
              
              app.start_session(SessionType::Practice);
              
              let card = app.get_current_card().unwrap();
              app.display_character(&card.character);
              
              // Select answer from multiple choice
              app.select_answer("one");
              let result = app.check_answer();
              assert!(result.is_correct);
              
              let stats = app.get_statistics();
              assert_eq!(stats.correct_reviews, 1);
          }
          
          #[test]
          fn test_spaced_repetition_due_cards() {
              let (_temp, mut app) = setup_app();
              
              // Addcards with different intervals
              app.add_character("一", "one", vec![]);
              app.add_character("二", "two", vec![]);
              app.add_character("三", "three", vec![]);
              
              // Practice cards to set different due dates
              app.start_session(SessionType::Practice);
              
              let mut card1 = app.get_card("一").unwrap();
              card1.update_sm2(5); // Due in 1 day
              app.save_card(&card1);
              
              let mut card2 = app.get_card("二").unwrap();
              card2.update_sm2(5);
              card2.update_sm2(5); // Due in 6 days
              app.save_card(&card2);
              
              // Check due cards today
              let due_cards = app.get_due_cards();
              assert!(due_cards.iter().any(|c| c.character == "一"));
              assert!(due_cards.iter().any(|c| c.character == "三"));
              assert!(!due_cards.iter().any(|c| c.character == "二"));
          }
          
          #[test]
          fn test_statistics_persistence_across_sessions() {
              let temp_dir = TempDir::new().unwrap();
              let db_path = temp_dir.path().join("test.db");
              
              // Session 1
              {
                  let mut app = Application::new(&db_path).unwrap();
                  app.add_character("一", "one", vec![]);
                  app.start_session(SessionType::Learning);
                  app.submit_answer(Quality::Perfect);
                  
                  let stats = app.get_statistics();
                  assert_eq!(stats.total_reviews, 1);
              }
              
              // Session 2 - load from same database
              {
                  let mut app = Application::new(&db_path).unwrap();
                  let stats = app.get_statistics();
                  assert_eq!(stats.total_reviews, 1);

                  app.start_session(SessionType::Practice);
                  app.submit_answer(Quality::Good);
                  
                  let updated_stats = app.get_statistics();
                  assert_eq!(updated_stats.total_reviews, 2);
              }
          }
          
          #[test]
          fn test_settings_persistence_and_application() {
              let temp_dir = TempDir::new().unwrap();
              let db_path = temp_dir.path().join("test.db");
              
              // Save settings
              {
                  let mut app = Application::new(&db_path).unwrap();
                  app.settings.practice_mode = PracticeMode::Writing;
                  app.settings.cards_per_session = 15;
                  app.save_settings();
              }
              
              // Load and verify settings applied
              {
                  let app = Application::new(&db_path).unwrap();
                  assert_eq!(app.settings.practice_mode, PracticeMode::Writing);
                  assert_eq!(app.settings.cards_per_session, 15);
              }
          }
          
          #[test]
          fn test_ui_state_transitions() {
              let (_temp, mut app) = setup_app();
              app.add_character("一", "one", vec![]);
              
              // Initial state
              assert_eq!(app.state, AppState::Menu);
              
              // Menu -> Learning
              app.start_session(SessionType::Learning);
              assert_eq!(app.state, AppState::Learning);
              
              // Learning -> Statistics
              app.show_statistics();
              assert_eq!(app.state, AppState::Statistics);
              
              // Statistics -> Menu
              app.return_to_menu();
              assert_eq!(app.state, AppState::Menu);
              
              // Menu -> Settings
              app.open_settings();
              assert_eq!(app.state, AppState::Settings);

              // Settings -> Menu
              app.return_to_menu();
              assert_eq!(app.state, AppState::Menu);
          }
          
          #[test]
          fn test_database_operations_workflow() {
              let temp_dir = TempDir::new().unwrap();
              let db_path = temp_dir.path().join("test.db");
              
              let mut app = Application::new(&db_path).unwrap();
              
              // Add multiple cards
              app.add_character("一", "one", vec![]);
              app.add_character("二", "two", vec![]);
              app.add_character("三", "three", vec![]);
              
              // Save
              app.save_all();
              
              // Backup
              let backup_path = temp_dir.path().join("backup.db");
              app.backup_database(&backup_path).unwrap();
              assert!(backup_path.exists());
              
              // Modify data
              app.add_character("四", "four", vec![]);
              
              // Restore from backup
              app.restore_database(&backup_path).unwrap();
              
              // Verify restored state
              let cards = app.get_all_cards();
              assert_eq!(cards.len(), 3);
              assert!(!cards.iter().any(|c| c.character == "四"));
          }
          
          #[test]
          fn test_animation_rendering_workflow() {
              let (_temp, mut app) = setup_app();
              
              let strokes = vec![
                  vec![(0.0, 0.0), (100.0, 0.0)],
                  vec![(50.0, 0.0), (50.0, 100.0)]
              ];
              app.add_character("十", "ten", strokes.clone());
              
              // Start animation
              app.start_animation("十");
              assert_eq!(app.animation_state, AnimationState::Playing);
              
              // Advance animation frames
              let mut frame_count = 0;
              while app.animation_state == AnimationState::Playing {
                  app.update_animation(16.67); // 60fps = 16.67ms per frame
                  frame_count += 1;
                  if frame_count > 1000 { break; } // Safety limit
              }
              
              assert!(frame_count > 0);
              assert_eq!(app.animation_state, AnimationState::Completed);
          }
          
          #[test]
          fn test_stroke_recognition_workflow() {
              let (_temp, mut app) = setup_app();
              
              let reference_stroke = vec![(0.0, 0.0), (100.0, 0.0)];
              app.add_character("一", "one", vec![reference_stroke.clone()]);
              
              app.start_session(SessionType::Practice);
              app.settings.practice_mode = PracticeMode::Writing;
              
              // User draws stroke
              let user_stroke = vec![(0.0, 0.0), (95.0, 5.0)]; // Similar to reference
              app.draw_stroke(user_stroke);
              app.submit_drawing();
              
              let result = app.get_recognition_result();
              assert!(result.similarity > 0.8);
              assert!(result.is_acceptable());
          }
          
          #[test]
          fn test_complete_multi_session_workflow() {
              let temp_dir = TempDir::new().unwrap();
              let db_path = temp_dir.path().join("test.db");
              
              // Day 1: Learn new cards
              {
                  let mut app = Application::new(&db_path).unwrap();
                  app.add_character("一", "one", vec![]);
                  app.add_character("二", "two", vec![]);
                  
                  app.start_session(SessionType::Learning);
                  app.submit_answer(Quality::Perfect);
                  app.next_card();
                  app.submit_answer(Quality::Good);

                  let stats = app.get_statistics();
                  assert_eq!(stats.cards_studied_today, 2);
              }
              
              // Day 2: Review due cards
              {
                  let mut app = Application::new(&db_path).unwrap();
                  
                  let due_cards = app.get_due_cards();
                  assert!(due_cards.len() > 0);
                  
                  app.start_session(SessionType::Review);
                  app.submit_answer(Quality::Good);
                  
                  let stats = app.get_statistics();
                  assert!(stats.total_reviews >= 3);
              }
          }
      }
      
      #[cfg(test)]
      mod property_tests {
          use super::*;
          use proptest::prelude::*;
          
          proptest! {
              #[test]
              fn prop_sm2_easiness_factor_bounded(quality in 0u8..=5) {
                  let mut card = FlashCard::new("test".to_string(), "test".to_string());
                  for _ in 0..100 {
                      card.update_sm2(quality);
                  }
                  prop_assert!(card.easiness_factor >= 1.3);
                  prop_assert!(card.easiness_factor <= 3.5);
              }
              
              #[test]
              fn prop_sm2_interval_monotonic_on_success(qualities in prop::collection::vec(4u8..=5, 1..20)) {
                  let mut card = FlashCard::new("test".to_string(), "test".to_string());
                  let mut intervals = vec![card.interval];
                  
                  for quality in qualities {
                      card.update_sm2(quality);
                      intervals.push(card.interval);
                  }
                  
                  // Intervals should be non-decreasing for quality >= 4
                  for i in 1..intervals.len() {
                      prop_assert!(intervals[i] >= intervals[i-1]);
                  }
              }
              
              #[test]
              fn prop_sm2_repetitions_increase_on_success(quality in 4u8..=5, count in 1..20usize) {
                  let mut card = FlashCard::new("test".to_string(), "test".to_string());
                  
                  for _ in 0..count {
                      card.update_sm2(quality);
                  }
                  
                  prop_assert_eq!(card.repetitions, count);
              }
              
              #[test]
              fn prop_sm2_failure_resets_repetitions(quality_fail in 0u8..=2, setup_quality in 4u8..=5, setup_count in 1..10usize) {
                  let mut card = FlashCard::new("test".to_string(), "test".to_string());
                  
                  // Build up repetitions
                  for _ in 0..setup_count {
                      card.update_sm2(setup_quality);
                  }
                  
                  // Fail once
                  card.update_sm2(quality_fail);
                  
                  prop_assert_eq!(card.repetitions, 0);
                  prop_assert_eq!(card.interval, 1);
              }
              
              #[test]
              fn prop_statistics_accuracy_valid_percentage(correct in 0u32..=1000, total in 0u32..=1000) {
                  let mut stats = Statistics::new();
                  stats.correct_reviews = correct;
                  stats.total_reviews = total.max(correct);
                  
                  let accuracy = stats.accuracy_rate();
                  prop_assert!(accuracy >= 0.0);
                  prop_assert!(accuracy <= 100.0);
              }
              
              #[test]
              fn prop_statistics_correct_never_exceeds_total(reviews in prop::collection::vec(proptest::bool::ANY, 1..100)) {
                  let mut stats = Statistics::new();

                  for is_correct in reviews {
                      stats.record_review(is_correct);
                  }
                  
                  prop_assert!(stats.correct_reviews <= stats.total_reviews);
              }
              
              #[test]
              fn prop_stroke_normalization_bounds(points in prop::collection::vec((0.0f64..=1000.0, 0.0f64..=1000.0), 2..50)) {
                  let mut stroke = Stroke::new();
                  for (x, y) in points {
                      stroke.add_point(x, y);
                  }
                  
                  let normalized = stroke.normalize();
                  
                  for point in &normalized.points {
                      prop_assert!(point.x >= 0.0);
                      prop_assert!(point.x <= 1.0);
                      prop_assert!(point.y >= 0.0);
                      prop_assert!(point.y <= 1.0);
                  }
              }
              
              #[test]
              fn prop_stroke_comparison_symmetric(points1 in prop::collection::vec((0.0f64..=100.0, 0.0f64..=100.0), 2..20),
                                                   points2 in prop::collection::vec((0.0f64..=100.0, 0.0f64..=100.0), 2..20)) {
                  let mut stroke1 = Stroke::new();
                  for (x, y) in points1 {
                      stroke1.add_point(x, y);
                  }
                  
                  let mut stroke2 = Stroke::new();
                  for (x, y) in points2 {
                      stroke2.add_point(x, y);
                  }
                  
                  let similarity_1_2 = stroke1.compare(&stroke2);
                  let similarity_2_1 = stroke2.compare(&stroke1);
                  
                  prop_assert!((similarity_1_2 - similarity_2_1).abs() < 0.01);
              }
              
              #[test]
              fn prop_stroke_comparison_identity(points in prop::collection::vec((0.0f64..=100.0, 0.0f64..=100.0), 2..20)) {
                  let mut stroke = Stroke::new();
                  for (x, y) in &points {
                      stroke.add_point(*x, *y);
                  }
                  
                  let similarity = stroke.compare(&stroke);
                  prop_assert!(similarity > 0.99);
              }
              
              #[test]
              fn prop_database_save_load_idempotent(character in "[一-龯]", meaning in "[a-z]{3,10}") {
                  let temp_dir = TempDir::new().unwrap();
                  let db_path = temp_dir.path().join("test.db");
                  let mut db = Database::new(&db_path).unwrap();
                  
                  let card = FlashCard::new(character.clone(), meaning.clone());
                  db.save_card(&card).unwrap();
                  
                  let loaded1 = db.load_card(&character).unwrap();
                  db.save_card(&loaded1).unwrap();
                  let loaded2 = db.load_card(&character).unwrap();
                  
                  prop_assert_eq!(loaded1.character, loaded2.character);
                  prop_assert_eq!(loaded1.meaning, loaded2.meaning);
                  prop_assert_eq!(loaded1.repetitions, loaded2.repetitions);
                  prop_assert_eq!(loaded1.interval, loaded2.interval);
              }
          }
      }
      
      #[cfg(test)]
      mod benchmark_tests {
          use super::*;
          use criterion::{black_box, Criterion, criterion_group, criterion_main};
          use tempfile::TempDir;
          
          fn benchmark_animation_rendering(c: &mut Criterion) {
              let strokes = vec![
                  vec![(0.0, 0.0), (100.0, 0.0)],
                  vec![(50.0, 0.0), (50.0, 100.0)],
                  vec![(0.0, 50.0), (100.0, 50.0)]
              ];
              
              c.bench_function("animation_render_frame", |b| {
                  b.iter(|| {
                      let mut animator = Animator::new(black_box(&strokes));
                      animator.render_frame(16.67); // 60fps target
                  });
              });
              
              c.bench_function("animation_complete_stroke", |b| {
                  b.iter(|| {
                      let mut animator = Animator::new(black_box(&strokes));
                      while !animator.is_complete() {
                          animator.render_frame(16.67);
                      }
                  });
              });
          }
          
          fn benchmark_database_operations(c: &mut Criterion) {
              c.bench_function("db_save_single_card", |b| {
                  let temp_dir = TempDir::new().unwrap();
                  let db_path = temp_dir.path().join("bench.db");
                  let mut db = Database::new(&db_path).unwrap();
                  let card = FlashCard::new("一".to_string(), "one".to_string());
                  
                  b.iter(|| {
                      db.save_card(black_box(&card)).unwrap();
                  });
              });
              
              c.bench_function("db_load_single_card", |b| {
                  let temp_dir = TempDir::new().unwrap();
                  let db_path = temp_dir.path().join("bench.db");
                  let mut db = Database::new(&db_path).unwrap();
                  let card = FlashCard::new("一".to_string(), "one".to_string());
                  db.save_card(&card).unwrap();
                  
                  b.iter(|| {
                      db.load_card(black_box("一")).unwrap();
                  });
              });
              
              c.bench_function("db_save_100_cards", |b| {
                  b.iter(|| {
                      let temp_dir = TempDir::new().unwrap();
                      let db_path = temp_dir.path().join("bench.db");
                      let mut db = Database::new(&db_path).unwrap();

                      for i in 0..100 {
                          let card = FlashCard::new(format!("char{}", i), format!("meaning{}", i));
                          db.save_card(&card).unwrap();
                      }
                  });
              });
              
              c.bench_function("db_load_all_100_cards", |b| {
                  let temp_dir = TempDir::new().unwrap();
                  let db_path = temp_dir.path().join("bench.db");
                  let mut db = Database::new(&db_path).unwrap();
                  
                  for i in 0..100 {
                      let card = FlashCard::new(format!("char{}", i), format!("meaning{}", i));
                      db.save_card(&card).unwrap();
                  }
                  
                  b.iter(|| {
                      db.load_all_cards().unwrap();
                  });
              });
          }
          
          fn benchmark_stroke_recognition(c: &mut Criterion) {
              c.bench_function("stroke_normalize", |b| {
                  let mut stroke = Stroke::new();
                  for i in 0..50 {
                      stroke.add_point(i as f64 * 2.0, i as f64 * 2.0);
                  }
                  
                  b.iter(|| {
                      black_box(&stroke).normalize();
                  });
              });
              
              c.bench_function("stroke_comparison", |b| {
                  let mut stroke1 = Stroke::new();
                  let mut stroke2 = Stroke::new();
                  
                  for i in 0..50 {
                      stroke1.add_point(i as f64 * 2.0, i as f64 * 2.0);
                      stroke2.add_point(i as f64 * 2.0 + 1.0, i as f64 * 2.0 + 1.0);
                  }
                  
                  b.iter(|| {
                      black_box(&stroke1).compare(black_box(&stroke2));
                  });
              });
              
              c.bench_function("character_recognition_full", |b| {
                  let reference_strokes = vec![
                      vec![(0.0, 0.0), (100.0, 0.0)],
                      vec![(50.0, 0.0), (50.0, 100.0)]
                  ];
                  
                  let user_strokes = vec![
                      vec![(0.0, 0.0), (95.0, 5.0)],
                      vec![(48.0, 0.0), (48.0, 98.0)]
                  ];
                  
                  b.iter(|| {
                      recognize_character(black_box(&user_strokes), black_box(&reference_strokes));
                  });
              });
          }
          
          fn benchmark_sm2_algorithm(c: &mut Criterion) {
              c.bench_function("sm2_update_single", |b| {
                  let mut card = FlashCard::new("test".to_string(), "test".to_string());
                  
                  b.iter(|| {
                      card.update_sm2(black_box(4));
                  });
              });
              
              c.bench_function("sm2_update_sequence", |b| {
                  b.iter(|| {
                      let mut card = FlashCard::new("test".to_string(), "test".to_string());
                      for quality in &[5, 4, 5, 3, 4, 5, 5] {
                          card.update_sm2(*quality);
                      }
                  });
              });
          }
          
          criterion_group!(
              benches,
              benchmark_animation_rendering,
              benchmark_database_operations,
              benchmark_stroke_recognition,
              benchmark_sm2_algorithm
          );
          criterion_main!(benches);
      }

  coverage:
    - "SM-2 algorithm initial card state with default values"
    - "SM-2 quality 5 increases interval and repetitions"
    - "SM-2 quality 4 maintains progress without easiness change"
    - "SM-2 quality 3 resets repetitions and interval"
    - "SM-2 quality below 3 resets all progress"
    - "SM-2 easiness factor has minimum floor of 1.3"
    - "SM-2 progressive intervals increase with consecutive successes"
    - "Statistics initial state has zero values"
    - "Statistics accuracy calculation with valid data"
    - "Statistics accuracy returns 0.0 for zero reviews"
    - "Statistics correctly increments on correct review"
    - "Statistics correctly increments on incorrect review"
    - "Statistics tracks current streak correctly"
    - "Statistics tracks longest streak across resets"
    - "Stroke point creation with coordinates"
    - "Stroke distance calculation between two points"
    - "Stroke normalization handles empty stroke"
    - "Stroke normalization handles single point"
    - "Stroke normalization scales to 0-1 range"
    - "Stroke comparison returns high similarity for identical strokes"
    - "Stroke comparison returns low similarity for different strokes"
    - "Database creation initializes file"
    - "Database saves and loads single card"
    - "Database saves and loads multiple cards"
    - "Database updates existing card"
    - "Database saves and loads statistics"
    - "Database backup and restore functionality"
    - "Database save operation completes under 100ms"
    - "Settings default values initialization"
    - "Settings persistence across save and load"
    - "Complete learning session from new character to statistics update"
    - "Complete practice session in writing mode"
    - "Complete practice session in recognition mode"
    - "Spaced repetition due card calculation"
    - "Statistics persistence across application restarts"
    - "Settings persistence and application on reload"
    - "UI state transitions between all modes"
    - "Database operations workflow including backup and restore"
    - "Animation rendering workflow from start to completion"
    - "Stroke recognition workflow with user input"
    - "Multi-session workflow spanning multiple days"
    - "Property test: SM-2 easiness factor bounded between 1.3 and 3.5"
    - "Property test: SM-2 interval monotonically increases on success"
    - "Property test: SM-2 repetitions increase with consecutive successes"
    - "Property test: SM-2 failure resets repetitions to zero"
    - "Property test: Statistics accuracy always valid percentage"
    - "Property test: Statistics correct reviews never exceed total"
    - "Property test: Stroke normalization always bounds to 0-1"
    - "Property test: Stroke comparison is symmetric"
    - "Property test: Stroke comparison identity returns near 1.0"
    - "Property test: Database save-load is idempotent"
    - "Benchmark: Animation renders single frame at 60fps target"
    - "Benchmark: Animation completes full stroke sequence"
    - "Benchmark: Database saves single card under 100ms"
    - "Benchmark: Database loads single card efficiently"
    - "Benchmark: Database saves 100 cards in batch"
    - "Benchmark: Database loads all 100 cards efficiently"
    - "Benchmark: Stroke normalization performance"
    - "Benchmark: Stroke comparison performance"
    - "Benchmark: Full character recognition performance"
    - "Benchmark: SM-2 single update performance"
    - "Benchmark: SM-2 sequence update performance"

dependencies:
  depends_on:
    - task_id: 1
      reason: "All features must be implemented before final testing"
    - task_id: 2
      reason: "All features must be implemented before final testing"
    - task_id: 3
      reason: "All features must be implemented before final testing"
    - task_id: 4
      reason: "All features must be implemented before final testing"
    - task_id: 5
      reason: "All features must be implemented before final testing"
    - task_id: 6
      reason: "All features must be implemented before final testing"
    - task_id: 7
      reason: "All features must be implemented before final testing"
    - task_id: 8
      reason: "All features must be implemented before final testing"
    - task_id: 9
      reason: "All features must be implemented before final testing"
    - task_id: 10
      reason: "All features must be implemented before final testing"
    - task_id: 11
      reason: "All features must be implemented before final testing"
    - task_id: 12
      reason: "All features must be implemented before final testing"
    - task_id: 13
      reason: "All features must be implemented before final testing"

  depended_upon_by: []

  external:
    - name: "criterion"
      type: "crate"
      status: "to be imported"
    - name: "proptest"
      type: "crate"
      status: "to be imported"
    - name: "tempfile"
      type: "crate"
      status: "to be imported"
    - name: "insta"
      type: "crate"
      status: "to be imported"
    - name: "assert_cmd"
      type: "crate"
      status: "to be imported"
    - name: "cargo-bundle"
      type: "crate"
      status: "to be imported"
    - name: "cargo-tarpaulin"
      type: "crate"
      status: "to be imported"
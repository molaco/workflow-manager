workflow_execution_analysis:
  execution_models:
    process_based:
      description: "Primary execution model where workflows run as separate OS processes"
      implementation:
        location: "src/runtime.rs:125-178, src/app/workflow_ops.rs:99-235"
        spawning_mechanism:
          command: "std::process::Command"
          stdio_config:
            stdin: "Stdio::null()"
            stdout: "Stdio::piped()"
            stderr: "Stdio::piped()"
        workflow_discovery:
          method: "Binary scanning with metadata extraction"
          location: "src/discovery.rs:15-78"
          search_paths:
            - "~/.workflow-manager/workflows/"
            - "../target/debug (same dir as TUI binary)"
            - "../target/release"
          discovery_protocol: "Execute `binary --workflow-metadata` and parse JSON response"
          metadata_schema: "FullWorkflowMetadata { metadata, fields }"
        
      characteristics:
        isolation: "Strong - separate process space per workflow"
        communication_protocol:
          format: "__WF_EVENT__:<JSON>"
          transport: "stderr (parsed by parent process)"
          event_types: 15
          structure: "Hierarchical: Phase → Task → Agent"
        binary_requirements:
          - "Must be executable (0o111 permissions on Unix)"
          - "Must respond to --workflow-metadata flag"
          - "Must emit structured logs to stderr in JSON format"
        
      advantages:
        - "Process isolation prevents workflow crashes from affecting TUI"
        - "Clean resource cleanup on process termination"
        - "Workflows can use any language (compiled to binary)"
        - "Built-in sandboxing via OS process boundaries"
      
      disadvantages:
        - "Process spawn overhead (~10-50ms per workflow)"
        - "IPC overhead for event streaming"
        - "Complex state synchronization via stderr parsing"
        - "No direct memory sharing"
        
    library_based:
      description: "In-process execution using claude-agent-sdk as library"
      implementation:
        examples:
          - "examples/research_agent.rs:109-157 (execute_research_prompt)"
          - "examples/new_research_agent.rs:352-414 (execute_research_prompt)"
        pattern: "Direct SDK usage with async/await"
        code_structure: |
          let options = ClaudeAgentOptions::builder()
              .system_prompt(SystemPrompt::Preset(preset))
              .permission_mode(BypassPermissions)
              .build();
          
          let stream = query(&prompt, Some(options)).await?;
          // Process streaming responses
        
      characteristics:
        isolation: "None - runs in same process as caller"
        communication: "Direct function calls and async streams"
        state_sharing: "Direct memory access via Arc/Mutex"
        
      advantages:
        - "No process spawn overhead"
        - "Direct memory access for state"
        - "Easier debugging (single process)"
        - "Lower latency for small tasks"
      
      disadvantages:
        - "No isolation - crashes affect entire application"
        - "Resource limits harder to enforce"
        - "Workflow must be written in Rust"
        - "Tightly coupled to SDK version"
        
      current_usage:
        status: "Examples only - not integrated into TUI runtime"
        use_cases:
          - "Claude Agent SDK integration demos"
          - "Prototyping new workflow patterns"
          - "Hook system demonstrations"

  workflow_state_management:
    state_hierarchy:
      levels:
        phase:
          type: "WorkflowPhase"
          fields:
            - "id: usize"
            - "name: String"
            - "status: PhaseStatus (NotStarted/Running/Completed/Failed)"
            - "tasks: Vec<WorkflowTask>"
            - "output_files: Vec<(String, String)>"
          lifecycle:
            start: "WorkflowLog::PhaseStarted"
            complete: "WorkflowLog::PhaseCompleted"
            fail: "WorkflowLog::PhaseFailed"
            
        task:
          type: "WorkflowTask"
          fields:
            - "id: String"
            - "phase: usize"
            - "description: String"
            - "status: TaskStatus"
            - "agents: Vec<WorkflowAgent>"
            - "messages: Vec<String>"
            - "result: Option<String>"
          lifecycle:
            start: "WorkflowLog::TaskStarted"
            progress: "WorkflowLog::TaskProgress"
            complete: "WorkflowLog::TaskCompleted"
            fail: "WorkflowLog::TaskFailed"
            
        agent:
          type: "WorkflowAgent"
          fields:
            - "id: String (format: '{task_id}:{agent_name}')"
            - "task_id: String"
            - "name: String"
            - "description: String"
            - "status: AgentStatus"
            - "messages: Vec<String>"
            - "result: Option<String>"
          lifecycle:
            start: "WorkflowLog::AgentStarted"
            message: "WorkflowLog::AgentMessage (streaming text)"
            complete: "WorkflowLog::AgentCompleted"
            fail: "WorkflowLog::AgentFailed"
    
    storage:
      in_memory:
        structure: "Arc<Mutex<Vec<WorkflowPhase>>>"
        scope: "Per-tab (for TUI tabs) or per-execution (for runtime)"
        persistence: "None - lost on application restart"
        location:
          tui: "src/app/models/tab.rs:26 (WorkflowTab.workflow_phases)"
          runtime: "src/runtime.rs:17-23 (ExecutionState)"
        
      event_streaming:
        mechanism: "tokio::sync::broadcast channel"
        capacity: 100
        subscribers: "Multiple (TUI, logging, MCP clients)"
        location: "src/runtime.rs:151-152"
        
    state_tracking:
      event_handler:
        function: "App::handle_workflow_event"
        location: "src/app/workflow_ops.rs:472-637"
        behavior: "Dynamic hierarchy construction from events"
        features:
          - "Auto-creates phases/tasks/agents on-demand"
          - "Handles out-of-order events gracefully"
          - "Updates nested status propagation"
          
  log_capture:
    structured_events:
      protocol: "__WF_EVENT__:<JSON>"
      location: "workflow-manager-sdk/src/lib.rs:198-208"
      emission:
        method: "WorkflowLog::emit() writes to stderr"
        format: "JSON-serialized enum with discriminated union"
        flush: "Explicit stderr flush for async contexts"
        
      parsing:
        location: "src/runtime.rs:214-253 (parse_workflow_stderr)"
        implementation: "Async line-by-line reader with JSON deserialization"
        error_handling: "Invalid JSON silently ignored, valid events broadcast"
        
    event_types:
      count: 15
      categories:
        phase_lifecycle: ["PhaseStarted", "PhaseCompleted", "PhaseFailed"]
        task_lifecycle: ["TaskStarted", "TaskProgress", "TaskCompleted", "TaskFailed"]
        agent_lifecycle: ["AgentStarted", "AgentMessage", "AgentCompleted", "AgentFailed"]
        state_files: ["StateFileCreated"]
      
    helper_macros:
      location: "workflow-manager-sdk/src/lib.rs:210-374"
      macros:
        - "log_phase_start!($phase, $name, $total)"
        - "log_task_start!($phase, $task_id, $desc)"
        - "log_agent_message!($task_id, $agent, $msg)"
      purpose: "Ergonomic event emission with compile-time safety"
      
  process_lifecycle_control:
    spawning:
      command_builder:
        location: "src/runtime.rs:60-77"
        args_construction: "Field values mapped to CLI args (--flag value)"
        working_directory: "Inherited from parent"
        
    monitoring:
      stdout_reader:
        location: "src/app/workflow_ops.rs:164-176"
        thread: "Dedicated thread per workflow"
        buffer: "Arc<Mutex<Vec<String>>>"
        
      stderr_parser:
        location: "src/runtime.rs:214-253, src/app/workflow_ops.rs:179-200"
        thread: "Dedicated async task"
        parsing: "Line-by-line with prefix check"
        
      completion_watcher:
        location: "src/app/workflow_ops.rs:203-223"
        thread: "Dedicated thread per workflow"
        exit_status: "Captured from child.wait()"
        
    cancellation:
      method: "child.kill()"
      locations:
        runtime: "src/runtime.rs:199-211"
        tui_tabs: "src/app/tabs.rs:72-87"
      behavior:
        - "Sends SIGKILL on Unix (immediate termination)"
        - "No graceful shutdown signal"
        - "Status updated to WorkflowStatus::Failed"
      
      tab_cleanup:
        close_tab: "src/app/tabs.rs:44-69 (kills child if running)"
        kill_current: "src/app/tabs.rs:72-87 (explicit kill command)"
        app_shutdown: "Implicit - child processes orphaned"
        
  api_support_assessment:
    process_based_execution:
      readiness: "Production-ready foundation"
      strengths:
        - "Clean isolation model"
        - "Well-defined communication protocol"
        - "Existing WorkflowRuntime trait (sdk/src/lib.rs:398-431)"
        - "Async execution with handle-based tracking"
        - "Broadcast log subscription"
        
      implementation_status:
        runtime_trait: "Fully implemented in ProcessBasedRuntime"
        methods:
          - "list_workflows() -> Vec<FullWorkflowMetadata>"
          - "get_workflow_metadata(id) -> FullWorkflowMetadata"
          - "validate_workflow_inputs(id, params) -> Result<()>"
          - "execute_workflow(id, params) -> WorkflowHandle"
          - "subscribe_logs(handle) -> broadcast::Receiver<WorkflowLog>"
          - "get_status(handle) -> WorkflowStatus"
          - "cancel_workflow(handle) -> Result<()>"
          
    library_based_execution:
      readiness: "Experimental - not integrated"
      status: "Examples demonstrate pattern but no runtime implementation"
      requirements_for_api:
        - "Define LibraryBasedRuntime implementing WorkflowRuntime trait"
        - "Registry of workflow functions (HashMap<String, WorkflowFn>)"
        - "Isolate workflow state per execution"
        - "Convert WorkflowLog emissions to broadcast channels"
      
      challenges:
        isolation: "Requires careful Arc/Mutex usage to prevent cross-execution interference"
        error_handling: "Panics propagate to parent process"
        resource_limits: "No built-in CPU/memory controls"
        
  sandboxing_and_resource_limits:
    current_implementation:
      sandboxing: "None - relies on OS process boundaries only"
      resource_limits: "None - workflows can consume unlimited CPU/memory/disk"
      concurrency_control:
        pattern: "Semaphore-based (tokio::sync::Semaphore)"
        location: "examples/new_research_agent.rs:604, 727"
        scope: "Application-level concurrency, not per-workflow"
        usage: "Limits parallel Claude API calls (--batch-size flag)"
        
    missing_features:
      cpu_limits:
        mechanisms:
          - "Unix: setrlimit(RLIMIT_CPU) via nix crate"
          - "Linux: cgroups v2 CPU quotas"
          - "Cross-platform: timeout-based termination"
        recommendation: "Start with timeout-based approach for portability"
        
      memory_limits:
        mechanisms:
          - "Unix: setrlimit(RLIMIT_AS) for address space"
          - "Linux: cgroups v2 memory controller"
        challenges: "Workflows spawn child processes (Claude SDK) - need process group limits"
        
      network_limits:
        current: "No restrictions"
        requirements:
          - "Rate limiting for API calls"
          - "Domain allowlists/blocklists"
          - "Bandwidth quotas"
        implementation: "Hook system can enforce pre-tool-use checks"
        
      filesystem_limits:
        current: "Full access to parent process permissions"
        requirements:
          - "Chroot/jail for write operations"
          - "Disk quota enforcement"
          - "Temp directory isolation"
        
    timeout_mechanism:
      status: "Not implemented"
      proposed_approach:
        location: "src/runtime.rs:ExecutionState"
        implementation: |
          struct ExecutionState {
              start_time: Instant,
              timeout_duration: Option<Duration>,
              timeout_handle: Option<tokio::task::JoinHandle<()>>,
          }
          
          // Spawn timeout task that kills child after duration
          let timeout_task = tokio::spawn(async move {
              tokio::time::sleep(timeout_duration).await;
              if let Some(mut child) = child_handle.lock().take() {
                  let _ = child.kill();
              }
          });
        
  execution_model_comparison:
    use_cases:
      process_based_recommended:
        - "Long-running workflows (>1 minute)"
        - "Workflows requiring isolation"
        - "Workflows with external dependencies"
        - "Production deployments"
        - "Multi-tenant scenarios"
        
      library_based_recommended:
        - "Fast micro-tasks (<1 second)"
        - "Tightly integrated with application state"
        - "Development/debugging workflows"
        - "Single-tenant trusted environments"
        
  api_design_implications:
    dual_mode_support:
      feasibility: "Yes - WorkflowRuntime trait supports both"
      runtime_selection:
        configuration: |
          enum ExecutionMode {
              Process,
              Library,
              Hybrid { library_for: Vec<String> }
          }
        
        per_workflow_override:
          annotation: "@workflow(execution_mode = \"process\")"
          runtime_check: "Check workflow metadata for preferred mode"
          
    async_execution_model:
      status: "Already implemented for process-based"
      handle_pattern:
        creation: "execute_workflow() returns WorkflowHandle"
        tracking: "UUID-based lookup in HashMap<Uuid, ExecutionState>"
        polling: "get_status(handle) for status checks"
        streaming: "subscribe_logs(handle) for real-time events"
        
    state_persistence:
      current: "In-memory only"
      requirements_for_api:
        - "Database for execution history (PostgreSQL/SQLite)"
        - "Checkpoint/resume for long workflows"
        - "Query API for historical executions"
        - "Retention policies"
        
  concurrency_and_parallelism:
    application_level:
      semaphore_pattern:
        implementation: "Arc<Semaphore::new(batch_size)>"
        usage: "examples/new_research_agent.rs controls parallel Claude calls"
        scope: "User-specified concurrency limit"
        
      futures_unordered:
        pattern: "FuturesUnordered for dynamic task spawning"
        location: "examples/new_research_agent.rs:979-998"
        behavior: "Fail-fast on first error, collect all results"
        
    workflow_level:
      current: "No per-workflow concurrency control"
      requirements:
        - "Max concurrent workflows per user/tenant"
        - "Priority queues for workflow scheduling"
        - "Backpressure when system overloaded"
        
  recommendations:
    immediate_priorities:
      1:
        action: "Support both process and library execution via unified API"
        rationale: "Flexibility for different use cases"
        effort: "Medium - requires LibraryBasedRuntime implementation"
        
      2:
        action: "Add timeout mechanism for process-based workflows"
        rationale: "Prevent runaway processes"
        effort: "Low - spawn timeout task that calls child.kill()"
        
      3:
        action: "Implement resource limit hooks in WorkflowRuntime trait"
        rationale: "Foundation for sandboxing"
        effort: "Medium - add setrlimit calls before spawn"
        
    medium_term:
      1:
        action: "Add cgroups-based resource control for Linux"
        rationale: "Production-grade CPU/memory limits"
        effort: "High - requires cgroups v2 API integration"
        
      2:
        action: "Implement state persistence layer"
        rationale: "Enable resume and historical queries"
        effort: "High - database schema + migration"
        
      3:
        action: "Add workflow scheduler with priority queues"
        rationale: "Multi-tenant fairness"
        effort: "Medium - queue + executor implementation"
        
    long_term:
      1:
        action: "Investigate WebAssembly sandboxing for library-based workflows"
        rationale: "Strong isolation without process overhead"
        effort: "Very High - WASM runtime integration"
        
      2:
        action: "Distributed execution for horizontally scaled deployments"
        rationale: "Cloud-native architecture"
        effort: "Very High - requires job queue + worker pool"

  cancellation_patterns:
    graceful_shutdown:
      status: "Not implemented"
      current_behavior: "Immediate SIGKILL"
      requirements:
        - "Send SIGTERM first, wait grace period"
        - "Workflows trap signal and clean up"
        - "SIGKILL as last resort"
      implementation_approach: |
        // Phase 1: SIGTERM
        child.kill_with_signal(Signal::SIGTERM)?;
        
        // Phase 2: Wait with timeout
        tokio::select! {
            _ = tokio::time::sleep(Duration::from_secs(5)) => {
                child.kill()?; // SIGKILL
            }
            result = child.wait() => {
                // Clean exit
            }
        }
        
  state_file_handling:
    intermediate_outputs:
      event: "WorkflowLog::StateFileCreated"
      use_cases:
        - "Multi-phase workflows pass data via files"
        - "Resume workflows from checkpoints"
        - "Debug intermediate results"
      tracking:
        location: "WorkflowPhase.output_files: Vec<(String, String)>"
        ui_display: "Listed per phase in TUI"
        
    cross_workflow_state:
      field_type: "FieldType::StateFile { pattern, phase }"
      validation: "Check file exists and matches pattern"
      use_case: "Workflow chains (output of workflow A → input of workflow B)"

  hook_system:
    implementation:
      location: "src/bin/hooks_demo.rs"
      sdk: "claude_agent_sdk::types::{HookEvent, HookMatcher, HookOutput}"
      events: ["PreToolUse", "PostToolUse"]
      
    use_cases:
      validation: "Block dangerous commands (rm, dd, etc.)"
      audit_logging: "Log all tool invocations"
      resource_control: "Deny tool use based on quotas"
      
    integration_with_workflows:
      status: "Available but not enforced by runtime"
      potential: "WorkflowRuntime could inject hooks for all executions"
      example: |
        // In ProcessBasedRuntime::execute_workflow
        let options = ClaudeAgentOptions {
            hooks: Some(security_hooks()),
            ..default
        };

summary:
  current_state: "Process-based execution is production-ready for basic use cases"
  library_based: "Experimental - demonstrated in examples but not integrated"
  api_readiness: "WorkflowRuntime trait provides foundation but lacks resource controls"
  
  critical_gaps:
    - "No timeout mechanism"
    - "No resource limits (CPU/memory/disk)"
    - "No graceful shutdown"
    - "No state persistence"
    - "No multi-tenancy controls"
    
  recommended_architecture:
    default: "Process-based for isolation and safety"
    opt_in_library: "Allow trusted workflows to run in-process for performance"
    hybrid_mode: "Mix both models based on workflow metadata annotations"
    
  implementation_phases:
    phase_1:
      focus: "Harden process-based execution"
      features:
        - "Timeout mechanism"
        - "Basic resource limits (setrlimit)"
        - "Graceful shutdown"
      effort: "2-3 weeks"
      
    phase_2:
      focus: "Library-based runtime"
      features:
        - "LibraryBasedRuntime implementation"
        - "Workflow function registry"
        - "State isolation"
      effort: "3-4 weeks"
      
    phase_3:
      focus: "Production hardening"
      features:
        - "State persistence"
        - "Cgroups integration"
        - "Multi-tenancy"
      effort: "6-8 weeks"
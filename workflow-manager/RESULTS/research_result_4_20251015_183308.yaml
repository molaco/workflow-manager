api_layer_organization_analysis:
  date: 2025-10-15
  
  current_crate_structure:
    workspace_members:
      - name: workflow-manager
        type: binary_tui
        description: Main TUI application for workflow execution and management
        dependencies:
          - claude-agent-sdk
          - workflow-manager-sdk
          - tokio (full features)
          - ratatui
          - crossterm
          - clap
          - reqwest
        responsibilities:
          - TUI rendering and user interaction
          - Workflow discovery via filesystem scanning
          - Process-based workflow execution
          - Log parsing and display
          - MCP server implementation for external API
          
      - name: workflow-manager-sdk
        type: library
        description: SDK for creating workflow definitions with trait-based contracts
        dependencies:
          - workflow-manager-macros (proc-macro re-export)
          - claude-agent-sdk (convenience re-export)
          - tokio (sync feature only)
          - serde
          - uuid
          - async-trait
        responsibilities:
          - WorkflowDefinition trait
          - Field schema types (FieldSchema, FieldType)
          - Metadata structs (WorkflowMetadata, FullWorkflowMetadata)
          - WorkflowRuntime trait (API contract)
          - WorkflowLog events and logging macros
          - WorkflowStatus, WorkflowHandle types
        runtime_specificity: Minimal - uses tokio::sync only
        
      - name: workflow-manager-macros
        type: proc_macro
        description: Derive macro for WorkflowDefinition trait
        dependencies:
          - syn
          - quote
          - proc-macro2
        responsibilities:
          - Derive macro implementation for WorkflowDefinition
          - Field introspection and metadata extraction
        
      - name: claude-agent-sdk
        type: library
        description: External SDK for interacting with Claude AI agents
        is_external: true
        runtime_specificity: Tokio-specific (uses tokio features extensively)

  current_api_implementation:
    location: workflow-manager/src/runtime.rs
    type: ProcessBasedRuntime
    implements: WorkflowRuntime trait from workflow-manager-sdk
    characteristics:
      - Process spawning and management
      - Stderr parsing for workflow events
      - Broadcast channels for log distribution
      - Workflow discovery integration
      - Tokio-specific (tokio::process, tokio::io, etc.)
    
  dependency_analysis:
    current_flow:
      workflow_manager:
        depends_on:
          - workflow-manager-sdk (for traits and types)
          - claude-agent-sdk (for AI integration)
      workflow_manager_sdk:
        depends_on:
          - workflow-manager-macros (re-exported)
          - claude-agent-sdk (re-exported for convenience)
          - tokio (minimal - sync feature only)
      workflow_manager_macros:
        depends_on: [syn, quote, proc-macro2]
      
    circular_dependency_risk:
      status: LOW
      reasoning: |
        Current structure avoids circular dependencies by having SDK define
        traits/contracts and binary implement them. Macro crate is isolated.
        SDK re-exports but doesn't create circular dependencies.

  strategic_options:

    option_1_extend_sdk:
      name: Extend workflow-manager-sdk with API module
      structure: |
        workflow-manager-sdk/
        ├── src/
        │   ├── lib.rs (traits, types, macros re-export)
        │   ├── api/
        │   │   ├── mod.rs
        │   │   ├── process_runtime.rs (ProcessBasedRuntime)
        │   │   └── mcp_server.rs (MCP integration)
      
      pros:
        - Single SDK crate for users to depend on
        - Follows serde pattern (core + optional features)
        - No additional workspace complexity
        - Clear separation via modules
        - Can use feature flags for optional dependencies
        
      cons:
        - Mixes trait definitions with implementations
        - SDK becomes runtime-specific (tokio dependency)
        - Increases SDK compile time for all users
        - Process management logic seems out of place in "SDK"
        - Would need to pull in process/io dependencies
        
      feature_flag_strategy:
        default: []
        runtime: [tokio/process, tokio/io-util]
        mcp: [claude-agent-sdk, reqwest]
        
      circular_dependency_risk: NONE
      
      recommendations:
        viability: MEDIUM
        use_case: If API is simple and tightly coupled to SDK
        
    option_2_new_api_crate:
      name: Create separate workflow-manager-api crate
      structure: |
        workflow-manager-api/
        ├── Cargo.toml
        └── src/
            ├── lib.rs
            ├── runtime/
            │   ├── mod.rs
            │   ├── process.rs (ProcessBasedRuntime)
            │   └── discovery.rs
            ├── mcp/
            │   ├── mod.rs
            │   └── server.rs
            └── client/
                ├── mod.rs
                └── http.rs (future HTTP client)
      
      dependencies:
        workflow-manager-sdk: Required (for traits/types)
        claude-agent-sdk: Required (for AI integration)
        tokio: Required (full runtime features)
        
      workspace_members_after:
        - workflow-manager (binary/TUI)
        - workflow-manager-sdk (trait definitions, types)
        - workflow-manager-api (runtime implementations, API layer)
        - workflow-manager-macros (derive macro)
        - claude-agent-sdk (external)
      
      pros:
        - Clear separation of concerns (SDK vs API vs TUI)
        - SDK remains lightweight and runtime-agnostic
        - API crate can be runtime-specific without polluting SDK
        - Follows tokio pattern (split core from runtime impl)
        - TUI and future clients both depend on same API layer
        - Easier to version independently
        - Better discoverability (workflow-manager-api clearly indicates API)
        
      cons:
        - Additional crate to maintain
        - More workspace complexity
        - Users need two dependencies (SDK + API)
        - Potential for version drift between crates
        
      circular_dependency_risk: NONE
      
      dependency_flow:
        workflow-manager-api:
          depends_on:
            - workflow-manager-sdk (traits, types)
            - claude-agent-sdk (AI)
            - tokio (runtime)
        workflow-manager:
          depends_on:
            - workflow-manager-api (runtime implementation)
            - workflow-manager-sdk (types for UI)
        workflow-implementations:
          depends_on:
            - workflow-manager-sdk (only SDK needed)
            
      recommendations:
        viability: HIGH
        use_case: If API will grow or have multiple runtimes
        
    option_3_split_sdk:
      name: Split SDK into core and runtime crates
      structure: |
        workflow-manager-sdk-core/
        ├── traits and types only
        └── no runtime dependencies
        
        workflow-manager-sdk/
        ├── re-exports core
        ├── re-exports macros
        └── optional runtime features
      
      similar_to: serde (serde core + serde_derive)
      
      pros:
        - Maximum flexibility
        - Core can be truly runtime-agnostic
        - Follows established patterns
        
      cons:
        - Significant complexity for current needs
        - Overkill unless multiple runtime backends planned
        - Users confused about which crate to use
        
      circular_dependency_risk: NONE
      
      recommendations:
        viability: LOW
        use_case: Only if planning multiple runtime backends (async-std, smol, etc.)

  rust_ecosystem_patterns_analysis:
    
    tokio_pattern:
      observation: Originally split into many crates, consolidated into single crate with feature flags
      lesson: Split when components have different stability, consolidate for maintenance
      relevance: Medium - we're early stage, not dealing with stability issues yet
      
    serde_pattern:
      observation: Core (serde) + derive (serde_derive), derive now a feature flag
      lesson: Proc macros must be separate crate, but can be feature-flagged in main crate
      relevance: High - already following this with workflow-manager-macros
      
    aws_sdk_pattern:
      observation: Separate crate per service (aws-sdk-s3, aws-sdk-ec2)
      lesson: Split when components are independent and users need subsets
      relevance: Low - our API is cohesive, not modular services
      
    best_practice_synthesis:
      - Avoid premature splitting
      - Use feature flags for optional dependencies
      - Split only when there's clear benefit (stability, subset usage, independence)
      - Proc macros always separate crate (technical requirement)

  recommendations:
    
    primary_recommendation:
      choice: option_2_new_api_crate
      rationale: |
        Creating workflow-manager-api as a separate crate provides the best
        balance of separation of concerns while avoiding the complexity of
        option 3. The SDK remains clean and lightweight for workflow authors,
        while the API crate handles all runtime-specific concerns.
        
      benefits:
        - SDK stays focused on trait definitions and types
        - API crate can evolve independently
        - Clear mental model: SDK = contracts, API = implementation
        - Follows industry patterns (client libraries often separate)
        - Positions well for future MCP server, HTTP API, gRPC, etc.
        
      migration_path:
        step_1: Create workflow-manager-api crate
        step_2: Move ProcessBasedRuntime from workflow-manager to api crate
        step_3: Move discovery logic to api crate
        step_4: Update workflow-manager to depend on api crate
        step_5: Export clean public API from workflow-manager-api
        
      public_api_design:
        workflow-manager-api exports:
          - ProcessBasedRuntime (implements WorkflowRuntime)
          - McpWorkflowServer (MCP protocol server)
          - Future: HttpApiServer, GrpcApiServer
          
    alternative_recommendation:
      choice: option_1_extend_sdk
      use_when: |
        If the runtime implementation will remain simple and there's no plan
        for multiple runtime backends. Uses feature flags to keep SDK minimal
        by default.
        
      implementation:
        features:
          default: []
          runtime: [tokio/process, tokio/io-util]
        modules:
          - lib.rs (traits, types, always included)
          - runtime.rs (gated by "runtime" feature)
          
    anti_recommendation:
      avoid: option_3_split_sdk
      reason: |
        Premature optimization. The SDK is not large enough to warrant this
        level of splitting. Wait until there are concrete requirements for
        multiple runtime backends or the SDK grows significantly.

  runtime_agnostic_considerations:
    
    current_sdk_tokio_usage:
      location: workflow-manager-sdk/src/lib.rs
      usage:
        - tokio::sync::broadcast (for WorkflowRuntime trait)
        - async_trait macro
      assessment: Minimal but present - already tokio-specific
      
    making_truly_runtime_agnostic:
      would_require:
        - Abstract over channel types (generic over broadcast impl)
        - Remove tokio::sync dependency
        - Use only std/core types
      complexity: High
      value: Low (most Rust async ecosystem is tokio)
      
    recommendation: |
      Accept tokio dependency in SDK. It's minimal (only sync feature),
      ubiquitous in ecosystem, and trying to abstract over it adds
      significant complexity for little practical benefit.

  mcp_integration_considerations:
    
    current_location: workflow-manager/src/mcp_tools.rs
    purpose: Expose workflows via MCP protocol for external tools
    
    should_move_to_api_crate: YES
    reasoning: |
      MCP server is API surface, not TUI-specific. Moving to api crate
      allows both TUI and standalone MCP server to use same implementation.
      
    future_architecture:
      workflow-manager-api:
        - ProcessBasedRuntime
        - McpWorkflowServer (wraps runtime)
      workflow-manager:
        - TUI (uses runtime directly)
        - Optional: spawn McpWorkflowServer in background
      workflow-manager-mcp (future standalone binary):
        - Minimal binary that just runs McpWorkflowServer

  final_architecture_proposal:
    
    crate_structure:
      workflow-manager-sdk:
        purpose: Trait definitions, types, metadata schemas
        dependencies: [serde, uuid, tokio/sync, async-trait]
        exports:
          - WorkflowDefinition trait
          - WorkflowRuntime trait
          - WorkflowLog, WorkflowStatus, WorkflowMetadata
          - Field schemas and types
          - Logging macros
        users: Workflow implementers
        
      workflow-manager-macros:
        purpose: Derive macro for WorkflowDefinition
        dependencies: [syn, quote, proc-macro2]
        re-exported-by: workflow-manager-sdk
        users: Indirect (via SDK)
        
      workflow-manager-api:
        purpose: Runtime implementations and API servers
        dependencies: [workflow-manager-sdk, claude-agent-sdk, tokio/full]
        exports:
          - ProcessBasedRuntime
          - McpWorkflowServer
          - Discovery utilities
        users: API consumers (TUI, servers, integrations)
        
      workflow-manager:
        purpose: Terminal UI for workflow management
        dependencies: [workflow-manager-api, ratatui, crossterm]
        users: End users via CLI
        
      claude-agent-sdk:
        purpose: External AI integration
        status: External dependency
        
    dependency_graph: |
      workflow-manager-macros
              ↓ (re-export)
      workflow-manager-sdk ← claude-agent-sdk (re-export)
              ↓                      ↓
      workflow-manager-api ←←←←←←←←←←
              ↓
      workflow-manager (TUI binary)
      
      Workflow implementations depend on: workflow-manager-sdk only
      
    circular_dependency_verification:
      result: NO CIRCULAR DEPENDENCIES
      validation: All dependencies flow downward, no cycles exist

  implementation_notes:
    
    tokio_features:
      workflow-manager-sdk: [sync]
      workflow-manager-api: [full] or [process, io-util, sync, rt-multi-thread]
      workflow-manager: [full]
      
    version_management:
      strategy: Workspace-level version management
      sync_versions: true
      reasoning: All crates released together, avoid version drift
      
    re_exports:
      workflow-manager-sdk:
        - pub use workflow_manager_macros::WorkflowDefinition
        - pub use claude_agent_sdk (for convenience)
      workflow-manager-api:
        - pub use workflow_manager_sdk (for convenience)
        
    backward_compatibility:
      concern: Moving code from workflow-manager to workflow-manager-api
      impact: Internal change, no public API yet
      migration: Safe to do now before 1.0 release

  timeline_recommendation:
    
    phase_1_immediate:
      - Create workflow-manager-api crate
      - Move ProcessBasedRuntime to api crate
      - Move discovery logic to api crate
      - Update workflow-manager imports
      
    phase_2_mcp_integration:
      - Move MCP server to api crate
      - Expose as public API
      - Add tests for API surface
      
    phase_3_future:
      - Consider HTTP/REST API in api crate
      - Consider gRPC support
      - Consider WebSocket support for streaming logs

  risk_assessment:
    
    technical_risks:
      circular_dependencies: NONE (validated)
      version_drift: LOW (workspace management)
      breaking_changes: LOW (pre-1.0)
      
    organizational_risks:
      maintenance_burden: LOW (one additional crate)
      user_confusion: LOW (clear naming and docs)
      
    migration_risks:
      code_movement: LOW (internal only)
      breaking_external_users: NONE (no external users yet)
      
    overall_risk: LOW

  conclusion:
    recommendation: Create workflow-manager-api crate (Option 2)
    confidence: HIGH
    next_step: Begin implementation of workflow-manager-api crate
    estimated_effort: 2-4 hours for initial migration
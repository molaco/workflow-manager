analysis_timestamp: "2025-10-15"
research_objective: "Type System Analysis for API Exposure in workflow-manager-sdk"
codebase_location: "/home/molaco/Documents/japanese/workflow-manager"

# ============================================================================
# EXECUTIVE SUMMARY
# ============================================================================

executive_summary:
  status: "Types are 75% API-ready but need refinements for production MCP/HTTP APIs"
  
  current_strengths:
    - "All core types use serde Serialize/Deserialize"
    - "Tagged enum serialization for FieldType is well-structured"
    - "FullWorkflowMetadata already used for JSON-based discovery"
    - "WorkflowRuntime trait provides clean abstraction layer"
    - "Process-based execution model enables isolation"
  
  critical_gaps:
    - "No versioning (schema_version or sdk_version fields)"
    - "PhaseSelector and StateFile have no standard JSON Schema mapping"
    - "No JSON Schema generation for MCP tool definitions"
    - "Parameter validation is minimal (only checks required fields)"
    - "No backwards compatibility strategy for type evolution"
    - "Complex types use string formats that need parsing"

# ============================================================================
# TYPE SYSTEM ANALYSIS
# ============================================================================

type_system:
  
  core_metadata_types:
    
    WorkflowMetadata:
      location: "workflow-manager-sdk/src/lib.rs:16-20"
      current_definition: |
        #[derive(Debug, Clone, Serialize, Deserialize)]
        pub struct WorkflowMetadata {
            pub id: String,
            pub name: String,
            pub description: String,
        }
      
      serialization_status: "✓ Fully serializable"
      api_exposure_readiness: "Ready but needs versioning"
      
      recommended_changes:
        add_schema_version:
          rationale: "Track metadata format version for breaking changes"
          implementation: |
            pub schema_version: String,  // default "1.0.0"
          serde_config: '#[serde(default = "default_schema_version")]'
          migration_strategy: "Missing field defaults to 1.0.0 for old workflows"
        
        add_created_at:
          rationale: "Workflow creation timestamp for auditing"
          implementation: |
            #[serde(default)]
            pub created_at: Option<String>,  // ISO 8601
          
        add_tags:
          rationale: "Enable categorization and filtering"
          implementation: |
            #[serde(default)]
            pub tags: Vec<String>,
    
    FullWorkflowMetadata:
      location: "workflow-manager-sdk/src/lib.rs:23-28"
      current_definition: |
        #[derive(Debug, Clone, Serialize, Deserialize)]
        pub struct FullWorkflowMetadata {
            #[serde(flatten)]
            pub metadata: WorkflowMetadata,
            pub fields: Vec<FieldSchema>,
        }
      
      serialization_status: "✓ Fully serializable"
      current_use: "Binary discovery via --workflow-metadata flag"
      api_exposure_readiness: "Ready but needs SDK versioning"
      
      recommended_changes:
        add_sdk_version:
          rationale: "Track which SDK version generated workflow"
          implementation: |
            pub sdk_version: String,  // from workflow-manager-sdk Cargo.toml
          serde_config: '#[serde(default = "env!(\"CARGO_PKG_VERSION\").to_string")]'
          
        add_capabilities:
          rationale: "Declare workflow features (streaming, cancellation, resume)"
          implementation: |
            #[serde(default)]
            pub capabilities: WorkflowCapabilities,
          definition: |
            #[derive(Debug, Clone, Serialize, Deserialize, Default)]
            pub struct WorkflowCapabilities {
                pub supports_resume: bool,
                pub supports_cancellation: bool,
                pub supports_streaming_logs: bool,
                pub estimated_duration_seconds: Option<u64>,
            }
    
    FieldSchema:
      location: "workflow-manager-sdk/src/lib.rs:31-42"
      current_definition: |
        #[derive(Debug, Clone, Serialize, Deserialize)]
        pub struct FieldSchema {
            pub name: String,
            pub field_type: FieldType,
            pub label: String,
            pub description: String,
            pub cli_arg: String,
            pub required: bool,
            pub default: Option<String>,
            #[serde(skip_serializing_if = "Option::is_none")]
            pub required_for_phases: Option<Vec<usize>>,
        }
      
      serialization_status: "✓ Fully serializable"
      api_exposure_issues:
        - "cli_arg is TUI/CLI-specific, not relevant for programmatic API"
        - "default is String but should be typed (Value or field_type-specific)"
        - "No JSON Schema generation method"
        - "required_for_phases logic is complex for API validation"
      
      recommended_changes:
        add_json_schema_method:
          rationale: "Generate JSON Schema for MCP tool definitions"
          implementation: |
            impl FieldSchema {
                pub fn to_json_schema(&self) -> serde_json::Value {
                    let mut schema = self.field_type.to_json_schema_object();
                    schema["description"] = json!(self.description);
                    if let Some(default) = &self.default {
                        schema["default"] = json!(default);
                    }
                    schema
                }
            }
          location: "Add to workflow-manager-sdk/src/lib.rs"
          
        separate_cli_metadata:
          rationale: "CLI-specific fields pollute API types"
          option_1_new_struct:
            implementation: |
              #[serde(default, skip_serializing_if = "Option::is_none")]
              pub cli_metadata: Option<CliFieldMetadata>,
              
              #[derive(Debug, Clone, Serialize, Deserialize)]
              pub struct CliFieldMetadata {
                  pub arg: String,  // e.g., "--message"
                  pub short: Option<char>,  // e.g., Some('m')
              }
          
          option_2_feature_gate:
            implementation: |
              #[cfg_attr(feature = "cli", serde(default))]
              pub cli_arg: String,
            pros: "Conditionally include CLI fields"
            cons: "Complicates serialization compatibility"
        
        typed_default_value:
          rationale: "String default requires parsing; type-safe default is better"
          challenge: "Rust enums can't hold variant-specific default types"
          option_1_json_value:
            implementation: |
              pub default: Option<serde_json::Value>,
            pros: "Type-flexible, directly usable"
            cons: "Runtime type checking needed"
          
          option_2_string_with_parsing:
            implementation: "Keep as String, add parse_default() method"
            location: |
              impl FieldSchema {
                  pub fn parse_default(&self) -> Result<serde_json::Value> {
                      // Parse based on field_type
                  }
              }

  field_type_enum:
    location: "workflow-manager-sdk/src/lib.rs:45-70"
    serialization_format: '#[serde(tag = "type", rename_all = "snake_case")]'
    
    variants:
      
      Text:
        current_definition: "Text,"
        json_representation: '{"type": "text"}'
        json_schema_mapping:
          straightforward: true
          implementation: |
            {
              "type": "string",
              "description": "..."
            }
        api_readiness: "✓ Ready"
      
      Number:
        current_definition: |
          Number {
              #[serde(skip_serializing_if = "Option::is_none")]
              min: Option<i64>,
              #[serde(skip_serializing_if = "Option::is_none")]
              max: Option<i64>,
          }
        json_representation: '{"type": "number", "min": 1, "max": 100}'
        json_schema_mapping:
          straightforward: true
          implementation: |
            {
              "type": "integer",
              "minimum": min,
              "maximum": max,
              "description": "..."
            }
        api_readiness: "✓ Ready"
      
      FilePath:
        current_definition: |
          FilePath {
              #[serde(skip_serializing_if = "Option::is_none")]
              pattern: Option<String>,
          }
        json_representation: '{"type": "file_path", "pattern": "*.yaml"}'
        json_schema_mapping:
          complexity: "Medium - glob patterns need conversion"
          implementation: |
            {
              "type": "string",
              "format": "path",
              "pattern": "^.*\\.yaml$",  // converted from *.yaml glob
              "description": "..."
            }
        
        api_readiness: "Mostly ready, needs glob-to-regex converter"
        
        recommended_changes:
          add_glob_to_regex_converter:
            location: "workflow-manager-sdk/src/lib.rs"
            implementation: |
              impl FieldType {
                  fn glob_to_regex(glob: &str) -> String {
                      glob.replace("*", ".*")
                          .replace("?", ".")
                  }
              }
      
      Select:
        current_definition: |
          Select {
              options: Vec<String>,
          }
        json_representation: '{"type": "select", "options": ["a", "b"]}'
        json_schema_mapping:
          straightforward: true
          implementation: |
            {
              "type": "string",
              "enum": ["option1", "option2", "option3"],
              "description": "..."
            }
        api_readiness: "✓ Ready"
      
      PhaseSelector:
        current_definition: |
          PhaseSelector {
              total_phases: usize,
          }
        json_representation: '{"type": "phase_selector", "total_phases": 5}'
        
        current_value_format:
          format: "Comma-separated string"
          examples:
            - "\"0,1,2\""
            - "\"0,2,4\""
          tui_rendering: "src/app/file_browser.rs:15 - checkbox UI"
          cli_input: "--phases 0,1,2"
        
        json_schema_mapping:
          complexity: "HIGH - No standard JSON Schema equivalent"
          
          option_1_string_with_pattern:
            json_schema: |
              {
                "type": "string",
                "pattern": "^(\\d+,)*\\d+$",
                "description": "Comma-separated phase indices (0-{total_phases-1})",
                "examples": ["0,1,2", "0,2,4"]
              }
            pros:
              - "Matches current CLI/TUI format"
              - "No conversion needed"
              - "Simple validation"
            cons:
              - "String parsing required"
              - "No type safety for individual phases"
              - "Client must parse description for valid range"
          
          option_2_array_of_integers:
            json_schema: |
              {
                "type": "array",
                "items": {
                  "type": "integer",
                  "minimum": 0,
                  "maximum": 4  // total_phases - 1
                },
                "uniqueItems": true,
                "description": "Phase indices to execute"
              }
            pros:
              - "Type-safe, validates each phase"
              - "Clear semantics"
              - "Standard JSON Schema pattern"
            cons:
              - "Requires conversion: [0,1,2] → \"0,1,2\" for CLI"
              - "API and CLI formats diverge"
            
            implementation_notes:
              runtime_conversion: |
                impl WorkflowRuntime {
                    fn normalize_phase_selector(value: serde_json::Value) -> Result<String> {
                        match value {
                            Value::String(s) => Ok(s),  // "0,1,2"
                            Value::Array(arr) => {
                                let phases: Vec<String> = arr.iter()
                                    .filter_map(|v| v.as_u64())
                                    .map(|n| n.to_string())
                                    .collect();
                                Ok(phases.join(","))
                            }
                            _ => Err("Invalid phase selector format")
                        }
                    }
                }
          
          option_3_hybrid_with_x_extension:
            json_schema: |
              {
                "oneOf": [
                  {"type": "string", "pattern": "^(\\d+,)*\\d+$"},
                  {"type": "array", "items": {"type": "integer"}}
                ],
                "x-phase-selector": {
                  "total_phases": 5,
                  "format": "hybrid"
                },
                "description": "Phase indices (string or array)"
              }
            pros:
              - "Supports both API and CLI formats"
              - "Preserves metadata via x- extension"
            cons:
              - "Non-standard x- property"
              - "More complex validation"
              - "Not all JSON Schema validators support oneOf well"
        
        recommendation:
          preferred: "option_2_array_of_integers"
          rationale: "Type safety and standard schema outweigh conversion cost"
          migration_path:
            api: "Accept array of integers"
            cli: "Keep string format, convert in argument parser"
            validation: "Normalize both formats to string internally"
        
        api_readiness: "Needs redesign for API exposure"
      
      StateFile:
        current_definition: |
          StateFile {
              pattern: String,  // e.g., "codebase_analysis_*.yaml"
              #[serde(skip_serializing_if = "Option::is_none")]
              phase: Option<usize>,  // which phase generates this file
          }
        json_representation: '{"type": "state_file", "pattern": "*.yaml", "phase": 0}'
        
        current_use:
          purpose: "Reference intermediate files from previous phases"
          tui_integration: "src/app/file_browser.rs:15 - file picker with pattern filter"
          workflow_example: "research_agent: codebase_analysis_*.yaml from phase 0"
        
        json_schema_mapping:
          complexity: "HIGH - References files that may not exist yet"
          
          option_1_simple_string:
            json_schema: |
              {
                "type": "string",
                "format": "path",
                "description": "Path to {pattern} file from phase {phase}"
              }
            pros:
              - "Simple, straightforward"
              - "Standard JSON Schema"
            cons:
              - "Loses pattern and phase metadata"
              - "No programmatic file discovery"
              - "Client can't validate against pattern"
          
          option_2_with_x_metadata:
            json_schema: |
              {
                "type": "string",
                "format": "path",
                "x-state-file": {
                  "pattern": "codebase_analysis_*.yaml",
                  "source_phase": 0,
                  "glob_pattern": true
                },
                "description": "Analysis file from phase 0 matching pattern"
              }
            pros:
              - "Preserves all metadata"
              - "Clients can implement file discovery"
              - "Pattern available for validation"
            cons:
              - "Non-standard x- extension"
              - "Requires custom client logic"
          
          option_3_companion_discovery_tool:
            approach: "Separate MCP tool for file discovery"
            tools:
              list_state_files:
                input:
                  workflow_id: "string"
                  pattern: "string"
                  phase: "integer (optional)"
                output: "Array of {path, created_at, size, workflow_id, phase}"
            json_schema: |
              {
                "type": "string",
                "format": "path",
                "description": "Path to state file (use list_state_files tool to discover)"
              }
            pros:
              - "Clean separation of concerns"
              - "Standard JSON Schema for parameter"
              - "Discovery logic centralized in tool"
            cons:
              - "Two-step process for users"
              - "Additional MCP tool complexity"
        
        recommendation:
          preferred: "option_3_companion_discovery_tool"
          rationale: "Cleaner API design, standard schema, discoverable workflow"
          implementation:
            parameter_schema: "Simple string path"
            discovery_tool: "list_state_files in MCP server"
            validation: "Check file exists and matches expected pattern"
        
        api_readiness: "Needs companion discovery tool"

# ============================================================================
# JSON SCHEMA GENERATION
# ============================================================================

json_schema_generation:
  
  current_state:
    status: "No automated generation exists"
    current_approach: "Manual schema in mcp_tools.rs"
    example_location: "src/mcp_tools.rs:46-52"
    current_implementation: |
      json!({
          "type": "object",
          "properties": {
              "workflow_id": {"type": "string"},
              "parameters": {"type": "object"}
          },
          "required": ["workflow_id", "parameters"]
      })
  
  recommended_approaches:
    
    approach_1_schemars_crate:
      crate: "schemars = \"0.8\""
      implementation:
        derive_macro: |
          #[derive(Serialize, Deserialize, JsonSchema)]
          pub struct FieldSchema { ... }
        
        usage: |
          use schemars::schema_for;
          let schema = schema_for!(FieldSchema);
      
      pros:
        - "Automatic schema generation"
        - "Well-maintained, widely used"
        - "Stays in sync with type definitions"
      
      cons:
        - "Additional dependency"
        - "May need custom implementations for PhaseSelector/StateFile"
        - "Generated schema might be too generic"
      
      custom_implementation_needed:
        location: "workflow-manager-sdk/src/lib.rs"
        example: |
          impl schemars::JsonSchema for FieldType {
              fn schema_name() -> String {
                  "FieldType".to_string()
              }
              
              fn json_schema(gen: &mut SchemaGenerator) -> Schema {
                  match self {
                      FieldType::PhaseSelector { total_phases } => {
                          // Custom schema for phase selector
                      }
                      _ => { /* default */ }
                  }
              }
          }
    
    approach_2_manual_implementation:
      implementation:
        location: "workflow-manager-sdk/src/lib.rs"
        trait_method: |
          impl FieldType {
              pub fn to_json_schema_object(&self) -> serde_json::Value {
                  match self {
                      FieldType::Text => json!({"type": "string"}),
                      
                      FieldType::Number { min, max } => {
                          let mut schema = json!({"type": "integer"});
                          if let Some(min_val) = min {
                              schema["minimum"] = json!(min_val);
                          }
                          if let Some(max_val) = max {
                              schema["maximum"] = json!(max_val);
                          }
                          schema
                      }
                      
                      FieldType::FilePath { pattern } => {
                          let mut schema = json!({
                              "type": "string",
                              "format": "path"
                          });
                          if let Some(glob) = pattern {
                              schema["pattern"] = json!(glob_to_regex(glob));
                          }
                          schema
                      }
                      
                      FieldType::Select { options } => json!({
                          "type": "string",
                          "enum": options
                      }),
                      
                      FieldType::PhaseSelector { total_phases } => json!({
                          "type": "array",
                          "items": {
                              "type": "integer",
                              "minimum": 0,
                              "maximum": total_phases - 1
                          },
                          "uniqueItems": true
                      }),
                      
                      FieldType::StateFile { pattern, phase } => {
                          let mut schema = json!({
                              "type": "string",
                              "format": "path"
                          });
                          if let Some(phase_num) = phase {
                              schema["description"] = json!(
                                  format!("State file from phase {} matching {}", phase_num, pattern)
                              );
                          }
                          schema
                      }
                  }
              }
          }
        
        full_workflow_schema: |
          impl FullWorkflowMetadata {
              pub fn to_mcp_tool_schema(&self) -> serde_json::Value {
                  let mut properties = serde_json::Map::new();
                  let mut required = Vec::new();
                  
                  for field in &self.fields {
                      properties.insert(
                          field.name.clone(),
                          field.to_json_schema()
                      );
                      
                      if field.required {
                          required.push(field.name.clone());
                      }
                  }
                  
                  json!({
                      "type": "object",
                      "properties": properties,
                      "required": required
                  })
              }
          }
      
      pros:
        - "Full control over schema output"
        - "No external dependencies"
        - "Can optimize for MCP tool definitions"
      
      cons:
        - "Manual maintenance required"
        - "Potential for drift from serialization"
        - "More code to write and test"
    
    approach_3_hybrid:
      strategy: "Use schemars for standard types, manual for special cases"
      implementation:
        base: "Derive JsonSchema on FieldSchema"
        overrides: "Manual impl for FieldType with custom logic"
      
      pros:
        - "Best of both worlds"
        - "Reduced boilerplate for common types"
        - "Precision for complex types"
      
      recommended: true
      
  recommendation:
    preferred: "approach_2_manual_implementation"
    rationale:
      - "No additional dependencies"
      - "Full control for PhaseSelector and StateFile"
      - "Simpler to maintain alongside serde serialization"
      - "Direct integration with MCP tool creation"
    
    implementation_plan:
      phase_1: "Add to_json_schema_object() to FieldType"
      phase_2: "Add to_json_schema() to FieldSchema"
      phase_3: "Add to_mcp_tool_schema() to FullWorkflowMetadata"
      phase_4: "Update mcp_tools.rs to use generated schemas"

# ============================================================================
# PARAMETER VALIDATION
# ============================================================================

parameter_validation:
  
  current_implementation:
    location: "src/runtime.rs:105-122"
    current_logic: |
      fn validate_workflow_inputs(&self, id: &str, params: HashMap<String, String>) -> WorkflowResult<()> {
          // Check required fields
          for field in &workflow.fields {
              if field.required && !params.contains_key(&field.name) {
                  return Err(format!("Required field '{}' missing", field.name).into());
              }
          }
          Ok(())
      }
    
    limitations:
      - "Only checks field presence"
      - "No type validation (all params are String)"
      - "No constraint validation (min/max, pattern, enum)"
      - "No required_for_phases logic"
      - "No cross-field validation"
  
  recommended_validation_layers:
    
    layer_1_presence_validation:
      status: "✓ Currently implemented"
      checks:
        - "Required field present"
        - "Unknown field detection (optional)"
    
    layer_2_type_validation:
      status: "✗ Not implemented"
      implementation:
        location: "workflow-manager-sdk/src/validation.rs (new module)"
        function: |
          pub fn validate_field_type(
              field: &FieldSchema,
              value: &str
          ) -> Result<(), ValidationError> {
              match &field.field_type {
                  FieldType::Text => Ok(()),
                  
                  FieldType::Number { min, max } => {
                      let num = value.parse::<i64>()
                          .map_err(|_| ValidationError::InvalidNumber)?;
                      
                      if let Some(min_val) = min {
                          if num < *min_val {
                              return Err(ValidationError::BelowMinimum);
                          }
                      }
                      if let Some(max_val) = max {
                          if num > *max_val {
                              return Err(ValidationError::AboveMaximum);
                          }
                      }
                      Ok(())
                  }
                  
                  FieldType::FilePath { pattern } => {
                      let path = PathBuf::from(value);
                      if !path.exists() {
                          return Err(ValidationError::FileNotFound);
                      }
                      if let Some(glob_pattern) = pattern {
                          // Validate against glob pattern
                      }
                      Ok(())
                  }
                  
                  FieldType::Select { options } => {
                      if !options.contains(&value.to_string()) {
                          return Err(ValidationError::InvalidOption);
                      }
                      Ok(())
                  }
                  
                  FieldType::PhaseSelector { total_phases } => {
                      let phases: Vec<usize> = value.split(',')
                          .map(|s| s.trim().parse())
                          .collect::<Result<_, _>>()
                          .map_err(|_| ValidationError::InvalidPhaseFormat)?;
                      
                      for phase in &phases {
                          if *phase >= *total_phases {
                              return Err(ValidationError::PhaseOutOfRange);
                          }
                      }
                      Ok(())
                  }
                  
                  FieldType::StateFile { pattern, phase } => {
                      let path = PathBuf::from(value);
                      if !path.exists() {
                          return Err(ValidationError::StateFileNotFound);
                      }
                      // Could validate against pattern
                      Ok(())
                  }
              }
          }
    
    layer_3_phase_specific_validation:
      status: "✗ Not implemented"
      challenge: "required_for_phases logic"
      implementation: |
        pub fn validate_phase_requirements(
            field: &FieldSchema,
            value: Option<&str>,
            executing_phases: &[usize]
        ) -> Result<(), ValidationError> {
            if let Some(required_phases) = &field.required_for_phases {
                let needs_field = required_phases.iter()
                    .any(|p| executing_phases.contains(p));
                
                if needs_field && value.is_none() {
                    return Err(ValidationError::RequiredForPhase);
                }
            }
            Ok(())
        }
      
      challenge_details:
        problem: "Executing phases unknown until execution time"
        solution_1: "Validate during execute_workflow() with phase list"
        solution_2: "Add validate_for_phases() separate method"
    
    layer_4_cross_field_validation:
      status: "✗ Not implemented"
      future_consideration: "Add validation rules between fields"
      example_use_case:
        scenario: "If field 'mode' is 'parallel', require 'batch_size'"
        implementation: "Custom validation trait or declarative rules"
  
  validation_error_types:
    definition: |
      #[derive(Debug, thiserror::Error)]
      pub enum ValidationError {
          #[error("Field '{0}' is required")]
          MissingRequired(String),
          
          #[error("Invalid number format")]
          InvalidNumber,
          
          #[error("Value {0} is below minimum {1}")]
          BelowMinimum(i64, i64),
          
          #[error("Value {0} is above maximum {1}")]
          AboveMaximum(i64, i64),
          
          #[error("File not found: {0}")]
          FileNotFound(PathBuf),
          
          #[error("Invalid option: {0}. Valid options: {1:?}")]
          InvalidOption(String, Vec<String>),
          
          #[error("Invalid phase selector format")]
          InvalidPhaseFormat,
          
          #[error("Phase {0} out of range (0-{1})")]
          PhaseOutOfRange(usize, usize),
          
          #[error("State file not found: {0}")]
          StateFileNotFound(PathBuf),
          
          #[error("Field '{0}' is required for phases {1:?}")]
          RequiredForPhase(String, Vec<usize>),
      }
  
  api_integration:
    mcp_validation:
      location: "src/mcp_tools.rs execute_workflow_tool"
      before_execution: |
        // Validate all parameters before spawning process
        runtime.validate_workflow_inputs(workflow_id, params_map)?;
      
      error_handling: |
        match runtime.execute_workflow(workflow_id, params_map).await {
            Ok(handle) => Ok(ToolResult::text(...)),
            Err(ValidationError::...) => Ok(ToolResult::error(...)),
        }
    
    http_api_validation:
      status_code: "400 Bad Request for validation errors"
      response_format: |
        {
          "error": "Validation failed",
          "details": [
            {"field": "batch_size", "error": "Value 100 is above maximum 10"}
          ]
        }

# ============================================================================
# VERSIONING & BACKWARDS COMPATIBILITY
# ============================================================================

versioning_and_compatibility:
  
  current_state:
    schema_version: "None - no version tracking"
    sdk_version: "None - not captured in metadata"
    compatibility_strategy: "None - breaks on parse failure"
  
  recommended_versioning_scheme:
    
    schema_versioning:
      add_to: "WorkflowMetadata"
      field: |
        #[serde(default = "default_schema_version")]
        pub schema_version: String,
      
      default_impl: |
        fn default_schema_version() -> String {
            "1.0.0".to_string()
        }
      
      usage:
        discovery: "Check schema_version when parsing metadata"
        validation: "Reject unsupported versions or apply compatibility shims"
        mcp_exposure: "Include in list_workflows response"
      
      version_format: "SemVer (major.minor.patch)"
      version_semantics:
        major: "Breaking changes to FieldType or WorkflowMetadata structure"
        minor: "New FieldType variants or optional fields"
        patch: "Bug fixes, no schema changes"
      
      current_version: "1.0.0"
    
    sdk_versioning:
      add_to: "FullWorkflowMetadata"
      field: |
        #[serde(default = "default_sdk_version")]
        pub sdk_version: String,
      
      default_impl: |
        fn default_sdk_version() -> String {
            env!("CARGO_PKG_VERSION").to_string()
        }
      
      usage:
        tracking: "Know which SDK version generated workflow"
        debugging: "Correlate workflow issues with SDK version"
        deprecation: "Warn users about old SDK versions"
      
      captured_at: "Workflow compilation time via env!(\"CARGO_PKG_VERSION\")"
  
  backwards_compatibility_strategy:
    
    reading_old_workflows:
      approach: "Graceful degradation with defaults"
      serde_configuration: |
        #[serde(default)]  // Use Default::default() if missing
        #[serde(default = "default_fn")]  // Use custom default
      
      example: |
        // Old workflow without schema_version
        {
          "id": "old_workflow",
          "name": "...",
          // schema_version missing
        }
        
        // Deserialized as:
        WorkflowMetadata {
            schema_version: "1.0.0",  // default
            ...
        }
    
    writing_new_workflows:
      approach: "Always include all fields"
      configuration: |
        #[serde(skip_serializing_if = "Option::is_none")]  // Only for true optionals
      
      example: |
        // New workflow always has:
        {
          "schema_version": "1.0.0",
          "sdk_version": "0.1.0",
          ...
        }
    
    handling_unknown_variants:
      challenge: "New FieldType variants in old SDK"
      
      option_1_serde_other:
        implementation: |
          #[derive(Serialize, Deserialize)]
          #[serde(tag = "type", rename_all = "snake_case")]
          pub enum FieldType {
              Text,
              Number { min: Option<i64>, max: Option<i64> },
              // ...existing variants...
              
              #[serde(other)]
              Unknown,
          }
        pros: "Doesn't fail on unknown variants"
        cons: "Loses information, can't render field properly"
      
      option_2_untagged_fallback:
        implementation: |
          #[derive(Serialize, Deserialize)]
          #[serde(untagged)]
          pub enum FieldType {
              Text,
              Number { ... },
              // ...
              UnknownVariant(serde_json::Value),
          }
        pros: "Preserves raw JSON for future processing"
        cons: "Loses type tag structure"
      
      option_3_version_gating:
        approach: "Check schema_version before parsing"
        implementation: |
          if metadata.schema_version > SUPPORTED_VERSION {
              return Err("Unsupported workflow version");
          }
        pros: "Explicit version compatibility check"
        cons: "Fails loudly instead of degrading gracefully"
      
      recommended: "option_1_serde_other for runtime compatibility"
    
    deprecation_strategy:
      announce_deprecation:
        field: |
          #[serde(default)]
          #[deprecated(since = "0.2.0", note = "Use new_field instead")]
          pub old_field: Option<String>,
        
        documentation: "Mark as deprecated in schema_version release notes"
      
      removal_timeline:
        deprecate: "schema_version N.0.0"
        remove: "schema_version (N+1).0.0"
        support_duration: "At least one major version"
  
  migration_path_examples:
    
    example_1_add_optional_field:
      change: "Add tags: Vec<String> to WorkflowMetadata"
      version_bump: "1.0.0 → 1.1.0 (minor)"
      
      implementation: |
        #[serde(default)]
        pub tags: Vec<String>,
      
      compatibility:
        old_workflows: "Deserialize with tags: vec![]"
        new_workflows: "Include tags in JSON"
        runtime: "No breaking changes"
    
    example_2_add_fieldtype_variant:
      change: "Add FieldType::Date { format: String }"
      version_bump: "1.0.0 → 1.1.0 (minor)"
      
      implementation: |
        pub enum FieldType {
            // ...existing...
            Date {
                format: String,  // e.g., "YYYY-MM-DD"
            },
        }
      
      compatibility:
        old_sdk: "Deserializes as FieldType::Unknown"
        new_sdk: "Can create and validate Date fields"
        runtime: "Old TUI shows as text input"
    
    example_3_breaking_change:
      change: "Change required: bool to required_mode: RequiredMode enum"
      version_bump: "1.0.0 → 2.0.0 (major)"
      
      implementation: |
        #[serde(rename = "required")]
        pub required_mode: RequiredMode,
        
        pub enum RequiredMode {
            Always,
            Never,
            ForPhases(Vec<usize>),
        }
      
      migration_guide: "Document conversion from bool to RequiredMode"
      support: "Maintain 1.x branch for 6 months"

# ============================================================================
# COMPLEX TYPE REPRESENTATION
# ============================================================================

complex_type_representation:
  
  PhaseSelector:
    
    current_representation:
      internal_format: "Comma-separated string"
      example: "\"0,1,2\""
      usage:
        tui: "Rendered as-is or <empty>"
        cli: "--phases 0,1,2"
      parsing_location: "No centralized parsing"
    
    recommended_api_representation:
      
      external_api_format:
        type: "Array of integers"
        json_example: "[0, 1, 2]"
        json_schema: |
          {
            "type": "array",
            "items": {"type": "integer", "minimum": 0, "maximum": 4},
            "uniqueItems": true
          }
      
      internal_storage_format:
        keep_as: "String (for CLI compatibility)"
        example: "\"0,1,2\""
      
      conversion_layer:
        location: "workflow-manager-sdk/src/types.rs (new module)"
        implementation: |
          pub fn normalize_phase_selector(value: &serde_json::Value) -> Result<String> {
              match value {
                  Value::String(s) => {
                      // Validate format
                      validate_phase_string(s)?;
                      Ok(s.clone())
                  }
                  Value::Array(arr) => {
                      let phases: Vec<usize> = arr.iter()
                          .filter_map(|v| v.as_u64())
                          .map(|n| n as usize)
                          .collect();
                      Ok(phases.iter().map(|p| p.to_string()).collect::<Vec<_>>().join(","))
                  }
                  _ => Err("Invalid phase selector format")
              }
          }
          
          fn validate_phase_string(s: &str) -> Result<()> {
              for part in s.split(',') {
                  part.trim().parse::<usize>()
                      .map_err(|_| "Invalid phase number")?;
              }
              Ok(())
          }
      
      usage_in_runtime:
        location: "src/runtime.rs execute_workflow"
        code: |
          // MCP receives: {"phases": [0, 1, 2]}
          let phases_value = params.get("phases");
          let phases_string = normalize_phase_selector(phases_value)?;
          // Pass "0,1,2" to CLI
    
    impact_on_validation:
      api_validation: "Validate array elements against 0..total_phases"
      cli_validation: "Parse string and validate each phase"
      unified_validator: |
        pub fn validate_phases(
            phases: &str,
            total_phases: usize
        ) -> Result<Vec<usize>> {
            let parsed: Vec<usize> = phases.split(',')
                .map(|s| s.trim().parse())
                .collect::<Result<_, _>>()?;
            
            for phase in &parsed {
                if *phase >= total_phases {
                    return Err(ValidationError::PhaseOutOfRange(*phase, total_phases));
                }
            }
            
            Ok(parsed)
        }
  
  StateFile:
    
    current_representation:
      internal_format: "String path"
      metadata_fields:
        - "pattern: String (glob like 'codebase_*.yaml')"
        - "phase: Option<usize> (source phase)"
      
      tui_integration:
        file_browser: "src/app/file_browser.rs - opens file picker"
        pattern_filtering: "Filter files matching glob pattern"
      
      cli_usage: "--analysis-file codebase_analysis_20251015.yaml"
    
    recommended_api_representation:
      
      parameter_format:
        type: "String path"
        json_example: '"/path/to/codebase_analysis_20251015_120000.yaml"'
        json_schema: |
          {
            "type": "string",
            "format": "path",
            "description": "Path to state file from phase {phase} matching {pattern}"
          }
      
      companion_discovery_tool:
        tool_name: "list_state_files"
        purpose: "Help API users discover available state files"
        
        mcp_tool_definition:
          description: "List state files matching pattern for workflow resumption"
          input_schema: |
            {
              "type": "object",
              "properties": {
                "workflow_id": {"type": "string"},
                "pattern": {"type": "string"},
                "phase": {"type": "integer"}
              },
              "required": ["workflow_id", "pattern"]
            }
          
          output_format: |
            [
              {
                "path": "/path/to/file1.yaml",
                "phase": 0,
                "timestamp": "2025-10-15T12:00:00Z",
                "size_bytes": 4096,
                "workflow_id": "research_agent"
              }
            ]
        
        implementation_location: "src/mcp_tools.rs"
        implementation: |
          fn list_state_files_tool() -> SdkMcpTool {
              SdkMcpTool::new(
                  "list_state_files",
                  "List state files for workflow resumption",
                  json!({...}),
                  move |params| {
                      let pattern = params.get("pattern").unwrap().as_str().unwrap();
                      let workflow_id = params.get("workflow_id").unwrap().as_str().unwrap();
                      
                      // Search for files matching pattern
                      let files = glob::glob(pattern)?
                          .filter_map(|p| p.ok())
                          .map(|path| StateFileInfo {
                              path: path.display().to_string(),
                              // extract phase from filename or metadata
                          })
                          .collect::<Vec<_>>();
                      
                      Ok(ToolResult::text(serde_json::to_string(&files)?))
                  }
              )
          }
      
      validation_strategy:
        check_existence: "Validate file exists before execution"
        check_pattern: "Optionally validate filename matches expected pattern"
        implementation: |
          pub fn validate_state_file(
              path: &str,
              pattern: &str
          ) -> Result<()> {
              let path_buf = PathBuf::from(path);
              
              if !path_buf.exists() {
                  return Err(ValidationError::StateFileNotFound(path_buf));
              }
              
              // Optional: validate against glob pattern
              if !matches_pattern(&path_buf, pattern) {
                  return Err(ValidationError::PatternMismatch);
              }
              
              Ok(())
          }
    
    workflow_resumption_pattern:
      use_case: "Execute phases 1,2 using output from phase 0"
      
      api_call_example: |
        execute_workflow({
          "workflow_id": "research_agent",
          "parameters": {
            "phases": [1, 2],  // or "1,2" if string format
            "analysis_file": "/path/to/codebase_analysis_20251015.yaml",
            "objective": "Document the API layer"
          }
        })
      
      workflow_handling:
        phase_0_skipped: "Not in phases list"
        phase_1_starts: "Reads analysis_file instead of generating it"
        validation: "Ensure analysis_file exists and is valid YAML"

# ============================================================================
# MCP TOOL DEFINITIONS
# ============================================================================

mcp_tool_definitions:
  
  current_implementation:
    location: "src/mcp_tools.rs"
    tools:
      - "list_workflows: List all discovered workflows"
      - "execute_workflow: Execute with parameters"
      - "get_workflow_logs: Stream logs from execution"
      - "get_workflow_status: Check execution status"
      - "cancel_workflow: Cancel running workflow"
    
    schema_approach: "Hardcoded json!() schemas"
    
    example_current_tool: |
      SdkMcpTool::new(
          "execute_workflow",
          "Execute a workflow with provided parameters",
          json!({
              "type": "object",
              "properties": {
                  "workflow_id": {"type": "string"},
                  "parameters": {"type": "object"}
              },
              "required": ["workflow_id", "parameters"]
          }),
          move |params| { ... }
      )
  
  recommended_improvements:
    
    dynamic_schema_generation:
      approach: "Generate tool schemas from FullWorkflowMetadata"
      
      implementation:
        location: "src/mcp_tools.rs"
        helper_function: |
          fn create_workflow_tool(
              workflow: &FullWorkflowMetadata
          ) -> SdkMcpTool {
              let tool_name = format!("execute_{}", workflow.metadata.id);
              let description = format!("Execute {} workflow", workflow.metadata.name);
              let schema = workflow.to_mcp_tool_schema();
              
              SdkMcpTool::new(&tool_name, &description, schema, move |params| {
                  // Execute workflow
              })
          }
        
        registration: |
          pub fn create_workflow_mcp_server(runtime: Arc<dyn WorkflowRuntime>) -> SdkMcpServer {
              let mut server = SdkMcpServer::new("workflow_manager").version("1.0.0");
              
              // Core management tools
              server = server.tool(list_workflows_tool(runtime.clone()));
              server = server.tool(execute_workflow_tool(runtime.clone()));
              
              // Optional: Per-workflow tools
              let workflows = runtime.list_workflows().unwrap();
              for workflow in workflows {
                  server = server.tool(create_workflow_tool(&workflow));
              }
              
              server
          }
      
      benefits:
        - "One tool per workflow with specific schema"
        - "Better IDE autocomplete and validation"
        - "Self-documenting API"
      
      drawbacks:
        - "Many tools registered (one per workflow)"
        - "Discovery latency (must scan workflows first)"
    
    enhanced_tool_suite:
      
      new_tools:
        
        get_workflow_schema:
          name: "get_workflow_schema"
          purpose: "Get full JSON Schema for a specific workflow"
          input: |
            {
              "workflow_id": "string"
            }
          output: |
            {
              "workflow_id": "research_agent",
              "schema_version": "1.0.0",
              "input_schema": {
                "type": "object",
                "properties": {
                  "objective": {"type": "string", ...},
                  "phases": {"type": "array", ...},
                  ...
                },
                "required": ["objective"]
              }
            }
          implementation: |
            fn get_workflow_schema_tool(runtime: Arc<dyn WorkflowRuntime>) -> SdkMcpTool {
                SdkMcpTool::new(
                    "get_workflow_schema",
                    "Get JSON Schema for workflow inputs",
                    json!({"type": "object", "properties": {"workflow_id": {"type": "string"}}}),
                    move |params| {
                        let workflow_id = params.get("workflow_id").unwrap().as_str().unwrap();
                        let metadata = runtime.get_workflow_metadata(workflow_id)?;
                        let schema = metadata.to_mcp_tool_schema();
                        Ok(ToolResult::text(serde_json::to_string_pretty(&schema)?))
                    }
                )
            }
        
        list_state_files:
          name: "list_state_files"
          purpose: "Discover state files for workflow resumption"
          details: "See complex_type_representation.StateFile above"
        
        validate_workflow_inputs:
          name: "validate_workflow_inputs"
          purpose: "Validate parameters before execution"
          input: |
            {
              "workflow_id": "string",
              "parameters": "object"
            }
          output: |
            {
              "valid": true,
              "errors": []
            }
            // or
            {
              "valid": false,
              "errors": [
                {"field": "batch_size", "message": "Above maximum 10"}
              ]
            }
          implementation: |
            fn validate_workflow_inputs_tool(runtime: Arc<dyn WorkflowRuntime>) -> SdkMcpTool {
                SdkMcpTool::new(
                    "validate_workflow_inputs",
                    "Validate workflow parameters without execution",
                    json!({...}),
                    move |params| {
                        match runtime.validate_workflow_inputs(workflow_id, params_map) {
                            Ok(_) => Ok(ToolResult::text(json!({"valid": true, "errors": []}).to_string())),
                            Err(e) => Ok(ToolResult::text(json!({"valid": false, "errors": [e.to_string()]}).to_string()))
                        }
                    }
                )
            }
      
      updated_tool_list:
        - "list_workflows"
        - "get_workflow_schema (NEW)"
        - "validate_workflow_inputs (NEW)"
        - "execute_workflow"
        - "list_state_files (NEW)"
        - "get_workflow_logs"
        - "get_workflow_status"
        - "cancel_workflow"

# ============================================================================
# PROGRAMMATIC API CALLS
# ============================================================================

programmatic_api:
  
  rust_api:
    purpose: "Direct Rust crate usage (no MCP, no CLI)"
    target_users:
      - "Rust applications embedding workflow-manager"
      - "Custom workflow runners"
      - "Testing and automation tools"
    
    current_state:
      workflow_runtime_trait: "✓ Defined in workflow-manager-sdk/src/lib.rs:398-431"
      implementation: "✓ ProcessBasedRuntime in workflow-manager/src/runtime.rs"
      
      trait_definition: |
        #[async_trait]
        pub trait WorkflowRuntime: Send + Sync {
            fn list_workflows(&self) -> WorkflowResult<Vec<FullWorkflowMetadata>>;
            fn get_workflow_metadata(&self, id: &str) -> WorkflowResult<FullWorkflowMetadata>;
            fn validate_workflow_inputs(&self, id: &str, params: HashMap<String, String>) -> WorkflowResult<()>;
            async fn execute_workflow(&self, id: &str, params: HashMap<String, String>) -> WorkflowResult<WorkflowHandle>;
            async fn subscribe_logs(&self, handle_id: &Uuid) -> WorkflowResult<tokio::sync::broadcast::Receiver<WorkflowLog>>;
            async fn get_status(&self, handle_id: &Uuid) -> WorkflowResult<WorkflowStatus>;
            async fn cancel_workflow(&self, handle_id: &Uuid) -> WorkflowResult<()>;
        }
    
    usage_example: |
      use workflow_manager::runtime::ProcessBasedRuntime;
      use workflow_manager_sdk::WorkflowRuntime;
      
      #[tokio::main]
      async fn main() {
          // Create runtime
          let runtime = ProcessBasedRuntime::new().unwrap();
          
          // List workflows
          let workflows = runtime.list_workflows().unwrap();
          println!("Found {} workflows", workflows.len());
          
          // Execute workflow
          let mut params = HashMap::new();
          params.insert("objective".to_string(), "Analyze auth system".to_string());
          params.insert("phases".to_string(), "0,1,2".to_string());
          
          let handle = runtime.execute_workflow("research_agent", params).await.unwrap();
          println!("Execution started: {}", handle.id());
          
          // Subscribe to logs
          let mut logs_rx = runtime.subscribe_logs(handle.id()).await.unwrap();
          while let Ok(log) = logs_rx.recv().await {
              println!("Log: {:?}", log);
          }
          
          // Check status
          let status = runtime.get_status(handle.id()).await.unwrap();
          println!("Status: {:?}", status);
      }
    
    parameter_handling:
      current_format: "HashMap<String, String>"
      limitation: "All values are strings, requires parsing"
      
      recommended_enhancement:
        change_signature: "HashMap<String, serde_json::Value>"
        benefits:
          - "Type-safe parameter passing"
          - "No string parsing needed"
          - "Direct JSON compatibility"
        
        updated_trait: |
          async fn execute_workflow(
              &self,
              id: &str,
              params: HashMap<String, serde_json::Value>
          ) -> WorkflowResult<WorkflowHandle>;
        
        conversion_to_cli: |
          // Inside ProcessBasedRuntime::execute_workflow
          fn value_to_cli_arg(value: &serde_json::Value) -> String {
              match value {
                  Value::String(s) => s.clone(),
                  Value::Number(n) => n.to_string(),
                  Value::Bool(b) => b.to_string(),
                  Value::Array(arr) => {
                      // PhaseSelector: [0,1,2] -> "0,1,2"
                      arr.iter()
                          .filter_map(|v| v.as_u64())
                          .map(|n| n.to_string())
                          .collect::<Vec<_>>()
                          .join(",")
                  }
                  _ => serde_json::to_string(value).unwrap()
              }
          }
  
  http_api:
    status: "Not implemented"
    future_consideration: "Expose WorkflowRuntime over HTTP/REST or WebSocket"
    
    potential_endpoints:
      - "GET /workflows - List workflows"
      - "GET /workflows/{id}/schema - Get workflow schema"
      - "POST /workflows/{id}/execute - Execute workflow"
      - "GET /executions/{handle_id}/status - Get status"
      - "GET /executions/{handle_id}/logs - Stream logs (WebSocket)"
      - "DELETE /executions/{handle_id} - Cancel execution"
    
    implementation_suggestion:
      framework: "axum or actix-web"
      location: "workflow-manager/src/http_api.rs"
      integration: "Wrap WorkflowRuntime trait"

# ============================================================================
# RECOMMENDED CHANGES
# ============================================================================

recommended_changes:
  
  priority_1_critical:
    
    add_versioning:
      impact: "HIGH - Enables future compatibility"
      effort: "LOW - 1-2 hours"
      changes:
        - "Add schema_version: String to WorkflowMetadata"
        - "Add sdk_version: String to FullWorkflowMetadata"
        - "Update macro to inject versions"
        - "Update discovery to check versions"
      files_affected:
        - "workflow-manager-sdk/src/lib.rs"
        - "workflow-manager-macros/src/lib.rs"
    
    implement_json_schema_generation:
      impact: "HIGH - Required for MCP tool definitions"
      effort: "MEDIUM - 4-6 hours"
      changes:
        - "Add FieldType::to_json_schema_object() method"
        - "Add FieldSchema::to_json_schema() method"
        - "Add FullWorkflowMetadata::to_mcp_tool_schema() method"
        - "Update mcp_tools.rs to use generated schemas"
      files_affected:
        - "workflow-manager-sdk/src/lib.rs"
        - "workflow-manager/src/mcp_tools.rs"
    
    add_parameter_validation:
      impact: "HIGH - Prevents runtime errors"
      effort: "MEDIUM - 6-8 hours"
      changes:
        - "Create validation module"
        - "Implement ValidationError enum"
        - "Implement type validation for each FieldType"
        - "Update WorkflowRuntime::validate_workflow_inputs"
        - "Add validation tests"
      files_affected:
        - "workflow-manager-sdk/src/validation.rs (new)"
        - "workflow-manager/src/runtime.rs"
  
  priority_2_important:
    
    redesign_phase_selector_for_api:
      impact: "MEDIUM - Improves API usability"
      effort: "MEDIUM - 4-6 hours"
      changes:
        - "Accept array of integers in API"
        - "Keep string format for CLI"
        - "Add normalize_phase_selector() converter"
        - "Update validation logic"
        - "Update JSON schema generation"
      files_affected:
        - "workflow-manager-sdk/src/types.rs (new)"
        - "workflow-manager/src/runtime.rs"
        - "workflow-manager-sdk/src/lib.rs"
    
    add_state_file_discovery_tool:
      impact: "MEDIUM - Enables workflow resumption via API"
      effort: "LOW - 2-3 hours"
      changes:
        - "Implement list_state_files MCP tool"
        - "Add file pattern matching logic"
        - "Add timestamp/phase extraction from filenames"
      files_affected:
        - "workflow-manager/src/mcp_tools.rs"
    
    enhance_mcp_tool_suite:
      impact: "MEDIUM - Better API developer experience"
      effort: "MEDIUM - 4-5 hours"
      changes:
        - "Add get_workflow_schema tool"
        - "Add validate_workflow_inputs tool"
        - "Update server registration"
      files_affected:
        - "workflow-manager/src/mcp_tools.rs"
  
  priority_3_nice_to_have:
    
    change_parameters_to_json_value:
      impact: "LOW - Type safety improvement"
      effort: "MEDIUM - 6-8 hours"
      changes:
        - "Update WorkflowRuntime trait signature"
        - "Update ProcessBasedRuntime implementation"
        - "Add value_to_cli_arg converter"
        - "Update all call sites"
        - "Update tests"
      files_affected:
        - "workflow-manager-sdk/src/lib.rs"
        - "workflow-manager/src/runtime.rs"
        - "workflow-manager/src/mcp_tools.rs"
    
    add_workflow_capabilities:
      impact: "LOW - Better metadata"
      effort: "LOW - 2-3 hours"
      changes:
        - "Add WorkflowCapabilities struct"
        - "Add to FullWorkflowMetadata"
        - "Update macro to extract capabilities"
        - "Expose in MCP tools"
      files_affected:
        - "workflow-manager-sdk/src/lib.rs"
        - "workflow-manager-macros/src/lib.rs"
    
    separate_cli_metadata:
      impact: "LOW - Cleaner type separation"
      effort: "LOW - 2-3 hours"
      changes:
        - "Create CliFieldMetadata struct"
        - "Make cli_arg optional in FieldSchema"
        - "Update macro generation"
        - "Update TUI/CLI consumers"
      files_affected:
        - "workflow-manager-sdk/src/lib.rs"
        - "workflow-manager-macros/src/lib.rs"

# ============================================================================
# IMPLEMENTATION ROADMAP
# ============================================================================

implementation_roadmap:
  
  phase_1_foundational:
    duration: "1-2 days"
    goal: "Establish versioning and validation foundation"
    tasks:
      - task: "Add schema_version and sdk_version fields"
        effort: "1-2 hours"
        priority: "Critical"
      
      - task: "Implement JSON Schema generation methods"
        effort: "4-6 hours"
        priority: "Critical"
      
      - task: "Create validation module with ValidationError"
        effort: "6-8 hours"
        priority: "Critical"
    
    deliverables:
      - "Versioned WorkflowMetadata"
      - "FieldType::to_json_schema_object()"
      - "Comprehensive parameter validation"
  
  phase_2_api_improvements:
    duration: "2-3 days"
    goal: "Improve API representation of complex types"
    tasks:
      - task: "Redesign PhaseSelector for array API"
        effort: "4-6 hours"
        priority: "Important"
      
      - task: "Add list_state_files MCP tool"
        effort: "2-3 hours"
        priority: "Important"
      
      - task: "Add get_workflow_schema and validate_workflow_inputs tools"
        effort: "4-5 hours"
        priority: "Important"
    
    deliverables:
      - "PhaseSelector accepts array or string"
      - "State file discovery via MCP"
      - "Enhanced MCP tool suite"
  
  phase_3_polish:
    duration: "1-2 days"
    goal: "Type safety and metadata enhancements"
    tasks:
      - task: "Change WorkflowRuntime params to HashMap<String, Value>"
        effort: "6-8 hours"
        priority: "Nice-to-have"
      
      - task: "Add WorkflowCapabilities metadata"
        effort: "2-3 hours"
        priority: "Nice-to-have"
      
      - task: "Separate CLI metadata from core FieldSchema"
        effort: "2-3 hours"
        priority: "Nice-to-have"
    
    deliverables:
      - "Type-safe parameter passing"
      - "Rich workflow metadata"
      - "Clean type separation"
  
  total_estimated_effort: "30-45 hours (4-6 days)"

# ============================================================================
# RISK ASSESSMENT
# ============================================================================

risks_and_mitigations:
  
  risk_1_breaking_changes:
    risk: "Adding versioning breaks existing workflows"
    likelihood: "LOW - serde defaults handle missing fields"
    impact: "HIGH - All workflows fail discovery"
    mitigation:
      - "Use #[serde(default)] for new fields"
      - "Test with old workflow binaries"
      - "Document migration in changelog"
  
  risk_2_validation_performance:
    risk: "Complex validation slows execution"
    likelihood: "MEDIUM - Validation adds overhead"
    impact: "LOW - Usually milliseconds"
    mitigation:
      - "Validate once before execution"
      - "Cache validation results"
      - "Make validation optional for trusted sources"
  
  risk_3_schema_drift:
    risk: "Manual JSON Schema generation drifts from serde"
    likelihood: "MEDIUM - Manual code requires discipline"
    impact: "MEDIUM - API schemas incorrect"
    mitigation:
      - "Comprehensive unit tests"
      - "Round-trip serialization tests"
      - "Consider schemars crate for future"
  
  risk_4_api_format_confusion:
    risk: "PhaseSelector accepts two formats, users confused"
    likelihood: "MEDIUM - Documentation needed"
    impact: "LOW - Validation catches errors"
    mitigation:
      - "Clear documentation"
      - "Examples in MCP tool descriptions"
      - "Helpful validation error messages"

# ============================================================================
# TESTING STRATEGY
# ============================================================================

testing_strategy:
  
  unit_tests:
    location: "workflow-manager-sdk/src/lib.rs #[cfg(test)]"
    coverage:
      - "FieldType::to_json_schema_object() for all variants"
      - "FieldSchema::to_json_schema() with various configs"
      - "Validation for all FieldType variants"
      - "Phase selector normalization (string and array)"
      - "Versioning defaults and backwards compatibility"
  
  integration_tests:
    location: "workflow-manager/tests/"
    coverage:
      - "End-to-end workflow execution via WorkflowRuntime"
      - "MCP tool invocations with various inputs"
      - "Validation error handling"
      - "State file discovery"
  
  compatibility_tests:
    purpose: "Ensure old workflows still work"
    approach:
      - "Keep old workflow JSON fixtures"
      - "Test deserialization with missing fields"
      - "Test Unknown FieldType handling"
  
  schema_validation_tests:
    purpose: "Ensure generated schemas are valid JSON Schema"
    approach:
      - "Use jsonschema validation crate"
      - "Validate generated schemas against JSON Schema spec"
      - "Test round-trip: Type → Schema → Validation → Type"

# ============================================================================
# CONCLUSION
# ============================================================================

conclusion:
  
  overall_assessment:
    current_readiness: "75% - Core types are serializable, but API-specific features missing"
    
    strengths:
      - "Clean type hierarchy with serde"
      - "WorkflowRuntime trait provides good abstraction"
      - "Process-based execution is robust"
      - "Structured logging system is well-designed"
    
    weaknesses:
      - "No versioning (critical gap)"
      - "Complex types (PhaseSelector, StateFile) not API-friendly"
      - "Minimal parameter validation"
      - "No JSON Schema generation"
      - "CLI-specific concerns mixed with core types"
    
    effort_to_production_ready: "30-45 hours over 4-6 days"
  
  key_recommendations:
    
    immediate_actions:
      - "Add schema_version and sdk_version (1-2 hours)"
      - "Implement JSON Schema generation (4-6 hours)"
      - "Build validation module (6-8 hours)"
    
    short_term_actions:
      - "Redesign PhaseSelector API (4-6 hours)"
      - "Add state file discovery tool (2-3 hours)"
      - "Enhance MCP tool suite (4-5 hours)"
    
    long_term_considerations:
      - "Consider HTTP/REST API exposure"
      - "Implement workflow persistence"
      - "Add workflow scheduling and queuing"
      - "Support workflow composition and nesting"
  
  next_steps:
    step_1: "Review this analysis with team"
    step_2: "Prioritize changes based on immediate needs"
    step_3: "Implement Phase 1 (foundational changes)"
    step_4: "Test with existing workflows"
    step_5: "Iterate based on MCP API usage feedback"
architecture_analysis:
  overview: |
    The workflow-manager is a terminal-based workflow orchestration system with a tabbed TUI interface.
    It uses a plugin-based architecture where workflows are separate binaries that implement the WorkflowDefinition
    trait via a derive macro. The system follows a clear separation between workflow definition (SDK),
    workflow execution (separate processes), and workflow monitoring (TUI).

  components:
    workflow_manager_sdk:
      location: "../workflow-manager-sdk/src/lib.rs"
      purpose: "Core SDK for defining workflows"
      
      key_types:
        WorkflowMetadata:
          fields:
            - id: "String"
            - name: "String"
            - description: "String"
          purpose: "Basic workflow identification"
          
        FullWorkflowMetadata:
          fields:
            - metadata: "WorkflowMetadata (flattened)"
            - fields: "Vec<FieldSchema>"
          purpose: "Complete workflow definition exported as JSON via --workflow-metadata flag"
          serialization: "JSON via serde_json"
          
        FieldSchema:
          fields:
            - name: "String"
            - field_type: "FieldType"
            - label: "String"
            - description: "String"
            - cli_arg: "String"
            - required: "bool"
            - default: "Option<String>"
            - required_for_phases: "Option<Vec<usize>>"
          purpose: "Defines input fields for workflow configuration"
          
        FieldType:
          variants:
            Text:
              purpose: "Free-form text input"
            Number:
              fields:
                - min: "Option<i64>"
                - max: "Option<i64>"
              purpose: "Numeric input with optional bounds"
            FilePath:
              fields:
                - pattern: "Option<String>"
              purpose: "File/directory path selection"
            Select:
              fields:
                - options: "Vec<String>"
              purpose: "Dropdown selection"
            PhaseSelector:
              fields:
                - total_phases: "usize"
              purpose: "Select which workflow phases to run"
            StateFile:
              fields:
                - pattern: "String"
                - phase: "Option<usize>"
              purpose: "Reference to intermediate workflow output files"
          
        WorkflowDefinition:
          trait_methods:
            - "metadata() -> WorkflowMetadata"
            - "fields() -> Vec<FieldSchema>"
            - "print_metadata(&self)"
          implementation: "Auto-derived via #[derive(WorkflowDefinition)] macro"
          
        WorkflowStatus:
          variants: ["NotStarted", "Running", "Completed", "Failed"]
          usage: "Tracks execution state in TUI"
          
        WorkflowLog:
          purpose: "Structured logging events for workflow progress tracking"
          protocol: "Emitted to stderr as '__WF_EVENT__:<json>'"
          variants:
            PhaseStarted:
              fields:
                phase: "usize"
                name: "String"
                total_phases: "usize"
            PhaseCompleted:
              fields:
                phase: "usize"
                name: "String"
            PhaseFailed:
              fields:
                phase: "usize"
                name: "String"
                error: "String"
            TaskStarted:
              fields:
                phase: "usize"
                task_id: "String"
                description: "String"
                total_tasks: "Option<usize>"
            TaskProgress:
              fields:
                task_id: "String"
                message: "String"
            TaskCompleted:
              fields:
                task_id: "String"
                result: "Option<String>"
            TaskFailed:
              fields:
                task_id: "String"
                error: "String"
            AgentStarted:
              fields:
                task_id: "String"
                agent_name: "String"
                description: "String"
            AgentMessage:
              fields:
                task_id: "String"
                agent_name: "String"
                message: "String"
            AgentCompleted:
              fields:
                task_id: "String"
                agent_name: "String"
                result: "Option<String>"
            AgentFailed:
              fields:
                task_id: "String"
                agent_name: "String"
                error: "String"
            StateFileCreated:
              fields:
                phase: "usize"
                file_path: "String"
                description: "String"
          
          helper_macros:
            - "log_phase_start!"
            - "log_phase_complete!"
            - "log_phase_failed!"
            - "log_task_start!"
            - "log_task_progress!"
            - "log_task_complete!"
            - "log_task_failed!"
            - "log_agent_start!"
            - "log_agent_message!"
            - "log_agent_complete!"
            - "log_agent_failed!"
            - "log_state_file!"

    workflow_manager_macros:
      location: "../workflow-manager-macros/src/lib.rs"
      purpose: "Procedural macro for deriving WorkflowDefinition trait"
      
      attributes:
        workflow:
          fields:
            id: "String"
            name: "String"
            description: "String"
          usage: "#[workflow(id = \"...\", name = \"...\", description = \"...\")]"
          
        field:
          fields:
            - label: "String"
            - description: "String"
            - type: "String (text|number|file_path|phase_selector|state_file)"
            - min: "Option<i64>"
            - max: "Option<i64>"
            - pattern: "Option<String>"
            - total_phases: "Option<usize>"
            - phase: "Option<usize>"
            - required_for_phases: "Option<String> (comma-separated phase indices)"
          usage: "#[field(label = \"...\", description = \"...\", type = \"...\")]"
          
      code_generation:
        - "Implements WorkflowDefinition::metadata()"
        - "Implements WorkflowDefinition::fields()"
        - "Implements WorkflowDefinition::print_metadata()"
        - "Generates FieldSchema from struct fields and attributes"
        - "Detects Option<T> types to determine required vs optional fields"

    discovery_system:
      location: "src/discovery.rs"
      purpose: "Discovers and loads workflow binaries"
      
      workflow_discovery:
        search_paths:
          - "~/.workflow-manager/workflows/ (user workflows)"
          - "../target/debug/ (built-in/development workflows)"
        
        filtering_rules:
          - "Skip workflow-manager binary itself"
          - "Skip files with extensions (.d, .rlib, etc.)"
          - "Skip files with hash suffixes (build artifacts)"
          - "Only include executable files (Unix: mode & 0o111 != 0)"
        
        metadata_extraction:
          command: "<binary> --workflow-metadata"
          output_format: "JSON (FullWorkflowMetadata)"
          protocol: "Stdout contains JSON, stderr suppressed"
        
      DiscoveredWorkflow:
        fields:
          - metadata: "WorkflowMetadata"
          - fields: "Vec<FieldSchema>"
          - binary_path: "PathBuf"
        
      functions:
        discover_workflows: "Vec<DiscoveredWorkflow>"
        build_workflow_command: "Converts field values to CLI command string"

    main_tui_application:
      location: "src/main.rs (3416 lines)"
      purpose: "Terminal UI for workflow management"
      
      core_structures:
        App:
          workflow_catalog:
            - workflows: "Vec<Workflow>"
            - selected: "usize"
          
          tab_management:
            - open_tabs: "Vec<WorkflowTab>"
            - active_tab_idx: "usize"
            - workflow_counters: "HashMap<String, usize>"
            - show_close_confirmation: "bool"
            - in_new_tab_flow: "bool"
          
          view_state:
            - current_view: "View"
            - should_quit: "bool"
          
          edit_mode:
            - edit_field_index: "usize"
            - edit_buffer: "String"
            - is_editing: "bool"
            - field_values: "HashMap<String, String>"
          
          file_browser:
            - show_file_browser: "bool"
            - file_browser_items: "Vec<PathBuf>"
            - file_browser_selected: "usize"
            - file_browser_search: "String"
            - current_dir: "PathBuf"
          
          dropdown:
            - show_dropdown: "bool"
            - dropdown_items: "Vec<PathBuf>"
            - dropdown_selected: "usize"
          
          history:
            - history: "WorkflowHistory"
            - history_items: "Vec<String>"
          
          legacy_running_state:
            - workflow_output: "Arc<Mutex<Vec<String>>>"
            - workflow_running: "bool"
            - workflow_phases: "Arc<Mutex<Vec<WorkflowPhase>>>"
            - expanded_phases: "HashSet<usize>"
            - expanded_tasks: "HashSet<String>"
            - expanded_agents: "HashSet<String>"
            - selected_phase: "usize"
            - selected_task: "Option<String>"
            - selected_agent: "Option<String>"
            - workflow_scroll_offset: "usize"
        
        WorkflowTab:
          identity:
            - id: "String (unique: workflow_id_timestamp)"
            - workflow_idx: "usize (index in App.workflows)"
            - workflow_name: "String"
            - instance_number: "usize (display counter)"
            - start_time: "Option<DateTime<Local>>"
          
          execution_state:
            - status: "WorkflowStatus"
            - child_process: "Option<Child>"
            - exit_code: "Option<i32>"
          
          workflow_data:
            - workflow_phases: "Arc<Mutex<Vec<WorkflowPhase>>>"
            - workflow_output: "Arc<Mutex<Vec<String>>>"
            - field_values: "HashMap<String, String>"
          
          ui_state:
            - scroll_offset: "usize"
            - expanded_phases: "HashSet<usize>"
            - expanded_tasks: "HashSet<String>"
            - expanded_agents: "HashSet<String>"
            - selected_phase: "usize"
            - selected_task: "Option<String>"
            - selected_agent: "Option<String>"
          
          persistence:
            - saved_logs: "Option<Vec<String>>"
        
        WorkflowPhase:
          fields:
            - id: "usize"
            - name: "String"
            - status: "PhaseStatus (NotStarted|Running|Completed|Failed)"
            - tasks: "Vec<WorkflowTask>"
            - output_files: "Vec<(String, String)> (path, description)"
        
        WorkflowTask:
          fields:
            - id: "String"
            - phase: "usize"
            - description: "String"
            - status: "TaskStatus (NotStarted|Running|Completed|Failed)"
            - agents: "Vec<WorkflowAgent>"
            - messages: "Vec<String>"
            - result: "Option<String>"
        
        WorkflowAgent:
          fields:
            - id: "String (format: task_id:agent_name)"
            - task_id: "String"
            - name: "String"
            - description: "String"
            - status: "AgentStatus (NotStarted|Running|Completed|Failed)"
            - messages: "Vec<String>"
            - result: "Option<String>"
        
        View:
          variants:
            - "WorkflowList (catalog browsing)"
            - "WorkflowDetail(usize) (read-only view)"
            - "WorkflowEdit(usize) (field configuration)"
            - "WorkflowRunning(usize) (legacy single-workflow view)"
            - "Tabs (main tabbed interface)"
        
        WorkflowHistory:
          structure: "HashMap<workflow_id, HashMap<field_name, Vec<String>>>"
          storage: "~/.workflow-manager/history.json"
          purpose: "Recent field values for autocomplete"
      
      key_functions:
        workflow_lifecycle:
          load_workflows:
            source: "main.rs:1785"
            steps:
              - "Call load_builtin_workflows() for ../target/debug binaries"
              - "Call load_discovered_workflows() for user workflows"
              - "Merge and return Vec<Workflow>"
          
          load_builtin_workflows:
            source: "main.rs:1797"
            discovery:
              - "Scan ../target/debug directory"
              - "Execute each binary with --workflow-metadata"
              - "Parse FullWorkflowMetadata JSON from stdout"
              - "Create Workflow with WorkflowSource::BuiltIn"
          
          launch_workflow_in_tab:
            source: "main.rs:909"
            steps:
              - "Get next instance number from workflow_counters"
              - "Build CLI args from field_values (handle bool flags)"
              - "Create WorkflowTab with unique ID"
              - "Spawn process with stdout/stderr piped"
              - "Spawn thread to read stdout (raw output)"
              - "Spawn thread to read stderr (parse WorkflowLog events)"
              - "Add tab to open_tabs and switch to it"
          
          rerun_current_tab:
            source: "main.rs:441"
            steps:
              - "Kill existing process if running"
              - "Reset tab state (status, exit_code, clear output/phases)"
              - "Re-spawn process with saved field_values"
              - "Re-attach stdout/stderr threads"
          
          poll_all_tabs:
            source: "main.rs:637"
            purpose: "Checks process status for all running tabs"
            frequency: "Called every render loop iteration"
            actions:
              - "Call child.try_wait() for running tabs"
              - "Update tab.status on completion/failure"
              - "Save field values to history on success"
              - "Append completion/error message to output"
        
        event_handling:
          handle_workflow_event:
            source: "main.rs:1055"
            purpose: "Parse WorkflowLog events and update hierarchical state"
            input: "WorkflowLog event from stderr"
            output: "Updates Arc<Mutex<Vec<WorkflowPhase>>>"
            logic:
              PhaseStarted:
                - "Ensure phases vector has enough capacity"
                - "Set phase.name and phase.status = Running"
              PhaseCompleted:
                - "Set phase.status = Completed"
              PhaseFailed:
                - "Set phase.status = Failed"
              TaskStarted:
                - "Ensure phase exists"
                - "Create or update task with status = Running"
              TaskProgress:
                - "Find task and append message"
              TaskCompleted:
                - "Set task.status = Completed, save result"
              TaskFailed:
                - "Set task.status = Failed, append error"
              AgentStarted:
                - "Create agent_id from 'task_id:agent_name'"
                - "Create or update agent with status = Running"
              AgentMessage:
                - "Find agent and append message"
              AgentCompleted:
                - "Set agent.status = Completed, save result"
              AgentFailed:
                - "Set agent.status = Failed, append error"
              StateFileCreated:
                - "Add (file_path, description) to phase.output_files"
        
        session_management:
          save_session:
            source: "main.rs:228"
            storage: "~/.workflow-manager/session.json"
            persisted_data:
              - "workflow_idx"
              - "workflow_name"
              - "instance_number"
              - "field_values"
              - "status"
              - "saved_logs (Vec<String> from workflow_output)"
          
          restore_session:
            source: "main.rs:264"
            behavior:
              - "Load session.json on startup"
              - "Restore tabs with NotStarted/Completed/Failed status"
              - "Restore saved_logs into workflow_output"
              - "Update workflow_counters for instance numbering"
        
        ui_rendering:
          ui:
            source: "main.rs:2173"
            purpose: "Main render dispatch function"
          
          render_workflow_list:
            source: "main.rs:2267"
            purpose: "Catalog of available workflows"
          
          render_workflow_edit:
            source: "main.rs:2415"
            purpose: "Field configuration form with history dropdown"
          
          render_tab_bar:
            source: "main.rs:3063"
            purpose: "Horizontal tab selector with status indicators"
          
          render_tab_content:
            source: "main.rs:3203"
            purpose: "Displays hierarchical Phase→Task→Agent tree and output"
          
          render_file_browser:
            source: "main.rs:2973"
            purpose: "File picker for FilePath/StateFile fields"
          
          render_dropdown:
            source: "main.rs:2864"
            purpose: "History-based autocomplete for field values"

  data_flow:
    workflow_definition_to_execution:
      step_1_author_workflow:
        action: "Developer creates Rust struct with #[derive(WorkflowDefinition)]"
        attributes:
          - "#[workflow(id = \"...\", name = \"...\", description = \"...\")]"
          - "#[field(label = \"...\", description = \"...\", type = \"...\")]"
        example: "src/bin/research_agent.rs:157-200"
      
      step_2_macro_expansion:
        action: "workflow-manager-macros generates WorkflowDefinition impl"
        generates:
          - "metadata() -> WorkflowMetadata"
          - "fields() -> Vec<FieldSchema>"
          - "print_metadata(&self) -> JSON output"
      
      step_3_compile_binary:
        action: "Workflow compiled as standalone binary"
        location: "target/debug/<workflow_id>"
        cli_interface:
          - "--workflow-metadata: Print FullWorkflowMetadata JSON to stdout"
          - "<field_args>: Run workflow with configured fields"
      
      step_4_discovery:
        action: "TUI discovers workflows on startup"
        function: "load_workflows() -> Vec<Workflow>"
        process:
          - "Scan target/debug and ~/.workflow-manager/workflows"
          - "Execute each binary with --workflow-metadata"
          - "Parse JSON and populate workflows catalog"
      
      step_5_user_configuration:
        action: "User selects workflow and fills fields in TUI"
        views:
          - "WorkflowList: Browse catalog"
          - "WorkflowEdit: Configure fields with history dropdown"
        storage: "field_values: HashMap<String, String>"
      
      step_6_execution:
        action: "User presses 't' to launch in new tab"
        function: "launch_workflow_in_tab()"
        process:
          - "Build CLI command from field_values"
          - "Spawn binary as child process"
          - "Create WorkflowTab to track state"
          - "Add to open_tabs and switch to it"
      
      step_7_monitoring:
        action: "TUI monitors workflow progress"
        stdout_handling:
          thread: "Spawned thread reads stdout line-by-line"
          storage: "Appended to tab.workflow_output"
          display: "Raw output shown in tab content"
        
        stderr_handling:
          thread: "Spawned thread reads stderr line-by-line"
          protocol: "Lines starting with '__WF_EVENT__:' are parsed as JSON"
          function: "handle_workflow_event() updates tab.workflow_phases"
          display: "Hierarchical Phase→Task→Agent tree rendered"
        
        polling:
          function: "poll_all_tabs() called every frame"
          purpose: "Check child.try_wait() for completion"
          on_complete:
            - "Update tab.status"
            - "Save field_values to history"
            - "Append success/failure message"
      
      step_8_persistence:
        action: "TUI saves session on exit"
        function: "save_session()"
        storage: "~/.workflow-manager/session.json"
        restores_on_startup:
          - "Tab list with field_values"
          - "Completed/Failed status"
          - "Saved logs"

  metadata_and_field_schemas:
    field_type_mapping:
      Text:
        tui_widget: "Text input with edit buffer"
        validation: "None"
        
      Number:
        tui_widget: "Text input with numeric validation"
        validation: "min/max bounds if specified"
        
      FilePath:
        tui_widget: "Text input + file browser (Ctrl+F)"
        browser_features:
          - "Fuzzy search by filename"
          - "Navigate directories"
          - "Filter by pattern if specified"
        
      StateFile:
        tui_widget: "Text input + file browser with StateFile filtering"
        discovery: "Scan for files matching pattern from specific phase"
        
      PhaseSelector:
        tui_widget: "Multi-select checkboxes (not yet implemented)"
        purpose: "Select which phases to run (e.g., --phases 0,1,2)"
        
      Select:
        tui_widget: "Dropdown menu (not implemented)"
        purpose: "Choose from predefined options"
    
    required_for_phases:
      purpose: "Mark fields as required only for specific phases"
      example: "input field required for phase 1 but not phase 0"
      usage: "#[field(required_for_phases = \"1\")]"
      tui_behavior: "Field marked as optional if not required for selected phases"
    
    metadata_retrieval:
      protocol: "<binary> --workflow-metadata"
      output_format: "JSON (FullWorkflowMetadata)"
      example_output: |
        {
          "id": "research_agent",
          "name": "Research Agent Workflow",
          "description": "Multi-phase research workflow...",
          "fields": [
            {
              "name": "input",
              "field_type": {"type": "text"},
              "label": "Research Objective",
              "description": "[TEXT] What do you want to research?",
              "cli_arg": "--input",
              "required": false,
              "default": null,
              "required_for_phases": [1]
            }
          ]
        }

  logging_system:
    protocol:
      channel: "stderr"
      format: "__WF_EVENT__:<json>"
      encoding: "JSON (WorkflowLog enum with serde)"
    
    event_hierarchy:
      Phase:
        events: ["PhaseStarted", "PhaseCompleted", "PhaseFailed"]
        purpose: "Top-level workflow stages"
        
      Task:
        events: ["TaskStarted", "TaskProgress", "TaskCompleted", "TaskFailed"]
        purpose: "Discrete units of work within a phase"
        parent: "Phase (via phase: usize field)"
        
      Agent:
        events: ["AgentStarted", "AgentMessage", "AgentCompleted", "AgentFailed"]
        purpose: "Sub-agents running within a task (e.g., Claude agent)"
        parent: "Task (via task_id: String field)"
        
      StateFile:
        event: "StateFileCreated"
        purpose: "Document intermediate output files for chaining phases"
        parent: "Phase (via phase: usize field)"
    
    tui_integration:
      parsing:
        location: "main.rs:536, 857, 1016 (stderr reading threads)"
        pattern: "line.strip_prefix('__WF_EVENT__:')"
        deserialization: "serde_json::from_str::<WorkflowLog>(json_str)"
      
      state_update:
        function: "handle_workflow_event(event, &phases)"
        storage: "Arc<Mutex<Vec<WorkflowPhase>>>"
        behavior: "Dynamically creates/updates Phase→Task→Agent hierarchy"
      
      rendering:
        function: "render_tab_content() -> main.rs:3203"
        layout:
          - "Hierarchical tree view (expandable)"
          - "Phase with status indicator"
          - "Tasks with progress messages"
          - "Agents with streaming messages"
          - "Output files with clickable links"
    
    example_workflow_logging:
      phase_logging: |
        log_phase_start!(0, "Analyze Codebase", 5);
        // ... phase work ...
        log_phase_complete!(0, "Analyze Codebase");
      
      task_logging: |
        log_task_start!(0, "analyze_structure", "Analyzing directory structure");
        log_task_progress!("analyze_structure", "Scanned 150 files");
        log_task_complete!("analyze_structure", "Found 10 modules");
      
      agent_logging: |
        log_agent_start!("analyze_structure", "claude", "Analyzing code patterns");
        log_agent_message!("analyze_structure", "claude", "Found MVC pattern");
        log_agent_complete!("analyze_structure", "claude", "Analysis complete");
      
      state_file_logging: |
        log_state_file!(0, "./codebase_analysis.yaml", "Codebase structure analysis");

  tui_coupled_vs_api_exposable:
    tightly_coupled_to_tui:
      location: "src/main.rs"
      line_range: "1-3416"
      components:
        - component: "ratatui rendering (render_* functions)"
          lines: "2173-3416"
          dependencies: ["ratatui::Frame", "ratatui::widgets::*"]
          
        - component: "crossterm event handling"
          lines: "Throughout main event loop"
          dependencies: ["crossterm::event::Event", "KeyCode"]
          
        - component: "App state management"
          lines: "129-174 (struct), 175-1783 (methods)"
          reason: "Deeply coupled to TUI views and keyboard navigation"
          
        - component: "File browser UI"
          lines: "1222-1438"
          reason: "Interactive fuzzy search widget"
          
        - component: "Dropdown UI"
          lines: "2864-2972"
          reason: "History-based autocomplete widget"
          
        - component: "Session persistence"
          lines: "228-326"
          reason: "Saves/restores tabs for TUI continuity"
    
    loosely_coupled_api_exposable:
      discovery_system:
        location: "src/discovery.rs"
        components:
          - "discover_workflows"
          - "extract_workflow_metadata"
          - "build_workflow_command"
        api_potential: "HIGH - Pure data transformation, no TUI deps"
        suggested_api: |
          GET /api/workflows -> List<WorkflowMetadata>
          GET /api/workflows/{id}/metadata -> FullWorkflowMetadata
      
      workflow_execution:
        location: "src/main.rs:909-1053"
        components:
          - "launch_workflow_in_tab (core logic)"
          - "Build CLI command from field_values"
          - "Spawn process with piped stdout/stderr"
        api_potential: "HIGH - Extract into execution service"
        refactoring_needed:
          - "Separate WorkflowExecution struct from WorkflowTab"
          - "Extract process spawning into ExecutionManager"
          - "Return execution_id for polling"
        suggested_api: |
          POST /api/workflows/{id}/execute
            Body: { field_values: {field_name: value} }
            Returns: { execution_id: "uuid", status: "running" }
          
          GET /api/executions/{id}/status
            Returns: { status: "running|completed|failed", exit_code: int }
          
          GET /api/executions/{id}/output (SSE stream)
            Returns: Server-sent events with stdout lines
          
          GET /api/executions/{id}/events (SSE stream)
            Returns: Server-sent events with WorkflowLog events
      
      event_parsing:
        location: "src/main.rs:1055-1220"
        component: "handle_workflow_event"
        api_potential: "MEDIUM - Needs refactoring for stateless API"
        current_design: "Updates Arc<Mutex<Vec<WorkflowPhase>>> in-place"
        suggested_refactoring: |
          struct WorkflowExecutionState {
            phases: Vec<WorkflowPhase>,
            raw_output: Vec<String>
          }
          
          impl WorkflowExecutionState {
            fn apply_event(&mut self, event: WorkflowLog) { ... }
            fn to_json(&self) -> String { ... }
          }
        suggested_api: |
          GET /api/executions/{id}/state
            Returns: { phases: [...], status: "..." }
      
      workflow_catalog:
        location: "src/main.rs:1785-1885"
        components:
          - "load_workflows"
          - "load_builtin_workflows"
          - "load_discovered_workflows"
        api_potential: "HIGH - Already isolated from TUI"
        suggested_api: |
          GET /api/workflows -> List<Workflow>
          GET /api/workflows/{id} -> Workflow
      
      field_validation:
        location: "workflow-manager-sdk (FieldSchema, FieldType)"
        api_potential: "HIGH - Reusable for API validation"
        suggested_api: |
          POST /api/workflows/{id}/validate
            Body: { field_values: {...} }
            Returns: { valid: bool, errors: [...] }
      
      history_system:
        location: "src/main.rs (WorkflowHistory)"
        components:
          - "save_history"
          - "load_history"
        api_potential: "MEDIUM - Useful for API autocomplete/suggestions"
        suggested_api: |
          GET /api/workflows/{id}/history/{field}
            Returns: { recent_values: [...] }

  architectural_recommendations:
    for_api_implementation:
      step_1_extract_core_logic:
        create_modules:
          - "workflow_discovery: Discover and load workflows"
          - "workflow_execution: Spawn and monitor workflow processes"
          - "event_processing: Parse and aggregate WorkflowLog events"
          - "field_validation: Validate field values against schemas"
        
        extract_from_main_rs:
          - "Move WorkflowPhase/Task/Agent to SDK or separate types module"
          - "Extract process spawning logic into ExecutionManager"
          - "Create WorkflowExecutionState for stateless event aggregation"
      
      step_2_define_execution_model:
        stateful_execution_manager:
          storage: "HashMap<Uuid, WorkflowExecution>"
          fields:
            - execution_id: "Uuid"
            - workflow_id: "String"
            - field_values: "HashMap<String, String>"
            - child_process: "Child"
            - state: "WorkflowExecutionState"
            - stdout_receiver: "mpsc::Receiver<String>"
            - stderr_receiver: "mpsc::Receiver<WorkflowLog>"
          
        event_streaming:
          protocol: "Server-Sent Events (SSE)"
          endpoints:
            - "/api/executions/{id}/output (stdout stream)"
            - "/api/executions/{id}/events (WorkflowLog stream)"
            - "/api/executions/{id}/state (snapshot polling)"
      
      step_3_implement_rest_api:
        framework_suggestion: "axum or actix-web"
        endpoints:
          catalog:
            - "GET /api/workflows"
            - "GET /api/workflows/{id}"
            - "GET /api/workflows/{id}/metadata"
          
          execution:
            - "POST /api/workflows/{id}/execute"
            - "GET /api/executions/{id}"
            - "DELETE /api/executions/{id} (kill process)"
            - "GET /api/executions/{id}/output (SSE)"
            - "GET /api/executions/{id}/events (SSE)"
            - "GET /api/executions/{id}/state"
          
          history:
            - "GET /api/workflows/{id}/history/{field}"
            - "POST /api/workflows/{id}/history/{field} (save value)"
      
      step_4_maintain_tui_compatibility:
        strategy: "TUI becomes API client"
        benefits:
          - "Decouples UI from execution logic"
          - "Enables multiple frontends (TUI, Web UI, CLI)"
          - "Simplifies testing (API endpoints testable independently)"
        
        migration_path:
          phase_1: "Extract core logic into library modules"
          phase_2: "Implement API server using extracted modules"
          phase_3: "Refactor TUI to call API endpoints"
          phase_4: "Deprecate direct process spawning in TUI"

  protocol_specification:
    workflow_binary_interface:
      metadata_query:
        command: "<binary> --workflow-metadata"
        stdout: "JSON (FullWorkflowMetadata)"
        stderr: "Ignored"
        exit_code: 0
      
      execution:
        command: "<binary> <field_args>"
        field_args_format:
          text_field: "--field-name value"
          bool_field: "--field-name (if true, omitted if false)"
          file_path: "--file-path /path/to/file"
          number: "--count 42"
        
        stdout: "Raw workflow output (unstructured)"
        stderr: "Structured WorkflowLog events (__WF_EVENT__:<json>)"
        exit_code: "0 = success, non-zero = failure"
    
    structured_logging_protocol:
      format: "__WF_EVENT__:<json>"
      channel: "stderr"
      json_schema: "WorkflowLog enum (serde-serialized)"
      
      event_ordering:
        phase_lifecycle: "PhaseStarted → [Tasks...] → PhaseCompleted|PhaseFailed"
        task_lifecycle: "TaskStarted → [Progress|Agents...] → TaskCompleted|TaskFailed"
        agent_lifecycle: "AgentStarted → [Messages...] → AgentCompleted|AgentFailed"
      
      tui_behavior:
        - "Parse __WF_EVENT__: lines from stderr"
        - "Deserialize JSON into WorkflowLog"
        - "Call handle_workflow_event() to update state"
        - "Render hierarchical tree from updated state"
      
      api_behavior_suggestion:
        - "Spawn threads to read stdout/stderr"
        - "Parse WorkflowLog events and aggregate into WorkflowExecutionState"
        - "Stream events via SSE to connected clients"
        - "Store final state for historical queries"

  summary:
    architecture_strengths:
      - "Clean separation: Workflows are independent binaries"
      - "Discoverable: Metadata query via --workflow-metadata"
      - "Structured logging: WorkflowLog events enable rich monitoring"
      - "Flexible fields: FieldType enum supports various input types"
      - "Phase-aware: required_for_phases enables conditional fields"
      - "Developer-friendly: Derive macro simplifies workflow creation"
    
    tui_coupling_assessment:
      tightly_coupled_percentage: "~85% (2900/3416 lines)"
      reason: "Main.rs is monolithic TUI application"
      
      loosely_coupled_components:
        - "discovery.rs (147 lines)"
        - "workflow-manager-sdk (367 lines)"
        - "workflow-manager-macros (procedural macro)"
        - "Workflow execution logic (extractable from main.rs)"
    
    api_feasibility:
      overall_rating: "HIGH"
      reasoning: |
        The core workflow execution model (binary spawning, event parsing, state tracking)
        is logically separate from the TUI but currently embedded in App methods.
        Extracting these into standalone modules would enable API implementation
        with minimal changes to the SDK or workflow binaries.
      
      estimated_effort:
        extract_execution_logic: "2-3 days"
        implement_rest_api: "3-5 days"
        sse_event_streaming: "1-2 days"
        refactor_tui_as_client: "3-4 days"
        total: "~2 weeks"
    
    recommended_next_steps:
      - "Extract WorkflowExecutionState and event aggregation logic"
      - "Create ExecutionManager for process lifecycle management"
      - "Implement REST API with axum/actix-web"
      - "Add SSE endpoints for real-time event streaming"
      - "Refactor TUI to consume API (optional, for decoupling)"
api_layer_organization_analysis:
  date: 2025-10-14
  project: workflow-manager
  
  current_state:
    crates:
      - name: workflow-manager
        type: binary
        purpose: TUI application for managing workflows
        dependencies:
          - claude-agent-sdk (path: ../claude-agent-sdk-rust)
          - workflow-manager-sdk (path: ../workflow-manager-sdk)
          - tokio with features [fs, process, io-util]
          - ratatui, crossterm (TUI)
          - reqwest, serde, serde_json, serde_yaml
        
      - name: workflow-manager-sdk
        type: library
        purpose: |
          Trait definitions for workflows, metadata types, field schemas,
          structured logging (WorkflowLog enum), and helper macros.
          Pure types with minimal dependencies.
        dependencies:
          - serde, serde_json (only)
          - Re-exports: workflow-manager-macros, claude-agent-sdk
        current_scope:
          - WorkflowDefinition trait
          - WorkflowMetadata, FullWorkflowMetadata
          - FieldSchema, FieldType enums
          - WorkflowStatus, WorkflowProgress, WorkflowInfo
          - WorkflowLog event system
          - Logging macros (log_phase_start, log_task_start, etc.)
        
      - name: workflow-manager-macros
        type: proc-macro
        purpose: Derive macro for WorkflowDefinition trait
        dependencies:
          - syn, quote, proc-macro2 (only)
        
      - name: claude-agent-sdk
        type: library
        purpose: |
          Full SDK for interacting with Claude Code CLI.
          Includes client, transport, MCP, hooks, permissions.
        dependencies:
          - tokio (full features) - tightly coupled
          - reqwest, futures, async-stream, async-trait
          - serde, serde_json
        runtime_coupling: Tightly coupled to tokio runtime
        scope: Complete client implementation with transport layer

    dependency_graph: |
      workflow-manager (binary)
      ├── claude-agent-sdk
      │   └── tokio (full)
      ├── workflow-manager-sdk
      │   ├── workflow-manager-macros
      │   ├── claude-agent-sdk (re-export)
      │   └── serde, serde_json
      └── tokio, ratatui, reqwest, etc.
    
    current_circular_dependency_risks:
      status: NONE DETECTED
      analysis: |
        - workflow-manager-sdk is pure types/traits (no implementation)
        - workflow-manager binary depends on SDK (unidirectional)
        - claude-agent-sdk is independent (no workflow knowledge)
        - No circular dependencies in current structure

  proposed_architectures:
    
    option_1_extend_sdk:
      name: "Extend workflow-manager-sdk with API client"
      structure: |
        workflow-manager-sdk/
        ├── types.rs (existing: traits, metadata, schemas)
        ├── api_client.rs (NEW: HTTP client for remote API)
        ├── error.rs (NEW: error types)
        └── lib.rs (re-exports)
      
      dependencies_added:
        - reqwest (HTTP client)
        - tokio (for async runtime)
        - Optional feature flag: "api-client"
      
      pros:
        - Single crate for all SDK functionality
        - Simpler for users (one dependency)
        - Easier to maintain internal consistency
        - Types and client always in sync
        - No additional crate overhead
      
      cons:
        - SDK becomes tokio-coupled (loses purity)
        - Heavier dependency footprint
        - Users who only want types get HTTP client too
        - Mixes concerns: traits/types + network client
        - Runtime coupling leaks into SDK
        - Cannot use SDK in non-tokio contexts
      
      circular_dependency_risk: LOW
      rationale: |
        No circular dependencies introduced. SDK remains dependency target,
        never a dependent. However, SDK loses purity by gaining implementation.
      
      runtime_implications: |
        - SDK becomes tokio-specific
        - Cannot use with other async runtimes
        - Build times increase (reqwest, tokio dependencies)
        - Feature flags can mitigate: default = [], api = ["reqwest", "tokio"]

    option_2_new_api_crate:
      name: "Create workflow-manager-api crate"
      structure: |
        workflow-manager-api/
        ├── client.rs (HTTP client implementation)
        ├── endpoints.rs (API endpoint definitions)
        ├── error.rs (API-specific errors)
        └── lib.rs
        
        Dependencies:
        workflow-manager-api
        ├── workflow-manager-sdk (types, traits)
        ├── reqwest (HTTP)
        └── tokio
      
      dependencies_added:
        New crate with:
        - workflow-manager-sdk (for types)
        - reqwest, tokio
      
      pros:
        - Clean separation of concerns
        - SDK remains pure (types/traits only)
        - Users choose: SDK (local) or API (remote)
        - API crate can evolve independently
        - SDK stays runtime-agnostic
        - Minimal dependencies for type-only users
        - Can version API separately
      
      cons:
        - Additional crate to maintain
        - Two crates to import if using both
        - More complex project structure
        - Need to coordinate releases
        - Re-export management
      
      circular_dependency_risk: NONE
      rationale: |
        Perfect unidirectional flow:
        workflow-manager-sdk (types) ← workflow-manager-api (client)
        
        API crate depends on SDK for types, SDK never depends on API.
        This is the standard pattern (SQLx, AWS SDK, Tonic).
      
      runtime_implications: |
        - API crate is tokio-specific (like reqwest, tonic, aws-sdk)
        - SDK remains runtime-agnostic (just traits/types)
        - Future: Could add workflow-manager-api-async-std if needed
        - Clear separation allows runtime choice per component

    option_3_types_crate_separation:
      name: "Three-crate split with types foundation"
      structure: |
        workflow-manager-types/
        ├── workflow.rs (traits, metadata)
        ├── field.rs (FieldSchema, FieldType)
        ├── log.rs (WorkflowLog events)
        └── lib.rs
        Dependencies: serde only
        
        workflow-manager-sdk/
        ├── executor.rs (local workflow execution)
        ├── discovery.rs (workflow discovery)
        └── lib.rs
        Dependencies: workflow-manager-types, tokio
        
        workflow-manager-api/
        ├── client.rs (HTTP client)
        ├── endpoints.rs
        └── lib.rs
        Dependencies: workflow-manager-types, reqwest, tokio
      
      pros:
        - Maximum separation of concerns
        - Types crate is ultra-stable foundation
        - Zero circular dependency risk
        - SDK and API completely independent
        - Types can be shared with other projects
        - Clear versioning story
        - Runtime-agnostic types
      
      cons:
        - Most complex structure (3 crates)
        - Higher maintenance burden
        - Users must know which crate to import
        - Types crate might be too granular
        - More cognitive overhead
        - Requires discipline to keep types pure
      
      circular_dependency_risk: NONE
      rationale: |
        Perfect dependency tree:
        workflow-manager-types (foundation)
        ├── workflow-manager-sdk → types
        └── workflow-manager-api → types
        
        SDK and API never depend on each other, only on types.
        This is AWS SDK / Smithy pattern.
      
      runtime_implications: |
        - Types: completely runtime-agnostic
        - SDK: can choose runtime abstraction or tokio-specific
        - API: tokio-specific (like most HTTP clients)
        - Maximum flexibility for future runtime changes

  comparative_analysis:
    
    dependency_complexity:
      option_1_extend_sdk:
        user_perspective: Simple (one crate import)
        maintainer_perspective: Simple (one crate to maintain)
        rating: 9/10 simplicity
      
      option_2_new_api_crate:
        user_perspective: Medium (two crate imports if using both)
        maintainer_perspective: Medium (two crates, coordinate releases)
        rating: 7/10 simplicity
      
      option_3_types_separation:
        user_perspective: Complex (must know which crate for what)
        maintainer_perspective: Complex (three crates, version management)
        rating: 5/10 simplicity
    
    circular_dependency_prevention:
      option_1_extend_sdk:
        risk: LOW
        details: SDK is leaf dependency, no circle possible
        best_practice_alignment: Moderate (monolithic approach)
      
      option_2_new_api_crate:
        risk: NONE
        details: Unidirectional SDK ← API dependency
        best_practice_alignment: HIGH (matches SQLx, Tonic patterns)
      
      option_3_types_separation:
        risk: NONE
        details: Types foundation prevents any circular deps
        best_practice_alignment: HIGHEST (matches AWS SDK pattern)
    
    runtime_agnosticism:
      option_1_extend_sdk:
        sdk_runtime_agnostic: NO (becomes tokio-coupled)
        api_runtime_agnostic: N/A (integrated)
        mitigations: Feature flags can make dependencies optional
      
      option_2_new_api_crate:
        sdk_runtime_agnostic: YES (stays pure types/traits)
        api_runtime_agnostic: NO (tokio-coupled is fine for HTTP)
        mitigations: None needed, separation is the solution
      
      option_3_types_separation:
        types_runtime_agnostic: YES (pure types)
        sdk_runtime_agnostic: CHOICE (can be trait-based like SQLx)
        api_runtime_agnostic: NO (tokio-coupled is fine)
        mitigations: Types layer enables maximum flexibility
    
    future_extensibility:
      option_1_extend_sdk:
        adding_grpc_client: Requires bloating SDK further
        adding_websocket_api: More SDK bloat
        supporting_async_std: Difficult, SDK is tokio-coupled
        rating: 4/10 extensibility
      
      option_2_new_api_crate:
        adding_grpc_client: Create workflow-manager-grpc crate
        adding_websocket_api: Add to API crate or new crate
        supporting_async_std: SDK stays agnostic, add api-async-std
        rating: 8/10 extensibility
      
      option_3_types_separation:
        adding_grpc_client: Create workflow-manager-grpc → types
        adding_websocket_api: Create workflow-manager-ws → types
        supporting_async_std: Easy, types are foundation
        rating: 10/10 extensibility
    
    real_world_examples:
      option_1_extend_sdk:
        similar_to: reqwest (monolithic with features)
        works_well_for: Simple, focused libraries with one purpose
        not_ideal_for: Multi-protocol, multi-transport systems
      
      option_2_new_api_crate:
        similar_to: Tonic (tonic + tonic-types + tonic-build)
        works_well_for: Core library + optional client layer
        not_ideal_for: When types and client are inseparable
      
      option_3_types_separation:
        similar_to: AWS SDK (smithy-types + aws-types + services)
        works_well_for: Large ecosystems with many implementations
        not_ideal_for: Small projects with limited scope

  recommendation:
    
    primary_choice: option_2_new_api_crate
    
    rationale: |
      Based on analysis of current structure and Rust ecosystem patterns,
      creating workflow-manager-api as a separate crate is the optimal choice:
      
      1. PRESERVES SDK PURITY
         - workflow-manager-sdk stays focused on types, traits, macros
         - No runtime coupling introduced to SDK
         - SDK remains minimal dependency footprint
      
      2. MATCHES ESTABLISHED PATTERNS
         - Follows Tonic pattern (types + optional client)
         - Aligns with SQLx pattern (core + drivers)
         - Similar to AWS SDK (types + services)
      
      3. PREVENTS CIRCULAR DEPENDENCIES
         - Clear unidirectional flow: SDK → API
         - API depends on SDK for types (never reverse)
         - No risk of circular dependencies
      
      4. RUNTIME FLEXIBILITY
         - SDK can stay runtime-agnostic
         - API can be tokio-specific (like all Rust HTTP clients)
         - Future: add different API implementations per runtime
      
      5. CLEAN VERSIONING
         - SDK can have stable 1.x version
         - API can evolve more rapidly (0.x or 1.x)
         - Breaking API changes don't affect SDK users
      
      6. APPROPRIATE COMPLEXITY
         - Not too simple (option 1 couples concerns)
         - Not too complex (option 3 premature splitting)
         - Right level for current project size
      
      7. FUTURE EXTENSIBILITY
         - Easy to add: workflow-manager-grpc, workflow-manager-ws
         - Easy to add: workflow-manager-server (API server)
         - All depend on SDK, none depend on each other
    
    implementation_plan:
      
      step_1_create_api_crate:
        action: Create workflow-manager-api crate in workspace
        location: /home/molaco/Documents/japanese/workflow-manager-api/
        initial_structure: |
          workflow-manager-api/
          ├── Cargo.toml
          └── src/
              ├── lib.rs
              ├── client.rs (WorkflowApiClient struct)
              ├── endpoints.rs (API routes and methods)
              ├── error.rs (ApiError enum)
              └── types.rs (request/response types)
        
        cargo_toml: |
          [package]
          name = "workflow-manager-api"
          version = "0.1.0"
          edition = "2021"
          description = "HTTP API client for workflow-manager"
          
          [dependencies]
          workflow-manager-sdk = { path = "../workflow-manager-sdk" }
          reqwest = { version = "0.11", features = ["json"] }
          tokio = { version = "1", features = ["rt"] }
          serde = { version = "1", features = ["derive"] }
          serde_json = "1"
          thiserror = "1.0"
          
          [features]
          default = []
          # Future: native-tls vs rustls choice
      
      step_2_define_api_interface:
        action: Define WorkflowApiClient public API
        example_code: |
          // workflow-manager-api/src/client.rs
          use workflow_manager_sdk::{WorkflowMetadata, FullWorkflowMetadata};
          
          pub struct WorkflowApiClient {
              base_url: String,
              client: reqwest::Client,
          }
          
          impl WorkflowApiClient {
              pub fn new(base_url: impl Into<String>) -> Self {
                  Self {
                      base_url: base_url.into(),
                      client: reqwest::Client::new(),
                  }
              }
              
              pub async fn list_workflows(&self) -> Result<Vec<WorkflowMetadata>> { }
              pub async fn get_workflow(&self, id: &str) -> Result<FullWorkflowMetadata> { }
              pub async fn execute_workflow(&self, id: &str, params: serde_json::Value) -> Result<ExecutionId> { }
              pub async fn get_execution_status(&self, exec_id: &ExecutionId) -> Result<ExecutionStatus> { }
          }
      
      step_3_update_sdk_if_needed:
        action: Add any missing types to workflow-manager-sdk
        potential_additions:
          - ExecutionId newtype
          - ExecutionStatus enum
          - WorkflowRequest/WorkflowResponse types
        rationale: |
          API client should use types from SDK for consistency.
          If API needs types not in SDK, add them to SDK (keeps SDK as source of truth).
      
      step_4_update_binary_dependencies:
        action: Update workflow-manager binary to use API crate
        cargo_toml_change: |
          [dependencies]
          workflow-manager-api = { path = "../workflow-manager-api", optional = true }
          
          [features]
          api-client = ["dep:workflow-manager-api"]
        
        rationale: |
          Binary can choose whether to include API client or not.
          For local-only TUI, don't need API client.
          For remote workflow execution, enable api-client feature.
      
      step_5_documentation:
        action: Document architecture decision
        locations:
          - README in workflow-manager-api/
          - Architecture section in main README
          - Doc comments explaining SDK vs API separation
        
        key_points_to_document:
          - When to use SDK (local types, traits, logging)
          - When to use API (remote workflow execution)
          - Dependency relationship (API depends on SDK)
          - Runtime requirements (API requires tokio)
    
    alternative_if_no_remote_api:
      scenario: If API layer is NOT for remote HTTP API
      question: What is the API layer for?
      
      if_websocket_protocol:
        recommendation: Still create separate crate (workflow-manager-ws)
        rationale: Same benefits as HTTP client separation
      
      if_grpc_protocol:
        recommendation: workflow-manager-grpc crate + tonic
        rationale: Follows tonic's own pattern
      
      if_internal_api_abstraction:
        recommendation: Keep in workflow-manager-sdk as traits
        rationale: |
          If "API layer" means internal abstraction (not network protocol),
          then it belongs in SDK as traits. No separate crate needed.
          
          Example: WorkflowExecutor trait with multiple implementations
          (LocalExecutor, RemoteExecutor, MockExecutor) - all in SDK.
      
      if_builder_pattern_api:
        recommendation: Keep in workflow-manager-sdk
        rationale: |
          If "API" means user-facing builder/fluent API for constructing
          workflows, keep it in SDK. It's part of the SDK's purpose.

  tokio_specific_considerations:
    
    current_tokio_usage:
      workflow_manager_binary:
        uses: tokio with features [fs, process, io-util]
        purpose: TUI event loop, process spawning, file I/O
        coupling: Tightly coupled to tokio
      
      claude_agent_sdk:
        uses: tokio with full features
        purpose: Async I/O, subprocess communication, timeouts
        coupling: Tightly coupled to tokio (by design)
      
      workflow_manager_sdk:
        uses: None currently (pure types)
        coupling: Runtime-agnostic
    
    should_sdk_remain_runtime_agnostic:
      answer: YES
      reasons:
        - SDK is currently pure types/traits
        - No implementation logic requiring async runtime
        - Logging macros use eprintln! (sync, no runtime)
        - Re-exports claude-agent-sdk but doesn't depend on its runtime
        - Users might want to use types in non-tokio contexts
      
      exceptions_where_tokio_ok:
        - If SDK adds async WorkflowExecutor implementation
        - If SDK adds async storage backend
        - In these cases: make tokio dependency optional via features
    
    should_api_be_tokio_specific:
      answer: YES
      reasons:
        - All major Rust HTTP clients are tokio-based (reqwest, hyper)
        - All major Rust gRPC libraries are tokio-based (tonic)
        - Entire async Rust ecosystem gravitates toward tokio
        - Runtime abstraction adds complexity with minimal benefit
        - Can always add async-std variant later if needed
      
      precedents:
        - reqwest: tokio-only (even blocking API uses internal tokio)
        - tonic: tokio-only
        - aws-sdk-rust: tokio-only
        - hyper: tokio-only
      
      future_flexibility:
        strategy: If async-std support needed, create workflow-manager-api-async-std
        rationale: Separate crate per runtime is cleaner than trait abstraction
        example: Like tower (tower-layer) vs tower-service split
    
    recommendations:
      - Keep workflow-manager-sdk runtime-agnostic (current state)
      - Make workflow-manager-api explicitly tokio-coupled
      - Document runtime requirements clearly
      - Use feature flags if adding async to SDK
      - Don't prematurely abstract over runtimes (YAGNI)

  final_verdict:
    
    create_workflow_manager_api: YES
    extend_workflow_manager_sdk: NO
    create_types_crate: NOT YET (wait for more complexity)
    
    rationale_summary: |
      CREATE workflow-manager-api as separate crate because:
      
      ✅ Preserves SDK purity (types stay runtime-agnostic)
      ✅ Prevents circular dependencies (unidirectional SDK ← API)
      ✅ Matches Rust ecosystem patterns (Tonic, SQLx, AWS SDK)
      ✅ Enables future extensibility (gRPC, WebSocket, etc.)
      ✅ Appropriate complexity for current project size
      ✅ Clean versioning story (SDK vs API can version independently)
      ✅ Users compile only what they need (types vs types+client)
      
      DO NOT extend workflow-manager-sdk because:
      
      ❌ Would couple SDK to tokio runtime
      ❌ Would bloat SDK dependencies (reqwest, etc.)
      ❌ Would mix concerns (types + network client)
      ❌ Would reduce future flexibility
      ❌ Goes against Rust best practices
      
      DO NOT create types crate yet because:
      
      ⚠️  Premature optimization (SDK is already small)
      ⚠️  Adds maintenance burden for limited benefit
      ⚠️  Can refactor to types crate later if needed
      ⚠️  Current SDK is already mostly types (good state)
    
    action_items:
      - Create workflow-manager-api crate in workspace
      - Define WorkflowApiClient with HTTP methods
      - Keep workflow-manager-sdk as-is (pure types/traits)
      - Document architecture decision in README
      - Add feature flags to binary for optional API client
      - Explicitly document runtime requirements (API = tokio)
    
    success_criteria:
      - workflow-manager-sdk has no tokio dependency
      - workflow-manager-api depends on SDK (unidirectional)
      - No circular dependencies in workspace
      - Users can use SDK without API crate
      - Users can use API crate for remote workflows
      - Clear separation of concerns

  references:
    rust_patterns:
      - "Tokio's evolution from many crates to consolidated tokio crate"
      - "AWS SDK's smithy-types → aws-types → services hierarchy"
      - "SQLx's core traits + driver implementation pattern"
      - "Tonic's types + build + runtime separation"
      - "Reqwest's monolithic-with-features approach"
    
    documentation:
      - "Cargo Book on workspace dependencies"
      - "Rust API Guidelines on crate organization"
      - "Async Book on runtime considerations"
    
    crate_structure_examples:
      aws_sdk: "https://github.com/awslabs/aws-sdk-rust"
      tokio: "https://github.com/tokio-rs/tokio"
      sqlx: "https://github.com/launchbadge/sqlx"
      tonic: "https://github.com/hyperium/tonic"
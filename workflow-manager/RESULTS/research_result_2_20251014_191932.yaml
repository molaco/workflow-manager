research_title: "MCP Server Implementation Patterns in claude-agent-sdk"
date: "2025-10-14"
focus_areas:
  - SdkMcpServer architecture
  - SdkMcpTool registration and invocation
  - McpServerConfig patterns
  - Async execution model
  - Error handling patterns
  - Integration with ClaudeSDKClient

findings:

  core_architecture:
    summary: "MCP servers are in-process, async, JSONRPC-based tool providers with automatic Claude integration"
    
    sdk_mcp_server:
      location: "claude-agent-sdk-rust/src/mcp/server.rs"
      purpose: "In-process MCP server hosting custom tools without subprocess overhead"
      key_components:
        - name: "String (server name)"
        - version: "String (server version)"
        - tools: "HashMap<String, SdkMcpTool> (tool registry)"
      
      builder_pattern:
        - "SdkMcpServer::new(name) - creates server"
        - ".version(ver) - sets version (default: 1.0.0)"
        - ".tool(tool) - registers single tool"
        - ".tools(vec) - registers multiple tools"
      
      protocol_methods:
        initialize:
          method: "initialize"
          returns: "protocolVersion, serverInfo, capabilities"
          location: "src/mcp/server.rs:185-199"
        
        notifications_initialized:
          method: "notifications/initialized"
          returns: "acknowledgement"
          location: "src/mcp/server.rs:202-206"
        
        tools_list:
          method: "tools/list"
          returns: "array of tool metadata (name, description, inputSchema)"
          location: "src/mcp/server.rs:209-218"
        
        tools_call:
          method: "tools/call"
          params: "name (string), arguments (JSON object)"
          returns: "ToolResult with content array and optional is_error"
          validation: "Pre-compiled JSONSchema validation before invocation"
          location: "src/mcp/server.rs:221-281"

    sdk_mcp_tool:
      location: "claude-agent-sdk-rust/src/mcp/tool.rs"
      purpose: "Individual tool definition with async handler"
      
      structure:
        name: "String - unique tool identifier"
        description: "String - human-readable description"
        input_schema: "serde_json::Value - JSON schema for parameters"
        compiled_schema: "Option<JSONSchema> - pre-compiled validator"
        handler: "ToolHandler - Arc<dyn Fn(Value) -> Future<Result<ToolResult>>>"
      
      handler_signature:
        type: "async fn(serde_json::Value) -> Result<ToolResult>"
        constraints: "Send + Sync + 'static"
        execution: "Box::pin(async move { ... })"
        
      validation:
        approach: "Pre-compilation of JSON schema at tool creation"
        method: "validate_input(&input) - validates before invocation"
        location: "src/mcp/tool.rs:136-144"
        error_type: "ClaudeError::ValidationError"
      
      creation_example:
        pattern: |
          SdkMcpTool::new(
              "tool_name",
              "Tool description",
              json!({
                  "type": "object",
                  "properties": { "param": {"type": "string"} },
                  "required": ["param"]
              }),
              |input| Box::pin(async move {
                  let param = input["param"].as_str().unwrap_or("");
                  Ok(ToolResult::text(format!("Result: {}", param)))
              })
          )
        location: "examples/mcp_demo.rs:67-94"

    tool_result_types:
      location: "claude-agent-sdk-rust/src/mcp/tool.rs:166-230"
      
      tool_result:
        structure:
          content: "Vec<ToolContent> - array of content blocks"
          is_error: "Option<bool> - error flag"
        
        constructors:
          text: "ToolResult::text(string) - success with text"
          error: "ToolResult::error(string) - error with text"
          custom: "ToolResult { content, is_error }"
      
      tool_content:
        variants:
          text:
            format: "Text { text: String }"
          image:
            format: "Image { data: String, mime_type: String }"
            note: "base64 encoded image data"
        
        serialization: "Tagged enum with type field (lowercase)"

  configuration_and_registration:
    
    mcp_server_config:
      location: "claude-agent-sdk-rust/src/types.rs:433-442"
      enum_variants:
        stdio: "McpStdioServerConfig - subprocess with stdio"
        sse: "McpSseServerConfig - Server-Sent Events"
        http: "McpHttpServerConfig - HTTP endpoints"
        sdk: "SdkMcpServerMarker - in-process server"
      
      sdk_marker:
        location: "src/types.rs:423-429"
        fields:
          name: "String - server name"
          instance: "Arc<SdkMcpServer> - shared server instance"
        purpose: "Wraps SDK server for registration in ClaudeAgentOptions"
    
    registration_pattern:
      location: "examples/mcp_integration_demo.rs:78-104"
      steps:
        create_server: |
          let server = SdkMcpServer::new("name")
              .version("1.0.0")
              .tool(tool1)
              .tool(tool2);
        
        wrap_in_arc: "let server_arc = Arc::new(server);"
        
        register_config: |
          let mut mcp_servers = HashMap::new();
          mcp_servers.insert(
              "server_key".to_string(),
              McpServerConfig::Sdk(SdkMcpServerMarker {
                  name: "server_key".to_string(),
                  instance: server_arc,
              })
          );
        
        create_options: |
          let options = ClaudeAgentOptions {
              mcp_servers: McpServers::Dict(mcp_servers),
              allowed_tools: vec![
                  ToolName::new("mcp__server_key__tool1"),
                  ToolName::new("mcp__server_key__tool2"),
              ],
              ...
          };
    
    tool_naming_convention:
      pattern: "mcp__{server_name}__{tool_name}"
      example: "mcp__calculator__add"
      location: "examples/test2.rs:96"
      wildcard: "mcp__{server_name}__* allows all tools from server"

  integration_with_client:
    
    client_extraction:
      location: "claude-agent-sdk-rust/src/client/mod.rs:266-279"
      process: |
        // Extract SDK MCP servers from ClaudeAgentOptions
        if let McpServers::Dict(ref servers) = options.mcp_servers {
            servers.iter()
                .filter_map(|(name, config)| {
                    if let McpServerConfig::Sdk(marker) = config {
                        Some((name.clone(), marker.instance.clone()))
                    } else {
                        None
                    }
                })
                .collect::<HashMap<_, _>>()
        }
      
      storage: "HashMap<String, Arc<SdkMcpServer>> stored in ClaudeSDKClient"
      lifecycle: "Kept alive via #[allow(dead_code)] field for background tasks"
    
    request_handling:
      location: "claude-agent-sdk-rust/src/client/mod.rs:750-820"
      trigger: "MCP request from control protocol"
      
      flow:
        lookup_server: "Find server by name in sdk_mcp_servers HashMap"
        convert_request: "Convert control protocol request to JsonRpcRequest"
        invoke: "await server.handle_request(jsonrpc_request)"
        convert_response: "Serialize JsonRpcResponse to JSON"
        send_callback: "Send response via MCP callback channel"
      
      key_code: |
        // src/client/mod.rs:789
        match server.handle_request(jsonrpc_request.clone()).await {
            Ok(jsonrpc_response) => {
                let response_json = serde_json::to_value(&jsonrpc_response)?;
                // Send via protocol.send_mcp_callback_response()
            }
            Err(e) => {
                // Return error response
            }
        }
    
    background_task:
      purpose: "Handle MCP requests asynchronously"
      location: "src/client/mod.rs:750-820"
      channel: "mcp_callback_rx receives (RequestId, server_name, params)"
      concurrency: "tokio::spawn for non-blocking execution"

  async_execution_model:
    
    handler_execution:
      type: "Fully async with Box::pin"
      signature: "Pin<Box<dyn Future<Output = Result<ToolResult>> + Send>>"
      location: "src/mcp/mod.rs:100-104"
      
      invocation:
        location: "src/mcp/tool.rs:129-131"
        code: "(self.handler)(input).await"
        note: "Direct async call, no blocking"
    
    concurrency:
      server_level: "SdkMcpServer is Send + Sync via Arc wrapping"
      tool_level: "ToolHandler is Send + Sync + 'static"
      client_level: "Background task handles requests concurrently"
      
    no_blocking:
      benefit: "No subprocess overhead, no IPC serialization"
      performance: "In-process async execution"
      debugging: "Full stack traces available"

  error_handling:
    
    validation_errors:
      location: "src/mcp/server.rs:261-266"
      phase: "Pre-invocation"
      response: "JsonRpcResponse::error with McpError::invalid_params"
      
    tool_execution_errors:
      location: "src/mcp/server.rs:276-279"
      response: "McpError::internal_error with error message"
      propagation: "Wrapped in JsonRpcResponse, not panicking"
    
    error_types:
      location: "src/mcp/protocol.rs:59-107"
      variants:
        method_not_found: "code: -32601"
        invalid_params: "code: -32602"
        internal_error: "code: -32603"
        tool_not_found: "code: -32001 (custom)"
      
    tool_result_errors:
      location: "src/mcp/tool.rs:204-209"
      pattern: "ToolResult::error(message)"
      structure: "is_error: Some(true), content: [Text { text: error_msg }]"
      note: "Error is in result, not in JSON-RPC error field"

  protocol_implementation:
    
    jsonrpc_structure:
      location: "claude-agent-sdk-rust/src/mcp/protocol.rs"
      
      request:
        fields:
          jsonrpc: "String - always '2.0'"
          id: "Option<Value> - request ID"
          method: "String - method name"
          params: "Option<Value> - parameters"
      
      response:
        fields:
          jsonrpc: "String - always '2.0'"
          id: "Value - matching request ID"
          result: "Option<Value> - success result"
          error: "Option<McpError> - error details"
    
    request_dispatch:
      location: "src/mcp/server.rs:169-182"
      routing:
        - "initialize -> handle_initialize"
        - "notifications/initialized -> handle_notifications_initialized"
        - "tools/list -> handle_tools_list"
        - "tools/call -> handle_tools_call"
        - "* -> method_not_found error"

  recommended_patterns_for_workflows:
    
    tool_organization:
      approach: "Single SdkMcpServer per logical domain"
      example: "workflow_manager server with execute, pause, resume, status tools"
      benefit: "Natural grouping, shared state possible via Arc<Mutex<State>>"
    
    state_management:
      pattern: |
        let state = Arc::new(Mutex::new(WorkflowState::new()));
        let state_clone = state.clone();
        
        let tool = SdkMcpTool::new("execute", "...", schema, move |input| {
            let state = state_clone.clone();
            Box::pin(async move {
                let mut s = state.lock().await;
                // ... use state ...
                Ok(ToolResult::text("done"))
            })
        });
      location: "Pattern observed in examples"
    
    error_handling:
      approach: "Return ToolResult::error for domain errors, propagate system errors"
      example: |
        if workflow_not_found {
            return Ok(ToolResult::error("Workflow not found"));
        }
        
        match execute_workflow().await {
            Ok(result) => Ok(ToolResult::text(result)),
            Err(e) => Ok(ToolResult::error(format!("Execution failed: {}", e)))
        }
    
    schema_design:
      recommendation: "Strict JSON schemas with required fields"
      validation: "Automatic via pre-compiled JSONSchema"
      benefit: "Claude receives clear validation errors"
    
    tool_naming:
      convention: "Verb-based names: execute_workflow, pause_workflow, get_status"
      description: "Clear, action-oriented descriptions"
      parameters: "Self-documenting parameter names with descriptions"
    
    integration_checklist:
      - "Create tools with SdkMcpTool::new"
      - "Register tools with .tool() or .tools()"
      - "Wrap server in Arc<SdkMcpServer>"
      - "Create SdkMcpServerMarker with instance"
      - "Add to McpServers::Dict in ClaudeAgentOptions"
      - "Add tool patterns to allowed_tools (mcp__server__*)"
      - "Handle async state access with Arc<Mutex<T>>"
      - "Return ToolResult::text or ToolResult::error"

  key_file_locations:
    mcp_module: "claude-agent-sdk-rust/src/mcp/mod.rs"
    server_impl: "claude-agent-sdk-rust/src/mcp/server.rs"
    tool_impl: "claude-agent-sdk-rust/src/mcp/tool.rs"
    protocol: "claude-agent-sdk-rust/src/mcp/protocol.rs"
    types: "claude-agent-sdk-rust/src/types.rs:381-442"
    client_integration: "claude-agent-sdk-rust/src/client/mod.rs:266-279, 750-820"
    
  example_references:
    basic_demo: "examples/mcp_demo.rs - standalone server demo"
    integration_demo: "examples/mcp_integration_demo.rs - Claude integration"
    test_tools: "examples/test_mcp_tools.rs - calculator example"
    advanced: "examples/test2.rs - with hooks, config loading"

implementation_recommendations:
  
  for_workflow_manager:
    server_name: "workflow_manager"
    
    tools:
      - name: "execute_workflow"
        description: "Execute a workflow by name or ID"
        params: "workflow_id: string, inputs: object"
        
      - name: "list_workflows"
        description: "List all available workflows"
        params: "filter: optional string"
        
      - name: "get_workflow_status"
        description: "Get execution status of a workflow"
        params: "execution_id: string"
        
      - name: "pause_workflow"
        description: "Pause a running workflow"
        params: "execution_id: string"
        
      - name: "resume_workflow"
        description: "Resume a paused workflow"
        params: "execution_id: string"
    
    state_approach: |
      Arc<Mutex<WorkflowManager>> shared across all tools
      Each tool handler clones Arc and locks when needed
      
    error_strategy: |
      Domain errors: ToolResult::error("user-friendly message")
      System errors: propagate via Result::Err
      
    registration: |
      Create server with all tools
      Wrap in Arc, register as McpServerConfig::Sdk
      Add "mcp__workflow_manager__*" to allowed_tools

notes:
  - "SDK MCP servers run in-process, no subprocess overhead"
  - "Tools are async, support concurrent execution"
  - "Validation happens automatically via pre-compiled JSON schemas"
  - "Error handling uses JSONRPC error responses + ToolResult.is_error"
  - "Registration requires Arc wrapping and SdkMcpServerMarker"
  - "Tool names follow mcp__{server}__{tool} convention"
  - "Client handles MCP requests in background task"
  - "State sharing via Arc<Mutex<T>> in closures"
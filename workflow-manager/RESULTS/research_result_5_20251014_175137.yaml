workflow_execution_analysis:
  timestamp: "2025-10-14T17:50:18Z"
  
  execution_models:
    process_based:
      description: "Workflows execute as separate OS processes spawned by TUI"
      implementation:
        location: "src/main.rs:500-560"
        method: "std::process::Command"
        stdio_configuration:
          stdin: "null"
          stdout: "piped"
          stderr: "piped"
      workflow_binary_pattern: "../target/debug/<workflow_id>"
      examples:
        - "simple_echo.rs - Basic stdout logging"
        - "demo_multiphase.rs - Hierarchical phase/task/agent logging"
        - "hooks_demo.rs - In-process SDK client with hooks"
        - "research_agent.rs - Complex multi-phase with concurrent execution"
    
    in_process_agent:
      description: "Workflows use claude-agent-sdk for in-process LLM interaction"
      implementation:
        location: "src/bin/hooks_demo.rs:52-285"
        sdk: "claude-agent-sdk (path = ../claude-agent-sdk-rust)"
        client_type: "ClaudeSDKClient"
      features:
        - "Bidirectional streaming communication with Claude"
        - "Hook system for intercepting tool calls"
        - "Permission control via callbacks"
        - "SDK MCP server for custom tools"
      examples:
        - "hooks_demo.rs - Validates bash commands, blocks dangerous operations"
        - "simple_query.rs - One-shot query with streaming response"
        - "research_agent.rs - Concurrent multi-agent orchestration"

  state_management:
    workflow_phases:
      structure: "Hierarchical: Phase -> Task -> Agent"
      types:
        phase:
          fields:
            - "id: usize"
            - "name: String"
            - "status: PhaseStatus"
            - "tasks: Vec<WorkflowTask>"
            - "output_files: Vec<(String, String)>"
          status_enum:
            - "NotStarted"
            - "Running"
            - "Completed"
            - "Failed"
        task:
          fields:
            - "id: String"
            - "phase: usize"
            - "description: String"
            - "status: TaskStatus"
            - "agents: Vec<WorkflowAgent>"
            - "messages: Vec<String>"
          status_enum:
            - "NotStarted"
            - "Running"
            - "Completed"
            - "Failed"
        agent:
          fields:
            - "id: String"
            - "task_id: String"
            - "name: String"
            - "description: String"
            - "status: AgentStatus"
            - "messages: Vec<String>"
          status_enum:
            - "NotStarted"
            - "Running"
            - "Completed"
            - "Failed"
    
    per_tab_state:
      location: "src/main.rs:88-118"
      fields:
        identity:
          - "id: String"
          - "workflow_idx: usize"
          - "workflow_name: String"
          - "instance_number: usize"
          - "start_time: Option<DateTime>"
        execution:
          - "status: WorkflowStatus"
          - "child_process: Option<std::process::Child>"
          - "exit_code: Option<i32>"
        data:
          - "workflow_phases: Arc<Mutex<Vec<WorkflowPhase>>>"
          - "workflow_output: Arc<Mutex<Vec<String>>>"
          - "field_values: HashMap<String, String>"
        ui:
          - "scroll_offset: usize"
          - "expanded_phases: HashSet<usize>"
          - "expanded_tasks: HashSet<String>"
    
    session_persistence:
      location: "src/main.rs:228-326"
      saved_data:
        - "workflow_idx and instance_number"
        - "field_values for workflow re-execution"
        - "saved_logs (completed workflows only)"
        - "status (NotStarted/Completed/Failed)"
      storage_path: "~/.local/share/workflow-manager/session.json"
      restoration: "Automatic on app startup, creates tabs from previous session"

  log_capture_mechanism:
    structured_logging:
      protocol: "__WF_EVENT__:<JSON>"
      stream: "stderr"
      format: "JSON-serialized WorkflowLog enum"
      parser_location: "src/main.rs:536-547"
    
    event_types:
      location: "workflow-manager-sdk/src/lib.rs:119-191"
      variants:
        - "PhaseStarted {phase, name, total_phases}"
        - "PhaseCompleted {phase, name}"
        - "PhaseFailed {phase, name, error}"
        - "TaskStarted {phase, task_id, description, total_tasks}"
        - "TaskProgress {task_id, message}"
        - "TaskCompleted {task_id, result}"
        - "TaskFailed {task_id, error}"
        - "AgentStarted {task_id, agent_name, description}"
        - "AgentMessage {task_id, agent_name, message}"
        - "AgentCompleted {task_id, agent_name, result}"
        - "AgentFailed {task_id, agent_name, error}"
        - "StateFileCreated {phase, file_path, description}"
    
    emission_method:
      location: "workflow-manager-sdk/src/lib.rs:193-200"
      implementation: "impl WorkflowLog { pub fn emit(&self) { if let Ok(json) = serde_json::to_string(self) { eprintln!(\"__WF_EVENT__:{}\", json); } } }"
    
    convenience_macros:
      location: "workflow-manager-sdk/src/lib.rs:203-366"
      available:
        - "log_phase_start!(phase, name, total)"
        - "log_phase_complete!(phase, name)"
        - "log_task_start!(phase, task_id, desc)"
        - "log_task_progress!(task_id, msg)"
        - "log_task_complete!(task_id, result)"
        - "log_agent_start!(task_id, agent, desc)"
        - "log_agent_message!(task_id, agent, msg)"
        - "log_agent_complete!(task_id, agent, result)"
        - "log_state_file!(phase, path, desc)"
    
    output_streams:
      stdout:
        purpose: "Human-readable output and regular logging"
        capture: "Arc<Mutex<Vec<String>>> shared via thread"
        reader_location: "src/main.rs:512-524"
        display: "Rendered in tab UI panel"
      stderr:
        purpose: "Structured events (__WF_EVENT__) and error messages"
        capture: "Parsed by dedicated thread, non-event lines prefixed with 'ERROR:'"
        parser_location: "src/main.rs:527-547"
        processing: "JSON events update workflow_phases, other output goes to workflow_output"

  process_lifecycle_control:
    spawning:
      location: "src/main.rs:500-560"
      mechanism: "std::process::Command with piped stdio"
      thread_model: "Two dedicated threads per workflow: stdout reader + stderr parser"
      shared_state: "Arc<Mutex<>> for thread-safe access to output and phases"
    
    monitoring:
      method: "poll_all_tabs() called on each event loop iteration"
      location: "src/main.rs:637-699"
      check: "child.try_wait() - non-blocking status check"
      status_transitions:
        - "Running -> Completed (exit code 0)"
        - "Running -> Failed (non-zero exit code)"
        - "Running -> Failed (process error)"
    
    cancellation:
      user_initiated:
        - "Press 'K' in Tabs view to kill current workflow"
        - "Close tab with confirmation if running (Ctrl+W)"
      implementation: "child.kill() - SIGKILL on Unix, TerminateProcess on Windows"
      locations:
        - "kill_current_tab(): src/main.rs:424-439"
        - "close_tab_confirmed(): src/main.rs:399-422"
        - "rerun_current_tab(): src/main.rs:441-560 (kills before rerun)"
    
    cleanup:
      automatic: "Process handle dropped when tab closed"
      thread_cleanup: "Threads exit when stdout/stderr reach EOF"
      session_save: "Completed/Failed workflows saved to session.json on exit"

  execution_trade_offs:
    process_based:
      advantages:
        - "Process isolation - crashes don't affect TUI"
        - "Resource accounting via OS (memory, CPU)"
        - "Easy to kill/restart workflows"
        - "Parallel execution in separate tabs"
        - "Standard CLI binary interface"
      disadvantages:
        - "IPC overhead (pipes, JSON serialization)"
        - "Cannot share in-memory state"
        - "Binary compilation required for each workflow"
        - "Harder to debug (separate process)"
    
    library_based:
      advantages:
        - "Direct function calls - no IPC overhead"
        - "Shared memory and state"
        - "Easier debugging (same process)"
        - "Dynamic workflow loading possible"
        - "Fine-grained control over execution"
      disadvantages:
        - "No process isolation - panics crash TUI"
        - "Harder to cancel (need cooperative cancellation)"
        - "Resource limits require explicit tracking"
        - "Workflow bugs affect TUI stability"

  resource_controls:
    current_implementation:
      sandboxing: "None - workflows run with same privileges as TUI"
      resource_limits: "None - OS-level limits only"
      max_turns:
        location: "claude-agent-sdk-rust/src/types.rs:800-808"
        limit: "1000 turns maximum (validated at build time)"
        purpose: "Prevent infinite agent loops"
      buffer_limits:
        location: "claude-agent-sdk-rust/src/transport/subprocess.rs:100"
        default: "1MB (DEFAULT_MAX_BUFFER_SIZE)"
        purpose: "Prevent memory exhaustion from large JSON messages"
      timeouts:
        read_timeout:
          location: "claude-agent-sdk-rust/src/transport/subprocess.rs:543-545"
          duration: "300 seconds (5 minutes)"
          purpose: "Prevent hanging on slow/blocked reads"
        graceful_shutdown:
          location: "claude-agent-sdk-rust/src/transport/subprocess.rs:653-655"
          duration: "5 seconds"
          purpose: "Wait for process exit before SIGKILL"
    
    security_features:
      environment_filtering:
        dangerous_vars:
          - "LD_PRELOAD"
          - "PATH"
          - "NODE_OPTIONS"
        enforcement: "Blocked at subprocess spawn"
      argument_validation:
        method: "Allowlist of CLI flags"
        location: "claude-agent-sdk-rust/src/transport/subprocess.rs:34-38"
        allowed:
          - "timeout"
          - "retries"
          - "log-level"
          - "debug"
          - "verbose"

  api_design_considerations:
    dual_execution_support:
      recommendation: "Support both process-based and library-based execution"
      rationale:
        - "Process-based for production (isolation, reliability)"
        - "Library-based for development (debugging, testing)"
        - "Trait-based abstraction for unified interface"
      proposed_trait: "trait WorkflowExecutor { async fn execute(&mut self, params: WorkflowParams) -> Result<WorkflowResult>; async fn cancel(&mut self) -> Result<()>; fn status(&self) -> WorkflowStatus; fn logs(&self) -> impl Stream<Item = WorkflowLog>; }"
    
    sandboxing_strategy:
      current: "None - full OS privileges"
      future_options:
        linux:
          - "seccomp-bpf syscall filtering"
          - "cgroups for CPU/memory limits"
          - "namespaces for filesystem isolation"
          - "landlock for file access restrictions"
        cross_platform:
          - "WASM sandbox for untrusted workflows"
          - "Resource limits via rlimit crate"
          - "Filesystem access via permission callbacks"
    
    cancellation_model:
      current: "Forceful (SIGKILL)"
      future_enhancements:
        - "Graceful cancellation with timeout (SIGTERM -> SIGKILL)"
        - "Cancellation tokens for library-based execution"
        - "Checkpoint/resume for long-running workflows"
        - "Progress preservation on cancel"

  workflow_discovery:
    mechanism: "Query binaries with --workflow-metadata flag"
    location: "src/discovery.rs:120-124"
    metadata_format: "JSON (FullWorkflowMetadata)"
    binary_scan: "Checks ../target/debug/* for workflow binaries"
    caching: "In-memory only, rescans on startup"

  integration_points:
    tui_to_workflow:
      - "Command-line argument construction from field_values"
      - "Process spawning with piped stdio"
      - "Threaded stdout/stderr readers"
      - "Polling for exit status"
    
    workflow_to_tui:
      - "Structured events via stderr (__WF_EVENT__)"
      - "Human-readable logs via stdout"
      - "Exit code for success/failure"
      - "State files referenced in events"
    
    workflow_to_sdk:
      - "ClaudeSDKClient for agent interactions"
      - "Hooks for intercepting tool calls"
      - "Permission callbacks for access control"
      - "MCP servers for custom tools"

  real_world_examples:
    simple_echo:
      execution: "Process-based"
      features:
        - "Basic stdout logging"
        - "No structured events"
        - "Sleep delays for UX"
      complexity: "Low"
    
    demo_multiphase:
      execution: "Process-based"
      features:
        - "3 phases"
        - "Multiple tasks per phase"
        - "Nested agents"
        - "State files"
        - "Full structured logging"
      complexity: "Medium"
      location: "src/bin/demo_multiphase.rs"
    
    hooks_demo:
      execution: "In-process SDK client"
      features:
        - "Dangerous command blocking"
        - "Audit logging"
        - "Multiple hooks per event"
        - "Tool-specific matchers"
      complexity: "Medium"
      location: "src/bin/hooks_demo.rs"
    
    research_agent:
      execution: "Process-based with in-process SDK"
      features:
        - "5 phases"
        - "Concurrent execution"
        - "YAML validation"
        - "File I/O"
        - "External process calls"
        - "Retry logic"
      complexity: "High"
      location: "src/bin/research_agent.rs"
      concurrent_operations:
        - "Phase 2: Concurrent research prompts (configurable batch_size)"
        - "Phase 3: Concurrent YAML validation and fixing"
      phases:
        0: "Codebase analysis (file scanning, structure mapping)"
        1: "Prompt generation (LLM-based)"
        2: "Research execution (concurrent LLM queries)"
        3: "YAML validation and repair (concurrent fixing)"
        4: "Documentation synthesis (final output)"

recommendations:
  api_design:
    - "Expose both ProcessExecutor and LibraryExecutor implementations"
    - "Provide WorkflowExecutor trait for abstraction"
    - "Support streaming log events via async Stream"
    - "Include cancellation tokens in API"
    - "Add progress tracking with checkpointing"
  
  resource_management:
    - "Implement cgroup-based CPU/memory limits on Linux"
    - "Add rlimit-based limits for cross-platform support"
    - "Provide configurable timeout per workflow"
    - "Support workflow-level resource budgets"
  
  sandboxing:
    - "Short-term: Permission callbacks for filesystem access"
    - "Medium-term: landlock/pledge for file access restrictions"
    - "Long-term: WASM sandbox for untrusted workflows"
  
  cancellation:
    - "Implement graceful cancellation (SIGTERM with fallback)"
    - "Add cooperative cancellation for library-based execution"
    - "Support cancellation callbacks for cleanup"
    - "Preserve partial results on cancellation"
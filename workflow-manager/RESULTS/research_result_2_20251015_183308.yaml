mcp_server_implementation_analysis:
  overview: |
    The claude-agent-sdk crate implements an in-process MCP (Model Context Protocol) server
    system that allows custom tools to be registered and invoked by Claude without subprocess
    overhead. The implementation follows a builder pattern with async execution and JSONRPC protocol.

  core_types:
    SdkMcpServer:
      location: ../claude-agent-sdk-rust/src/mcp/server.rs
      description: Container for MCP server with registered tools
      fields:
        - name: String (server identifier)
        - version: String (server version)
        - tools: HashMap<String, SdkMcpTool> (registered tools by name)
      builder_methods:
        - "new(name) -> Self"
        - "version(version) -> Self"
        - "tool(tool) -> Self"
        - "tools(vec) -> Self"
      key_methods:
        - "handle_request(&self, JsonRpcRequest) -> Result<JsonRpcResponse>"
        - "get_tool(&self, name) -> Option<&SdkMcpTool>"
        - "list_tools(&self) -> Vec<&SdkMcpTool>"
      jsonrpc_methods_handled:
        - "initialize": Returns server info and capabilities
        - "notifications/initialized": Acknowledges initialization
        - "tools/list": Returns list of available tools
        - "tools/call": Invokes a specific tool with validation

    SdkMcpTool:
      location: ../claude-agent-sdk-rust/src/mcp/tool.rs
      description: Individual tool definition with async handler
      fields:
        - name: String (unique tool identifier)
        - description: String (human-readable description)
        - input_schema: serde_json::Value (JSON schema for validation)
        - compiled_schema: Option<JSONSchema> (pre-compiled validator)
        - handler: ToolHandler (async function for execution)
      constructor:
        signature: |
          pub fn new<F, Fut>(
              name: impl Into<String>,
              description: impl Into<String>,
              input_schema: serde_json::Value,
              handler: F
          ) -> Self
          where
              F: Fn(serde_json::Value) -> Fut + Send + Sync + 'static,
              Fut: Future<Output = Result<ToolResult>> + Send + 'static
      key_methods:
        - "invoke(&self, input: Value) -> Result<ToolResult>"
        - "validate_input(&self, input: &Value) -> Result<()>"
        - "to_tool_info(&self) -> Value" (for tools/list response)

    ToolHandler:
      location: ../claude-agent-sdk-rust/src/mcp/mod.rs:100-104
      type_alias: |
        Arc<dyn Fn(serde_json::Value) 
          -> Pin<Box<dyn Future<Output = Result<ToolResult>> + Send>>
          + Send + Sync>
      description: |
        Type-erased async function that processes tool inputs.
        Must be Send + Sync + 'static for concurrent invocation.

    ToolResult:
      location: ../claude-agent-sdk-rust/src/mcp/tool.rs:166-210
      description: Result returned by tool handlers
      fields:
        - content: Vec<ToolContent> (output content blocks)
        - is_error: Option<bool> (error flag)
      convenience_methods:
        - "ToolResult::text(text) -> Self" (creates text result)
        - "ToolResult::error(text) -> Self" (creates error result with is_error=true)

    ToolContent:
      location: ../claude-agent-sdk-rust/src/mcp/tool.rs:212-229
      description: Content block in tool result
      variants:
        Text:
          fields:
            - text: String
        Image:
          fields:
            - data: String (base64 encoded)
            - mime_type: String (e.g., "image/png")
      serialization: Tagged enum with type field (lowercase)

  registration_pattern:
    McpServerConfig:
      location: ../claude-agent-sdk-rust/src/types.rs:433-442
      enum_variants:
        - Stdio(McpStdioServerConfig): External subprocess via stdio
        - Sse(McpSseServerConfig): Server-Sent Events transport
        - Http(McpHttpServerConfig): HTTP-based MCP server
        - Sdk(SdkMcpServerMarker): In-process SDK server
      
    SdkMcpServerMarker:
      location: ../claude-agent-sdk-rust/src/types.rs:423-429
      fields:
        - name: String (server identifier)
        - instance: Arc<SdkMcpServer> (actual server instance)
      purpose: |
        Wrapper to hold SDK MCP server instance in McpServerConfig enum.
        Arc allows shared ownership across async tasks.

    ClaudeAgentOptions:
      mcp_servers_field: McpServers (enum: None, Dict, String)
      registration_example: |
        let mut mcp_servers = HashMap::new();
        mcp_servers.insert(
            "workflow_manager".to_string(),
            McpServerConfig::Sdk(SdkMcpServerMarker {
                name: "workflow_manager".to_string(),
                instance: Arc::new(mcp_server),
            })
        );
        let options = ClaudeAgentOptions {
            mcp_servers: McpServers::Dict(mcp_servers),
            allowed_tools: vec![
                ToolName::new("mcp__workflow_manager__list_workflows"),
                // ... other tools
            ],
            ..Default::default()
        };

    tool_naming_convention:
      pattern: "mcp__{server_name}__{tool_name}"
      example: "mcp__workflow_manager__execute_workflow"
      purpose: Namespaces tools to prevent collisions between servers

  async_execution_model:
    handler_signature: |
      |input: serde_json::Value| -> impl Future<Output = Result<ToolResult>> + Send
    
    execution_flow:
      - Claude requests tool via tools/call JSONRPC method
      - SdkMcpServer.handle_request() receives JsonRpcRequest
      - Request routed to handle_tools_call()
      - Tool name extracted from params
      - Tool looked up in HashMap
      - Input validated against compiled JSON schema
      - tool.invoke() called with arguments
      - Handler closure executed asynchronously
      - ToolResult serialized to JSON
      - JsonRpcResponse returned to Claude

    concurrency:
      - Tools handlers must be Send + Sync + 'static
      - Multiple tools can be invoked concurrently
      - Arc wrapping allows shared server across tasks
      - No explicit locks in SDK (user responsible for thread safety in handlers)

  error_handling:
    validation_errors:
      location: SdkMcpTool.validate_input()
      mechanism: Pre-compiled JSONSchema validation
      on_failure: Returns ClaudeError::ValidationError with details
      
    tool_execution_errors:
      handler_returns: Result<ToolResult>
      error_conversion: |
        match tool.invoke(args).await {
            Ok(result) => JsonRpcResponse::success(request_id, result),
            Err(e) => JsonRpcResponse::error(
                request_id,
                McpError::internal_error(format!("Tool execution failed: {e}"))
            )
        }
    
    explicit_error_results:
      method: ToolResult::error(message)
      effect: Sets is_error=Some(true) in result
      handling: Claude receives successful JSONRPC response but content indicates error

    jsonrpc_errors:
      location: ../claude-agent-sdk-rust/src/mcp/protocol.rs:59-107
      standard_codes:
        - "-32601": Method not found
        - "-32602": Invalid params
        - "-32603": Internal error
        - "-32001": Tool not found (custom)
      structure:
        - code: i32
        - message: String
        - data: Option<Value>

  protocol_implementation:
    jsonrpc_version: "2.0"
    transport: In-process function calls (no IPC)
    
    JsonRpcRequest:
      location: ../claude-agent-sdk-rust/src/mcp/protocol.rs:8-20
      fields:
        - jsonrpc: String ("2.0")
        - id: Option<Value> (None for notifications)
        - method: String (e.g., "tools/call")
        - params: Option<Value>
    
    JsonRpcResponse:
      location: ../claude-agent-sdk-rust/src/mcp/protocol.rs:23-57
      fields:
        - jsonrpc: String ("2.0")
        - id: Value (matches request)
        - result: Option<Value> (on success)
        - error: Option<McpError> (on failure)

  integration_examples:
    basic_tool_creation:
      file: ../claude-agent-sdk-rust/examples/mcp_demo.rs:67-94
      pattern: |
        let tool = SdkMcpTool::new(
            "add",
            "Add two numbers together",
            json!({
                "type": "object",
                "properties": {
                    "a": {"type": "number"},
                    "b": {"type": "number"}
                },
                "required": ["a", "b"]
            }),
            |input| Box::pin(async move {
                let a = input["a"].as_f64().unwrap_or(0.0);
                let b = input["b"].as_f64().unwrap_or(0.0);
                let result = a + b;
                Ok(ToolResult::text(format!("{} + {} = {}", a, b, result)))
            })
        );

    server_creation:
      file: ../claude-agent-sdk-rust/examples/mcp_demo.rs:159-164
      pattern: |
        let server = SdkMcpServer::new("calculator")
            .version("1.0.0")
            .tool(add_tool)
            .tool(multiply_tool)
            .tool(divide_tool);

    workflow_manager_implementation:
      file: src/mcp_tools.rs
      pattern: |
        pub fn create_workflow_mcp_server(runtime: Arc<dyn WorkflowRuntime>) -> SdkMcpServer {
            SdkMcpServer::new("workflow_manager")
                .version("1.0.0")
                .tool(list_workflows_tool(runtime.clone()))
                .tool(execute_workflow_tool(runtime.clone()))
                .tool(get_workflow_logs_tool(runtime.clone()))
                .tool(get_workflow_status_tool(runtime.clone()))
                .tool(cancel_workflow_tool(runtime))
        }
      
      tool_example:
        location: src/mcp_tools.rs:42-86
        demonstrates:
          - Closure capturing runtime Arc
          - Async execution with runtime methods
          - Parameter extraction and validation
          - Error handling with ToolResult::error()
          - JSON serialization of results

    chat_interface_integration:
      file: src/chat.rs:70-110
      key_steps:
        - Create MCP server with runtime
        - Wrap in Arc<SdkMcpServer>
        - Create SdkMcpServerMarker
        - Insert into HashMap with McpServerConfig::Sdk variant
        - Configure allowed_tools with mcp__ prefix
        - Pass options to ClaudeSDKClient::new()

  patterns_for_workflow_operations:
    state_capture:
      mechanism: Closures capture Arc<dyn WorkflowRuntime>
      benefits:
        - Shared ownership across multiple tools
        - Thread-safe reference counting
        - No lifetime issues with async execution
      
    async_operations:
      pattern: |
        move |params| {
            let runtime = runtime.clone();
            Box::pin(async move {
                // Clone Arc for this invocation
                match runtime.async_operation().await {
                    Ok(result) => Ok(ToolResult::text(serialize(result))),
                    Err(e) => Ok(ToolResult::error(format!("Operation failed: {}", e)))
                }
            })
        }

    parameter_extraction:
      pattern: |
        let param = match params.get("param_name").and_then(|v| v.as_str()) {
            Some(p) => p,
            None => return Ok(ToolResult::error("Missing param_name"))
        };
      validation: JSON schema validates structure before handler runs
      
    uuid_handling:
      pattern: |
        let handle_id = match Uuid::parse_str(handle_id_str) {
            Ok(id) => id,
            Err(e) => return Ok(ToolResult::error(format!("Invalid UUID: {}", e)))
        };

    log_streaming:
      location: src/mcp_tools.rs:116-124
      pattern: |
        match runtime.subscribe_logs(&handle_id).await {
            Ok(mut logs_rx) => {
                let mut logs = Vec::new();
                while logs.len() < limit {
                    match logs_rx.try_recv() {
                        Ok(log) => logs.push(log),
                        Err(_) => break,
                    }
                }
                Ok(ToolResult::text(serde_json::to_string_pretty(&logs)?))
            }
            Err(e) => Ok(ToolResult::error(format!("Failed to get logs: {}", e)))
        }
      note: Uses try_recv() to avoid blocking, collects up to limit

    result_serialization:
      success_pattern: |
        match serde_json::to_string_pretty(&data) {
            Ok(json) => Ok(ToolResult::text(json)),
            Err(e) => Ok(ToolResult::error(format!("Serialization error: {}", e)))
        }
      structured_pattern: |
        let result = json!({
            "handle_id": handle.id().to_string(),
            "workflow_id": handle.workflow_id,
            "status": "running"
        });
        Ok(ToolResult::text(serde_json::to_string_pretty(&result).unwrap()))

  testing_patterns:
    direct_invocation:
      location: ../claude-agent-sdk-rust/examples/mcp_demo.rs:240-297
      pattern: |
        let request = JsonRpcRequest {
            jsonrpc: "2.0".to_string(),
            id: Some(json!(1)),
            method: "tools/call".to_string(),
            params: Some(json!({
                "name": "add",
                "arguments": {"a": 5, "b": 3}
            }))
        };
        let response = server.handle_request(request).await?;

    unit_test_example:
      location: ../claude-agent-sdk-rust/src/mcp/tool.rs:236-269
      demonstrates:
        - Tool creation in test
        - Async invocation
        - Content verification
        - Error handling tests

  recommended_adoption_patterns:
    for_workflow_operations:
      - Use Arc<dyn WorkflowRuntime> for state sharing
      - Implement one tool per workflow operation (list, execute, status, logs, cancel)
      - Use JSON schema to validate complex parameters
      - Return structured JSON for rich data, plain text for simple results
      - Use ToolResult::error() for domain errors (not Err())
      - Serialize workflow data structures to JSON
      - Use UUID string parameters for handle identification
      - Implement pagination/limits for log retrieval
      - Provide descriptive error messages in ToolResult::error()

    naming_conventions:
      - Server name: lowercase with underscores (e.g., "workflow_manager")
      - Tool names: verb_noun pattern (e.g., "execute_workflow", "get_logs")
      - Allowed tools: "mcp__{server}__{tool}" format

    error_boundaries:
      validation_errors: Caught by JSON schema before handler
      extraction_errors: Return ToolResult::error() immediately
      async_operation_errors: Wrap in ToolResult::error() with context
      serialization_errors: Return ToolResult::error() with details

    performance_considerations:
      - Pre-compiled JSON schemas validate efficiently
      - Arc avoids cloning runtime state
      - Box::pin required for trait object futures
      - No IPC overhead vs subprocess MCP servers
      - Concurrent tool invocations supported

  key_differences_from_subprocess_mcp:
    transport: In-process function calls vs stdio/SSE/HTTP
    lifecycle: No process management required
    latency: Near-zero vs process spawn + IPC
    debugging: Stack traces available vs separate process
    deployment: Single binary vs separate executable
    state_sharing: Direct Arc references vs IPC serialization

  related_files:
    core_implementation:
      - ../claude-agent-sdk-rust/src/mcp/mod.rs
      - ../claude-agent-sdk-rust/src/mcp/server.rs
      - ../claude-agent-sdk-rust/src/mcp/tool.rs
      - ../claude-agent-sdk-rust/src/mcp/protocol.rs
    
    examples:
      - ../claude-agent-sdk-rust/examples/mcp_demo.rs
      - ../claude-agent-sdk-rust/examples/mcp_integration_demo.rs
      - ../claude-agent-sdk-rust/examples/test_mcp_tools.rs
    
    project_usage:
      - src/mcp_tools.rs (workflow tools implementation)
      - src/chat.rs:70-110 (registration in ChatInterface)
      - examples/test2.rs (external MCP config loading example)
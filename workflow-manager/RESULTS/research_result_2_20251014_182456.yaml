mcp_implementation_analysis:
  investigation_summary: "Comprehensive analysis of MCP server implementation patterns in claude-agent-sdk, focusing on SdkMcpServer, SdkMcpTool, protocol handling, and recommendations for workflow integration"
  
  core_components:
    sdk_mcp_server:
      location: "/home/molaco/Documents/japanese/claude-agent-sdk-rust/src/mcp/server.rs"
      description: "In-process MCP server that hosts custom tools without subprocess overhead"
      structure:
        name: "Server identifier"
        version: "Server version string"
        tools: "HashMap<String, SdkMcpTool> - keyed by tool name"
      builder_pattern:
        creation: "SdkMcpServer::new(name)"
        version_setting: ".version(version_string)"
        tool_registration: ".tool(SdkMcpTool) or .tools(Vec<SdkMcpTool>)"
      key_methods:
        get_tool: "Retrieve tool by name"
        list_tools: "Get all registered tools"
        handle_request: "Process JSONRPC requests (async)"
      protocol_handlers:
        initialize: "MCP connection initialization"
        notifications_initialized: "Post-initialization acknowledgment"
        tools_list: "Returns available tools with schemas"
        tools_call: "Executes specified tool with validation"
      
    sdk_mcp_tool:
      location: "/home/molaco/Documents/japanese/claude-agent-sdk-rust/src/mcp/tool.rs"
      description: "Tool definition with async handler, JSON schema validation, and invocation logic"
      structure:
        name: "Unique tool identifier (String)"
        description: "Human-readable description (String)"
        input_schema: "JSON Schema for parameter validation (serde_json::Value)"
        compiled_schema: "Pre-compiled JSONSchema validator (Option<JSONSchema>)"
        handler: "ToolHandler - Arc-wrapped async function"
      creation_signature: |
        SdkMcpTool::new<F, Fut>(
            name: impl Into<String>,
            description: impl Into<String>,
            input_schema: serde_json::Value,
            handler: F
        )
        where
            F: Fn(serde_json::Value) -> Fut + Send + Sync + 'static,
            Fut: Future<Output = Result<ToolResult>> + Send + 'static
      key_methods:
        invoke: "Execute tool handler with input (async)"
        validate_input: "Validate input against JSON schema"
        to_tool_info: "Convert to MCP tools/list format"
      validation:
        approach: "Pre-compiled JSON Schema validation using jsonschema crate"
        timing: "Validation occurs before handler invocation"
        error_handling: "Returns detailed validation error messages"

    tool_handler_type:
      location: "/home/molaco/Documents/japanese/claude-agent-sdk-rust/src/mcp/mod.rs:100-104"
      definition: |
        type ToolHandler = Arc<
            dyn Fn(serde_json::Value) 
                -> Pin<Box<dyn Future<Output = Result<ToolResult>> + Send>>
            + Send + Sync
        >
      characteristics:
        thread_safety: "Send + Sync for concurrent invocation"
        lifetime: "'static - must be self-contained"
        async_model: "Returns boxed pinned future"
        error_propagation: "Returns Result<ToolResult> from claude_agent_sdk::error"

  communication_types:
    tool_result:
      location: "/home/molaco/Documents/japanese/claude-agent-sdk-rust/src/mcp/tool.rs:166-210"
      structure:
        content: "Vec<ToolContent> - multiple content blocks"
        is_error: "Option<bool> - error flag"
      factory_methods:
        text: "ToolResult::text(text) - successful text response"
        error: "ToolResult::error(text) - error response with is_error=true"
      serialization: "Serde JSON format matching MCP protocol"
      
    tool_content:
      location: "/home/molaco/Documents/japanese/claude-agent-sdk-rust/src/mcp/tool.rs:212-229"
      enum_variants:
        text:
          type: "Text content"
          fields:
            text: "String content"
        image:
          type: "Base64 encoded image"
          fields:
            data: "Base64 encoded image data"
            mime_type: "MIME type (e.g., 'image/png')"
      serialization: "Tagged enum with 'type' field, lowercase variant names"

  protocol_implementation:
    jsonrpc_protocol:
      version: "JSONRPC 2.0"
      location: "/home/molaco/Documents/japanese/claude-agent-sdk-rust/src/mcp/protocol.rs"
      
    request_structure:
      fields:
        jsonrpc: "Always '2.0'"
        id: "Option<serde_json::Value> - null for notifications"
        method: "Method name (String)"
        params: "Option<serde_json::Value> - method parameters"
        
    response_structure:
      fields:
        jsonrpc: "Always '2.0'"
        id: "Matches request ID"
        result: "Option<serde_json::Value> - present on success"
        error: "Option<McpError> - present on failure"
      factory_methods:
        success: "JsonRpcResponse::success(id, result)"
        error: "JsonRpcResponse::error(id, McpError)"
        
    error_codes:
      method_not_found: -32601
      invalid_params: -32602
      internal_error: -32603
      tool_not_found: -32001
      
    supported_methods:
      initialize:
        purpose: "MCP connection initialization"
        response: "Server info and capabilities"
      notifications_initialized:
        purpose: "Post-init acknowledgment"
        response: "Empty success"
      tools_list:
        purpose: "List available tools"
        response: "Array of tool definitions with schemas"
      tools_call:
        purpose: "Execute specific tool"
        params:
          name: "Tool name (required)"
          arguments: "Tool input matching schema"
        response: "ToolResult serialized as JSON"

  async_execution_model:
    handler_execution:
      model: "Tokio async runtime"
      concurrency: "Tools can be invoked concurrently (thread-safe)"
      error_handling: "Result-based with ClaudeError propagation"
      
    invocation_flow:
      steps:
        - "Receive JSONRPC tools/call request"
        - "Extract tool name and arguments from params"
        - "Lookup tool in HashMap by name"
        - "Validate arguments against compiled JSON schema"
        - "Invoke tool handler (await async function)"
        - "Serialize ToolResult to JSON"
        - "Return JSONRPC success response or error"
      
    error_handling_layers:
      validation_errors:
        level: "Pre-invocation"
        type: "JSON Schema validation failures"
        response: "JSONRPC error with code -32602 (invalid params)"
      tool_execution_errors:
        level: "During handler execution"
        type: "Handler returns Err(ClaudeError)"
        response: "JSONRPC error with code -32603 (internal error)"
      tool_not_found:
        level: "Pre-invocation"
        type: "Tool name not in HashMap"
        response: "JSONRPC error with code -32001 (custom)"

  integration_patterns:
    registration_with_client:
      location: "examples/mcp_integration_demo.rs:86-104"
      pattern: |
        // Create server
        let server = SdkMcpServer::new("server_name")
            .tool(tool1)
            .tool(tool2);
        let server_arc = Arc::new(server);
        
        // Register in ClaudeAgentOptions
        let mut mcp_servers = HashMap::new();
        mcp_servers.insert(
            "server_id".to_string(),
            McpServerConfig::Sdk(SdkMcpServerMarker {
                name: "server_id".to_string(),
                instance: server_arc,
            })
        );
        
        let options = ClaudeAgentOptions {
            mcp_servers: McpServers::Dict(mcp_servers),
            allowed_tools: vec![
                ToolName::new("mcp__server_id__tool1"),
                ToolName::new("mcp__server_id__tool2"),
            ],
            ..Default::default()
        };
        
    tool_naming_convention:
      format: "mcp__{server_id}__{tool_name}"
      example: "mcp__calc__add"
      wildcard: "mcp__{server_id}__* - allow all tools from server"
      
    example_tool_implementation:
      location: "examples/mcp_integration_demo.rs:20-47"
      pattern: |
        let add_tool = SdkMcpTool::new(
            "add",
            "Add two numbers together",
            json!({
                "type": "object",
                "properties": {
                    "a": {"type": "number", "description": "First number"},
                    "b": {"type": "number", "description": "Second number"}
                },
                "required": ["a", "b"]
            }),
            |input| {
                Box::pin(async move {
                    let a = input["a"].as_f64().unwrap();
                    let b = input["b"].as_f64().unwrap();
                    let result = a + b;
                    
                    Ok(ToolResult {
                        content: vec![ToolContent::Text {
                            text: format!("{a} + {b} = {result}"),
                        }],
                        is_error: None,
                    })
                })
            },
        );

  workflow_integration_recommendations:
    workflow_operations_as_tools:
      list_workflows:
        tool_name: "list_workflows"
        description: "List all available workflows with metadata"
        input_schema:
          type: "object"
          properties:
            filter_source:
              type: "string"
              enum: ["built_in", "user_defined", "all"]
              description: "Filter by workflow source"
        handler_logic:
          - "Call discover_workflows() from discovery module"
          - "Serialize workflow metadata to JSON"
          - "Return ToolResult::text with formatted list"
        
      execute_workflow:
        tool_name: "execute_workflow"
        description: "Execute a workflow with provided parameters"
        input_schema:
          type: "object"
          properties:
            workflow_id:
              type: "string"
              description: "Unique workflow identifier"
            parameters:
              type: "object"
              description: "Workflow-specific parameters"
            phase:
              type: "number"
              description: "Optional phase to resume from"
          required: ["workflow_id"]
        handler_logic:
          - "Lookup workflow by ID"
          - "Validate parameters against workflow field schemas"
          - "Spawn workflow process with tokio::process::Command"
          - "Stream progress via WorkflowLog events"
          - "Return execution status and results"
        async_considerations:
          - "Use tokio::process for non-blocking execution"
          - "Parse stderr for __WF_EVENT__ structured logs"
          - "Accumulate progress messages"
          - "Handle long-running workflows (timeout/cancellation)"
          
      get_workflow_status:
        tool_name: "get_workflow_status"
        description: "Get status of running or completed workflow"
        input_schema:
          type: "object"
          properties:
            execution_id:
              type: "string"
              description: "Workflow execution identifier"
          required: ["execution_id"]
        handler_logic:
          - "Lookup execution by ID in execution tracker"
          - "Return current status, progress, and logs"
          - "Support streaming updates for running workflows"
          
      get_workflow_metadata:
        tool_name: "get_workflow_metadata"
        description: "Get detailed metadata for a specific workflow"
        input_schema:
          type: "object"
          properties:
            workflow_id:
              type: "string"
              description: "Unique workflow identifier"
          required: ["workflow_id"]
        handler_logic:
          - "Lookup workflow by ID"
          - "Return WorkflowMetadata and FieldSchema array"
          - "Serialize to JSON for Claude inspection"

    state_management:
      execution_tracking:
        approach: "Maintain HashMap<execution_id, ExecutionState> in MCP server"
        structure:
          execution_id: "UUID generated per execution"
          workflow_id: "Reference to workflow"
          status: "WorkflowStatus enum"
          process_handle: "tokio::process::Child"
          progress_logs: "Vec<WorkflowLog>"
          start_time: "chrono::DateTime"
          end_time: "Option<chrono::DateTime>"
        concurrency: "Arc<RwLock<HashMap>> for thread-safe access"
        
      progress_streaming:
        mechanism: "Parse stderr for __WF_EVENT__:{json} markers"
        parsing: "Deserialize WorkflowLog enum variants"
        storage: "Append to execution's progress_logs vector"
        notification: "Potentially emit to client via progress updates"

    error_handling_strategy:
      workflow_not_found:
        return: "ToolResult::error with descriptive message"
        code: "Workflow-specific error in text"
      validation_failures:
        return: "ToolResult::error with field-specific messages"
        approach: "Validate against FieldSchema before execution"
      execution_failures:
        capture: "Parse stderr for WorkflowLog::PhaseFailed/TaskFailed"
        return: "ToolResult::error with failure details"
        cleanup: "Mark execution as Failed in state"
      timeout_handling:
        mechanism: "tokio::time::timeout wrapper"
        default: "Configurable per workflow (e.g., 30 minutes)"
        return: "ToolResult::error('Workflow execution timeout')"

    schema_integration:
      workflow_field_to_json_schema:
        approach: "Convert FieldSchema to JSON Schema properties"
        mapping:
          text: '{"type": "string"}'
          number: '{"type": "number", "minimum": "min", "maximum": "max"}'
          filepath: '{"type": "string", "pattern": "pattern"}'
          select: '{"type": "string", "enum": "options"}'
          phase_selector: '{"type": "number", "minimum": 1, "maximum": "total_phases"}'
          state_file: '{"type": "string", "pattern": "pattern"}'
        dynamic_generation: "Build input_schema dynamically per workflow"
        
      validation_approach:
        static: "Use compiled JSON schemas in SdkMcpTool"
        dynamic: "Custom validation logic in handler for complex rules"
        error_messages: "Map validation errors to user-friendly messages"

  example_workflow_mcp_server:
    implementation_sketch: |
      // Workflow MCP Server with state management
      pub struct WorkflowMcpState {
          executions: Arc<RwLock<HashMap<String, ExecutionState>>>,
          workflows: Arc<Vec<DiscoveredWorkflow>>,
      }
      
      pub fn create_workflow_mcp_server() -> SdkMcpServer {
          let state = Arc::new(WorkflowMcpState {
              executions: Arc::new(RwLock::new(HashMap::new())),
              workflows: Arc::new(discover_workflows()),
          });
          
          let list_tool = create_list_workflows_tool(state.clone());
          let execute_tool = create_execute_workflow_tool(state.clone());
          let status_tool = create_workflow_status_tool(state.clone());
          let metadata_tool = create_workflow_metadata_tool(state.clone());
          
          SdkMcpServer::new("workflow-manager")
              .version("1.0.0")
              .tool(list_tool)
              .tool(execute_tool)
              .tool(status_tool)
              .tool(metadata_tool)
      }
      
      fn create_execute_workflow_tool(state: Arc<WorkflowMcpState>) -> SdkMcpTool {
          SdkMcpTool::new(
              "execute_workflow",
              "Execute a workflow with parameters",
              json!({
                  "type": "object",
                  "properties": {
                      "workflow_id": {"type": "string"},
                      "parameters": {"type": "object"}
                  },
                  "required": ["workflow_id"]
              }),
              move |input| {
                  let state = state.clone();
                  Box::pin(async move {
                      let workflow_id = input["workflow_id"].as_str().unwrap();
                      let params = input.get("parameters");
                      
                      // Find workflow
                      let workflow = state.workflows.iter()
                          .find(|w| w.metadata.id == workflow_id)
                          .ok_or_else(|| anyhow::anyhow!("Workflow not found"))?;
                      
                      // Validate parameters
                      // ... validate against workflow.fields ...
                      
                      // Generate execution ID
                      let execution_id = uuid::Uuid::new_v4().to_string();
                      
                      // Spawn workflow process
                      let mut cmd = tokio::process::Command::new(&workflow.binary_path);
                      // ... add parameters as CLI args ...
                      cmd.stderr(Stdio::piped());
                      
                      let mut child = cmd.spawn()?;
                      
                      // Track execution
                      let mut executions = state.executions.write().await;
                      executions.insert(execution_id.clone(), ExecutionState {
                          workflow_id: workflow_id.to_string(),
                          status: WorkflowStatus::Running,
                          process: child,
                          logs: Vec::new(),
                          start_time: chrono::Utc::now(),
                      });
                      drop(executions);
                      
                      // Start progress monitoring task
                      tokio::spawn(monitor_workflow_progress(
                          state.clone(), 
                          execution_id.clone()
                      ));
                      
                      Ok(ToolResult::text(format!(
                          "Workflow started with execution ID: {}", 
                          execution_id
                      )))
                  })
              },
          )
      }
      
      async fn monitor_workflow_progress(
          state: Arc<WorkflowMcpState>, 
          execution_id: String
      ) {
          // Read stderr and parse WorkflowLog events
          // Update execution state with progress
          // Handle completion/failure
      }

  key_patterns_summary:
    builder_pattern: "Fluent API for server and tool construction"
    arc_wrapped_state: "Share state across tool handlers with Arc<State>"
    async_handlers: "All handlers return Pin<Box<dyn Future>>"
    jsonrpc_abstraction: "Protocol details handled by SdkMcpServer"
    validation_first: "JSON Schema validation before handler execution"
    error_propagation: "Result<ToolResult> for handler errors, ToolResult::error for domain errors"
    type_safety: "Strong typing with Rust enums and structs"
    concurrent_execution: "Send + Sync traits enable parallel tool invocation"

  references:
    primary_files:
      - "/home/molaco/Documents/japanese/claude-agent-sdk-rust/src/mcp/server.rs"
      - "/home/molaco/Documents/japanese/claude-agent-sdk-rust/src/mcp/tool.rs"
      - "/home/molaco/Documents/japanese/claude-agent-sdk-rust/src/mcp/protocol.rs"
      - "/home/molaco/Documents/japanese/claude-agent-sdk-rust/src/mcp/mod.rs"
      - "/home/molaco/Documents/japanese/claude-agent-sdk-rust/examples/mcp_integration_demo.rs"
      - "/home/molaco/Documents/japanese/claude-agent-sdk-rust/examples/mcp_demo.rs"
    workflow_files:
      - "/home/molaco/Documents/japanese/workflow-manager-sdk/src/lib.rs"
      - "/home/molaco/Documents/japanese/workflow-manager/src/discovery.rs"
      - "/home/molaco/Documents/japanese/workflow-manager/examples/test2.rs"

  next_steps_for_workflow_mcp:
    - "Implement WorkflowMcpState struct with execution tracking"
    - "Create workflow discovery integration with MCP tools"
    - "Build execute_workflow tool with parameter validation"
    - "Implement progress monitoring via WorkflowLog parsing"
    - "Add status query and cancellation tools"
    - "Register workflow MCP server in ClaudeAgentOptions"
    - "Test with Claude CLI for workflow execution"
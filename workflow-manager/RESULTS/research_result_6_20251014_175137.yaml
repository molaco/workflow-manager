analysis_timestamp: "2025-10-14"
research_objective: "Type System and API Exposure Analysis for workflow-manager-sdk"

current_type_system:
  core_types:
    WorkflowMetadata:
      location: "workflow-manager-sdk/src/lib.rs:10-15"
      serialization: "serde Serialize + Deserialize"
      fields:
        - id: String
        - name: String
        - description: String
      current_use: "Basic workflow identification and discovery"
      
    FullWorkflowMetadata:
      location: "workflow-manager-sdk/src/lib.rs:18-23"
      serialization: "serde with #[serde(flatten)] for metadata"
      fields:
        - "metadata: WorkflowMetadata (flattened)"
        - "fields: Vec<FieldSchema>"
      current_use: "JSON export via --workflow-metadata flag for TUI discovery"
      
    FieldSchema:
      location: "workflow-manager-sdk/src/lib.rs:26-37"
      serialization: "serde Serialize + Deserialize"
      fields:
        - "name: String"
        - "field_type: FieldType"
        - "label: String"
        - "description: String"
        - "cli_arg: String"
        - "required: bool"
        - "default: Option<String>"
        - "required_for_phases: Option<Vec<usize>> with #[serde(skip_serializing_if)]"
      current_use: "Field definition for TUI form generation and CLI argument mapping"
      
    FieldType:
      location: "workflow-manager-sdk/src/lib.rs:40-65"
      serialization: "#[serde(tag = \"type\", rename_all = \"snake_case\")]"
      variants:
        Text:
          description: "Simple text input"
          json_representation: '{"type": "text"}'
          
        Number:
          description: "Numeric input with optional min/max constraints"
          fields:
            - "min: Option<i64> with #[serde(skip_serializing_if)]"
            - "max: Option<i64> with #[serde(skip_serializing_if)]"
          json_representation: '{"type": "number", "min": 1, "max": 5}'
          
        FilePath:
          description: "File path input with optional glob pattern"
          fields:
            - "pattern: Option<String> with #[serde(skip_serializing_if)]"
          json_representation: '{"type": "file_path", "pattern": "*.yaml"}'
          
        Select:
          description: "Dropdown selection from predefined options"
          fields:
            - "options: Vec<String>"
          json_representation: '{"type": "select", "options": ["opt1", "opt2"]}'
          
        PhaseSelector:
          description: "Multi-phase selection for resumable workflows"
          fields:
            - "total_phases: usize"
          json_representation: '{"type": "phase_selector", "total_phases": 5}'
          current_use: "TUI displays checkboxes for phase selection (e.g., '0,1,2')"
          value_format: "Comma-separated phase indices: \"0,1,2,3,4\""
          tui_rendering: "src/main.rs:2444-2450 - displays as-is or <empty>"
          
        StateFile:
          description: "Reference to phase-generated intermediate files"
          fields:
            - "pattern: String (glob pattern like 'codebase_analysis_*.yaml')"
            - "phase: Option<usize> (which phase generates this file)"
          json_representation: '{"type": "state_file", "pattern": "codebase_*.yaml", "phase": 0}'
          current_use: "TUI file browser for resumable workflow state"
          tui_rendering: "src/main.rs:2452-2455 - shows file picker with pattern"
          file_browser_integration: "src/main.rs:1228 - opens file browser on Tab key"
          
    WorkflowLog:
      location: "workflow-manager-sdk/src/lib.rs:119-191"
      serialization: "#[serde(tag = \"type\", rename_all = \"snake_case\")]"
      purpose: "Structured logging for hierarchical progress tracking"
      emission_protocol: "JSON to stderr with __WF_EVENT__: prefix"
      variants:
        - "PhaseStarted: { phase, name, total_phases }"
        - "PhaseCompleted: { phase, name }"
        - "PhaseFailed: { phase, name, error }"
        - "TaskStarted: { phase, task_id, description, total_tasks }"
        - "TaskProgress: { task_id, message }"
        - "TaskCompleted: { task_id, result }"
        - "TaskFailed: { task_id, error }"
        - "AgentStarted: { task_id, agent_name, description }"
        - "AgentMessage: { task_id, agent_name, message }"
        - "AgentCompleted: { task_id, agent_name, result }"
        - "AgentFailed: { task_id, agent_name, error }"
        - "StateFileCreated: { phase, file_path, description }"
      parsing: "src/main.rs:1143-1220 - TUI parses events for phase/task tracking"

  workflow_generation:
    macro_system:
      location: "workflow-manager-macros/src/lib.rs"
      macro_name: "WorkflowDefinition"
      attributes:
        workflow: "Container-level: #[workflow(id, name, description)]"
        field: "Field-level: #[field(label, description, type, ...)]"
      
    field_attribute_params:
      - "label: Display label for TUI"
      - "description: Help text"
      - "type: Override inferred type (text|number|file_path|select|phase_selector|state_file)"
      - "min: For number type"
      - "max: For number type"
      - "pattern: For file_path/state_file types"
      - "total_phases: For phase_selector type"
      - "phase: For state_file type"
      - "required_for_phases: Comma-separated phase list where field is required"
      
    type_inference:
      location: "workflow-manager-macros/src/lib.rs:275-312"
      rules:
        - "String → FieldType::Text"
        - "PathBuf → FieldType::FilePath { pattern: None }"
        - "usize|u32|u64|i32|i64 → FieldType::Number { min: None, max: None }"
        - "Option<T> → not required, inner type inferred"
      
    metadata_generation:
      output_format: "JSON via print_metadata() method"
      structure: "FullWorkflowMetadata { metadata, fields }"
      invocation: "Binary with --workflow-metadata flag"
      
  discovery_mechanism:
    location: "workflow-manager/src/discovery.rs"
    search_paths:
      - "~/.workflow-manager/workflows/ (user workflows)"
    discovery_process:
      - "Scan directories for executable binaries"
      - "Execute: <binary> --workflow-metadata"
      - "Parse JSON output as FullWorkflowMetadata"
      - "Create DiscoveredWorkflow { metadata, fields, binary_path }"
    metadata_extraction: "discovery.rs:118-147"
    command_building: "discovery.rs:150-170 - maps fields to CLI args"

api_exposure_requirements:
  
  mcp_tool_schema_generation:
    challenge: "Convert FieldType to JSON Schema for MCP tool definitions"
    reference_implementation: "examples/test2.rs:180-205 - shows MCP tool with JSON schema"
    
    json_schema_mapping:
      Text:
        json_schema:
          type: "string"
          description: "From FieldSchema.description"
        example: |
          {
            "type": "string",
            "description": "Research objective/question"
          }
          
      Number:
        json_schema:
          type: "integer"
          minimum: "From FieldType::Number.min (if Some)"
          maximum: "From FieldType::Number.max (if Some)"
          description: "From FieldSchema.description"
        example: |
          {
            "type": "integer",
            "minimum": 1,
            "maximum": 5,
            "description": "Tasks to run in parallel (1-5)"
          }
          
      FilePath:
        json_schema:
          type: "string"
          format: "path or uri"
          pattern: "From FieldType::FilePath.pattern (converted to regex if Some)"
          description: "From FieldSchema.description + pattern hint"
        example: |
          {
            "type": "string",
            "format": "path",
            "pattern": ".*\\.yaml$",
            "description": "Input file path (e.g., 'data.txt')"
          }
        challenges:
          - "Glob patterns (*.yaml) need conversion to regex (.*\\.yaml$)"
          - "Path validation is client-side vs server-side"
          
      Select:
        json_schema:
          type: "string"
          enum: "From FieldType::Select.options"
          description: "From FieldSchema.description"
        example: |
          {
            "type": "string",
            "enum": ["sequential", "parallel", "distributed"],
            "description": "Execution mode"
          }
          
      PhaseSelector:
        challenges:
          - "No direct JSON Schema equivalent for multi-select checkboxes"
          - "Current value format: comma-separated string '0,1,2'"
          - "Total phases info needs to be conveyed somehow"
        option_1_string_pattern:
          json_schema:
            type: "string"
            pattern: "^(\\d+,)*\\d+$"
            description: "Comma-separated phase indices (0-{total_phases-1})"
          example: |
            {
              "type": "string",
              "pattern": "^(\\d+,)*\\d+$",
              "description": "Phases to execute: comma-separated (0-4). Example: '0,1,2'"
            }
          pros:
            - "Simple, matches current CLI format"
            - "Easy validation"
          cons:
            - "No type safety for individual phase numbers"
            - "Client doesn't know valid range without parsing description"
            
        option_2_array_of_integers:
          json_schema:
            type: "array"
            items:
              type: "integer"
              minimum: 0
              maximum: "total_phases - 1"
            uniqueItems: true
            description: "Phase indices to execute"
          example: |
            {
              "type": "array",
              "items": {
                "type": "integer",
                "minimum": 0,
                "maximum": 4
              },
              "uniqueItems": true,
              "description": "Phases to execute (0-4)"
            }
          pros:
            - "Type-safe, validates each phase index"
            - "Clear semantics"
          cons:
            - "Requires conversion from/to comma-separated string"
            - "API input differs from CLI input format"
            
        option_3_hybrid_with_custom_x_property:
          json_schema:
            oneOf:
              - type: "string"
                pattern: "^(\\d+,)*\\d+$"
              - type: "array"
                items:
                  type: "integer"
            x-phase-selector:
              total_phases: "From FieldType::PhaseSelector.total_phases"
            description: "Phases to execute"
          pros:
            - "Supports both formats"
            - "Preserves total_phases metadata"
          cons:
            - "Non-standard x- extension"
            - "More complex validation"
            
      StateFile:
        challenges:
          - "References files that may not exist yet"
          - "Pattern is for discovery, not validation"
          - "Phase metadata indicates dependency"
        option_1_string_with_validation:
          json_schema:
            type: "string"
            format: "path"
            description: "Path to {pattern} file from phase {phase}"
          example: |
            {
              "type": "string",
              "format": "path",
              "description": "Path to codebase_analysis_*.yaml file from phase 0"
            }
          pros:
            - "Simple, straightforward"
          cons:
            - "No programmatic way to know pattern or source phase"
            - "File existence can't be validated at schema level"
            
        option_2_with_metadata:
          json_schema:
            type: "string"
            format: "path"
            x-state-file:
              pattern: "From FieldType::StateFile.pattern"
              source_phase: "From FieldType::StateFile.phase"
            description: "From FieldSchema.description"
          example: |
            {
              "type": "string",
              "format": "path",
              "x-state-file": {
                "pattern": "codebase_analysis_*.yaml",
                "source_phase": 0
              },
              "description": "Analysis file from phase 0"
            }
          pros:
            - "Preserves all metadata"
            - "Clients can implement file discovery"
          cons:
            - "Non-standard x- extension"
            - "Requires custom client logic"

  serialization_considerations:
    current_serde_config:
      - "Tagged enum serialization: #[serde(tag = \"type\", rename_all = \"snake_case\")]"
      - "Optional field skipping: #[serde(skip_serializing_if = \"Option::is_none\")]"
      - "Flatten for composition: #[serde(flatten)]"
    
    json_output_compatibility:
      status: "Already JSON-compatible via serde_json"
      validation: "discovery.rs:139 - FullWorkflowMetadata deserializes from binary output"
      
    schema_generation_approaches:
      option_1_schemars:
        crate: "schemars"
        implementation: "Derive JsonSchema trait on types"
        pros:
          - "Automatic schema generation"
          - "Well-maintained, standard approach"
        cons:
          - "May need custom implementations for PhaseSelector/StateFile"
          - "Additional dependency"
        example: |
          #[derive(Serialize, Deserialize, JsonSchema)]
          pub struct FieldSchema { ... }
          
      option_2_manual_implementation:
        implementation: "Method on FieldType to generate JSON Schema object"
        location: "Add to workflow-manager-sdk/src/lib.rs"
        pros:
          - "Full control over schema output"
          - "Can handle complex types precisely"
        cons:
          - "Manual maintenance"
          - "Potential for drift from actual serialization"
        example: |
          impl FieldType {
              pub fn to_json_schema(&self) -> serde_json::Value {
                  match self {
                      FieldType::Text => json!({ "type": "string" }),
                      FieldType::Number { min, max } => { ... },
                      // etc.
                  }
              }
          }
          
      option_3_hybrid:
        implementation: "Use schemars with custom implementations for special types"
        pros:
          - "Best of both worlds"
          - "Standard for common types, custom for special cases"

  versioning_and_compatibility:
    current_state:
      - "No explicit versioning in WorkflowMetadata"
      - "No SDK version tracking"
      - "Discovery relies on JSON parsing success/failure"
      
    recommended_changes:
      add_version_field:
        location: "WorkflowMetadata struct"
        field: "schema_version: String"
        default: "\"1.0.0\""
        purpose: "Track metadata format version for breaking changes"
        
      add_sdk_version:
        location: "FullWorkflowMetadata struct"
        field: "sdk_version: String"
        source: "From Cargo.toml package version"
        purpose: "Track which SDK version generated the workflow"
        
      backwards_compatibility_strategy:
        - "Use #[serde(default)] for new optional fields"
        - "Maintain schema_version in FullWorkflowMetadata"
        - "MCP server can negotiate supported versions"
        - "Older workflows without schema_version assume \"1.0.0\""
        
      breaking_change_handling:
        scenario: "Adding new FieldType variant"
        impact: "Old workflows can't be discovered by new TUI"
        mitigation: "Use #[serde(untagged)] fallback or Unknown variant"
        example: |
          #[derive(Serialize, Deserialize)]
          #[serde(tag = "type", rename_all = "snake_case")]
          pub enum FieldType {
              // existing variants...
              #[serde(other)]
              Unknown,
          }

  mcp_server_design:
    architecture:
      discovery_service:
        purpose: "Expose available workflows via MCP"
        tools:
          list_workflows:
            description: "List all discovered workflows"
            output: "Array of WorkflowMetadata"
          get_workflow_schema:
            description: "Get full schema for a workflow"
            input:
              workflow_id: "string"
            output: "FullWorkflowMetadata with JSON schemas"
              
      execution_service:
        purpose: "Execute workflows via MCP"
        tools:
          execute_workflow:
            description: "Execute a workflow with parameters"
            input:
              workflow_id: "string"
              parameters: "object (validated against workflow schema)"
            output: "Execution handle/ID for tracking"
          get_workflow_status:
            description: "Get execution status and logs"
            input:
              execution_id: "string"
            output: "WorkflowLog events, current status"
              
      state_management:
        purpose: "Resume workflows from saved state"
        tools:
          list_state_files:
            description: "List state files matching pattern"
            input:
              pattern: "string (glob pattern)"
              workflow_id: "string (optional)"
            output: "Array of { path, phase, timestamp, workflow_id }"
          resume_workflow:
            description: "Resume workflow from phase with state file"
            input:
              workflow_id: "string"
              phase: "integer or array<integer>"
              state_files: "object (field_name -> file_path)"
              parameters: "object (additional/override parameters)"
            output: "Execution handle/ID"
              
    schema_transformation:
      input: "FieldSchema with FieldType"
      output: "MCP tool input schema (JSON Schema format)"
      required_mapping: "FieldSchema.required + required_for_phases logic"
      
    implementation_location:
      suggested_path: "workflow-manager/src/mcp_server.rs"
      dependencies:
        - "workflow-manager-sdk (types)"
        - "discovery module (workflow scanning)"
        - "tokio (async execution)"
        - "serde_json (schema generation)"

  programmatic_api:
    rust_api:
      purpose: "Direct Rust crate usage without MCP"
      location: "workflow-manager-sdk/src/api.rs (new module)"
      
      discovery_api:
        function: "discover_workflows(search_paths: Vec<PathBuf>) -> Vec<DiscoveredWorkflow>"
        current: "Currently in workflow-manager/src/discovery.rs"
        needed_change: "Move to SDK or re-export for programmatic use"
        
      execution_api:
        trait: "WorkflowExecutor"
        methods:
          - "execute: (parameters: HashMap<String, Value>) -> Result<WorkflowHandle>"
          - "get_status: (handle: &WorkflowHandle) -> WorkflowStatus"
          - "subscribe_logs: (handle: &WorkflowHandle) -> Stream<WorkflowLog>"
        implementation:
          - "Spawn workflow binary as subprocess"
          - "Parse structured logs from stderr"
          - "Provide logs as async stream"
          
      validation_api:
        function: "validate_parameters(workflow: &DiscoveredWorkflow, params: &HashMap<String, Value>) -> Result<()>"
        checks:
          - "Required fields present"
          - "Type compatibility (string, integer, path exists)"
          - "Constraints (min/max for numbers, pattern for paths)"
          - "Phase-specific requirements (required_for_phases)"
          
    type_safety:
      challenge: "HashMap<String, Value> is not type-safe"
      alternative: "Generate typed structs per workflow"
      approach:
        - "Macro-generated workflows already have typed structs (Args)"
        - "External callers use untyped HashMap or JSON"
        - "Validation bridges the gap"

recommended_changes:
  
  priority_1_critical:
    add_versioning:
      changes:
        - "Add schema_version: String to WorkflowMetadata"
        - "Add sdk_version: String to FullWorkflowMetadata"
        - "Update macro to inject versions from Cargo.toml"
      rationale: "Essential for API stability and evolution"
      
    json_schema_generation:
      approach: "Manual implementation initially, migrate to schemars later"
      changes:
        - "Add impl FieldType { pub fn to_json_schema(&self) -> Value }"
        - "Add impl FieldSchema { pub fn to_json_schema(&self) -> Value }"
        - "Add impl FullWorkflowMetadata { pub fn to_mcp_tool_schema(&self) -> Value }"
      location: "workflow-manager-sdk/src/lib.rs"
      
    phase_selector_representation:
      decision: "Support both string ('0,1,2') and array ([0,1,2]) formats"
      changes:
        - "Add custom Deserialize impl for PhaseSelector value"
        - "JSON Schema uses oneOf with both formats"
        - "CLI continues using comma-separated string"
      rationale: "Backwards compatibility + API ergonomics"
      
    state_file_metadata:
      decision: "Use x-state-file extension in JSON Schema"
      changes:
        - "Include pattern and source_phase in schema"
        - "Add helper function to list matching state files"
      rationale: "Enables smart file discovery in MCP clients"
      
  priority_2_important:
    add_field_validation:
      changes:
        - "Add pub fn validate_value(&self, value: &Value) -> Result<()> to FieldType"
        - "Implement validation for each variant"
      location: "workflow-manager-sdk/src/lib.rs"
      
    workflow_execution_api:
      changes:
        - "Add workflow-manager-sdk/src/executor.rs module"
        - "Implement WorkflowExecutor trait"
        - "Add log parsing and streaming"
      rationale: "Enable programmatic workflow execution"
      
    mcp_server_implementation:
      changes:
        - "Add workflow-manager/src/mcp_server.rs"
        - "Implement discovery and execution tools"
        - "Add state file management tools"
      rationale: "Primary API exposure mechanism"
      
  priority_3_enhancements:
    structured_defaults:
      current: "default: Option<String> (string representation)"
      proposal: "default: Option<Value> (typed JSON value)"
      benefits:
        - "Type-safe defaults"
        - "Easier validation"
      challenges:
        - "Breaking change to FieldSchema"
        - "Need migration for existing workflows"
        
    workflow_composition:
      proposal: "Support workflows calling other workflows"
      type_addition: "FieldType::WorkflowReference { workflow_id: String }"
      use_case: "research_agent could reference analysis_agent"
      
    async_field_validation:
      proposal: "FieldType::AsyncValidated { validator_url: String }"
      use_case: "Validate API keys, check file existence, verify URLs"
      complexity: "Requires async validation infrastructure"

implementation_roadmap:
  
  phase_1_foundation:
    duration: "1-2 days"
    tasks:
      - "Add versioning to WorkflowMetadata and FullWorkflowMetadata"
      - "Implement to_json_schema() methods for FieldType and FieldSchema"
      - "Add PhaseSelector value parsing (string + array)"
      - "Add unit tests for schema generation"
      
  phase_2_validation:
    duration: "1-2 days"
    tasks:
      - "Implement validate_value() for all FieldType variants"
      - "Add validate_parameters() function for workflows"
      - "Add integration tests with example workflows"
      
  phase_3_mcp_server:
    duration: "2-3 days"
    tasks:
      - "Implement MCP server structure"
      - "Add list_workflows and get_workflow_schema tools"
      - "Add execute_workflow tool with parameter validation"
      - "Add state file management tools"
      - "Integration testing with MCP clients"
      
  phase_4_executor_api:
    duration: "2-3 days"
    tasks:
      - "Implement WorkflowExecutor trait"
      - "Add subprocess management"
      - "Implement log parsing and streaming"
      - "Add cancellation support"
      
  phase_5_documentation:
    duration: "1 day"
    tasks:
      - "Document type system and schema generation"
      - "Create MCP server usage guide"
      - "Add API examples for programmatic usage"
      - "Migration guide for versioning changes"

code_examples:
  
  json_schema_generation:
    rust: |
      impl FieldType {
          pub fn to_json_schema(&self) -> serde_json::Value {
              use serde_json::json;
              match self {
                  FieldType::Text => json!({
                      "type": "string"
                  }),
                  FieldType::Number { min, max } => {
                      let mut schema = json!({ "type": "integer" });
                      if let Some(min_val) = min {
                          schema["minimum"] = json!(min_val);
                      }
                      if let Some(max_val) = max {
                          schema["maximum"] = json!(max_val);
                      }
                      schema
                  },
                  FieldType::FilePath { pattern } => {
                      let mut schema = json!({
                          "type": "string",
                          "format": "path"
                      });
                      if let Some(pat) = pattern {
                          // Convert glob to regex (simplified)
                          let regex = pat.replace("*", ".*").replace("?", ".");
                          schema["pattern"] = json!(regex);
                      }
                      schema
                  },
                  FieldType::Select { options } => json!({
                      "type": "string",
                      "enum": options
                  }),
                  FieldType::PhaseSelector { total_phases } => json!({
                      "oneOf": [
                          {
                              "type": "string",
                              "pattern": "^(\\d+,)*\\d+$",
                              "description": format!("Comma-separated phase indices (0-{})", total_phases - 1)
                          },
                          {
                              "type": "array",
                              "items": {
                                  "type": "integer",
                                  "minimum": 0,
                                  "maximum": total_phases - 1
                              },
                              "uniqueItems": true
                          }
                      ],
                      "x-phase-selector": {
                          "total_phases": total_phases
                      }
                  }),
                  FieldType::StateFile { pattern, phase } => {
                      let mut schema = json!({
                          "type": "string",
                          "format": "path",
                          "x-state-file": {
                              "pattern": pattern
                          }
                      });
                      if let Some(p) = phase {
                          schema["x-state-file"]["source_phase"] = json!(p);
                      }
                      schema
                  }
              }
          }
      }
      
      impl FieldSchema {
          pub fn to_json_schema(&self) -> serde_json::Value {
              let mut schema = self.field_type.to_json_schema();
              schema["description"] = json!(self.description);
              schema
          }
      }
      
      impl FullWorkflowMetadata {
          pub fn to_mcp_tool_schema(&self) -> serde_json::Value {
              let mut properties = serde_json::Map::new();
              let mut required = Vec::new();
              
              for field in &self.fields {
                  properties.insert(
                      field.name.clone(),
                      field.to_json_schema()
                  );
                  if field.required {
                      required.push(field.name.clone());
                  }
              }
              
              json!({
                  "type": "object",
                  "properties": properties,
                  "required": required
              })
          }
      }
      
  validation_implementation:
    rust: |
      impl FieldType {
          pub fn validate_value(&self, value: &serde_json::Value) -> anyhow::Result<()> {
              match (self, value) {
                  (FieldType::Text, serde_json::Value::String(_)) => Ok(()),
                  
                  (FieldType::Number { min, max }, serde_json::Value::Number(n)) => {
                      if let Some(i) = n.as_i64() {
                          if let Some(min_val) = min {
                              if i < *min_val {
                                  anyhow::bail!("Value {} below minimum {}", i, min_val);
                              }
                          }
                          if let Some(max_val) = max {
                              if i > *max_val {
                                  anyhow::bail!("Value {} above maximum {}", i, max_val);
                              }
                          }
                          Ok(())
                      } else {
                          anyhow::bail!("Number is not an integer");
                      }
                  },
                  
                  (FieldType::Select { options }, serde_json::Value::String(s)) => {
                      if options.contains(s) {
                          Ok(())
                      } else {
                          anyhow::bail!("Value '{}' not in options: {:?}", s, options);
                      }
                  },
                  
                  (FieldType::PhaseSelector { total_phases }, value) => {
                      let phases: Vec<usize> = match value {
                          serde_json::Value::String(s) => {
                              s.split(',')
                                  .map(|p| p.trim().parse())
                                  .collect::<Result<Vec<_>, _>>()?
                          },
                          serde_json::Value::Array(arr) => {
                              arr.iter()
                                  .map(|v| v.as_u64()
                                      .ok_or_else(|| anyhow::anyhow!("Invalid phase index"))
                                      .map(|u| u as usize))
                                  .collect::<Result<Vec<_>, _>>()?
                          },
                          _ => anyhow::bail!("PhaseSelector must be string or array")
                      };
                      
                      for phase in &phases {
                          if phase >= total_phases {
                              anyhow::bail!("Phase {} out of range (0-{})", phase, total_phases - 1);
                          }
                      }
                      Ok(())
                  },
                  
                  _ => anyhow::bail!("Type mismatch")
              }
          }
      }
      
  mcp_tool_definition:
    rust: |
      // In workflow-manager/src/mcp_server.rs
      use claude_agent_sdk::mcp::{SdkMcpServer, SdkMcpTool, ToolResult};
      use workflow_manager_sdk::FullWorkflowMetadata;
      
      fn create_execute_workflow_tool(
          workflows: Vec<DiscoveredWorkflow>
      ) -> SdkMcpTool {
          SdkMcpTool::new(
              "execute_workflow",
              "Execute a discovered workflow with parameters",
              json!({
                  "type": "object",
                  "properties": {
                      "workflow_id": {
                          "type": "string",
                          "description": "ID of the workflow to execute"
                      },
                      "parameters": {
                          "type": "object",
                          "description": "Workflow parameters (validated against schema)"
                      }
                  },
                  "required": ["workflow_id", "parameters"]
              }),
              move |input| {
                  let workflows = workflows.clone();
                  Box::pin(async move {
                      let workflow_id = input["workflow_id"]
                          .as_str()
                          .ok_or_else(|| anyhow::anyhow!("Missing workflow_id"))?;
                      
                      let workflow = workflows.iter()
                          .find(|w| w.metadata.id == workflow_id)
                          .ok_or_else(|| anyhow::anyhow!("Workflow not found"))?;
                      
                      let params = input["parameters"]
                          .as_object()
                          .ok_or_else(|| anyhow::anyhow!("Invalid parameters"))?;
                      
                      // Validate parameters against schema
                      for field in &workflow.fields {
                          if field.required {
                              if !params.contains_key(&field.name) {
                                  return Ok(ToolResult::error(
                                      format!("Missing required field: {}", field.name)
                                  ));
                              }
                          }
                          
                          if let Some(value) = params.get(&field.name) {
                              if let Err(e) = field.field_type.validate_value(value) {
                                  return Ok(ToolResult::error(
                                      format!("Invalid {}: {}", field.name, e)
                                  ));
                              }
                          }
                      }
                      
                      // Execute workflow
                      let execution_id = execute_workflow_subprocess(workflow, params).await?;
                      
                      Ok(ToolResult::text(format!(
                          "Workflow {} started with execution ID: {}",
                          workflow_id, execution_id
                      )))
                  })
              }
          )
      }

key_insights:
  
  type_system_strengths:
    - "Well-structured enum-based FieldType with serde support"
    - "Macro-driven workflow generation reduces boilerplate"
    - "Already JSON-compatible via serde"
    - "Hierarchical logging system (WorkflowLog) enables rich progress tracking"
    
  type_system_gaps:
    - "No versioning for schema evolution"
    - "No JSON Schema generation (needed for MCP tools)"
    - "PhaseSelector and StateFile lack standard JSON Schema mappings"
    - "No runtime validation beyond type checking"
    
  complex_type_challenges:
    PhaseSelector:
      problem: "Multi-select UI pattern doesn't map to standard JSON Schema"
      current_value: "Comma-separated string ('0,1,2')"
      api_ergonomics: "Arrays ([0,1,2]) are more natural for APIs"
      solution: "Support both via oneOf, use x- extension for metadata"
      
    StateFile:
      problem: "References files that may not exist, pattern is for discovery"
      metadata_loss: "Pattern and source phase not preserved in simple string schema"
      solution: "Use x-state-file extension to preserve metadata"
      benefit: "Enables smart file discovery in MCP clients"
      
  mcp_integration_path:
    discovery: "Already supports JSON metadata export via --workflow-metadata"
    schema_generation: "Needs implementation (Priority 1)"
    execution: "Needs subprocess management and log parsing (Priority 2)"
    state_management: "Needs file discovery helpers (Priority 2)"
    
  backwards_compatibility_strategy:
    versioning: "Add schema_version field with default '1.0.0'"
    optional_fields: "Use #[serde(default)] for all new fields"
    unknown_types: "Add Unknown variant to FieldType for forward compatibility"
    
  api_surface_recommendations:
    mcp_server: "Primary external API (tools for discovery, execution, state)"
    rust_api: "Secondary programmatic API (re-export discovery, add executor)"
    json_schema: "Essential for both MCP and validation"

risks_and_mitigations:
  
  breaking_changes:
    risk: "Adding fields to WorkflowMetadata breaks existing workflows"
    mitigation: "Use #[serde(default)] and version field for detection"
    
  schema_drift:
    risk: "Manual JSON Schema generation diverges from actual serialization"
    mitigation: "Unit tests comparing serde output to schema, or use schemars"
    
  validation_complexity:
    risk: "Complex field types (PhaseSelector, StateFile) hard to validate"
    mitigation: "Comprehensive test suite, document edge cases"
    
  mcp_client_compatibility:
    risk: "Custom x- extensions not understood by all MCP clients"
    mitigation: "Make x- extensions optional enhancements, core schema still valid"
    
  subprocess_management:
    risk: "Workflow execution via subprocess is complex (signals, cleanup, etc.)"
    mitigation: "Use tokio::process, implement proper signal handling and timeouts"

next_steps:
  immediate:
    - "Implement versioning (schema_version, sdk_version)"
    - "Add to_json_schema() methods for FieldType and FieldSchema"
    - "Write unit tests for schema generation"
    
  short_term:
    - "Implement validation (validate_value, validate_parameters)"
    - "Build MCP server with discovery and execution tools"
    - "Add state file discovery helpers"
    
  medium_term:
    - "Implement WorkflowExecutor API for programmatic use"
    - "Add log streaming and subprocess management"
    - "Write comprehensive documentation and examples"
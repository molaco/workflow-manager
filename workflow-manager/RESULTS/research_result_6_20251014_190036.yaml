research_topic: "Type System Analysis for API Exposure in workflow-manager-sdk"
timestamp: "2025-10-14"
analysis_scope: "WorkflowMetadata, FieldSchema, FieldType, WorkflowLog serialization and API mapping"

executive_summary:
  current_state: "Strong foundation with serde-based serialization, but complex types need redesign for API exposure"
  api_readiness: "70% - Simple types ready, PhaseSelector and StateFile require architectural changes"
  key_findings:
    - "All core types use proper serde derives (Serialize, Deserialize)"
    - "Tagged enum pattern works well for WorkflowLog and FieldType"
    - "PhaseSelector and StateFile are CLI/TUI-centric, not suitable for programmatic APIs"
    - "No JSON Schema generation capability exists"
    - "No versioning strategy in serialized data"
    - "FieldSchema mixes concerns (cli_arg field is CLI-specific)"

core_types_analysis:

  WorkflowMetadata:
    location: "workflow-manager-sdk/src/lib.rs:10-15"
    structure:
      fields:
        - "id: String"
        - "name: String"
        - "description: String"
    serialization:
      status: "Fully API-ready"
      derives: "Debug, Clone, Serialize, Deserialize"
      format: "Flat JSON object"
    api_suitability: "EXCELLENT"
    concerns: "None - simple, stable, well-designed"
    mcp_mapping: "Direct 1:1 mapping to JSON properties"
    recommendations: "No changes needed"
    
  FullWorkflowMetadata:
    location: "workflow-manager-sdk/src/lib.rs:18-23"
    structure:
      fields:
        - "metadata: WorkflowMetadata (flattened)"
        - "fields: Vec<FieldSchema>"
    serialization:
      uses_flatten: true
      pattern: "#[serde(flatten)] on metadata field"
    current_usage: "Output format for --workflow-metadata flag"
    discovery_mechanism: "discovery.rs:139 - parses this from binary stdout"
    api_suitability: "GOOD"
    concerns:
      - "No schema_version field for future evolution"
      - "Nested FieldSchema contains CLI-specific fields"
    recommendations:
      add_version_field: |
        #[derive(Debug, Clone, Serialize, Deserialize)]
        pub struct FullWorkflowMetadata {
            #[serde(default = "default_schema_version")]
            pub schema_version: String,
            #[serde(flatten)]
            pub metadata: WorkflowMetadata,
            pub fields: Vec<FieldSchema>,
        }
      create_api_variant: "FullWorkflowMetadataApi with FieldSchemaApi"
    
  FieldSchema:
    location: "workflow-manager-sdk/src/lib.rs:26-37"
    structure:
      fields:
        - "name: String"
        - "field_type: FieldType"
        - "label: String"
        - "description: String"
        - "cli_arg: String ⚠️ CLI-specific"
        - "required: bool"
        - "default: Option<String>"
        - "required_for_phases: Option<Vec<usize>> ⚠️ Internal logic"
    api_suitability: "NEEDS REFACTORING"
    concerns:
      mixed_concerns: "CLI/API/internal validation mixed in one type"
      cli_arg_field: "Not relevant for MCP tools or REST APIs"
      required_for_phases: "Workflow execution logic, not schema metadata"
    recommendations:
      create_separate_type: |
        // API-focused variant
        #[derive(Serialize, Deserialize)]
        pub struct FieldSchemaApi {
            pub name: String,
            pub field_type: FieldTypeApi,
            pub label: String,
            pub description: String,
            pub required: bool,
            pub default: Option<serde_json::Value>, // Not String
        }
        
        impl From<FieldSchema> for FieldSchemaApi {
            fn from(schema: FieldSchema) -> Self {
                FieldSchemaApi {
                    name: schema.name,
                    field_type: schema.field_type.into(),
                    label: schema.label,
                    description: schema.description,
                    required: schema.required,
                    default: schema.default.map(|s| json!(s)),
                }
            }
        }
      keep_internal_type: "FieldSchema stays as-is for TUI/CLI"
      
  FieldType:
    location: "workflow-manager-sdk/src/lib.rs:40-65"
    serialization:
      strategy: "Tagged enum"
      attributes: '#[serde(tag = "type", rename_all = "snake_case")]'
      example_output: '{"type": "number", "min": 1, "max": 10}'
    
    variants_analysis:
      
      Text:
        api_ready: true
        json_schema: '{"type": "string"}'
        mcp_compatible: true
        concerns: "None"
        
      Number:
        fields: "min: Option<i64>, max: Option<i64>"
        api_ready: true
        json_schema: '{"type": "integer", "minimum": N, "maximum": M}'
        mcp_compatible: true
        concerns:
          - "Currently integer-only (i64)"
          - "Consider supporting floating point for broader use cases"
        recommendations: "Add Float variant or rename to Integer + add Number"
        
      FilePath:
        fields: "pattern: Option<String>"
        api_ready: "PARTIALLY"
        json_schema: '{"type": "string", "pattern": "glob"}'
        mcp_compatible: "For local workflows only"
        concerns:
          filesystem_dependency: "Assumes local file access"
          remote_api_problem: "Cannot work with remote API clients"
          pattern_is_glob: "Not regex - incompatible with JSON Schema pattern"
        recommendations:
          api_approach: "Accept string path, URL, or file upload reference"
          mcp_approach: "String parameter with description about expected format"
          separation: "Keep FilePath for local, add FileInput for API"
          
      Select:
        fields: "options: Vec<String>"
        api_ready: true
        json_schema: '{"type": "string", "enum": [...]}'
        mcp_compatible: true
        concerns: "None - perfect mapping to JSON Schema enum"
        
      PhaseSelector:
        fields: "total_phases: usize"
        current_format: "Comma-separated string: '0,1,2,3,4'"
        location_usage: "main.rs:2652-2660"
        api_ready: false
        concerns:
          string_format: "CLI-centric representation"
          not_standard: "No equivalent in JSON Schema"
          ui_coupling: "Type embeds UI display logic"
          validation_scattered: "Parsing and validation not centralized"
        problems:
          mcp_tool_definition: "Cannot represent as standard JSON Schema type"
          programmatic_usage: "Parsing string is error-prone"
          type_safety: "String doesn't convey semantic meaning"
        proposed_solution:
          api_format: "JSON array of integers: [0, 1, 2, 3, 4]"
          internal_format: "Vec<usize>"
          json_schema: '{"type": "array", "items": {"type": "integer", "minimum": 0, "maximum": N}}'
          migration_strategy: |
            // Accept both formats during transition
            #[derive(Serialize, Deserialize)]
            #[serde(untagged)]
            pub enum PhaseInput {
                Array(Vec<usize>),
                String(String), // Parse "0,1,2" -> [0,1,2]
            }
            
            impl PhaseInput {
                pub fn normalize(self) -> Result<Vec<usize>> {
                    match self {
                        PhaseInput::Array(vec) => Ok(vec),
                        PhaseInput::String(s) => {
                            s.split(',')
                                .map(|p| p.trim().parse())
                                .collect::<Result<Vec<_>, _>>()
                                .map_err(|e| anyhow!("Invalid phase format: {}", e))
                        }
                    }
                }
            }
          cli_compatibility: "Keep string input for CLI, convert internally"
          api_usage: "Accept only array format in API"
          
      StateFile:
        fields:
          - "pattern: String (glob pattern)"
          - "phase: Option<usize>"
        current_purpose: "Reference intermediate output from previous workflow phase"
        location_usage: "main.rs:2660-2663"
        api_ready: false
        concerns:
          tight_coupling: "Couples input specification to execution state"
          filesystem_assumption: "Assumes local file access and pattern matching"
          phase_dependency: "Inter-field constraint (phase determines available files)"
          discovery_vs_input: "Pattern is for UI file picker, not input format"
          remote_incompatible: "Cannot work with remote API calls"
        problems:
          api_exposure: "How does remote client provide a file from 'phase 2'?"
          file_upload: "No mechanism for remote file submission"
          pattern_matching: "Server-side concern, not API parameter"
        architectural_issue: "Type conflates three concepts"
        three_concepts:
          - "FileInput: What the user provides (path, URL, or content)"
          - "FilePattern: Discovery constraint for UI (glob pattern)"
          - "StateFileReference: Internal tracking of workflow outputs"
        proposed_solution:
          separate_types: |
            // API input type
            #[derive(Serialize, Deserialize)]
            #[serde(tag = "type", rename_all = "snake_case")]
            pub enum FileInput {
                Path { path: String },
                Url { url: String },
                Content { 
                    filename: String,
                    content: String, // base64
                    mime_type: Option<String>,
                },
                Reference {
                    workflow_id: String,
                    phase: usize,
                    file_id: String,
                }
            }
            
            // Internal workflow state tracking
            #[derive(Serialize, Deserialize)]
            pub struct StateFileReference {
                pub path: PathBuf,
                pub phase: usize,
                pub created_at: String, // ISO timestamp
                pub file_id: String, // unique ID
            }
            
            // Metadata for UI/validation
            #[derive(Serialize, Deserialize)]
            pub struct StateFileConstraint {
                pub pattern: String,
                pub source_phase: Option<usize>,
                pub required_format: Option<String>, // "yaml", "json"
            }
          field_type_change: "Replace StateFile with File that accepts FileInput"
          discovery: "Pattern and phase remain as metadata, not in value type"
          mcp_approach: "String parameter with description about expected format"
          api_approach: "Multi-format support via enum + file upload endpoint"

  WorkflowLog:
    location: "workflow-manager-sdk/src/lib.rs:119-191"
    serialization:
      strategy: "Tagged enum"
      attributes: '#[serde(tag = "type", rename_all = "snake_case")]'
    variants: 11
    current_usage: "Emitted to stderr with __WF_EVENT__: prefix"
    parsing: "main.rs:1397-1425 - parsed by TUI from workflow stderr"
    api_suitability: "EXCELLENT"
    concerns: "None - well-designed for streaming"
    recommendations:
      streaming_api: "Perfect for WebSocket or Server-Sent Events (SSE)"
      rest_api: "Can be used for polling-based status updates"
      mcp_integration: "Can stream events as tool execution progresses"
    example_events:
      - "PhaseStarted {phase: 0, name: 'Analyze', total_phases: 5}"
      - "TaskStarted {phase: 0, task_id: 'task_1', description: '...', total_tasks: Some(3)}"
      - "AgentMessage {task_id: 'task_1', agent_name: 'researcher', message: '...'}"
      - "StateFileCreated {phase: 0, file_path: './output.yaml', description: '...'}"
    state_management: "TUI tracks workflow state via these events (main.rs:1400-1425)"
    
  WorkflowStatus:
    location: "workflow-manager-sdk/src/lib.rs:75-81"
    variants: "NotStarted, Running, Completed, Failed"
    api_suitability: "EXCELLENT"
    concerns: "None - simple enum, perfect for API"
    
  WorkflowProgress:
    location: "workflow-manager-sdk/src/lib.rs:84-90"
    variants: "Started, Progress, Completed, Failed (with message/error)"
    api_suitability: "GOOD"
    concerns:
      - "Overlaps with WorkflowLog (same information, different structure)"
      - "Potentially redundant - could be consolidated"
    recommendations: "Consider deprecating in favor of WorkflowLog for consistency"

serialization_framework:
  current_dependencies:
    serde: "1.0.228 with derive feature"
    serde_json: "1.0.145"
    serde_yaml: "implied in workflow examples"
    jsonschema: "0.18.3 (in claude-agent-sdk dependency tree)"
  
  patterns_used:
    derive_macros: "All types use #[derive(Serialize, Deserialize)]"
    tagged_enums: "#[serde(tag = \"type\", rename_all = \"snake_case\")]"
    flatten: "#[serde(flatten)] for WorkflowMetadata in FullWorkflowMetadata"
    conditional_skip: "#[serde(skip_serializing_if = \"Option::is_none\")]"
    transparency: "Not used (could benefit SessionId-like newtypes)"
  
  strengths:
    - "Clean, idiomatic JSON output"
    - "Type-safe serialization with compile-time checks"
    - "Consistent enum tagging strategy"
    - "Good use of Option for optional fields"
  
  weaknesses:
    - "No JSON Schema generation"
    - "No validation attributes (validator crate)"
    - "No API versioning in types"
    - "No OpenAPI/Swagger annotations"
    - "Default values not well-specified"

json_schema_generation:
  current_state: "Not implemented"
  requirement: "Critical for MCP tool definitions"
  
  dependency_options:
    schemars:
      version: "0.8"
      pros:
        - "Most popular Rust JSON Schema library"
        - "Excellent serde integration"
        - "Supports custom schema attributes"
        - "Can derive JsonSchema alongside Serialize/Deserialize"
      cons:
        - "Adds compile time dependency"
        - "May need customization for complex types"
      example: |
        use schemars::{schema_for, JsonSchema};
        
        #[derive(Serialize, Deserialize, JsonSchema)]
        pub struct FieldSchema {
            #[schemars(description = "Field name")]
            pub name: String,
            // ...
        }
        
        let schema = schema_for!(FieldSchema);
    
    serde_json_schema:
      status: "Less mature than schemars"
      recommendation: "Not recommended"
    
    manual_implementation:
      pros: "Full control, no dependencies"
      cons: "High maintenance burden, error-prone"
      use_case: "For custom types only (PhaseSelector, StateFile)"
  
  recommended_approach:
    primary: "Use schemars for standard types"
    custom: "Manual impl for PhaseSelector and StateFile variants"
    location: "workflow-manager-sdk/src/schema.rs"
    
  implementation_example: |
    // workflow-manager-sdk/src/lib.rs
    impl FieldType {
        /// Generate JSON Schema for this field type
        pub fn to_json_schema(&self) -> serde_json::Value {
            match self {
                FieldType::Text => json!({
                    "type": "string"
                }),
                FieldType::Number { min, max } => {
                    let mut schema = json!({"type": "integer"});
                    if let Some(m) = min {
                        schema.as_object_mut().unwrap()
                            .insert("minimum".to_string(), json!(m));
                    }
                    if let Some(m) = max {
                        schema.as_object_mut().unwrap()
                            .insert("maximum".to_string(), json!(m));
                    }
                    schema
                },
                FieldType::FilePath { pattern } => {
                    let mut schema = json!({
                        "type": "string",
                        "description": "File path (local or URL)"
                    });
                    if let Some(p) = pattern {
                        schema["pattern"] = json!(p);
                    }
                    schema
                },
                FieldType::Select { options } => json!({
                    "type": "string",
                    "enum": options
                }),
                FieldType::PhaseSelector { total_phases } => json!({
                    "type": "array",
                    "items": {
                        "type": "integer",
                        "minimum": 0,
                        "maximum": total_phases - 1
                    },
                    "minItems": 1,
                    "uniqueItems": true,
                    "description": "Array of phase indices to execute"
                }),
                FieldType::StateFile { pattern, phase } => {
                    let mut schema = json!({
                        "type": "string",
                        "description": "File path or reference to workflow output"
                    });
                    if let Some(p) = phase {
                        schema["x-source-phase"] = json!(p);
                    }
                    schema["x-pattern"] = json!(pattern);
                    schema
                }
            }
        }
    }
    
    /// Generate MCP tool schema from workflow metadata
    pub fn workflow_to_mcp_schema(workflow: &FullWorkflowMetadata) -> serde_json::Value {
        let mut properties = serde_json::Map::new();
        let mut required = Vec::new();
        
        for field in &workflow.fields {
            properties.insert(
                field.name.clone(),
                field.field_type.to_json_schema()
            );
            
            if field.required {
                required.push(field.name.clone());
            }
        }
        
        json!({
            "type": "object",
            "properties": properties,
            "required": required
        })
    }

mcp_tool_integration:
  context:
    sdk: "claude-agent-sdk-rust (local dependency)"
    tool_definition: "src/mcp/tool.rs:52-154"
    schema_format: "JSON Schema passed to SdkMcpTool::new()"
    validation: "jsonschema 0.18.3 used for runtime validation"
  
  current_example: |
    // From test2.rs example
    SdkMcpTool::new(
        "notify_tts",
        "Send text-to-speech notification",
        json!({
            "type": "object",
            "properties": {
                "text": {
                    "type": "string",
                    "description": "Text to speak"
                }
            },
            "required": ["text"]
        }),
        |input| Box::pin(async move {
            // handler implementation
        })
    )
  
  workflow_as_mcp_tool:
    approach: "Generate MCP tool from FullWorkflowMetadata"
    implementation: |
      use workflow_manager_sdk::{FullWorkflowMetadata, workflow_to_mcp_schema};
      use claude_agent_sdk::mcp::{SdkMcpTool, ToolResult};
      
      fn workflow_to_mcp_tool(
          workflow: FullWorkflowMetadata,
          executor: impl Fn(HashMap<String, String>) -> Future<Output = Result<String>>
      ) -> SdkMcpTool {
          let schema = workflow_to_mcp_schema(&workflow);
          
          SdkMcpTool::new(
              workflow.id.clone(),
              workflow.description.clone(),
              schema,
              move |input| {
                  let workflow_id = workflow.id.clone();
                  Box::pin(async move {
                      // Convert JSON input to field values
                      let field_values = parse_mcp_input(input, &workflow)?;
                      
                      // Execute workflow
                      let result = executor(field_values).await?;
                      
                      Ok(ToolResult::text(result))
                  })
              }
          )
      }
    
    challenges:
      phase_selector: "Array format works naturally in MCP"
      state_file: "String path works for local, needs file upload for remote"
      file_path: "Same issue as StateFile"
      validation: "Need to validate phase indices, file patterns, etc."
  
  conversion_function: |
    /// Convert MCP tool input (JSON) to workflow field values
    fn parse_mcp_input(
        input: serde_json::Value,
        workflow: &FullWorkflowMetadata
    ) -> Result<HashMap<String, String>> {
        let mut field_values = HashMap::new();
        
        for field in &workflow.fields {
            let value = input.get(&field.name);
            
            let string_value = match (&field.field_type, value) {
                (FieldType::Text, Some(v)) => {
                    v.as_str().ok_or_else(|| anyhow!("Expected string"))?.to_string()
                },
                (FieldType::Number { .. }, Some(v)) => {
                    v.as_i64().ok_or_else(|| anyhow!("Expected integer"))?.to_string()
                },
                (FieldType::PhaseSelector { .. }, Some(v)) => {
                    // Accept array: [0, 1, 2] -> "0,1,2"
                    let arr = v.as_array().ok_or_else(|| anyhow!("Expected array"))?;
                    arr.iter()
                        .map(|n| n.as_u64().ok_or_else(|| anyhow!("Invalid phase")))
                        .collect::<Result<Vec<_>>>()?
                        .iter()
                        .map(|n| n.to_string())
                        .collect::<Vec<_>>()
                        .join(",")
                },
                (FieldType::StateFile { .. }, Some(v)) => {
                    // Accept string path
                    v.as_str().ok_or_else(|| anyhow!("Expected string"))?.to_string()
                },
                (FieldType::FilePath { .. }, Some(v)) => {
                    v.as_str().ok_or_else(|| anyhow!("Expected string"))?.to_string()
                },
                (FieldType::Select { options }, Some(v)) => {
                    let s = v.as_str().ok_or_else(|| anyhow!("Expected string"))?;
                    if !options.contains(&s.to_string()) {
                        anyhow::bail!("Invalid option: {}", s);
                    }
                    s.to_string()
                },
                (_, None) if field.required => {
                    anyhow::bail!("Missing required field: {}", field.name);
                },
                (_, None) => {
                    field.default.clone().unwrap_or_default()
                },
                _ => anyhow::bail!("Type mismatch for field: {}", field.name),
            };
            
            field_values.insert(field.name.clone(), string_value);
        }
        
        Ok(field_values)
    }

versioning_strategy:
  current_state:
    crate_version: "0.1.0 in Cargo.toml"
    serialized_data: "No version field in types"
    breaking_changes: "No detection mechanism"
    risk: "HIGH - Cannot detect or migrate old formats"
  
  requirements:
    semantic_versioning: "Follow semver for crate"
    data_versioning: "Version serialized data independently"
    migration_support: "Parse old formats and convert"
    deprecation_path: "Gradual transition for breaking changes"
  
  proposed_implementation:
    add_schema_version: |
      #[derive(Debug, Clone, Serialize, Deserialize)]
      pub struct FullWorkflowMetadata {
          #[serde(default = "default_schema_version")]
          pub schema_version: String,
          #[serde(flatten)]
          pub metadata: WorkflowMetadata,
          pub fields: Vec<FieldSchema>,
      }
      
      fn default_schema_version() -> String {
          "1.0".to_string()
      }
    
    version_parser: |
      pub fn parse_workflow_metadata(json: &str) -> Result<FullWorkflowMetadata> {
          let value: serde_json::Value = serde_json::from_str(json)?;
          let version = value.get("schema_version")
              .and_then(|v| v.as_str())
              .unwrap_or("1.0");
          
          match version {
              "1.0" => serde_json::from_value(value)
                  .map_err(|e| anyhow!("Parse error: {}", e)),
              "1.1" => {
                  // Parse v1.1 and convert to current format
                  let v1_1: FullWorkflowMetadataV1_1 = serde_json::from_value(value)?;
                  Ok(v1_1.to_current())
              },
              _ => Err(anyhow!("Unsupported schema version: {}", version))
          }
      }
    
    version_mapping:
      v1_0: "Current state (no explicit version field)"
      v1_1: "Add schema_version, keep all existing fields"
      v1_2: "Deprecate cli_arg, mark with #[deprecated]"
      v2_0: "Remove cli_arg, change PhaseSelector/StateFile types"
  
  api_versioning:
    http_api: "URL path versioning: /v1/workflows, /v2/workflows"
    mcp_tools: "Tool name suffix or separate server versions"
    semver: "Crate version tracks API compatibility"

backwards_compatibility:
  existing_workflows:
    discovery_mechanism: "discovery.rs - executes binaries with --workflow-metadata"
    format: "JSON output of FullWorkflowMetadata"
    parsing: "serde_json::from_str() at discovery.rs:139"
    impact: "Any breaking changes break workflow discovery"
  
  safe_changes:
    - "Adding optional fields (with #[serde(default)])"
    - "Adding new FieldType variants"
    - "Adding new WorkflowLog event types"
    - "Adding methods to existing types"
    - "Adding new types (doesn't affect existing types)"
  
  breaking_changes_to_avoid:
    - "Removing fields from FullWorkflowMetadata"
    - "Renaming fields without #[serde(rename = \"old_name\")]"
    - "Changing FieldType enum variant names"
    - "Changing JSON structure (e.g., removing #[serde(flatten)])"
    - "Changing enum tagging strategy"
  
  migration_strategy:
    phase_1_additive:
      version: "0.2.0"
      changes:
        - "Add schema_version field (optional)"
        - "Add API types alongside internal types"
        - "Add JSON Schema generation"
      breaking: false
      
    phase_2_deprecation:
      version: "0.3.0"
      changes:
        - "Mark cli_arg as deprecated"
        - "Add PhaseInput enum (accept both formats)"
        - "Add FileInput enum"
      breaking: false
      
    phase_3_stabilization:
      version: "1.0.0"
      changes:
        - "Remove deprecated fields"
        - "Finalize API types"
        - "Lock schema version"
      breaking: true
      migration_guide: "Required"

implementation_roadmap:

  immediate_priority_1:
    task: "Add FieldType::to_json_schema() method"
    file: "workflow-manager-sdk/src/lib.rs"
    effort: "2-3 hours"
    dependencies: "None"
    impact: "Enables MCP tool generation"
    implementation_notes: "Pattern shown in json_schema_generation section"
    
  immediate_priority_2:
    task: "Add workflow_to_mcp_schema() function"
    file: "workflow-manager-sdk/src/lib.rs"
    effort: "1-2 hours"
    dependencies: "Priority 1 (to_json_schema)"
    impact: "Direct MCP integration"
    testing: "Generate schema from test workflow, validate structure"
    
  immediate_priority_3:
    task: "Add schema_version field to FullWorkflowMetadata"
    file: "workflow-manager-sdk/src/lib.rs"
    effort: "1 hour"
    dependencies: "None"
    impact: "Future-proofs serialization format"
    migration: "Use #[serde(default)] to maintain compatibility"
    
  short_term_priority_1:
    task: "Add schemars dependency"
    file: "workflow-manager-sdk/Cargo.toml"
    effort: "30 minutes + testing"
    dependencies: "None"
    impact: "Enables automatic JSON Schema generation"
    version: "schemars = \"0.8\""
    
  short_term_priority_2:
    task: "Create API types module"
    file: "workflow-manager-sdk/src/api.rs"
    effort: "4-6 hours"
    dependencies: "None"
    impact: "Clean separation of concerns"
    contents:
      - "FieldSchemaApi (without cli_arg, required_for_phases)"
      - "FieldTypeApi (with redesigned PhaseSelector, StateFile)"
      - "Conversion traits: From<FieldSchema> for FieldSchemaApi"
    
  medium_term_priority_1:
    task: "Redesign PhaseSelector for API"
    file: "workflow-manager-sdk/src/lib.rs"
    effort: "1-2 days"
    dependencies: "API types module"
    impact: "Proper MCP and REST API support"
    approach: |
      // Internal enum for flexible parsing
      #[derive(Serialize, Deserialize)]
      #[serde(untagged)]
      pub enum PhaseInput {
          Array(Vec<usize>),
          String(String), // For CLI compatibility
      }
      
      impl PhaseInput {
          pub fn normalize(self) -> Result<Vec<usize>> { ... }
      }
    testing: "Test both array and string parsing"
    
  medium_term_priority_2:
    task: "Redesign StateFile for API"
    file: "workflow-manager-sdk/src/api.rs"
    effort: "2-3 days"
    dependencies: "API types module"
    impact: "Enables remote file handling"
    approach: "Separate FileInput, StateFileConstraint, StateFileReference"
    
  long_term_priority_1:
    task: "Implement version migration system"
    file: "workflow-manager-sdk/src/version.rs"
    effort: "3-5 days"
    dependencies: "schema_version field"
    impact: "Smooth upgrades across versions"
    
  long_term_priority_2:
    task: "Add validation framework"
    file: "workflow-manager-sdk/src/validation.rs"
    effort: "3-4 days"
    dependencies: "API types"
    impact: "Better error messages, input validation"
    approach: "Use validator crate or custom implementation"

risks_and_mitigations:
  
  risk_breaking_workflows:
    severity: "HIGH"
    probability: "MEDIUM"
    impact: "Existing workflows fail to load"
    detection: "Integration tests with compiled workflow binaries"
    mitigation:
      - "Maintain strict backwards compatibility in v0.x"
      - "Use #[serde(default)] for new fields"
      - "Test with all example workflows before release"
      - "Version detection and migration support"
    
  risk_mcp_schema_complexity:
    severity: "MEDIUM"
    probability: "MEDIUM"
    impact: "Claude cannot understand complex types"
    detection: "Test MCP tools with actual Claude API"
    mitigation:
      - "Keep schemas simple (use standard JSON Schema types)"
      - "Use clear descriptions for complex types"
      - "Provide examples in schema descriptions"
      - "Fall back to string types with validation"
    
  risk_phase_selector_confusion:
    severity: "MEDIUM"
    probability: "LOW"
    impact: "Users confused by array vs string format"
    detection: "User testing, error rate monitoring"
    mitigation:
      - "Accept both formats during transition"
      - "Clear error messages for invalid input"
      - "Documentation with examples"
      - "TUI continues to use string format"
    
  risk_file_handling_complexity:
    severity: "HIGH"
    probability: "HIGH"
    impact: "Remote workflows cannot access files"
    detection: "API testing with remote client"
    mitigation:
      - "Design file upload/download API endpoints"
      - "Support multiple file input methods"
      - "Clear documentation on file handling"
      - "File size limits and validation"

code_examples:

  complete_mcp_integration_example: |
    // workflow-manager/src/mcp_server.rs
    use workflow_manager_sdk::{FullWorkflowMetadata, workflow_to_mcp_schema};
    use claude_agent_sdk::mcp::{SdkMcpServer, SdkMcpTool, ToolResult};
    use std::collections::HashMap;
    
    /// Create MCP server with all discovered workflows as tools
    pub fn create_workflow_mcp_server(
        workflows: Vec<DiscoveredWorkflow>
    ) -> Result<SdkMcpServer> {
        let mut server = SdkMcpServer::new("workflow-manager");
        
        for workflow in workflows {
            let tool = workflow_to_mcp_tool(workflow)?;
            server = server.tool(tool);
        }
        
        Ok(server)
    }
    
    /// Convert discovered workflow to MCP tool
    fn workflow_to_mcp_tool(workflow: DiscoveredWorkflow) -> Result<SdkMcpTool> {
        let full_metadata = FullWorkflowMetadata {
            metadata: workflow.metadata.clone(),
            fields: workflow.fields.clone(),
        };
        
        let schema = workflow_to_mcp_schema(&full_metadata);
        let binary_path = workflow.binary_path.clone();
        
        Ok(SdkMcpTool::new(
            workflow.metadata.id.clone(),
            workflow.metadata.description.clone(),
            schema,
            move |input| {
                let workflow_id = workflow.metadata.id.clone();
                let binary_path = binary_path.clone();
                let full_metadata = full_metadata.clone();
                
                Box::pin(async move {
                    // Parse MCP input to field values
                    let field_values = parse_mcp_input(input, &full_metadata)?;
                    
                    // Build command
                    let mut cmd = Command::new(&binary_path);
                    for (name, value) in field_values {
                        let field = full_metadata.fields.iter()
                            .find(|f| f.name == name)
                            .ok_or_else(|| anyhow!("Unknown field: {}", name))?;
                        
                        cmd.arg(&field.cli_arg).arg(value);
                    }
                    
                    // Execute workflow
                    let output = cmd.output().await?;
                    
                    if output.status.success() {
                        let result = String::from_utf8_lossy(&output.stdout);
                        Ok(ToolResult::text(result.to_string()))
                    } else {
                        let error = String::from_utf8_lossy(&output.stderr);
                        Ok(ToolResult::error(error.to_string()))
                    }
                })
            }
        ))
    }

testing_requirements:
  
  unit_tests:
    - test_name: "test_field_type_json_schema"
      purpose: "Verify JSON Schema generation for each FieldType"
      location: "workflow-manager-sdk/src/lib.rs"
      
    - test_name: "test_workflow_to_mcp_schema"
      purpose: "Verify complete workflow schema generation"
      location: "workflow-manager-sdk/src/lib.rs"
      
    - test_name: "test_phase_input_parsing"
      purpose: "Test array and string format parsing"
      location: "workflow-manager-sdk/src/lib.rs"
      
    - test_name: "test_serialization_roundtrip"
      purpose: "Ensure serialize -> deserialize preserves data"
      location: "workflow-manager-sdk/src/lib.rs"
      
    - test_name: "test_schema_version_default"
      purpose: "Verify schema_version defaults correctly"
      location: "workflow-manager-sdk/src/lib.rs"
  
  integration_tests:
    - test_name: "test_mcp_tool_invocation"
      purpose: "End-to-end test of workflow as MCP tool"
      location: "workflow-manager/tests/mcp_integration.rs"
      
    - test_name: "test_workflow_discovery_compatibility"
      purpose: "Ensure new version can discover old workflows"
      location: "workflow-manager/tests/discovery_compat.rs"
      
    - test_name: "test_api_type_conversions"
      purpose: "Test FieldSchema <-> FieldSchemaApi conversion"
      location: "workflow-manager-sdk/tests/api_types.rs"

documentation_needs:
  
  api_documentation:
    - "JSON Schema format for each FieldType"
    - "How to generate MCP tools from workflows"
    - "Version migration guide"
    - "Examples of API vs CLI usage"
    
  developer_documentation:
    - "Architecture decision: Why separate API types"
    - "How to add new FieldType variants"
    - "Versioning policy"
    - "Testing guidelines for serialization"
    
  user_documentation:
    - "How PhaseSelector works (array vs string)"
    - "File handling in remote workflows"
    - "MCP tool usage examples"

summary:
  current_api_readiness: "70%"
  blocking_issues:
    - "PhaseSelector string format incompatible with standard JSON Schema"
    - "StateFile type assumes local filesystem access"
    - "No JSON Schema generation capability"
    - "No versioning in serialized data"
  
  recommended_immediate_actions:
    1: "Implement FieldType::to_json_schema() method"
    2: "Add schema_version field to FullWorkflowMetadata"
    3: "Create workflow_to_mcp_schema() function"
  
  recommended_short_term_actions:
    1: "Add schemars dependency for automatic schema generation"
    2: "Create api module with FieldSchemaApi and FieldTypeApi"
    3: "Implement PhaseInput enum (accept array or string)"
  
  recommended_medium_term_actions:
    1: "Redesign StateFile → FileInput + StateFileConstraint + StateFileReference"
    2: "Add validation framework"
    3: "Implement version migration system"
  
  estimated_timeline:
    immediate: "1 week - JSON Schema generation"
    short_term: "2-3 weeks - API types and PhaseSelector redesign"
    medium_term: "4-6 weeks - StateFile redesign and validation"
    long_term: "8-10 weeks - Full API maturity with versioning"
  
  success_criteria:
    - "All FieldTypes can generate JSON Schema"
    - "Workflows can be automatically exposed as MCP tools"
    - "PhaseSelector accepts both array and string formats"
    - "StateFile redesigned for remote file handling"
    - "schema_version field enables future migrations"
    - "100% backwards compatibility with existing workflows"
    - "API types separated from CLI/TUI types"

conclusion: |
  The workflow-manager-sdk type system has a solid foundation with serde-based
  serialization, but requires targeted enhancements for full API exposure. The main
  challenges are PhaseSelector and StateFile types, which are currently CLI/TUI-centric
  and not suitable for programmatic APIs or MCP tools.
  
  The recommended approach is to:
  1. Add JSON Schema generation capability (immediate)
  2. Create separate API types that mirror internal types without CLI concerns (short-term)
  3. Redesign PhaseSelector to accept JSON arrays while maintaining CLI compatibility (medium-term)
  4. Completely redesign StateFile into separate concerns for API input vs internal tracking (medium-term)
  5. Implement versioning to enable future schema evolution (ongoing)
  
  This approach maintains 100% backwards compatibility with existing workflows while
  enabling modern API patterns for MCP tools and future REST/GraphQL APIs.
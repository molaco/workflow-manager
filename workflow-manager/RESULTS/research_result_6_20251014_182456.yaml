metadata:
  project: workflow-manager
  sdk_version: 0.1.0
  analysis_scope: type_system_api_exposure
  
core_types:
  location: /workflow-manager-sdk/src/lib.rs
  
  WorkflowMetadata:
    line: 10-15
    purpose: Basic workflow identification
    fields:
      - id: String
      - name: String
      - description: String
    serialization:
      derives: "Serialize, Deserialize"
      format: flat_json
    status: api_ready
    notes: Simple, stable structure suitable for API exposure
    
  FullWorkflowMetadata:
    line: 18-23
    purpose: Complete workflow metadata with field schemas
    fields:
      - metadata: WorkflowMetadata (flattened via serde)
      - fields: Vec<FieldSchema>
    serialization:
      derives: "Serialize, Deserialize"
      flatten: metadata field uses #[serde(flatten)]
    status: api_ready
    current_usage: JSON export for workflow discovery
    notes: Used for --workflow-metadata CLI flag output
    
  FieldSchema:
    line: 26-37
    purpose: Define input field metadata for workflows
    fields:
      - name: String
      - field_type: FieldType (enum)
      - label: String
      - description: String
      - cli_arg: String
      - required: bool
      - default: Option<String>
      - required_for_phases: Option<Vec<usize>>
    serialization:
      derives: "Serialize, Deserialize"
      conditional: required_for_phases uses skip_serializing_if
    status: needs_enhancement
    api_concerns:
      - cli_arg is CLI-specific, not needed for API
      - required_for_phases is workflow-internal logic
      - needs separation of concerns for API vs internal use
      
  FieldType:
    line: 40-65
    purpose: Strongly-typed field types for validation
    serialization:
      strategy: tagged enum
      tag: type
      rename: snake_case
    variants:
      Text:
        api_mapping: string
        json_schema: '{"type": "string"}'
        mcp_compatible: yes
        
      Number:
        fields:
          - min: Option<i64>
          - max: Option<i64>
        api_mapping: integer with constraints
        json_schema: '{"type": "integer", "minimum": N, "maximum": M}'
        mcp_compatible: yes
        notes: Uses skip_serializing_if for optional constraints
        
      FilePath:
        fields:
          - pattern: Option<String>
        api_mapping: string with validation
        json_schema: '{"type": "string", "pattern": "..."}'
        mcp_compatible: yes
        notes: Pattern for glob matching
        
      Select:
        fields:
          - options: Vec<String>
        api_mapping: enum/oneOf
        json_schema: '{"type": "string", "enum": [...]}'
        mcp_compatible: yes
        
      PhaseSelector:
        fields:
          - total_phases: usize
        api_mapping: complex (comma-separated phase list)
        current_format: "0,1,2,3,4"
        status: needs_redesign
        concerns:
          - Not standard JSON Schema type
          - String format is CLI-centric
          - Should be array of integers for API
          - UI-specific logic embedded in type
        recommendations:
          - "API: Accept array of integers"
          - "CLI: Keep string parsing for backwards compatibility"
          - "MCP: Use JSON array parameter"
          
      StateFile:
        fields:
          - pattern: String (glob pattern)
          - phase: Option<usize>
        api_mapping: complex (file reference with phase context)
        status: needs_redesign
        concerns:
          - Couples file selection to workflow execution state
          - Pattern is filesystem-specific
          - Phase dependency creates inter-field constraints
          - Not suitable for remote API calls
        recommendations:
          - "API: Accept file path or content directly"
          - Consider file upload mechanism
          - Separate pattern matching from API schema
          - Phase validation should be server-side
          
  WorkflowLog:
    line: 119-191
    purpose: Structured event logging for workflow execution
    serialization:
      strategy: tagged enum
      tag: type
      rename: snake_case
    variants:
      - PhaseStarted
      - PhaseCompleted
      - PhaseFailed
      - TaskStarted
      - TaskProgress
      - TaskCompleted
      - TaskFailed
      - AgentStarted
      - AgentMessage
      - AgentCompleted
      - AgentFailed
      - StateFileCreated
    status: api_ready
    usage: "Event streaming via stderr parsing (__WF_EVENT__:)"
    api_potential: WebSocket/SSE event stream
    
  WorkflowStatus:
    line: 75-81
    purpose: Workflow execution state
    variants:
      - NotStarted
      - Running
      - Completed
      - Failed
    serialization: "Serialize, Deserialize, PartialEq"
    status: api_ready
    
  WorkflowProgress:
    line: 84-90
    purpose: Progress update messages
    serialization: tagged enum
    status: api_ready
    notes: Could be merged with WorkflowLog for consistency

current_state:
  framework: serde 1.0.228
  formats:
    - json: serde_json 1.0.145
    - yaml: implied via examples
  
  patterns_used:
    - derive_macros: "Serialize, Deserialize"
    - tagged_enums: "#[serde(tag = \"type\", rename_all = \"snake_case\")]"
    - flatten: "#[serde(flatten)]"
    - conditional_skip: "#[serde(skip_serializing_if = \"Option::is_none\")]"
    
  strengths:
    - Clean JSON output
    - Type-safe serialization
    - Idiomatic Rust patterns
    - Good enum discrimination with tags
    
  gaps:
    - No JSON Schema generation
    - No API versioning in serialized data
    - No validation attributes
    - No OpenAPI/Swagger annotations

json_schema_generation:
  status: not_implemented
  dependencies_available:
    - jsonschema: 0.18.3 (in dependency tree)
    - schemars: not included
    
  recommendation:
    add_crate: schemars
    version: "0.8"
    benefits:
      - Auto-generate JSON Schema from types
      - MCP tool definition generation
      - API documentation
      - Client SDK generation
      - Validation schemas
      
  implementation_example: |
    use schemars::{schema_for, JsonSchema};
    
    #[derive(Serialize, Deserialize, JsonSchema)]
    pub struct FieldSchema {
        // ... fields
    }
    
    // Generate schema
    let schema = schema_for!(FieldSchema);
    let json_schema = serde_json::to_string_pretty(&schema)?;

mapping_analysis:
  Text:
    json_schema_type: string
    api_representation: string
    validation: none (can add minLength, maxLength, pattern)
    example: '{"type": "string"}'
    
  Number:
    json_schema_type: integer
    api_representation: i64
    validation: min/max constraints
    example: '{"type": "integer", "minimum": 1, "maximum": 5}'
    notes: Consider f64 support for floating point
    
  FilePath:
    json_schema_type: string
    api_representation: string (path or URI)
    validation: pattern matching
    concerns:
      - Local filesystem paths invalid for remote API
      - Need file upload endpoint
      - Consider base64 encoding or multipart form data
    mcp_approach: string parameter with pattern validation
    rest_api_approach: separate file upload endpoint, return file ID
    
  Select:
    json_schema_type: string with enum
    api_representation: string
    validation: enum constraint
    example: '{"type": "string", "enum": ["option1", "option2"]}'
    
  PhaseSelector:
    current: string (e.g., "0,1,2,3,4")
    proposed_api: array of integers
    json_schema: '{"type": "array", "items": {"type": "integer"}}'
    migration_strategy:
      - Accept both formats during transition
      - Normalize internally to Vec<usize>
      - Deprecate string format in v2.0
    backward_compatibility:
      - "Parser function: parse_phases(input: String | Array) -> Vec<usize>"
      - CLI keeps string format
      - API uses array format
      
  StateFile:
    current: string (file path with pattern/phase metadata)
    proposed_api: object with multiple representations
    json_schema: |
      {
        "oneOf": [
          {"type": "string", "description": "File path"},
          {
            "type": "object",
            "properties": {
              "path": {"type": "string"},
              "phase": {"type": "integer"},
              "content": {"type": "string", "description": "Base64 encoded"}
            }
          }
        ]
      }
    concerns:
      - Pattern matching is server-side concern
      - Phase is execution context, not input parameter
      - File selection UI logic should not be in type system
    recommendations:
      - Separate StateFileInput (API) from StateFileReference (internal)
      - Phase validation at workflow execution layer
      - Pattern matching for discovery, not submission

mcp_context:
  sdk: claude-agent-sdk (dependency)
  tool_format: JSON Schema based
  example_from_codebase: test2.rs:180-205 (notify_tts tool)
  
  current_mcp_tool_creation: |
    SdkMcpTool::new(
        "tool_name",
        "description",
        json!({
            "type": "object",
            "properties": { ... },
            "required": [ ... ]
        }),
        handler_function
    )

workflow_to_mcp_conversion:
  approach: Generate MCP tool definition from WorkflowMetadata + FieldSchema
  
  proposed_function: |
    pub fn to_mcp_tool_schema(metadata: &FullWorkflowMetadata) -> Value {
        let mut properties = Map::new();
        let mut required = Vec::new();
        
        for field in &metadata.fields {
            properties.insert(
                field.name.clone(),
                field.field_type.to_json_schema()
            );
            if field.required {
                required.push(field.name.clone());
            }
        }
        
        json!({
            "type": "object",
            "properties": properties,
            "required": required,
            "description": metadata.metadata.description
        })
    }
    
  needed_method_on_FieldType: |
    impl FieldType {
        pub fn to_json_schema(&self) -> Value {
            match self {
                FieldType::Text => json!({"type": "string"}),
                FieldType::Number { min, max } => {
                    let mut schema = json!({"type": "integer"});
                    if let Some(m) = min {
                        schema["minimum"] = json!(m);
                    }
                    if let Some(m) = max {
                        schema["maximum"] = json!(m);
                    }
                    schema
                },
                FieldType::FilePath { pattern } => {
                    let mut schema = json!({"type": "string"});
                    if let Some(p) = pattern {
                        schema["pattern"] = json!(p);
                    }
                    schema
                },
                FieldType::Select { options } => {
                    json!({"type": "string", "enum": options})
                },
                FieldType::PhaseSelector { total_phases } => {
                    json!({
                        "type": "array",
                        "items": {"type": "integer", "minimum": 0, "maximum": total_phases - 1}
                    })
                },
                FieldType::StateFile { .. } => {
                    json!({"type": "string", "description": "File path"})
                }
            }
        }
    }

PhaseSelector:
  current_implementation:
    ui_location: src/main.rs:2444-2450
    display: Shows comma-separated string "0,1,2,3,4"
    storage: String in HashMap<String, String>
    
  problems:
    - UI logic coupled to data type
    - String format is arbitrary
    - Validation scattered
    - Not suitable for programmatic API
    
  proposed_redesign:
    internal_type: Vec<usize>
    api_input: JSON array of integers
    cli_input: comma-separated string (parsed)
    serialization: |
      #[derive(Serialize, Deserialize)]
      #[serde(untagged)]
      pub enum PhaseSelection {
          Array(Vec<usize>),
          #[serde(skip_deserializing)]
          String(String), // Only for serialization back to CLI
      }
    
    conversion: |
      impl PhaseSelection {
          pub fn to_vec(&self) -> Vec<usize> { ... }
          pub fn from_str(s: &str) -> Result<Self> { ... }
      }
      
StateFile:
  current_implementation:
    ui_location: src/main.rs:2452-2455
    purpose: Reference intermediate output files from previous phases
    pattern: Glob pattern for file matching
    phase: Optional phase number context
    
  problems:
    - Tightly couples input to workflow execution state
    - Assumes local filesystem access
    - Pattern matching is discovery mechanism, not input type
    - Cannot work with remote/uploaded files
    
  proposed_redesign:
    separate_concerns:
      - "StateFileReference: Internal workflow state tracking"
      - "FileInput: API input (path, URL, or content)"
      - "FilePattern: Discovery/validation metadata"
      
    api_type: |
      #[derive(Serialize, Deserialize)]
      pub enum FileInput {
          Path(String),
          Url(String),
          Content { filename: String, data: String }, // base64
      }
      
    internal_type: |
      #[derive(Serialize, Deserialize)]
      pub struct StateFileReference {
          pub path: PathBuf,
          pub phase: usize,
          pub created_at: DateTime<Utc>,
      }
      
    field_schema_extension: |
      #[derive(Serialize, Deserialize)]
      pub struct StateFileConstraint {
          pub pattern: String,      // For discovery
          pub phase: Option<usize>,  // For validation
          pub required_format: Option<String>, // yaml, json, etc.
      }

versioning_strategy:
  current_state:
    version_tracking: Cargo.toml only (v0.1.0)
    serialized_data: No version field in structs
    schema_evolution: Not planned
    risk: Breaking changes have no detection mechanism
    
  proposed_versioning:
    semantic_versioning: Follow semver strictly
    major: Breaking type changes
    minor: New optional fields
    patch: Bug fixes, no schema changes
    
  type_versioning:
    approach_1_version_in_data: |
      #[derive(Serialize, Deserialize)]
      pub struct VersionedWorkflowMetadata {
          #[serde(default = "default_version")]
          pub schema_version: String, // "1.0.0"
          #[serde(flatten)]
          pub data: WorkflowMetadata,
      }
      
      fn default_version() -> String {
          "1.0.0".to_string()
      }
    
    approach_2_api_versioning: |
      // HTTP API: /v1/workflows, /v2/workflows
      // MCP: Tool name suffix or metadata
      pub struct WorkflowApiV1 { ... }
      pub struct WorkflowApiV2 { ... }
      
  migration_strategy:
    parser_functions: |
      pub fn parse_workflow_metadata(json: &str) -> Result<WorkflowMetadata> {
          // Try to deserialize with version detection
          let value: Value = serde_json::from_str(json)?;
          let version = value.get("schema_version")
              .and_then(|v| v.as_str())
              .unwrap_or("1.0.0");
              
          match version {
              "1.0.0" => serde_json::from_value(value),
              "2.0.0" => {
                  let v2: WorkflowMetadataV2 = serde_json::from_value(value)?;
                  Ok(v2.to_v1()) // Convert to current version
              }
              _ => Err(anyhow!("Unsupported schema version: {}", version))
          }
      }

compatibility_concerns:
  existing_workflows:
    count: 6 example workflows discovered
    location: ~/.workflow-manager/workflows/
    discovery_mechanism: Binary execution with --workflow-metadata flag
    format: JSON output of FullWorkflowMetadata
    
  breaking_changes_to_avoid:
    - Removing fields from FullWorkflowMetadata
    - Changing field names in FieldSchema
    - Changing FieldType enum variants
    - Changing JSON serialization format
    
  safe_changes:
    - Adding optional fields (with #[serde(default)])
    - Adding new FieldType variants
    - Adding methods to existing types
    - Adding new logging events to WorkflowLog
    
  migration_path:
    phase_1_current: |
      - v0.1.0: Current state
      - CLI-based workflow execution
      - JSON metadata export
      
    phase_2_api_layer: |
      - v0.2.0: Add API types alongside existing types
      - Keep FieldSchema for internal use
      - Add FieldSchemaApi for API exposure
      - Conversion functions between types
      
    phase_3_unification: |
      - v0.3.0: Deprecate CLI-specific fields
      - Mark cli_arg as deprecated
      - Add #[serde(skip_serializing_if = "Option::is_none")]
      - Document migration guide
      
    phase_4_v1_api: |
      - v1.0.0: Stable API release
      - Clean separation of concerns
      - Full MCP integration
      - REST API (optional)
      - Backwards compatibility layer for old workflows

immediate_actions:
  priority_high:
    - action: Add schemars dependency
      reason: Enable JSON Schema generation
      impact: Foundation for MCP and API docs
      
    - action: Implement FieldType::to_json_schema()
      reason: Convert types to JSON Schema
      impact: MCP tool definition generation
      file: workflow-manager-sdk/src/lib.rs
      
    - action: Add schema_version field to FullWorkflowMetadata
      reason: Future-proof serialization
      impact: Enable version detection and migration
      
    - action: Create API-specific types module
      reason: Separate API concerns from internal types
      impact: Clean architecture, easier evolution
      location: workflow-manager-sdk/src/api/
      
  priority_medium:
    - action: Redesign PhaseSelector for API
      reason: Current string format not API-friendly
      impact: Better MCP integration
      approach: Accept both array and string, normalize internally
      
    - action: Redesign StateFile for API
      reason: Filesystem coupling prevents remote use
      impact: Enable remote workflows
      approach: Separate FileInput from StateFileReference
      
    - action: Add validation framework
      reason: Type-safe input validation
      impact: Better error messages, security
      suggestion: validator crate integration
      
  priority_low:
    - action: Consolidate WorkflowProgress and WorkflowLog
      reason: Overlapping concerns
      impact: Simpler event model
      breaking: Yes, defer to v2.0
      
    - action: Add OpenAPI/Swagger annotations
      reason: REST API documentation
      impact: Better API discoverability
      conditional: If building REST API

code_structure_proposal:
  directory_structure:
    base: workflow-manager-sdk/src/
    files:
      - lib.rs: Re-export main types
      - types.rs: Core types (current lib.rs content)
      - api.rs: API-specific types and conversions
      - schema.rs: JSON Schema generation
      - version.rs: Version handling and migration
      - validation.rs: Input validation
    
  api_module_example: |
    // api.rs
    use crate::{FieldSchema, FieldType};
    
    #[derive(Serialize, Deserialize, JsonSchema)]
    pub struct FieldSchemaApi {
        pub name: String,
        pub field_type: FieldTypeApi,
        pub label: String,
        pub description: String,
        pub required: bool,
        pub default: Option<String>,
    }
    
    impl From<FieldSchema> for FieldSchemaApi {
        fn from(schema: FieldSchema) -> Self {
            // Filter out CLI-specific fields
        }
    }
    
testing_needs:
  unit_tests:
    - Serialization round-trip tests
    - JSON Schema generation tests
    - Version migration tests
    - Type conversion tests
    
  integration_tests:
    - MCP tool definition generation
    - Workflow discovery with API types
    - Backwards compatibility with old workflows
    
  example_test: |
    #[test]
    fn test_field_type_json_schema() {
        let ft = FieldType::Number {
            min: Some(1),
            max: Some(10),
        };
        let schema = ft.to_json_schema();
        assert_eq!(schema["type"], "integer");
        assert_eq!(schema["minimum"], 1);
        assert_eq!(schema["maximum"], 10);
    }

suggested_roadmap:
  v0.2.0_api_foundation:
    duration: 2-3 weeks
    changes:
      - Add schemars dependency
      - Implement to_json_schema() methods
      - Add schema_version field
      - Create api module with API types
      - Add conversion functions
    breaking: No
    
  v0.3.0_type_improvements:
    duration: 2-3 weeks
    changes:
      - Redesign PhaseSelector (accept both formats)
      - Redesign StateFile (separate concerns)
      - Add validation framework
      - Deprecate CLI-specific fields
    breaking: Minimal (with compatibility layer)
    
  v1.0.0_stable_api:
    duration: 4-6 weeks
    changes:
      - Remove deprecated fields
      - Stabilize API types
      - Full MCP integration
      - Comprehensive documentation
      - Migration guide
    breaking: Yes (but planned and documented)

risks:
  high:
    - risk: Breaking existing workflows
      mitigation: Maintain compatibility layer through v1.0
      detection: Integration tests with old workflow binaries
      
    - risk: PhaseSelector/StateFile redesign impacts UX
      mitigation: Thorough testing of TUI with new types
      detection: Manual QA and user testing
      
  medium:
    - risk: JSON Schema generation complexity
      mitigation: Use proven library (schemars)
      detection: Schema validation tests
      
    - risk: Version migration bugs
      mitigation: Comprehensive migration tests
      detection: Round-trip version conversion tests
      
  low:
    - risk: Performance impact of validation
      mitigation: Lazy validation, caching
      detection: Benchmark tests

summary:
  current_state: Solid foundation with serde-based serialization
  api_readiness: 60% - Core types ready, complex types need work
  main_gaps:
    - No JSON Schema generation
    - Complex types (PhaseSelector, StateFile) not API-friendly
    - No versioning strategy
    - CLI concerns mixed with API concerns
    
  estimated_effort: 6-8 weeks for full API readiness
  
  critical_path:
    step_1: Add JSON Schema generation (schemars)
    step_2: Create API type layer (separate from internal types)
    step_3: Redesign complex types (PhaseSelector, StateFile)
    step_4: Add versioning and migration support
    step_5: Full MCP integration and documentation
    
  success_criteria:
    - All types have JSON Schema generation
    - MCP tools can be generated from FullWorkflowMetadata
    - Backwards compatible with existing workflows
    - Clean separation of API and internal concerns
    - Versioning enables future evolution
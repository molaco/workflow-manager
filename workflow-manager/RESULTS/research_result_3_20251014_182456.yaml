workflow_manager_api_analysis:
  timestamp: "2025-10-14"
  objective: "Design API operations for workflow-manager supporting both MCP server and TUI clients"
  
  data_structures:
    workflow_metadata:
      description: "Core workflow identity and description"
      fields:
        - id: "string (unique identifier, e.g., 'research_agent')"
        - name: "string (human-readable name)"
        - description: "string (multi-line description)"
      source: "workflow-manager-sdk/src/lib.rs:10-15"
    
    field_schema:
      description: "Field definition for workflow parameters"
      fields:
        - name: "string (parameter name)"
        - field_type: "FieldType enum"
        - label: "string (UI label)"
        - description: "string (help text, may contain [TYPE] hints)"
        - cli_arg: "string (e.g., '--input')"
        - required: "bool"
        - default: "Option<string>"
        - required_for_phases: "Option<Vec<usize>>"
      source: "workflow-manager-sdk/src/lib.rs:26-37"
    
    field_types:
      description: "Supported input field types"
      variants:
        - Text: "plain text input"
        - Number: "integer with optional min/max constraints"
        - FilePath: "file path with optional glob pattern for filtering"
        - Select: "dropdown with predefined options"
        - PhaseSelector: "comma-separated phase indices (e.g., '0,1,2')"
        - StateFile: "resumption file from previous phase output"
      source: "workflow-manager-sdk/src/lib.rs:40-65"
    
    workflow_status:
      description: "Execution state of a workflow instance"
      variants:
        - NotStarted: "initial state"
        - Running: "currently executing"
        - Completed: "successfully finished"
        - Failed: "terminated with error"
      source: "workflow-manager-sdk/src/lib.rs:75-81"
    
    workflow_log:
      description: "Structured events emitted during execution via stderr"
      event_types:
        phase_events:
          - PhaseStarted: "{phase: usize, name: string, total_phases: usize}"
          - PhaseCompleted: "{phase: usize, name: string}"
          - PhaseFailed: "{phase: usize, name: string, error: string}"
        task_events:
          - TaskStarted: "{phase: usize, task_id: string, description: string, total_tasks: Option<usize>}"
          - TaskProgress: "{task_id: string, message: string}"
          - TaskCompleted: "{task_id: string, result: Option<string>}"
          - TaskFailed: "{task_id: string, error: string}"
        agent_events:
          - AgentStarted: "{task_id: string, agent_name: string, description: string}"
          - AgentMessage: "{task_id: string, agent_name: string, message: string}"
          - AgentCompleted: "{task_id: string, agent_name: string, result: Option<string>}"
          - AgentFailed: "{task_id: string, agent_name: string, error: string}"
        state_events:
          - StateFileCreated: "{phase: usize, file_path: string, description: string}"
      protocol: "JSON emitted to stderr with '__WF_EVENT__:' prefix"
      source: "workflow-manager-sdk/src/lib.rs:119-191"

  api_operations:
    synchronous:
      list_workflows:
        operation: "GET /workflows"
        description: "List all available workflows (built-in + discovered)"
        request: "none"
        response:
          type: "array of WorkflowSummary"
          schema:
            - id: "string"
            - name: "string"
            - description: "string"
            - source: "enum (BuiltIn | UserDefined)"
        implementation_reference: "src/main.rs:1784-1795 (load_workflows)"
        tui_usage: "main.rs:176-225 (App::new loads workflows at startup)"
        notes:
          - "Scans ../target/debug for binaries"
          - "Executes each with --workflow-metadata flag"
          - "Parses JSON response containing metadata + fields"
      
      get_workflow_metadata:
        operation: "GET /workflows/{workflow_id}"
        description: "Get complete metadata and field schemas for a workflow"
        request:
          parameters:
            - workflow_id: "string (path parameter)"
        response:
          type: "FullWorkflowMetadata"
          schema:
            metadata:
              - id: "string"
              - name: "string"
              - description: "string"
            fields: "array of FieldSchema (see data_structures.field_schema)"
        implementation_reference: "src/discovery.rs:117-147 (extract_workflow_metadata)"
        tui_usage: "main.rs:1796-1850 (load_builtin_workflows calls binary with --workflow-metadata)"
        notes:
          - "Executes: <binary_path> --workflow-metadata"
          - "Parses stdout as JSON"
          - "Returns FullWorkflowMetadata struct"
      
      validate_workflow_inputs:
        operation: "POST /workflows/{workflow_id}/validate"
        description: "Validate field values against schema constraints"
        request:
          body:
            field_values: "map<string, string> (field_name -> value)"
        response:
          type: "ValidationResult"
          schema:
            valid: "bool"
            errors: "array of FieldValidationError"
            field_errors:
              - field_name: "string"
              - error_type: "enum (Required | TypeMismatch | OutOfRange | InvalidPattern)"
              - message: "string"
        implementation_reference: "Implicit in TUI form validation (main.rs:734-747)"
        tui_usage: "main.rs:1171-1188 (phase validation checks required fields)"
        validation_logic:
          required_fields: "Check if required=true fields have non-empty values"
          phase_requirements: "Check required_for_phases against selected phases"
          number_constraints: "Validate min/max for Number fields"
          file_patterns: "Check FilePath against glob patterns"
          select_options: "Ensure value is in allowed options list"
      
      build_workflow_command:
        operation: "POST /workflows/{workflow_id}/build-command"
        description: "Generate executable command string from field values"
        request:
          body:
            field_values: "map<string, string>"
        response:
          type: "CommandSpec"
          schema:
            binary_path: "string"
            args: "array of string"
            full_command: "string (for display)"
        implementation_reference: "src/discovery.rs:149-171 (build_workflow_command)"
        tui_usage: "main.rs:782-808 (launch_workflow builds args array)"
        arg_construction_rules:
          boolean_fields: "Only add flag if value='true' (no value parameter)"
          text_fields: "Add '--field-name value' pair"
          empty_values: "Skip field entirely if value is empty"
          underscore_conversion: "Convert field_name to --field-name"
      
      get_workflow_history:
        operation: "GET /workflows/{workflow_id}/history"
        description: "Get historical field values for autocomplete/suggestions"
        request:
          parameters:
            - workflow_id: "string"
            - field_name: "Optional<string> (filter to specific field)"
        response:
          type: "WorkflowHistory"
          schema:
            workflows:
              workflow_id:
                field_name: "array of string (up to 10 recent values)"
        implementation_reference: "main.rs:26-29, 1755-1782"
        tui_usage: "main.rs:1471-1516 (save_to_history after successful run)"
        storage: "~/.local/share/workflow-manager/history.json"
        notes:
          - "Stores last 10 unique values per field"
          - "Values saved only on successful completion"
          - "Most recent value at index 0"
    
    streaming:
      start_workflow:
        operation: "POST /workflows/{workflow_id}/start"
        description: "Start workflow execution and return execution ID"
        request:
          body:
            field_values: "map<string, string>"
            options:
              - stream_output: "bool (default: true)"
              - capture_stdout: "bool (default: true)"
              - capture_stderr: "bool (default: true)"
        response:
          type: "WorkflowExecution"
          schema:
            execution_id: "string (unique ID for this run)"
            workflow_id: "string"
            status: "WorkflowStatus"
            start_time: "ISO8601 timestamp"
            pid: "Optional<int> (process ID)"
        implementation_reference: "main.rs:767-906 (launch_workflow)"
        tui_usage: "main.rs:909-1043 (launch_workflow_in_tab)"
        process_management:
          spawn: "std::process::Command with piped stdout/stderr"
          threads: "Separate threads for stdout and stderr reading"
          stderr_parsing: "Lines prefixed with '__WF_EVENT__:' parsed as WorkflowLog JSON"
        notes:
          - "Returns immediately after process spawn"
          - "Use stream_workflow_logs for output"
      
      stream_workflow_logs:
        operation: "GET /workflows/executions/{execution_id}/logs (SSE)"
        description: "Stream stdout, stderr, and structured events in real-time"
        request:
          parameters:
            - execution_id: "string"
          query_params:
            - since: "Optional<int> (line number to resume from)"
            - filter: "Optional<string> (regex filter for output)"
        response:
          type: "Server-Sent Events stream"
          event_types:
            stdout_line:
              data: "{line_number: int, content: string}"
            stderr_line:
              data: "{line_number: int, content: string}"
            workflow_event:
              data: "WorkflowLog (JSON, see data_structures.workflow_log)"
            status_change:
              data: "{status: WorkflowStatus, exit_code: Optional<int>}"
        implementation_reference: "main.rs:834-872 (stdout/stderr thread readers)"
        tui_usage: "main.rs:512-548 (tab rerun spawns threads for output)"
        protocol_details:
          stdout_thread: "BufReader line-by-line, pushed to Arc<Mutex<Vec<String>>>"
          stderr_thread: "Parses '__WF_EVENT__:' prefix for structured logs"
          event_emission: "WorkflowLog::emit() writes to stderr"
        notes:
          - "TUI polls process with child.try_wait() for status"
          - "For MCP, implement SSE stream from captured output"
          - "Structured events enable real-time progress UI"
      
      stream_workflow_status:
        operation: "GET /workflows/executions/{execution_id}/status (SSE)"
        description: "Stream hierarchical execution state (phases/tasks/agents)"
        request:
          parameters:
            - execution_id: "string"
        response:
          type: "Server-Sent Events stream"
          event_types:
            hierarchy_update:
              data: "HierarchicalState (JSON)"
        hierarchical_state_schema:
          phases:
            - id: "usize"
              name: "string"
              status: "enum (NotStarted | Running | Completed | Failed)"
              tasks:
                - id: "string"
                  description: "string"
                  status: "TaskStatus"
                  agents:
                    - id: "string (task_id:agent_name)"
                      name: "string"
                      description: "string"
                      status: "AgentStatus"
                      messages: "array of string (streaming text)"
                      result: "Optional<string>"
              output_files:
                - path: "string"
                  description: "string"
        implementation_reference: "main.rs:32-85 (PhaseStatus, TaskStatus, AgentStatus structs)"
        tui_usage: "main.rs:850-872 (handle_workflow_event builds hierarchy)"
        event_handling: "main.rs:2062-2344 (handle_workflow_event method)"
        notes:
          - "TUI maintains Arc<Mutex<Vec<WorkflowPhase>>> shared with render"
          - "Updates triggered by WorkflowLog events from stderr"
          - "MCP server should maintain same structure in memory"
      
      get_agent_messages:
        operation: "GET /workflows/executions/{execution_id}/agents/{agent_id}/messages (SSE)"
        description: "Stream messages from a specific agent in real-time"
        request:
          parameters:
            - execution_id: "string"
            - agent_id: "string (format: task_id:agent_name)"
          query_params:
            - since: "Optional<int> (message index)"
        response:
          type: "Server-Sent Events stream"
          event_types:
            agent_message:
              data: "{index: int, message: string, timestamp: ISO8601}"
        implementation_reference: "main.rs:56-65 (WorkflowAgent struct)"
        tui_usage: "main.rs:2218-2228 (AgentMessage event appends to agent.messages)"
        notes:
          - "Enables fine-grained monitoring of LLM agent output"
          - "Used by research_agent.rs for parallel suborchestrator streams"
    
    control:
      stop_workflow:
        operation: "POST /workflows/executions/{execution_id}/stop"
        description: "Terminate a running workflow (SIGTERM)"
        request:
          parameters:
            - execution_id: "string"
          body:
            force: "bool (default: false, use SIGKILL if true)"
        response:
          type: "StopResult"
          schema:
            success: "bool"
            previous_status: "WorkflowStatus"
            exit_code: "Optional<int>"
        implementation_reference: "main.rs:424-439 (kill_current_tab)"
        tui_usage: "main.rs:399-422 (close_tab_confirmed kills child process)"
        notes:
          - "TUI calls child.kill() which sends SIGKILL"
          - "Could implement graceful shutdown with timeout"
      
      get_workflow_result:
        operation: "GET /workflows/executions/{execution_id}/result"
        description: "Get final execution result and output files"
        request:
          parameters:
            - execution_id: "string"
        response:
          type: "WorkflowResult"
          schema:
            execution_id: "string"
            status: "WorkflowStatus"
            exit_code: "Optional<int>"
            start_time: "ISO8601"
            end_time: "Optional<ISO8601>"
            output_files:
              - path: "string"
                description: "string"
                phase: "usize"
            stdout_lines: "array of string (full output)"
            final_message: "Optional<string>"
        implementation_reference: "main.rs:79-85 (WorkflowPhase.output_files)"
        tui_usage: "main.rs:2285-2297 (StateFileCreated event tracks outputs)"
        notes:
          - "output_files populated by StateFileCreated events"
          - "TUI displays in phase output section"
          - "Examples: codebase_analysis_*.yaml, research_results_*.yaml"
      
      list_executions:
        operation: "GET /workflows/executions"
        description: "List all workflow execution instances"
        request:
          query_params:
            - workflow_id: "Optional<string> (filter by workflow)"
            - status: "Optional<WorkflowStatus> (filter by status)"
            - limit: "Optional<int> (default: 50)"
        response:
          type: "array of ExecutionSummary"
          schema:
            - execution_id: "string"
            - workflow_id: "string"
            - workflow_name: "string"
            - status: "WorkflowStatus"
            - start_time: "ISO8601"
            - end_time: "Optional<ISO8601>"
        implementation_reference: "main.rs:88-118 (WorkflowTab struct)"
        tui_usage: "main.rs:228-262 (save_session persists tabs)"
        notes:
          - "TUI maintains open_tabs as execution instances"
          - "Session restored from ~/.local/share/workflow-manager/session.json"

  tui_interaction_flow:
    workflow_discovery_phase:
      step1: "App::new() calls load_workflows() (main.rs:176-225)"
      step2: "load_builtin_workflows() scans ../target/debug (main.rs:1796-1850)"
      step3: "For each binary: Command::new(path).arg('--workflow-metadata') (discovery.rs:120)"
      step4: "Parse JSON stdout as FullWorkflowMetadata (discovery.rs:139)"
      step5: "Store in App.workflows: Vec<Workflow> (main.rs:130)"
      data_needed_from_api:
        - "List of workflow IDs"
        - "Full metadata + field schemas for each"
    
    workflow_configuration_phase:
      step1: "User selects workflow → View::WorkflowEdit(idx) (main.rs:713-732)"
      step2: "Load field defaults from workflow.info.fields (main.rs:721-727)"
      step3: "Load historical values from history.json (main.rs:729-730)"
      step4: "User edits fields with type-specific validation (main.rs:734-765)"
      step5: "Phase validation checks required_for_phases (research_agent.rs:1177-1188)"
      data_needed_from_api:
        - "Field schemas with validation rules"
        - "Historical values for autocomplete"
        - "Validation errors for each field"
    
    workflow_execution_phase:
      step1: "launch_workflow_in_tab() creates WorkflowTab (main.rs:909-976)"
      step2: "Build args from field_values (main.rs:932-950)"
      step3: "Spawn process with piped stdout/stderr (main.rs:978-984)"
      step4: "Spawn thread for stdout: BufReader line reading (main.rs:990-1002)"
      step5: "Spawn thread for stderr: Parse __WF_EVENT__ JSON (main.rs:1007-1029)"
      step6: "Update workflow_phases on each WorkflowLog event (main.rs:2062-2344)"
      step7: "Poll child.try_wait() for exit status (main.rs:636-699)"
      data_needed_from_api:
        - "Execution ID on start"
        - "Streaming stdout/stderr lines"
        - "Streaming WorkflowLog events"
        - "Process status polling (Running/Completed/Failed)"
    
    workflow_monitoring_phase:
      step1: "Render hierarchical phases/tasks/agents (main.rs:2585-2815)"
      step2: "Display agent messages in expandable sections (main.rs:2754-2792)"
      step3: "Show output files from StateFileCreated events (main.rs:2793-2815)"
      step4: "Navigation: j/k for phase selection, Space to expand (main.rs:2366-2470)"
      step5: "Auto-scroll to follow running phase (main.rs:2526-2570)"
      data_needed_from_api:
        - "Real-time hierarchical state updates"
        - "Agent message streams"
        - "Output file metadata (path + description)"

  example_research_workflow:
    workflow_id: "research_agent"
    phases:
      phase0_analyze:
        name: "Analyze Codebase"
        tasks:
          - task_id: "analyze"
            description: "Analyzing codebase structure and dependencies"
            agents:
              - agent_name: "Suborchestrator Agent"
                description: "Analyzing codebase structure"
                messages:
                  - "Running bash: find . -name '*.rs' | wc -l"
                  - "Found 14 Rust files"
        output_files:
          - path: "codebase_analysis_20251014_175018.yaml"
            description: "Codebase analysis"
      
      phase1_prompts:
        name: "Generate Prompts"
        tasks:
          - task_id: "generate"
            description: "Generating research prompts from objective"
            agents:
              - agent_name: "Suborchestrator Agent"
                description: "Generating research prompts"
                messages:
                  - "Generated 7 research questions"
        output_files:
          - path: "research_prompts_20251014_175137.yaml"
            description: "Research prompts for Phase 2"
      
      phase2_research:
        name: "Execute Research"
        tasks:
          - task_id: "research_1"
            description: "Research task 1/7"
            agents:
              - agent_name: "Research Agent 1"
                description: "Executing: How does workflow discovery work?"
                messages:
                  - "Reading src/discovery.rs..."
                  - "Using Grep tool..."
          - task_id: "research_2"
            description: "Research task 2/7"
        output_files:
          - path: "RESULTS/research_result_1_20251014_175137.yaml"
          - path: "RESULTS/research_result_2_20251014_175137.yaml"
      
      phase3_validate:
        name: "Validate YAML"
        tasks:
          - task_id: "validate_initial"
            description: "Initial YAML validation scan"
          - task_id: "fix_yaml_1"
            description: "Fixing YAML file 1"
            agents:
              - agent_name: "YAML Fixer 1"
      
      phase4_synthesize:
        name: "Synthesize Docs"
        tasks:
          - task_id: "map_phase"
            description: "Summarizing 7 research results"
          - task_id: "reduce_round_1"
            description: "Reduce round 1: 7 → 4 docs"
          - task_id: "reduce_round_2"
            description: "Reduce round 2: 4 → 2 docs"
          - task_id: "final_synthesis"
            description: "Creating comprehensive documentation"
        output_files:
          - path: "docs/research_output.md"
            description: "Final synthesized documentation"
    
    event_sequence_sample:
      - event: "PhaseStarted {phase: 0, name: 'Analyze Codebase', total_phases: 5}"
      - event: "TaskStarted {phase: 0, task_id: 'analyze', description: '...'}"
      - event: "AgentStarted {task_id: 'analyze', agent_name: 'Suborchestrator Agent', ...}"
      - event: "AgentMessage {task_id: 'analyze', agent_name: '...', message: 'Running find...'}"
      - event: "AgentCompleted {task_id: 'analyze', agent_name: '...', result: 'Analysis complete'}"
      - event: "TaskCompleted {task_id: 'analyze', result: 'Saved to codebase_analysis_*.yaml'}"
      - event: "StateFileCreated {phase: 0, file_path: '...yaml', description: '...'}"
      - event: "PhaseCompleted {phase: 0, name: 'Analyze Codebase'}"

  operation_categorization:
    synchronous_operations:
      description: "Request-response operations suitable for MCP resources/tools"
      operations:
        - list_workflows: "GET catalog of available workflows"
        - get_workflow_metadata: "GET schema for workflow fields"
        - validate_workflow_inputs: "POST validate field values"
        - build_workflow_command: "POST generate command string"
        - get_workflow_history: "GET autocomplete suggestions"
      mcp_pattern: "Use as MCP tools (callable functions)"
      implementation: "Direct function calls, no state tracking needed"
    
    streaming_operations:
      description: "Long-running async operations with real-time updates"
      operations:
        - start_workflow: "POST spawn execution (returns immediately)"
        - stream_workflow_logs: "GET SSE stdout/stderr/events"
        - stream_workflow_status: "GET SSE hierarchical state"
        - get_agent_messages: "GET SSE agent-specific output"
      mcp_pattern: "Use sampling for long-running monitoring, SSE for real-time"
      implementation: "Maintain execution state server-side, stream updates"
    
    control_operations:
      description: "State management and lifecycle control"
      operations:
        - stop_workflow: "POST terminate execution"
        - get_workflow_result: "GET final outputs and files"
        - list_executions: "GET execution history"
      mcp_pattern: "Use as MCP tools for workflow management"
      implementation: "Track executions in-memory + persistent storage"

  mcp_server_design:
    resources:
      workflows_catalog:
        uri: "workflow://"
        description: "List all available workflows with metadata"
        mime_type: "application/json"
      
      workflow_schema:
        uri: "workflow://{workflow_id}"
        description: "Full schema for a specific workflow"
        mime_type: "application/json"
      
      execution_logs:
        uri: "workflow://executions/{execution_id}/logs"
        description: "Complete log output for an execution"
        mime_type: "text/plain"
      
      execution_status:
        uri: "workflow://executions/{execution_id}/status"
        description: "Current hierarchical state"
        mime_type: "application/json"
    
    tools:
      list_workflows:
        description: "Get all available workflows"
        input_schema: {}
        output: "Array of workflow summaries"
      
      start_workflow:
        description: "Start a workflow execution"
        input_schema:
          workflow_id: "string"
          field_values: "object"
        output: "Execution ID and initial status"
      
      get_workflow_status:
        description: "Check status of running workflow"
        input_schema:
          execution_id: "string"
        output: "Current status and phase/task breakdown"
      
      stop_workflow:
        description: "Terminate a running workflow"
        input_schema:
          execution_id: "string"
          force: "boolean"
        output: "Stop confirmation"
      
      get_workflow_result:
        description: "Get final result and output files"
        input_schema:
          execution_id: "string"
        output: "Complete result with file paths"
    
    sampling_strategy:
      long_running_workflows:
        pattern: "Claude samples get_workflow_status periodically"
        frequency: "Every 5-10 seconds during execution"
        termination: "When status = Completed or Failed"
      
      agent_message_monitoring:
        pattern: "Claude samples specific agent messages for progress"
        use_case: "Monitoring parallel research agents (phase 2 of research_agent)"
        implementation: "Filter WorkflowLog AgentMessage events by agent_name"
    
    state_management:
      execution_tracking:
        storage: "In-memory HashMap<execution_id, ExecutionState>"
        persistence: "Optional SQLite for execution history"
        cleanup: "TTL-based removal of completed executions (e.g., 24 hours)"
      
      process_lifecycle:
        spawn: "tokio::process::Command for async process management"
        output_capture: "tokio::io::BufReader for async line reading"
        event_parsing: "Parse __WF_EVENT__: prefix from stderr"
        status_polling: "child.try_wait() non-blocking status check"

  insights:
    tui_dependencies:
      workflow_list: "Needs workflow catalog with metadata (sync)"
      field_editing: "Needs field schemas with validation (sync)"
      execution_monitoring: "Needs real-time log stream (async)"
      phase_tracking: "Needs structured event stream (async)"
      output_files: "Needs StateFileCreated events (async)"
    
    streaming_necessity:
      justification:
        - "Workflows can run for minutes/hours (research_agent example)"
        - "Phase/task/agent hierarchy updates in real-time"
        - "Agent messages stream continuously (LLM output)"
        - "TUI needs immediate feedback for user experience"
      alternatives:
        polling: "Inefficient, adds latency, misses granular updates"
        batch_updates: "Loses real-time progress visibility"
        sse_streaming: "Ideal for unidirectional server→client updates"
    
    phase_resumption:
      pattern: "Workflows can resume from intermediate phases"
      mechanism: "StateFile fields reference output from previous phases"
      examples:
        - "--analysis-file codebase_analysis_20251014_175018.yaml"
        - "--prompts-file research_prompts_20251014_175137.yaml"
        - "--results-file research_results_20251014_175617.yaml"
      api_requirement: "validate_workflow_inputs must check phase prerequisites"
    
    hierarchical_execution:
      levels:
        - "Phase: High-level workflow stage (0-4 in research_agent)"
        - "Task: Specific work unit within phase (e.g., research_1)"
        - "Agent: LLM agent executing task (e.g., Research Agent 1)"
      state_propagation: "Parent status derived from children (Running if any child Running)"
      ui_requirement: "Collapsible tree view with expand/collapse"
    
    output_file_tracking:
      importance: "Critical for multi-phase workflows with resumption"
      event: "StateFileCreated emitted when phase generates output"
      ui_display: "Shown in phase output section with description"
      api_requirement: "Include in get_workflow_result response"

  code_references:
    workflow_sdk: "/home/molaco/Documents/japanese/workflow-manager-sdk/src/lib.rs"
    tui_main: "/home/molaco/Documents/japanese/workflow-manager/src/main.rs"
    discovery: "/home/molaco/Documents/japanese/workflow-manager/src/discovery.rs"
    research_agent: "/home/molaco/Documents/japanese/workflow-manager/src/bin/research_agent.rs"
    
  key_line_references:
    workflow_metadata: "workflow-manager-sdk/src/lib.rs:10-15"
    field_schema: "workflow-manager-sdk/src/lib.rs:26-37"
    field_types: "workflow-manager-sdk/src/lib.rs:40-65"
    workflow_log: "workflow-manager-sdk/src/lib.rs:119-191"
    log_emission: "workflow-manager-sdk/src/lib.rs:195-199"
    tui_event_handling: "main.rs:2062-2344 (handle_workflow_event)"
    tui_process_spawn: "main.rs:978-1043 (launch_workflow_in_tab)"
    tui_status_polling: "main.rs:636-699 (poll_all_tabs)"
    discovery_metadata: "discovery.rs:117-147 (extract_workflow_metadata)"
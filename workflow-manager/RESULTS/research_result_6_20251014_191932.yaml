analysis_title: "Type System Analysis for API Exposure - workflow-manager-sdk"
timestamp: "2025-10-14"
analyst: "Claude Code Agent"

executive_summary:
  api_readiness_score: "70%"
  foundation_quality: "Strong - serde-based with proper derives"
  critical_blockers: 2
  key_insight: "Core types are API-ready; PhaseSelector and StateFile require architectural redesign"
  immediate_action: "Add JSON Schema generation capability"

type_system_inventory:
  
  core_metadata_types:
    WorkflowMetadata:
      location: "workflow-manager-sdk/src/lib.rs:10-15"
      fields: ["id: String", "name: String", "description: String"]
      serialization: ["Serialize", "Deserialize", "Debug", "Clone"]
      api_compatibility: "PERFECT"
      json_output: |
        {
          "id": "research_agent",
          "name": "Research Agent Workflow",
          "description": "Multi-phase research workflow"
        }
      assessment: "No changes needed - already API-ready"
      
    FullWorkflowMetadata:
      location: "workflow-manager-sdk/src/lib.rs:18-23"
      structure:
        metadata: "WorkflowMetadata (flattened with #[serde(flatten)])"
        fields: "Vec<FieldSchema>"
      current_usage: "Output format for --workflow-metadata CLI flag"
      discovery: "Parsed by discovery.rs:139 when scanning for workflows"
      api_compatibility: "GOOD"
      concerns:
        - "No schema_version field for evolution tracking"
        - "Contains CLI-specific fields via nested FieldSchema"
      recommendations:
        immediate: "Add schema_version field with #[serde(default)]"
        future: "Create FullWorkflowMetadataApi variant without CLI concerns"
    
    FieldSchema:
      location: "workflow-manager-sdk/src/lib.rs:26-37"
      fields:
        name: "String - Field identifier"
        field_type: "FieldType - Type definition (enum)"
        label: "String - Human-readable label"
        description: "String - Help text"
        cli_arg: "String - CLI flag (e.g., '--input') ⚠️ CLI-specific"
        required: "bool - Validation flag"
        default: "Option<String> - Default value"
        required_for_phases: "Option<Vec<usize>> - Phase-specific validation ⚠️"
      api_compatibility: "MIXED"
      problems:
        concern_mixing: "Combines API metadata, CLI config, and validation logic"
        cli_arg_field: "Not relevant for MCP tools or programmatic APIs"
        phase_logic: "Execution logic leaking into schema definition"
      recommendations:
        create_api_variant: |
          pub struct FieldSchemaApi {
              pub name: String,
              pub field_type: FieldTypeApi,
              pub label: String,
              pub description: String,
              pub required: bool,
              pub default: Option<serde_json::Value>, // Not String
          }
        conversion: "Implement From<FieldSchema> for FieldSchemaApi"
        strategy: "Keep FieldSchema for internal use, expose FieldSchemaApi"

  field_type_enum:
    FieldType:
      location: "workflow-manager-sdk/src/lib.rs:40-65"
      serialization:
        strategy: "Tagged enum"
        tag: "type"
        rename: "snake_case"
        example: '{"type": "number", "min": 1, "max": 10}'
      
      variants:
        Text:
          definition: "Text"
          json_schema: '{"type": "string"}'
          api_ready: true
          assessment: "Perfect - maps directly to JSON Schema string"
          
        Number:
          definition: "Number { min: Option<i64>, max: Option<i64> }"
          json_schema: '{"type": "integer", "minimum": N, "maximum": M}'
          api_ready: true
          notes:
            - "Currently integer-only (i64)"
            - "Consider Float variant for broader use cases"
          assessment: "Good - standard JSON Schema integer type"
          
        FilePath:
          definition: "FilePath { pattern: Option<String> }"
          json_schema: '{"type": "string"}'
          api_ready: "PARTIAL"
          problems:
            - "Assumes local filesystem access"
            - "Pattern is glob, not regex (incompatible with JSON Schema)"
            - "Cannot work with remote API clients"
          recommendations:
            local_mcp: "String with description"
            remote_api: "File upload endpoint + reference ID"
            redesign: "Separate FileInput type with Path/Url/Content variants"
          assessment: "Works for local MCP, problematic for remote APIs"
          
        Select:
          definition: "Select { options: Vec<String> }"
          json_schema: '{"type": "string", "enum": [...]}'
          api_ready: true
          assessment: "Perfect - maps directly to JSON Schema enum"
          
        PhaseSelector:
          definition: "PhaseSelector { total_phases: usize }"
          current_format: "String - comma-separated: '0,1,2,3,4'"
          usage: "research_agent.rs:222 - phases field"
          parsing: "Split by comma, parse each as usize"
          api_ready: false
          critical_problem: "CLI-centric string format incompatible with standard APIs"
          issues:
            format: "String '0,1,2' is not a standard JSON type"
            validation: "Parsing happens in workflow, not validated by schema"
            type_safety: "Loses semantic meaning (array of phase indices)"
            json_schema_mapping: "No direct JSON Schema equivalent for this format"
          proposed_solution:
            api_format: "JSON array: [0, 1, 2, 3, 4]"
            internal_representation: "Vec<usize>"
            json_schema: |
              {
                "type": "array",
                "items": {
                  "type": "integer",
                  "minimum": 0,
                  "maximum": N
                },
                "minItems": 1,
                "uniqueItems": true
              }
            transition_approach: |
              #[derive(Serialize, Deserialize)]
              #[serde(untagged)]
              pub enum PhaseInput {
                  Array(Vec<usize>),       // API format
                  String(String),          // CLI format
              }
              
              impl PhaseInput {
                  pub fn normalize(self) -> Result<Vec<usize>> {
                      match self {
                          PhaseInput::Array(v) => Ok(v),
                          PhaseInput::String(s) => {
                              s.split(',')
                                  .map(|p| p.trim().parse())
                                  .collect()
                          }
                      }
                  }
              }
          migration_path:
            - "Accept both formats during transition (#[serde(untagged)])"
            - "CLI continues using string format"
            - "MCP tools use array format"
            - "Eventually deprecate string format in future major version"
          assessment: "BLOCKING - Must redesign for API exposure"
          
        StateFile:
          definition: "StateFile { pattern: String, phase: Option<usize> }"
          current_purpose: "Reference intermediate output from previous phase"
          usage: "research_agent.rs:225-242 - state file fields"
          current_behavior: "TUI scans for files matching glob pattern from specified phase"
          api_ready: false
          critical_problem: "Type conflates three separate concerns"
          architectural_issues:
            concern_1: "File discovery (glob pattern)"
            concern_2: "User input (what file to use)"
            concern_3: "Internal tracking (workflow output references)"
            mixing: "All three mixed into one type"
          problems:
            filesystem_coupling: "Assumes local filesystem with glob matching"
            remote_incompatible: "Cannot work with remote API calls"
            pattern_vs_input: "Pattern is for UI file picker, not API input"
            state_tracking: "Confuses metadata with actual file references"
          proposed_solution:
            separate_into_three:
              FileInput:
                purpose: "What user provides to API"
                variants: ["Path", "Url", "Content (base64)", "Reference (workflow_id + phase + file_id)"]
                api_compatible: true
              StateFileConstraint:
                purpose: "Metadata for validation and UI"
                fields: ["pattern: String", "source_phase: Option<usize>", "required_format: Option<String>"]
                usage: "Schema definition only"
              StateFileReference:
                purpose: "Internal workflow output tracking"
                fields: ["path: PathBuf", "phase: usize", "file_id: String", "created_at: String"]
                usage: "WorkflowLog::StateFileCreated"
          redesign_example: |
            // Replace StateFile with File that accepts FileInput
            pub enum FieldType {
                // ... other variants
                File { 
                    constraint: StateFileConstraint  // metadata only
                }
            }
            
            // Actual input at runtime
            pub enum FileInput {
                Path { path: String },
                Url { url: String },
                Content { 
                    filename: String,
                    content: String,  // base64
                    mime_type: Option<String> 
                },
                Reference {
                    workflow_id: String,
                    phase: usize,
                    file_id: String
                }
            }
          assessment: "BLOCKING - Requires complete architectural redesign"

  workflow_execution_types:
    WorkflowStatus:
      location: "workflow-manager-sdk/src/lib.rs:75-81"
      variants: ["NotStarted", "Running", "Completed", "Failed"]
      api_ready: true
      usage: "Status tracking for workflow execution"
      assessment: "Perfect for API exposure"
      
    WorkflowProgress:
      location: "workflow-manager-sdk/src/lib.rs:84-90"
      variants:
        Started: "{ message: String }"
        Progress: "{ message: String }"
        Completed: "{ message: String }"
        Failed: "{ error: String }"
      api_ready: true
      concern: "Overlaps with WorkflowLog - consider consolidating"
      assessment: "Good but potentially redundant"
      
    WorkflowLog:
      location: "workflow-manager-sdk/src/lib.rs:119-191"
      serialization: "Tagged enum with #[serde(tag = 'type')]"
      variants_count: 11
      event_types:
        - "PhaseStarted / PhaseCompleted / PhaseFailed"
        - "TaskStarted / TaskProgress / TaskCompleted / TaskFailed"
        - "AgentStarted / AgentMessage / AgentCompleted / AgentFailed"
        - "StateFileCreated"
      emission_protocol: "Emitted to stderr with __WF_EVENT__: prefix"
      parsing: "main.rs:539 - TUI reads and parses from stderr"
      api_ready: true
      api_potential: "EXCELLENT for streaming APIs"
      recommendations:
        websocket: "Perfect for WebSocket streaming"
        sse: "Ideal for Server-Sent Events"
        rest: "Can poll for events"
        mcp: "Stream events during tool execution"
      assessment: "Best-designed type for API - no changes needed"

serialization_analysis:
  current_framework:
    dependencies:
      serde: "1.0 with derive feature"
      serde_json: "1.0"
      serde_yaml: "Used in examples"
    
    patterns:
      derive_macros: "Consistent use of #[derive(Serialize, Deserialize)]"
      tagged_enums: "#[serde(tag = 'type', rename_all = 'snake_case')]"
      flatten: "#[serde(flatten)] for WorkflowMetadata composition"
      optional_skip: "#[serde(skip_serializing_if = 'Option::is_none')]"
      
    strengths:
      - "Clean, idiomatic JSON output"
      - "Type-safe with compile-time checks"
      - "Consistent tagging strategy"
      - "Good Optional handling"
      
    critical_gaps:
      - "No JSON Schema generation"
      - "No schema_version in serialized data"
      - "No validation attributes"
      - "No API versioning strategy"

json_schema_generation:
  current_state: "NOT IMPLEMENTED"
  requirement: "CRITICAL for MCP tool definitions"
  blocker_status: "Prevents automatic MCP tool generation"
  
  recommended_approach:
    library: "schemars 0.8"
    rationale:
      - "Most popular Rust JSON Schema library"
      - "Excellent serde integration"
      - "Derive macros match serde patterns"
      - "Supports custom schema attributes"
    
    implementation_strategy:
      method_1_manual:
        purpose: "For custom types (PhaseSelector, StateFile)"
        approach: "impl method to_json_schema() on FieldType"
        example: |
          impl FieldType {
              pub fn to_json_schema(&self) -> serde_json::Value {
                  match self {
                      FieldType::Text => json!({"type": "string"}),
                      FieldType::Number { min, max } => {
                          let mut s = json!({"type": "integer"});
                          if let Some(m) = min {
                              s["minimum"] = json!(m);
                          }
                          if let Some(m) = max {
                              s["maximum"] = json!(m);
                          }
                          s
                      },
                      FieldType::Select { options } => json!({
                          "type": "string",
                          "enum": options
                      }),
                      // ... etc
                  }
              }
          }
        
      method_2_schemars:
        purpose: "For standard types (WorkflowMetadata, etc.)"
        approach: "Add #[derive(JsonSchema)] alongside Serialize/Deserialize"
        example: |
          use schemars::{schema_for, JsonSchema};
          
          #[derive(Serialize, Deserialize, JsonSchema)]
          pub struct WorkflowMetadata {
              #[schemars(description = "Unique workflow identifier")]
              pub id: String,
              #[schemars(description = "Human-readable workflow name")]
              pub name: String,
              pub description: String,
          }
          
          // Generate schema
          let schema = schema_for!(WorkflowMetadata);
  
  mcp_integration:
    workflow_to_schema_function: |
      pub fn workflow_to_mcp_schema(workflow: &FullWorkflowMetadata) -> serde_json::Value {
          let mut properties = serde_json::Map::new();
          let mut required = Vec::new();
          
          for field in &workflow.fields {
              properties.insert(
                  field.name.clone(),
                  field.field_type.to_json_schema()
              );
              
              if field.required {
                  required.push(field.name.clone());
              }
          }
          
          json!({
              "type": "object",
              "properties": properties,
              "required": required
          })
      }
    
    mcp_tool_generation: |
      use claude_agent_sdk::mcp::{SdkMcpTool, ToolResult};
      
      fn workflow_to_mcp_tool(workflow: DiscoveredWorkflow) -> SdkMcpTool {
          let metadata = FullWorkflowMetadata {
              metadata: workflow.metadata.clone(),
              fields: workflow.fields.clone(),
          };
          
          let schema = workflow_to_mcp_schema(&metadata);
          
          SdkMcpTool::new(
              workflow.metadata.id,
              workflow.metadata.description,
              schema,
              move |input| {
                  Box::pin(async move {
                      // Convert JSON input to field values
                      let field_values = parse_mcp_input(input, &metadata)?;
                      
                      // Execute workflow binary
                      let output = execute_workflow(&workflow.binary_path, field_values).await?;
                      
                      Ok(ToolResult::text(output))
                  })
              }
          )
      }

versioning_strategy:
  current_state:
    crate_version: "0.1.0"
    data_version: "NONE - No version field in types"
    risk: "HIGH - Cannot detect or migrate old formats"
  
  requirements:
    semantic_versioning: "Follow semver for crate versioning"
    data_versioning: "Independent version for serialized formats"
    migration_support: "Parse old versions and upgrade"
    deprecation_path: "Gradual transitions for breaking changes"
  
  proposed_implementation:
    add_version_field: |
      #[derive(Debug, Clone, Serialize, Deserialize)]
      pub struct FullWorkflowMetadata {
          #[serde(default = "default_schema_version")]
          pub schema_version: String,
          #[serde(flatten)]
          pub metadata: WorkflowMetadata,
          pub fields: Vec<FieldSchema>,
      }
      
      fn default_schema_version() -> String {
          "1.0".to_string()
      }
    
    version_parser: |
      pub fn parse_workflow_metadata(json: &str) -> Result<FullWorkflowMetadata> {
          let value: serde_json::Value = serde_json::from_str(json)?;
          let version = value.get("schema_version")
              .and_then(|v| v.as_str())
              .unwrap_or("1.0");
          
          match version {
              "1.0" => serde_json::from_value(value)?,
              "1.1" => migrate_v1_1_to_current(value)?,
              _ => bail!("Unsupported version: {}", version)
          }
      }
    
    version_roadmap:
      v1_0: "Current state (implicit)"
      v1_1: "Add schema_version field"
      v1_2: "Deprecate cli_arg, mark as deprecated"
      v2_0: "Remove cli_arg, redesign PhaseSelector/StateFile"

backwards_compatibility:
  compatibility_requirement: "100% backwards compatibility with existing workflows"
  
  discovery_mechanism:
    process: "discovery.rs executes binaries with --workflow-metadata"
    parsing: "serde_json::from_str() at discovery.rs:139"
    impact: "Breaking changes break workflow discovery"
  
  safe_changes:
    - "Add optional fields with #[serde(default)]"
    - "Add new FieldType variants"
    - "Add new WorkflowLog event types"
    - "Add methods to existing types"
    - "Add new types (doesn't affect existing)"
  
  unsafe_changes:
    - "Remove fields"
    - "Rename fields without #[serde(rename)]"
    - "Change enum variant names"
    - "Modify JSON structure"
    - "Change tagging strategy"
  
  migration_phases:
    phase_1_additive:
      version: "0.2.0"
      breaking: false
      changes:
        - "Add schema_version (optional)"
        - "Add JSON Schema generation"
        - "Add API types alongside internal types"
    
    phase_2_deprecation:
      version: "0.3.0"
      breaking: false
      changes:
        - "Mark cli_arg as #[deprecated]"
        - "Add PhaseInput enum (accept both formats)"
        - "Add FileInput enum"
    
    phase_3_major:
      version: "1.0.0"
      breaking: true
      changes:
        - "Remove deprecated fields"
        - "Finalize API types"
        - "Lock schema versions"
      migration_guide: "Required"

mcp_tool_integration:
  context:
    sdk: "claude-agent-sdk-rust (../claude-agent-sdk-rust)"
    tool_definition: "src/mcp/tool.rs:52-154"
    schema_requirement: "JSON Schema for input validation"
    validation: "jsonschema 0.18.3 (runtime validation)"
  
  current_mcp_example:
    location: "claude-agent-sdk-rust/src/mcp/tool.rs:22-51"
    pattern: |
      SdkMcpTool::new(
          "tool_name",
          "Tool description",
          json!({
              "type": "object",
              "properties": {
                  "param": {"type": "string"}
              },
              "required": ["param"]
          }),
          |input| Box::pin(async move {
              // Handler implementation
              Ok(ToolResult::text("result"))
          })
      )
  
  workflow_mcp_adapter:
    input_conversion: |
      fn parse_mcp_input(
          input: serde_json::Value,
          workflow: &FullWorkflowMetadata
      ) -> Result<HashMap<String, String>> {
          let mut field_values = HashMap::new();
          
          for field in &workflow.fields {
              let value = input.get(&field.name);
              
              let string_value = match (&field.field_type, value) {
                  (FieldType::Text, Some(v)) => 
                      v.as_str()?.to_string(),
                  
                  (FieldType::Number{..}, Some(v)) => 
                      v.as_i64()?.to_string(),
                  
                  (FieldType::PhaseSelector{..}, Some(v)) => {
                      // Convert [0,1,2] -> "0,1,2"
                      v.as_array()?
                          .iter()
                          .map(|n| n.as_u64()?.to_string())
                          .collect::<Vec<_>>()
                          .join(",")
                  },
                  
                  (FieldType::Select{options}, Some(v)) => {
                      let s = v.as_str()?.to_string();
                      if !options.contains(&s) {
                          bail!("Invalid option");
                      }
                      s
                  },
                  
                  (_, None) if field.required => 
                      bail!("Missing required: {}", field.name),
                  
                  (_, None) => 
                      field.default.clone().unwrap_or_default(),
                  
                  _ => bail!("Type mismatch"),
              };
              
              field_values.insert(field.name.clone(), string_value);
          }
          
          Ok(field_values)
      }
    
    challenges:
      phase_selector: "Array format works well for MCP"
      state_file: "String path OK for local, needs file upload for remote"
      file_path: "Same issue as StateFile"
      validation: "Need to validate constraints (phase indices, patterns, etc.)"

implementation_roadmap:
  
  immediate_priority:
    priority_1:
      task: "Add FieldType::to_json_schema() method"
      file: "workflow-manager-sdk/src/lib.rs"
      effort: "2-3 hours"
      dependencies: "None"
      impact: "Enables MCP tool generation"
      blocks: "All MCP integration work"
      
    priority_2:
      task: "Add workflow_to_mcp_schema() function"
      file: "workflow-manager-sdk/src/lib.rs"
      effort: "1-2 hours"
      dependencies: "Priority 1"
      impact: "Complete MCP integration"
      
    priority_3:
      task: "Add schema_version field"
      file: "workflow-manager-sdk/src/lib.rs"
      effort: "1 hour"
      dependencies: "None"
      impact: "Future-proof serialization"
      implementation: "Use #[serde(default)] for compatibility"
  
  short_term:
    task_1:
      task: "Add schemars dependency"
      file: "workflow-manager-sdk/Cargo.toml"
      effort: "30 minutes + testing"
      version: "schemars = '0.8'"
      
    task_2:
      task: "Create API types module"
      file: "workflow-manager-sdk/src/api.rs"
      effort: "4-6 hours"
      contents:
        - "FieldSchemaApi (without cli_arg)"
        - "FieldTypeApi (redesigned variants)"
        - "Conversion traits: From<FieldSchema> for FieldSchemaApi"
      
    task_3:
      task: "Implement PhaseInput enum"
      file: "workflow-manager-sdk/src/lib.rs"
      effort: "2-4 hours"
      approach: "Untagged enum accepting Array or String"
  
  medium_term:
    task_1:
      task: "Redesign PhaseSelector for API"
      effort: "1-2 days"
      approach: "PhaseInput enum with normalize() method"
      testing: "Test both array and string parsing"
      
    task_2:
      task: "Redesign StateFile architecture"
      effort: "2-3 days"
      approach: "Separate FileInput, StateFileConstraint, StateFileReference"
      impact: "Enables remote file handling"
      
    task_3:
      task: "Add validation framework"
      effort: "3-4 days"
      approach: "Use validator crate or custom implementation"
  
  long_term:
    task_1:
      task: "Implement version migration system"
      file: "workflow-manager-sdk/src/version.rs"
      effort: "3-5 days"
      dependencies: "schema_version field"
      
    task_2:
      task: "Create REST API layer"
      effort: "1-2 weeks"
      dependencies: "API types, MCP integration"

risks_and_mitigations:
  
  risk_1_breaking_workflows:
    severity: "HIGH"
    probability: "MEDIUM"
    impact: "Existing workflow binaries fail to load"
    detection:
      - "Integration tests with compiled binaries"
      - "Test discovery mechanism"
    mitigation:
      - "Maintain strict backwards compatibility in 0.x"
      - "Use #[serde(default)] for all new fields"
      - "Test with all example workflows before release"
      - "Version detection and migration"
  
  risk_2_mcp_schema_complexity:
    severity: "MEDIUM"
    probability: "MEDIUM"
    impact: "Claude cannot understand complex field types"
    detection:
      - "Test MCP tools with actual Claude API"
      - "Monitor tool call success rate"
    mitigation:
      - "Keep schemas simple (standard JSON Schema)"
      - "Clear descriptions for complex types"
      - "Provide examples in descriptions"
      - "Fall back to string types if needed"
  
  risk_3_file_handling:
    severity: "HIGH"
    probability: "HIGH"
    impact: "Remote workflows cannot access files"
    detection: "API testing with remote client"
    mitigation:
      - "Design file upload/download endpoints"
      - "Support multiple input methods (Path/Url/Content)"
      - "Clear documentation"
      - "File size limits and validation"
  
  risk_4_phase_selector_confusion:
    severity: "MEDIUM"
    probability: "LOW"
    impact: "Users confused by format changes"
    detection: "User testing, error monitoring"
    mitigation:
      - "Accept both formats during transition"
      - "Clear error messages"
      - "Documentation with examples"
      - "TUI continues using string format"

testing_requirements:
  
  unit_tests:
    - test: "test_field_type_json_schema"
      purpose: "Verify JSON Schema for each FieldType"
      
    - test: "test_workflow_to_mcp_schema"
      purpose: "Complete workflow schema generation"
      
    - test: "test_phase_input_parsing"
      purpose: "Both array and string formats"
      
    - test: "test_serialization_roundtrip"
      purpose: "Serialize -> deserialize preserves data"
      
    - test: "test_schema_version_default"
      purpose: "Version defaults correctly"
  
  integration_tests:
    - test: "test_mcp_tool_invocation"
      purpose: "End-to-end workflow as MCP tool"
      location: "workflow-manager/tests/mcp_integration.rs"
      
    - test: "test_workflow_discovery_compat"
      purpose: "New version discovers old workflows"
      location: "workflow-manager/tests/discovery_compat.rs"
      
    - test: "test_api_type_conversions"
      purpose: "FieldSchema <-> FieldSchemaApi"
      location: "workflow-manager-sdk/tests/api_types.rs"

code_quality_observations:
  
  strengths:
    - "Consistent serde patterns throughout"
    - "Good use of tagged enums for extensibility"
    - "Clean separation of concerns (mostly)"
    - "WorkflowLog is excellently designed"
    - "Type-safe with compile-time checks"
  
  weaknesses:
    - "FieldSchema mixes API and CLI concerns"
    - "PhaseSelector uses CLI-centric string format"
    - "StateFile conflates three separate concepts"
    - "No JSON Schema generation"
    - "No versioning in serialized data"
    - "No validation attributes"
  
  recommendations:
    immediate:
      - "Add JSON Schema generation capability"
      - "Add schema_version field"
      - "Create workflow_to_mcp_schema function"
    
    short_term:
      - "Create separate API types"
      - "Add schemars dependency"
      - "Implement PhaseInput enum"
    
    long_term:
      - "Redesign StateFile completely"
      - "Add validation framework"
      - "Implement migration system"

summary:
  current_state: "Strong foundation with targeted issues"
  api_readiness: "70% - Core types ready, complex types need work"
  
  blocking_issues:
    issue_1:
      problem: "PhaseSelector string format"
      impact: "Cannot generate standard JSON Schema"
      severity: "CRITICAL"
      solution: "PhaseInput enum accepting array or string"
      
    issue_2:
      problem: "StateFile architectural issues"
      impact: "Cannot work with remote APIs"
      severity: "CRITICAL"
      solution: "Separate into FileInput, StateFileConstraint, StateFileReference"
      
    issue_3:
      problem: "No JSON Schema generation"
      impact: "Cannot auto-generate MCP tools"
      severity: "HIGH"
      solution: "Implement to_json_schema() methods"
  
  recommended_path_forward:
    week_1: "Implement JSON Schema generation"
    week_2_3: "Create API types and PhaseInput enum"
    week_4_6: "Redesign StateFile and add validation"
    week_8_10: "Full API maturity with versioning"
  
  success_criteria:
    - "All FieldTypes generate JSON Schema"
    - "Workflows auto-expose as MCP tools"
    - "PhaseSelector accepts array format"
    - "StateFile redesigned for remote files"
    - "schema_version enables migrations"
    - "100% backwards compatibility maintained"
  
  estimated_timeline:
    minimal_viable: "1 week (JSON Schema only)"
    production_ready: "6 weeks (includes redesigns)"
    fully_mature: "10 weeks (includes versioning)"

conclusion: |
  The workflow-manager-sdk type system has a solid serde-based foundation that is
  70% ready for API exposure. Core types (WorkflowMetadata, WorkflowLog, WorkflowStatus)
  are already API-ready and excellently designed. The main blockers are:
  
  1. PhaseSelector's CLI-centric string format (e.g., "0,1,2") is incompatible with
     standard JSON Schema and programmatic APIs. Solution: Accept JSON arrays while
     maintaining CLI compatibility via PhaseInput enum.
  
  2. StateFile conflates three concerns (file discovery, user input, and state tracking)
     and assumes local filesystem access. Solution: Complete architectural redesign
     into FileInput, StateFileConstraint, and StateFileReference.
  
  3. No JSON Schema generation capability prevents automatic MCP tool creation.
     Solution: Implement to_json_schema() methods and optionally add schemars.
  
  The recommended approach maintains 100% backwards compatibility with existing
  workflows while enabling modern API patterns. Immediate priority is adding JSON
  Schema generation (1 week effort), which unblocks MCP integration. The complete
  transformation to production-ready API types requires approximately 6 weeks.
tui_implementation_analysis:
  overview: |
    The Terminal User Interface is built with crossterm for terminal control and ratatui for rendering.
    It implements a non-blocking event loop that polls for keyboard input every 100ms while continuously
    processing background workflow progress updates via tokio mpsc channels.

  architecture:
    event_loop:
      location: "src/main.rs:474-527"
      pattern: "Poll-based loop with 100ms timeout"
      description: |
        The main loop follows a three-phase cycle:
        1. Process background workflow updates (non-blocking)
        2. Render UI frame
        3. Poll for keyboard events with 100ms timeout
      
      code_example: |
        fn run_app<B: Backend>(terminal: &mut Terminal<B>, app: &mut App) -> Result<()> {
            loop {
                // Phase 1: Process workflow progress (non-blocking)
                app.process_progress_updates();
                
                // Phase 2: Render current state
                terminal.draw(|f| ui(f, app))?;
                
                // Phase 3: Poll for keyboard events (100ms timeout)
                if event::poll(std::time::Duration::from_millis(100))? {
                    if let Event::Key(key) = event::read()? {
                        // Handle key press
                    }
                }
                
                if app.should_quit { break; }
            }
        }
      
      architectural_decisions:
        polling_interval: 
          value: "100ms"
          rationale: |
            Balances UI responsiveness with CPU efficiency. Short enough for smooth updates
            but long enough to avoid excessive CPU usage. This interval ensures progress
            messages appear near real-time (10 updates/second max) while keyboard input
            feels immediate to users.
        
        non_blocking_progress:
          method: "try_recv() in process_progress_updates()"
          rationale: |
            Prevents the UI from freezing while workflows execute. The loop continuously
            drains available messages without blocking, ensuring the UI can render and
            handle input even during heavy workflow activity.

  crossterm_ratatui_integration:
    terminal_setup:
      location: "src/main.rs:448-455"
      responsibilities:
        crossterm: "Raw mode control, alternate screen buffer, low-level terminal manipulation"
        ratatui: "Widget rendering, layout management, high-level UI composition"
      
      code_example: |
        fn main() -> Result<()> {
            // Crossterm: Enable raw mode (no line buffering, no echo)
            enable_raw_mode()?;
            let mut stdout = io::stdout();
            
            // Crossterm: Switch to alternate screen (preserves user's terminal state)
            execute!(stdout, EnterAlternateScreen)?;
            
            // Ratatui: Create backend and terminal wrapper
            let backend = CrosstermBackend::new(stdout);
            let mut terminal = Terminal::new(backend)?;
            
            // Run app...
            
            // Crossterm: Cleanup - restore terminal state
            disable_raw_mode()?;
            execute!(terminal.backend_mut(), LeaveAlternateScreen)?;
        }
    
    event_handling:
      location: "src/main.rs:484-520"
      crossterm_role: |
        Provides low-level event polling and reading. event::poll() checks for available
        input without blocking (respects timeout). event::read() consumes the event.
      
      code_example: |
        // Crossterm event polling with timeout
        if event::poll(std::time::Duration::from_millis(100))? {
            if let Event::Key(key) = event::read()? {
                if key.kind == KeyEventKind::Press {
                    match key.code {
                        KeyCode::Char('q') => app.should_quit = true,
                        KeyCode::Down => app.next(),
                        KeyCode::Enter => app.launch_workflow(),
                        // ... more handlers
                    }
                }
            }
        }
    
    rendering:
      location: "src/main.rs:529-904"
      ratatui_role: |
        Handles all rendering logic using a declarative widget system. The ui() function
        is called on every loop iteration and builds the entire UI from scratch based on
        current App state. Ratatui efficiently diffs and updates only changed regions.
      
      layout_system: |
        Uses constraint-based layouts that split terminal space into regions:
        
        Layout::default()
            .direction(Direction::Vertical)
            .constraints([
                Constraint::Length(3),    // Fixed height header
                Constraint::Min(0),       // Flexible content area
                Constraint::Length(3),    // Fixed height footer
            ])
            .split(f.area())
      
      widget_examples:
        - widget: "Paragraph"
          usage: "Headers, info panels, single-line text"
          location: "src/main.rs:553-568, 820-822"
        
        - widget: "List"
          usage: "Workflow items, task items with multi-line entries"
          location: "src/main.rs:698-699, 769-770"
        
        - widget: "Block"
          usage: "Borders and titles for all containers"
          location: "Throughout rendering functions"

  app_state_management:
    structure:
      location: "src/main.rs:114-123"
      fields:
        workflows: "Vec<Workflow> - All available workflows with status and progress"
        tasks: "Vec<Task> - Task list (currently static demo data)"
        selected: "usize - Currently selected item index in active view"
        current_view: "View enum - Controls which screen is rendered"
        should_quit: "bool - Signal to exit main loop"
        progress_rx: "Option<mpsc::Receiver<WorkflowProgress>> - Progress channel from active workflow"
        runtime: "tokio::runtime::Runtime - Async runtime for spawning workflows"
        scroll_offset: "usize - Vertical scroll position for logs"
      
      code_example: |
        struct App {
            workflows: Vec<Workflow>,
            tasks: Vec<Task>,
            selected: usize,
            current_view: View,
            should_quit: bool,
            progress_rx: Option<mpsc::Receiver<WorkflowProgress>>,
            runtime: tokio::runtime::Runtime,
            scroll_offset: usize,
        }
    
    view_transitions:
      state_machine:
        location: "src/main.rs:19-24"
        states:
          - WorkflowList: "Main launcher screen - browse and launch workflows"
          - WorkflowDetail(usize): "Shows real-time progress logs for running workflow"
          - TaskDashboard(usize): "Task list view (currently unused)"
        
        transitions:
          - trigger: "Enter key on workflow"
            from: "WorkflowList"
            to: "WorkflowDetail"
            condition: "Workflow must be Running or Completed"
            handler: "src/main.rs:359-366"
          
          - trigger: "Esc or 'b' key"
            from: "WorkflowDetail or TaskDashboard"
            to: "WorkflowList"
            handler: "src/main.rs:368-372"
      
      rendering_dispatch:
        location: "src/main.rs:543-547"
        code_example: |
          match app.current_view {
              View::WorkflowList => render_workflows(f, chunks[1], app),
              View::WorkflowDetail(workflow_id) => render_workflow_detail(f, chunks[1], app, workflow_id),
              View::TaskDashboard(_) => render_tasks(f, chunks[1], app),
          }

  message_passing_architecture:
    channel_setup:
      location: "src/main.rs:265-272"
      description: |
        When launching a workflow, the UI creates a bounded mpsc channel with capacity 100.
        The receiver (progress_rx) stays in the App, while the sender (tx) is moved into
        the background workflow task.
      
      code_example: |
        fn launch_workflow(&mut self) {
            // Create progress channel
            let (tx, rx) = mpsc::channel(100);
            self.progress_rx = Some(rx);
            
            // Spawn workflow in background on tokio runtime
            self.runtime.spawn(async move {
                let _ = run_workflow(config, tx).await;
            });
        }
      
      architectural_decisions:
        channel_capacity:
          value: 100
          rationale: |
            Large enough to buffer progress messages during busy periods without blocking
            workflow execution, but not so large as to cause excessive memory usage or
            message delay.
        
        sender_ownership:
          pattern: "Moved into async task"
          rationale: |
            Task owns the sender for its entire lifetime. When workflow completes, sender
            is dropped, which signals channel closure to the receiver.
    
    message_protocol:
      location: "src/lib.rs:48-59"
      variants:
        - PhaseStarted: "{ phase: usize, name: String }"
        - PhaseProgress: "{ phase: usize, message: String }"
        - PhaseCompleted: "{ phase: usize }"
        - TaskStarted: "{ phase: usize, task_id: usize, description: String }"
        - TaskProgress: "{ phase: usize, task_id: usize, message: String }"
        - TaskCompleted: "{ phase: usize, task_id: usize }"
        - TaskFailed: "{ phase: usize, task_id: usize, error: String }"
        - WorkflowCompleted: "Terminal message"
        - WorkflowFailed: "{ error: String } - Terminal message"
      
      code_example: |
        #[derive(Debug, Clone)]
        pub enum WorkflowProgress {
            PhaseStarted { phase: usize, name: String },
            PhaseProgress { phase: usize, message: String },
            PhaseCompleted { phase: usize },
            TaskStarted { phase: usize, task_id: usize, description: String },
            TaskProgress { phase: usize, task_id: usize, message: String },
            TaskCompleted { phase: usize, task_id: usize },
            TaskFailed { phase: usize, task_id: usize, error: String },
            WorkflowCompleted,
            WorkflowFailed { error: String },
        }
    
    message_processing:
      location: "src/main.rs:381-445"
      method: "Non-blocking drain pattern"
      description: |
        Called on every loop iteration. Uses try_recv() to drain all available messages
        without blocking, ensuring UI remains responsive even during message bursts.
      
      code_example: |
        fn process_progress_updates(&mut self) {
            let mut should_close = false;
            
            if let Some(rx) = &mut self.progress_rx {
                // Drain all available messages (non-blocking)
                while let Ok(progress) = rx.try_recv() {
                    match progress {
                        WorkflowProgress::PhaseStarted { phase, name } => {
                            workflow.current_phase = Some(format!("Phase {}: {}", phase, name));
                            workflow.progress_messages.push(format!("Started: {}", name));
                        }
                        WorkflowProgress::PhaseProgress { phase, message } => {
                            workflow.progress_messages.push(format!("[Phase {}] {}", phase, message));
                        }
                        // ... more handlers
                        WorkflowProgress::WorkflowCompleted => {
                            workflow.status = WorkflowStatus::Completed;
                            should_close = true;
                        }
                    }
                }
            }
            
            // Clean up channel when workflow terminates
            if should_close {
                self.progress_rx = None;
            }
        }
      
      architectural_decisions:
        non_blocking_drain:
          pattern: "while let Ok(msg) = rx.try_recv()"
          rationale: |
            Processes all queued messages immediately without blocking. If channel is
            empty, loop exits instantly. This keeps the UI responsive and ensures progress
            updates appear as soon as they arrive.
        
        message_accumulation:
          storage: "progress_messages: Vec<String>"
          rationale: |
            Stores all progress messages for display in WorkflowDetail view. Allows users
            to scroll through complete workflow history. Memory-bounded by workflow
            completion (channel closes and drops receiver).

  background_workflow_execution:
    tokio_runtime:
      location: "src/main.rs:223"
      initialization: "tokio::runtime::Runtime::new().unwrap()"
      description: |
        Single-threaded tokio runtime embedded in the App struct. Created during
        initialization and lives for the entire application lifetime. Allows spawning
        async workflows from synchronous UI code.
      
      architectural_decision:
        pattern: "Embedded runtime in synchronous app"
        rationale: |
          The main UI loop is synchronous (required by crossterm/ratatui), but workflows
          are async (Claude SDK is async). Embedding a runtime allows bridging these two
          worlds without making the entire app async, which would complicate the event loop.
    
    workflow_spawning:
      location: "src/main.rs:344-346"
      pattern: "Fire-and-forget spawn"
      code_example: |
        self.runtime.spawn(async move {
            let _ = run_workflow(config, tx).await;
        });
      
      description: |
        Workflows run independently in the background. The UI doesn't await completion;
        instead, it receives progress updates via the channel. Errors are sent as
        WorkflowFailed messages rather than propagating to UI thread.
      
      architectural_decision:
        error_handling: "Errors sent via channel, not propagated"
        rationale: |
          Prevents workflow errors from crashing the UI. All workflow lifecycle events
          (success, failure, progress) flow through the same message channel, providing
          a unified interface for the UI.
    
    workflow_execution_flow:
      location: "src/lib.rs:62-143"
      phases:
        - phase_0:
            name: "Analyze Codebase"
            location: "src/lib.rs:145-178"
            sends: "PhaseStarted, PhaseProgress, PhaseCompleted"
            description: "Uses Claude agent to analyze project structure"
        
        - phase_1:
            name: "Generate Research Prompts"
            location: "src/lib.rs:180-219"
            sends: "PhaseStarted, PhaseProgress, PhaseCompleted"
            description: "Generates research questions based on analysis"
        
        - phase_2:
            name: "Execute Research"
            location: "src/lib.rs:221-304"
            sends: "PhaseStarted, TaskStarted, TaskCompleted, TaskFailed, PhaseProgress, PhaseCompleted"
            description: "Executes prompts concurrently with semaphore rate limiting"
            concurrency_control: "Arc<Semaphore> with batch_size permits"
        
        - phase_3:
            name: "Validate YAML"
            location: "src/lib.rs:306-422"
            sends: "PhaseStarted, TaskStarted, TaskCompleted, TaskFailed, PhaseProgress, PhaseCompleted"
            description: "Validates and fixes YAML output files"
        
        - phase_4:
            name: "Synthesize Documentation"
            location: "src/lib.rs:424-452"
            sends: "PhaseStarted, PhaseProgress, PhaseCompleted"
            description: "Combines all research into final documentation"
      
      code_example: |
        pub async fn run_workflow(
            config: WorkflowConfig,
            progress_tx: tokio::sync::mpsc::Sender<WorkflowProgress>,
        ) -> Result<()> {
            // Execute phases based on config
            if config.phases.contains(&0) {
                execute_phase_0(&config, &progress_tx, &mut codebase_analysis).await?;
            }
            if config.phases.contains(&1) {
                execute_phase_1(&config, &progress_tx, &codebase_analysis, &mut prompts_data).await?;
            }
            // ... more phases
            
            progress_tx.send(WorkflowProgress::WorkflowCompleted).await?;
            Ok(())
        }

  ui_responsiveness:
    techniques:
      non_blocking_channel:
        mechanism: "try_recv() instead of recv()"
        location: "src/main.rs:386"
        benefit: "UI never blocks waiting for workflow messages"
      
      frequent_polling:
        interval: "100ms"
        location: "src/main.rs:484"
        benefit: "UI updates appear near real-time (10 Hz)"
      
      separate_async_runtime:
        pattern: "Tokio runtime for background work, synchronous event loop for UI"
        benefit: "Workflows don't block UI rendering or input handling"
      
      buffered_channel:
        capacity: 100
        benefit: "Workflow can send bursts of messages without blocking on UI processing"
    
    user_experience:
      real_time_feedback:
        description: |
          Users see progress messages appear within 100ms of being sent. The UI never
          freezes during workflow execution.
        
        example_flow: |
          1. User presses Enter to launch workflow
          2. Workflow spawns in background
          3. User presses 'v' to view details
          4. Progress messages stream in real-time
          5. User can press Esc to return to list (workflow keeps running)
          6. User can press 'q' to quit (workflow keeps running in background until process exits)
      
      concurrent_interaction:
        capabilities:
          - "Navigate between views while workflow runs"
          - "Scroll through progress logs while messages are arriving"
          - "Launch multiple workflows (though UI only shows one channel currently)"
        
        limitation: |
          Only one progress_rx channel is stored, so launching a second workflow would
          disconnect from the first. This could be extended to track multiple channels.

  architectural_strengths:
    - principle: "Separation of concerns"
      implementation: "UI rendering, event handling, and workflow execution are independent"
    
    - principle: "Non-blocking I/O"
      implementation: "try_recv(), event::poll(), async runtime isolation"
    
    - principle: "Message-driven updates"
      implementation: "All workflow state changes flow through typed message channel"
    
    - principle: "Declarative rendering"
      implementation: "UI rebuilt from App state each frame, ratatui handles diffing"
    
    - principle: "Graceful error handling"
      implementation: "Workflow errors sent as messages, not propagated to UI thread"

  potential_improvements:
    - enhancement: "Multiple concurrent workflow tracking"
      current_limitation: "Only one progress_rx channel"
      solution: "Store HashMap<workflow_id, mpsc::Receiver>"
    
    - enhancement: "Workflow cancellation"
      current_limitation: "No way to stop a running workflow"
      solution: "Add cancellation token passed to run_workflow()"
    
    - enhancement: "Progress persistence"
      current_limitation: "Progress lost on UI exit"
      solution: "Write progress messages to file as they arrive"
    
    - enhancement: "Adaptive polling interval"
      current_limitation: "Fixed 100ms may waste CPU when idle"
      solution: "Increase interval when no messages received, decrease when active"
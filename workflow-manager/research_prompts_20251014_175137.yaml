objective: Design and implement an API layer for workflow-manager to enable integration with MCP servers and TUI applications using the Claude Agent SDK
prompts:
- title: Current Workflow Manager Architecture Analysis
  query: Examine the current workflow-manager architecture, focusing on how workflows are defined, discovered, executed, and monitored. Analyze the WorkflowDefinition trait, workflow-manager-sdk structure, and the main.rs WorkflowAgent implementation. Document the data flow from workflow definition to execution, including field schemas, metadata handling, and the logging system (WorkflowLog events). Identify which components are tightly coupled to the TUI and which could be exposed via an API.
  focus:
  - WorkflowDefinition trait and macro system implementation
  - WorkflowAgent structure and execution model
  - Workflow discovery mechanism in discovery.rs
  - Communication patterns (WorkflowLog, WorkflowProgress, WorkflowStatus)
  - Current dependency structure between workflow-manager, workflow-manager-sdk, and claude-agent-sdk
- title: MCP Server Integration Patterns
  query: Investigate how MCP servers are implemented in the claude-agent-sdk crate by examining mcp_integration_demo.rs, mcp_demo.rs, and related examples. Analyze the SdkMcpServer, SdkMcpTool, and McpServerConfig patterns. Document how tools are registered, invoked, and how they communicate results back to Claude. Pay special attention to the async execution model, error handling, and the ToolResult/ToolContent types. Determine what patterns should be adopted for exposing workflow operations as MCP tools.
  focus:
  - SdkMcpServer builder pattern and tool registration
  - SdkMcpTool creation with async handlers
  - Tool input/output schemas using serde_json
  - Integration with ClaudeSDKClient and message handling
  - McpServerConfig::Sdk vs other server types
- title: API Surface Design Requirements
  query: 'Analyze what operations a workflow-manager API should expose to support both MCP server and TUI use cases. Consider operations like: listing available workflows, getting workflow metadata and field schemas, validating workflow inputs, starting/stopping workflows, querying workflow status, streaming workflow logs, and accessing workflow results. Examine how the current TUI (main.rs) interacts with workflows and what data it needs at each stage. Identify which operations should be synchronous vs streaming/async.'
  focus:
  - Workflow lifecycle operations (list, describe, validate, execute, cancel)
  - Real-time progress monitoring and log streaming
  - State management for concurrent workflow execution
  - Input validation and field schema queries
  - Result retrieval and error handling patterns
- title: Crate Separation and Module Organization
  query: 'Investigate the best strategy for organizing the API layer - whether to create a new crate (workflow-manager-api) or extend workflow-manager-sdk. Examine the current crate structure: workflow-manager (binary/TUI), workflow-manager-sdk (trait definitions), workflow-manager-macros (derive macro), and claude-agent-sdk. Consider dependencies, circular dependency risks, and whether the API should be runtime-agnostic or tokio-specific. Look at how other Rust projects separate SDK, API, and client concerns.'
  focus:
  - Dependency graph analysis (which crate depends on what)
  - Code reuse between TUI and API implementations
  - Trait-based abstraction vs concrete implementations
  - Runtime and async runtime considerations
  - Public API surface and semver compatibility
- title: Workflow Execution and Process Management
  query: Examine how workflows are currently executed as separate processes or in-process agents. Analyze the bin/ examples like simple_echo.rs, hooks_demo.rs, demo_multiphase.rs to understand execution patterns. Investigate how workflow state is managed, how logs are captured (stderr parsing of __WF_EVENT__), and how process lifecycle is controlled. Determine whether the API should support both process-based and library-based workflow execution, and how to handle sandboxing, resource limits, and cancellation.
  focus:
  - Process spawning vs in-process execution trade-offs
  - Workflow log parsing and streaming implementation
  - State persistence and recovery mechanisms
  - Cancellation and cleanup handling
  - Concurrent workflow execution management
- title: Type System and Serialization Strategy
  query: Analyze the current type system in workflow-manager-sdk (WorkflowMetadata, FieldSchema, FieldType, WorkflowLog, etc.) and determine what changes are needed for API exposure. Examine serialization with serde, JSON schema generation for MCP tool definitions, and how field types map to API parameters. Consider versioning, backwards compatibility, and how to represent complex types like PhaseSelector and StateFile in both MCP tools and programmatic API calls.
  focus:
  - Serde serialization patterns and schema generation
  - FieldType enum mapping to JSON schemas for MCP tools
  - API request/response type definitions
  - Error type design for API boundaries
  - Versioning strategy for API types
- title: Reference Implementation Design
  query: 'Research best practices for implementing dual-purpose APIs that serve both MCP servers and programmatic clients (like TUI). Look at similar projects that expose both CLI, API, and integration interfaces. Consider patterns like: facade pattern for unified API, builder pattern for configuration, trait-based plugin systems, and event-driven architectures. Determine concrete steps for implementing a minimal viable API that supports listing workflows, executing a workflow, and streaming its logs to both an MCP tool handler and a TUI component.'
  focus:
  - API facade/interface design patterns
  - Event streaming architectures (tokio channels, async streams)
  - Configuration and initialization patterns
  - Testing strategy for API layer
  - Example implementation sketch for 2-3 core operations

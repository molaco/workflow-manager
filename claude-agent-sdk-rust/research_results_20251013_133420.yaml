- title: CLI Subprocess Initialization Flow
  query: Trace the complete initialization sequence from SDK client instantiation
    through Claude Code CLI subprocess startup. Examine how the SubprocessCLITransport
    builds command-line arguments, spawns the subprocess with environment variables
    (CLAUDE_CODE_ENTRYPOINT, CLAUDE_AGENT_SDK_VERSION), and establishes stdin/stdout/stderr
    streams. Document the difference between string mode (--print with prompt) and
    streaming mode (--input-format stream-json), including how MCP servers are passed
    via --mcp-config flag.
  response: "python\ndef __init__(self, options: ClaudeAgentOptions | None = None,\
    \ transport: Transport | None = None):\n    if options is None:\n        options\
    \ = ClaudeAgentOptions()\n    self.options = options\n    self._custom_transport\
    \ = transport\n    self._transport: Transport | None = None\n    self._query:\
    \ Any | None = None\n    os.environ[\"CLAUDE_CODE_ENTRYPOINT\"] = \"sdk-py-client\""
  focus:
  - SubprocessCLITransport.connect() method and _build_command() logic
  - CLI argument construction for MCP servers and streaming modes
  - Process spawning with environment variables and stream setup
  - Version checking and validation (_check_claude_version)
- title: Control Protocol Handshake
  query: Investigate the bidirectional control protocol handshake that occurs after
    CLI subprocess startup. Examine how Query.initialize() sends the initialize control
    request with hooks configuration, how the CLI responds with supported commands
    and capabilities, and how this result is stored for later access. Document the
    JSON-RPC style message format and the request/response tracking mechanism using
    request IDs.
  response: "python\n   request = {\n       \"subtype\": \"initialize\",\n       \"\
    hooks\": hooks_config if hooks_config else None,\n   }"
  focus:
  - Query.initialize() control request format and hooks configuration
  - Control message routing in _read_messages() method
  - Request ID generation and pending response tracking
  - Initialization result storage and retrieval
- title: SDK MCP Server Registration
  query: Analyze how in-process SDK MCP servers are registered and distinguished from
    external MCP servers. Trace how create_sdk_mcp_server() creates MCP server instances,
    how they are passed in ClaudeAgentOptions.mcp_servers with type='sdk', and how
    the SDK separates the server instance from the configuration when passing to CLI
    via --mcp-config (stripping the 'instance' field while retaining other config).
  response: "python\nclass McpSdkServerConfig(TypedDict):\n    type: Literal[\"sdk\"\
    ]\n    name: str\n    instance: \"McpServer\"  # The actual MCP server instance"
  focus:
  - SDK vs external MCP server configuration format
  - MCP server instance extraction in InternalClient and ClaudeSDKClient
  - Command-line argument building for MCP servers
  - sdk_mcp_servers dictionary population and storage
- title: MCP Tool Communication Protocol
  query: Examine the bidirectional communication mechanism for SDK MCP tool invocations.
    Trace how the CLI sends control_request messages with subtype='mcp_message' containing
    JSONRPC payloads (initialize, tools/list, tools/call), how Query._handle_sdk_mcp_request()
    routes these to the appropriate in-process MCP server instance, and how responses
    flow back through control_response messages. Document the manual method routing
    and the limitations compared to TypeScript SDK's transport abstraction.
  response: "python\n# Message structure (types.py:578-582)\nclass SDKControlMcpMessageRequest(TypedDict):\n\
    \    subtype: Literal[\"mcp_message\"]\n    server_name: str  # Name of the SDK\
    \ MCP server\n    message: Any      # JSONRPC payload (initialize, tools/list,\
    \ tools/call)"
  focus:
  - Control request handling for MCP messages in Query
  - JSONRPC message routing to MCP server handlers
  - Method implementations (initialize, tools/list, tools/call)
  - Response format conversion and error handling
- title: Message Streaming and Parsing
  query: Investigate how messages flow bidirectionally between SDK and CLI after initialization.
    Examine how JSON messages are written to stdin via Transport.write(), how stdout
    is read line-by-line with TextReceiveStream, how partial JSON is buffered and
    parsed speculatively, and how messages are routed by type (control_request, control_response,
    regular SDK messages). Document the memory object stream used for SDK message
    queueing.
  response: "python\nasync def write(self, data: str) -> None:\n    \"\"\"Write raw\
    \ data to the transport.\"\"\"\n    # Safety checks\n    if not self._ready or\
    \ not self._stdin_stream:\n        raise CLIConnectionError(\"ProcessTransport\
    \ is not ready for writing\")\n    \n    if self._process and self._process.returncode\
    \ is not None:\n        raise CLIConnectionError(f\"Cannot write to terminated\
    \ process...\")\n    \n    if self._exit_error:\n        raise CLIConnectionError(f\"\
    Cannot write to process that exited with error...\")\n    \n    try:\n       \
    \ await self._stdin_stream.send(data)  # Write to TextSendStream\n    except Exception\
    \ as e:\n        self._ready = False\n        self._exit_error = CLIConnectionError(f\"\
    Failed to write to process stdin: {e}\")\n        raise self._exit_error from\
    \ e"
  focus:
  - Transport.write() and Transport.read_messages() implementations
  - JSON buffering and speculative parsing with max_buffer_size
  - Message type routing and control protocol separation
  - anyio memory object streams for message queueing
- title: Tool Permission Control Flow
  query: Analyze the tool permission callback mechanism when can_use_tool is provided.
    Trace how the SDK automatically sets permission_prompt_tool_name='stdio', how
    the CLI sends control_request with subtype='can_use_tool' containing tool name
    and input, how the SDK callback returns PermissionResultAllow or PermissionResultDeny,
    and how updated inputs and permissions flow back to the CLI. Include validation
    of mutually exclusive permission_prompt_tool_name and can_use_tool options.
  response: "python\nCanUseTool = Callable[\n    [str, dict[str, Any], ToolPermissionContext],\
    \ Awaitable[PermissionResult]\n]"
  focus:
  - Permission callback configuration and validation
  - SDKControlPermissionRequest message structure
  - PermissionResult conversion to control protocol format
  - Updated input and permission suggestions handling
- title: Streaming vs String Mode Differences
  query: Document the architectural differences between string mode (one-shot queries)
    and streaming mode (bidirectional clients). Examine how string mode passes prompts
    via CLI arguments and closes stdin immediately, while streaming mode uses --input-format
    stream-json and maintains open stdin for dynamic message sending. Trace how Query.is_streaming_mode
    affects control protocol availability, initialization handshake, and the ClaudeSDKClient's
    always-streaming architecture.
  response:
    architectural_differences_streaming_vs_string_mode:
      mode_determination:
        location: src/claude_agent_sdk/_internal/transport/subprocess_cli.py:43
        logic: 'self._is_streaming = not isinstance(prompt, str)

          - String mode: prompt is str

          - Streaming mode: prompt is AsyncIterable[dict[str, Any]]

          '
      cli_invocation:
        string_mode:
          location: src/claude_agent_sdk/_internal/transport/subprocess_cli.py:198-199
          command_format: 'cmd.extend(["--print", "--", str(self._prompt)])

            '
          characteristics:
          - Prompt passed as CLI argument via --print flag
          - No --input-format flag needed
          - One-shot execution model
        streaming_mode:
          location: src/claude_agent_sdk/_internal/transport/subprocess_cli.py:195-196
          command_format: 'cmd.extend(["--input-format", "stream-json"])

            '
          characteristics:
          - Uses --input-format stream-json flag
          - No prompt in CLI arguments
          - Messages sent via stdin
          - Bidirectional communication model
      output_format:
        both_modes:
          location: src/claude_agent_sdk/_internal/transport/subprocess_cli.py:88
          format: 'cmd = [self._cli_path, "--output-format", "stream-json", "--verbose"]

            '
          note: Both modes always use --output-format stream-json for responses
      stdin_handling:
        string_mode:
          location: src/claude_agent_sdk/_internal/transport/subprocess_cli.py:256-258
          behavior: "elif not self._is_streaming and self._process.stdin:\n    # String\
            \ mode: close stdin immediately\n    await self._process.stdin.aclose()\n"
          characteristics:
          - stdin closed immediately after process start
          - No further input possible
          - Process reads prompt from CLI args only
        streaming_mode:
          location: src/claude_agent_sdk/_internal/transport/subprocess_cli.py:254-255
          behavior: "if self._is_streaming and self._process.stdin:\n    self._stdin_stream\
            \ = TextSendStream(self._process.stdin)\n"
          characteristics:
          - stdin kept open via TextSendStream
          - Used for dynamic message sending
          - Enables bidirectional communication
          - Closed later via end_input() method
      control_protocol_availability:
        query_initialization:
          location: src/claude_agent_sdk/_internal/query.py:107-114
          logic: "async def initialize(self) -> dict[str, Any] | None:\n    \"\"\"\
            Initialize control protocol if in streaming mode.\"\"\"\n    if not self.is_streaming_mode:\n\
            \        return None\n"
          impact: '- String mode: Returns None, no initialization handshake

            - Streaming mode: Sends initialize control request, receives capabilities

            '
        control_request_validation:
          location: src/claude_agent_sdk/_internal/query.py:317-320
          logic: "async def _send_control_request(self, request: dict[str, Any]) ->\
            \ dict[str, Any]:\n    if not self.is_streaming_mode:\n        raise Exception(\"\
            Control requests require streaming mode\")\n"
          impact: 'All control protocol features disabled in string mode:

            - interrupt()

            - set_permission_mode()

            - set_model()

            - can_use_tool callbacks

            - hook callbacks

            - SDK MCP server handling

            '
        query_class_architecture:
          location: src/claude_agent_sdk/_internal/query.py:53-106
          is_streaming_mode_field:
            line: 86
            definition: self.is_streaming_mode = is_streaming_mode
            usage: Guards all bidirectional control protocol features
          bidirectional_capabilities_when_streaming:
          - Hook callbacks via hook_callbacks dict (line 94)
          - Tool permission callbacks via can_use_tool (line 87)
          - Control request/response routing (lines 92-93)
          - Initialization handshake (lines 107-145)
          - Dynamic message streaming (line 513-524)
      initialization_handshake:
        streaming_mode_only:
          location: src/claude_agent_sdk/_internal/query.py:136-145
          process: "# Build hooks configuration\nrequest = {\n    \"subtype\": \"\
            initialize\",\n    \"hooks\": hooks_config if hooks_config else None,\n\
            }\nresponse = await self._send_control_request(request)\nself._initialized\
            \ = True\nself._initialization_result = response\n"
          response_contains:
          - supported_commands: Available control protocol commands
          - output_styles: Current and available output styles
          - server_capabilities: What the CLI server can do
          usage_locations:
          - src/claude_agent_sdk/_internal/client.py:106-107
          - src/claude_agent_sdk/client.py:153-154
        string_mode:
          behavior: No initialization handshake performed
          implications:
          - No control protocol negotiation
          - No hook registration
          - No capability discovery
          - Fire-and-forget execution
      message_streaming:
        string_mode:
          prompt_delivery: Via CLI --print argument
          input_stream: Closed immediately, no dynamic messages
          output_stream: CLI streams responses via stdout
          flow: "Unidirectional (CLI \u2192 SDK)"
        streaming_mode:
          prompt_delivery: Via stdin as stream-json messages
          input_stream:
            location: src/claude_agent_sdk/_internal/query.py:513-524
            method: "async def stream_input(self, stream: AsyncIterable[dict[str,\
              \ Any]]) -> None:\n    async for message in stream:\n        if self._closed:\n\
              \            break\n        await self.transport.write(json.dumps(message)\
              \ + \"\\n\")\n    await self.transport.end_input()\n"
          output_stream: CLI streams responses via stdout
          flow: "Bidirectional (SDK \u2194 CLI)"
      client_integration:
        internal_client:
          location: src/claude_agent_sdk/_internal/client.py:41-121
          mode_detection:
            line: 90
            logic: is_streaming = not isinstance(prompt, str)
          initialization_flow:
            lines: 102-114
            logic: "await query.start()\nif is_streaming:\n    await query.initialize()\n\
              if isinstance(prompt, AsyncIterable) and query._tg:\n    query._tg.start_soon(query.stream_input,\
              \ prompt)\n"
          string_mode_behavior:
          - No initialization call
          - Prompt already in CLI args
          - Just starts reading responses
          streaming_mode_behavior:
          - Calls initialize() for handshake
          - Spawns background task to stream input
          - Enables bidirectional control protocol
        claude_sdk_client:
          location: src/claude_agent_sdk/client.py:14-336
          architecture: Always uses streaming mode
          key_design:
            line: 144
            code: "self._query = Query(\n    transport=self._transport,\n    is_streaming_mode=True,\
              \  # ClaudeSDKClient always uses streaming mode\n    ...\n)\n"
            rationale: 'ClaudeSDKClient is designed for interactive, bidirectional
              conversations.

              It always creates an AsyncIterable prompt (even if empty) to maintain

              an open stdin connection for dynamic message sending.

              '
          empty_stream_pattern:
            location: lines 94-99
            code: "async def _empty_stream() -> AsyncIterator[dict[str, Any]]:\n \
              \   # Never yields, but indicates this is an iterator and keeps connection\
              \ open\n    return\n    yield {}  # Unreachable but makes this an async\
              \ generator\n"
            usage: 'When connect() is called without a prompt, creates an empty async
              iterator

              to trigger streaming mode while keeping stdin open for later query()
              calls.

              '
          dynamic_querying:
            method: query(prompt, session_id)
            location: lines 170-199
            behavior: '# Converts string prompts to stream-json messages

              # Sends via already-open stdin connection

              # Requires prior connect() with streaming mode

              '
      control_protocol_features:
        available_in_streaming_only:
          interrupt:
            location: src/claude_agent_sdk/_internal/query.py:491-493
            sends_control_request:
              subtype: interrupt
          set_permission_mode:
            location: src/claude_agent_sdk/_internal/query.py:495-502
            sends_control_request:
              subtype: set_permission_mode
              mode: string
          set_model:
            location: src/claude_agent_sdk/_internal/query.py:504-511
            sends_control_request:
              subtype: set_model
              model: string
          can_use_tool_callback:
            location: src/claude_agent_sdk/_internal/query.py:215-256
            handles_request:
              subtype: can_use_tool
            bidirectional: CLI requests permission from SDK
          hook_callbacks:
            location: src/claude_agent_sdk/_internal/query.py:258-272
            handles_request:
              subtype: hook_callback
            bidirectional: CLI invokes SDK hook functions
          sdk_mcp_servers:
            location: src/claude_agent_sdk/_internal/query.py:274-289
            handles_request:
              subtype: mcp_message
            bidirectional: CLI routes MCP requests to in-process Python servers
        unavailable_in_string_mode:
          reason: No open stdin for control messages
          error_behavior: Exception raised if attempted
      message_routing:
        query_read_messages:
          location: src/claude_agent_sdk/_internal/query.py:154-205
          routing_logic: '- control_response: Routes to pending_control_results

            - control_request: Spawns handler task

            - control_cancel_request: TODO (not yet implemented)

            - Regular messages: Sent to _message_receive stream

            '
          both_modes: Message reading works the same
          difference: String mode never receives control messages
      architecture_summary:
        string_mode:
          use_case: One-shot queries with all inputs known upfront
          communication: "Unidirectional (CLI \u2192 SDK)"
          stdin: Closed immediately
          cli_args: Includes --print with prompt
          control_protocol: Disabled
          initialization: None
          suitable_for:
          - Simple questions
          - Batch processing
          - Fire-and-forget automation
          - Stateless operations
        streaming_mode:
          use_case: Interactive, bidirectional conversations
          communication: "Bidirectional (SDK \u2194 CLI)"
          stdin: Kept open for dynamic message sending
          cli_args: Includes --input-format stream-json
          control_protocol: Enabled
          initialization: Handshake with capability negotiation
          suitable_for:
          - Chat interfaces
          - Multi-turn conversations
          - Interactive debugging
          - Real-time applications
          - Dynamic permission management
          - SDK MCP server integration
        claude_sdk_client_always_streaming:
          design_principle: 'ClaudeSDKClient is architected exclusively for streaming
            mode to enable

            its core features: dynamic message sending via query(), interrupts,

            runtime permission/model changes, and bidirectional control protocol.

            '
          implementation:
          - Always passes is_streaming_mode=True to Query
          - Always uses --input-format stream-json
          - Always keeps stdin open
          - Always performs initialization handshake
          - Converts string prompts to stream-json messages internally
          contrast_with_query_function:
            query_function: Supports both string and streaming modes
            claude_sdk_client: Streaming mode only, by design
  focus:
  - Prompt handling in _build_command() for both modes
  - Stdin lifecycle management differences
  - Control protocol availability restrictions
  - InternalClient.process_query() vs ClaudeSDKClient.connect() patterns

task:
  id: 1
  name: "Project Structure and Application Foundation"

context:
  description: |
    This task establishes the foundational Rust project structure with iced GUI framework
    integration, including proper module organization, dependency configuration, and basic
    application scaffolding. This creates the skeleton that all other components will build upon.
    
    A well-organized project structure is critical for maintainability and scalability. The
    modular architecture separates concerns (UI, state, models, persistence, scheduling)
    allowing parallel development of features. Proper iced integration from the start ensures
    the Elm architecture pattern is correctly implemented.
    
    The outcome is a compilable Rust application with iced GUI framework configured, module
    structure in place, and a basic "Hello World" window that demonstrates the application
    lifecycle. All dependencies are properly configured in Cargo.toml with appropriate feature
    flags.

  key_points:
    - "Uses iced 0.13 with canvas, tokio, and advanced features for full GUI capability"
    - "Implements Elm architecture pattern through iced::Application trait"
    - "Modular structure separates state management, UI, models, persistence, and scheduling"
    - "Cross-platform data path detection using directories crate"
    - "Release profile optimized with LTO and minimal codegen units"
    - "Foundation enables parallel development of subsequent tasks"
    - "Type-safe message passing and state updates guaranteed by Rust type system"

files:
  - path: "Cargo.toml"
    description: "Project manifest defining dependencies (iced 0.13, directories, fonts), metadata, and build profiles with release optimizations"
  
  - path: "src/main.rs"
    description: "Application entry point that initializes and runs the iced Application with window settings"
  
  - path: "src/lib.rs"
    description: "Library root that declares and re-exports all major modules (state, ui, models, persistence, scheduler, data)"
  
  - path: "src/state/mod.rs"
    description: "State module root - placeholder for application state management structures"
  
  - path: "src/ui/mod.rs"
    description: "UI module root - placeholder for user interface components and view logic"
  
  - path: "src/models/mod.rs"
    description: "Models module root - placeholder for data structures representing domain entities"
  
  - path: "src/persistence/mod.rs"
    description: "Persistence module root - placeholder for data storage and retrieval logic"
  
  - path: "src/scheduler/mod.rs"
    description: "Scheduler module root - placeholder for task scheduling and recurring event management"
  
  - path: "src/data/mod.rs"
    description: "Data module root - placeholder for data initialization, validation, and management utilities"
  
  - path: "src/app.rs"
    description: "Main application struct implementing iced::Application trait with update, view, and lifecycle methods"

functions:
  - file: "src/main.rs"
    items:
      - type: "function"
        name: "main"
        description: "Application entry point that initializes and runs the iced application"
        preconditions: "None"
        postconditions: "Application window is created and event loop starts"
        invariants: "Must return Result type for error handling"
      
      - type: "struct"
        name: "HabitTrackerApp"
        description: "Main application struct implementing iced::Application trait"
        invariants: "Maintains application state throughout lifecycle"
      
      - type: "trait_impl"
        name: "iced::Application for HabitTrackerApp"
        description: "Implements the iced Application trait with Elm architecture pattern"
        postconditions: "Application follows Elm update-view cycle"
      
      - type: "method"
        name: "HabitTrackerApp::new"
        description: "Constructor for creating new application instance"
        postconditions: "Returns initialized HabitTrackerApp with default state"
      
      - type: "method"
        name: "HabitTrackerApp::title"
        description: "Returns the window title string"
        postconditions: "Returns static string for window title"
        invariants: "Always returns same title value"
      
      - type: "method"
        name: "HabitTrackerApp::update"
        description: "Handles application messages and updates state"
        preconditions: "Valid Message passed as parameter"
        postconditions: "Application state updated according to message"
      
      - type: "method"
        name: "HabitTrackerApp::view"
        description: "Renders the current application state to UI elements"
        postconditions: "Returns iced Element tree representing current UI"
        invariants: "Pure function - same state produces same UI"
      
      - type: "enum"
        name: "Message"
        description: "Enum defining all possible application messages/events"
        invariants: "Exhaustive set of all user interactions and system events"

  - file: "src/state/mod.rs"
    items:
      - type: "module_declaration"
        name: "state"
        description: "Module declaration for state management components"

  - file: "src/ui/mod.rs"
    items:
      - type: "module_declaration"
        name: "ui"
        description: "Module declaration for UI components and views"

  - file: "src/models/mod.rs"
    items:
      - type: "module_declaration"
        name: "models"
        description: "Module declaration for data models and domain types"

  - file: "src/persistence/mod.rs"
    items:
      - type: "module_declaration"
        name: "persistence"
        description: "Module declaration for data persistence and storage"

  - file: "src/scheduler/mod.rs"
    items:
      - type: "module_declaration"
        name: "scheduler"
        description: "Module declaration for habit scheduling logic"

  - file: "src/data/mod.rs"
    items:
      - type: "module_declaration"
        name: "data"
        description: "Module declaration for data utilities and helpers"

  - file: "Cargo.toml"
    items:
      - type: "constant"
        name: "[package]"
        description: "Package metadata including name, version, edition"
        invariants: "Edition must be 2021 or later"
      
      - type: "constant"
        name: "[dependencies]"
        description: "Project dependencies including iced with required features"
        invariants: "iced version 0.13 with canvas, tokio, and advanced features enabled"
      
      - type: "constant"
        name: "[profile.release]"
        description: "Release build optimizations for performance"
        postconditions: "Optimized binary with LTO and codegen-units=1"

formal_verification:
  needed: false
  level: "None"
  explanation: |
    Formal verification is not needed for this foundational task because:
    
    1. No Complex Logic: This task establishes project structure and boilerplate code
       with minimal logic beyond framework integration. The implementations are trivial
       stubs (empty update/view methods) that serve as placeholders.
    
    2. Framework Guarantees: The iced framework already provides type-safety and
       lifecycle guarantees through Rust's type system and the Application trait.
       The framework itself handles the Elm architecture constraints.
    
    3. Compiler Verification Sufficient: Rust's type system and borrow checker provide
       adequate verification at this stage. If the code compiles and the application
       launches, the structure is correct.
    
    4. No Critical Properties: There are no safety-critical invariants, concurrent
       operations, or complex state transitions to verify. The task creates empty
       containers that will be filled in later tasks.
    
    5. Low Risk Profile: The acceptance criteria are straightforward (compilation
       success, window display) and easily verified through basic testing. There are
       no algorithmic correctness concerns or edge cases.
    
    Formal verification becomes relevant in later tasks involving state management
    (Task 6), concurrent scheduling (Task 10), or complex rendering logic (Tasks 7-9)
    where invariants and properties must be maintained across operations.

tests:
  strategy:
    approach: "unit tests with compilation verification"
    rationale:
      - "Task focuses on project structure and basic setup with minimal logic to test"
      - "Primary verification is that the project compiles and dependencies are correctly configured"
      - "Testing strategy validates the application trait implementation and basic lifecycle"
      - "No complex business logic exists yet, so unit tests verify structural integrity"
      - "Smoke tests ensure iced integration works and window can be instantiated"

  implementation:
    file: "src/main.rs"
    location: "in existing test module"
    code: |
      #[cfg(test)]
      mod tests {
          use super::*;

          #[test]
          fn test_app_compiles() {
              // Verify that the App struct can be instantiated
              // This test ensures the basic structure compiles
              let _app = App;
              // Test passes if compilation succeeds
          }

          #[test]
          fn test_module_imports() {
              // Verify all module declarations are accessible
              // This ensures mod.rs files are properly structured
              
              // Attempt to reference each module namespace
              // If modules don't compile correctly, this test fails at compile time
              let _ = std::any::type_name::<crate::state::State>();
              let _ = std::any::type_name::<crate::models::Character>();
              let _ = std::any::type_name::<crate::ui::Message>();
          }

          #[test]
          fn test_app_implements_application_trait() {
              // Verify App implements required iced::Application trait methods
              // This is a compile-time check that ensures trait implementation
              fn assert_application<T: iced::Application>() {}
              assert_application::<App>();
          }

          #[test]
          fn test_default_state_creation() {
              // Verify default state can be created
              let state = State::default();
              assert!(state.characters.is_empty(), "Initial state should have no characters");
              assert!(state.groups.is_empty(), "Initial state should have no groups");
          }

          #[test]
          fn test_message_variants_exist() {
              // Verify Message enum has expected variants for basic operations
              // This ensures the message type is properly defined
              let _add_msg = Message::AddCharacter;
              let _remove_msg = Message::RemoveCharacter(String::new());
              let _none_msg = Message::None;
          }
      }

  additional_files:
    - file: "tests/integration_test.rs"
      location: "create new"
      code: |
        use std::time::Duration;
        
        /// Integration test to verify the application structure
        /// Note: This test verifies compilation and basic instantiation
        /// Full GUI testing requires additional infrastructure
        #[test]
        fn test_application_structure() {
            // Verify the application can be built
            // This is primarily a compilation test
            
            // Test that main dependencies are available
            assert!(cfg!(feature = "iced"), "iced feature should be available");
        }
        
        #[test]
        fn test_required_dependencies() {
            // Verify critical dependencies are accessible
            let _ = std::any::type_name::<iced::Application>();
            let _ = std::any::type_name::<serde::Serialize>();
            let _ = std::any::type_name::<chrono::DateTime<chrono::Utc>>();
        }
        
        /// Verify Cargo.toml includes required dependencies
        /// This is validated at compile time - if deps are missing, build fails
        #[test]
        fn test_cargo_dependencies_present() {
            // iced with required features
            let _iced = std::any::type_name::<iced::Application>();
            
            // serde for serialization
            let _serde = std::any::type_name::<serde::Serialize>();
            
            // chrono for date/time
            let _chrono = std::any::type_name::<chrono::DateTime<chrono::Utc>>();
            
            // directories for cross-platform paths
            let _dirs = std::any::type_name::<directories::ProjectDirs>();
            
            // Test passes if all imports compile
        }
        
        #[test]
        fn test_module_structure_complete() {
            // Verify all expected modules exist and are accessible
            // Compilation failure indicates missing module files
            
            // Core modules
            let _ = std::any::TypeId::of::<crate::state::State>();
            let _ = std::any::TypeId::of::<crate::models::Character>();
            let _ = std::any::TypeId::of::<crate::ui::Message>();
            let _ = std::any::TypeId::of::<crate::persistence::StorageManager>();
            let _ = std::any::TypeId::of::<crate::scheduler::Scheduler>();
            let _ = std::any::TypeId::of::<crate::data::SampleData>();
        }

    - file: "src/state/mod.rs"
      location: "in existing test module"
      code: |
        #[cfg(test)]
        mod tests {
            use super::*;

            #[test]
            fn test_state_default_initialization() {
                let state = State::default();
                assert!(state.characters.is_empty());
                assert!(state.groups.is_empty());
                assert_eq!(state.selected_character, None);
            }

            #[test]
            fn test_state_is_clonable() {
                let state = State::default();
                let cloned = state.clone();
                assert_eq!(state.characters.len(), cloned.characters.len());
            }

            #[test]
            fn test_state_serialization() {
                // Verify state can be serialized (needed for persistence)
                let state = State::default();
                let serialized = serde_json::to_string(&state);
                assert!(serialized.is_ok(), "State should be serializable");
            }
        }

    - file: "src/ui/mod.rs"
      location: "in existing test module"
      code: |
        #[cfg(test)]
        mod tests {
            use super::*;

            #[test]
            fn test_message_clone() {
                let msg = Message::None;
                let cloned = msg.clone();
                // Verify Message is Clone
                drop(msg);
                drop(cloned);
            }

            #[test]
            fn test_message_debug() {
                let msg = Message::AddCharacter;
                let debug_str = format!("{:?}", msg);
                assert!(!debug_str.is_empty(), "Message should have Debug implementation");
            }
        }

    - file: "src/models/mod.rs"
      location: "in existing test module"
      code: |
        #[cfg(test)]
        mod tests {
            use super::*;

            #[test]
            fn test_character_creation() {
                let character = Character::default();
                assert!(!character.id.is_empty(), "Character should have an ID");
                assert!(!character.name.is_empty(), "Character should have a default name");
            }

            #[test]
            fn test_character_serialization() {
                let character = Character::default();
                let serialized = serde_json::to_string(&character);
                assert!(serialized.is_ok(), "Character should be serializable");
                
                let json = serialized.unwrap();
                let deserialized: Result<Character, _> = serde_json::from_str(&json);
                assert!(deserialized.is_ok(), "Character should be deserializable");
            }

            #[test]
            fn test_group_creation() {
                let group = Group::default();
                assert!(!group.id.is_empty(), "Group should have an ID");
                assert!(group.members.is_empty(), "New group should have no members");
            }
        }

  coverage:
    - "Application struct compiles successfully"
    - "App implements iced::Application trait"
    - "All module directories are accessible and compile"
    - "State struct can be instantiated with default values"
    - "Message enum variants are properly defined"
    - "Required dependencies (iced, serde, chrono, directories) are available"
    - "Module structure is complete (state, ui, models, persistence, scheduler, data)"
    - "State implements Clone and Default traits"
    - "State is serializable with serde"
    - "Character model can be created and serialized"
    - "Group model can be created with default values"
    - "Message type implementsClone and Debug"
    - "Cross-module imports work correctly"
    - "Cargo.toml dependencies are properly configured"
    - "Basic data structures have required trait implementations"

dependencies:
  depends_on: []

  depended_upon_by:
    - task_id: 2
      reason: "Character data structures need module structure to exist"
    - task_id: 3
      reason: "Font loading requires application foundation"
    - task_id: 6
      reason: "State management builds on application structure"

  external:
    - name: "iced"
      type: "crate"
      status: "to be imported"
    - name: "serde"
      type: "crate"
      status: "to be imported"
    - name: "serde_json"
      type: "crate"
      status: "to be imported"
    - name: "chrono"
      type: "crate"
      status: "to be imported"
    - name: "directories"
      type: "crate"
      status: "to be imported"
    - name: "iced::Application"
      type: "trait"
      status: "to be imported"
---
task:
  id: 2
  name: "Character Data Structures and Loading System"

context:
  description: |
    This task establishes the foundational data layer for the hiragana and katakana learning
    application. It defines core data structures to represent all 92 kana characters (46 hiragana
    + 46 katakana) with complete metadata including Unicode values, romanization mappings, stroke
    order information, and frequency rankings. The implementation uses compile-time perfect hash
    maps (phf) for zero-cost O(1) character lookups, with data serialized in RON format for human
    readability and maintainability.
    
    The character database serves as the single source of truth for all kana information throughout
    the application. Stroke path data stored as SVG strings enables the animation system to render
    proper stroke order. Frequency rankings allow the flashcard system to present common characters
    first. Unicode values support text rendering and input recognition. The choice of compile-time
    embedding trades slightly larger binary size for eliminated runtime loading overhead and
    guaranteed data availability.
    
    Data will be sourced from established repositories like kana-svg-data or animCJK, then
    transformed into RON format for embedding. The loading system supports both compile-time
    (phf::Map) and runtime (lazy_static HashMap) approaches, with compile-time chosen for the
    MVP to maximize performance and simplify deployment.

  key_points:
    - "CharData struct is the canonical representation of kana characters, serializable via serde"
    - "Compile-time phf::Map provides O(1) lookups with zero runtime initialization cost"
    - "RON format balances human readability for maintenance with efficient deserialization"
    - "SVG path strings stored directly, parsed on-demand to avoid upfront processing overhead"
    - "Frequency rankings enable ordered presentation in learning modes (most common first)"
    - "Stroke count and path data are critical for animation and handwriting practice features"
    - "Unicode values bridge between character rendering, input recognition, and data lookup"
    - "Data integrity validated through comprehensive unit tests covering all 92 characters"

files:
  - path: "src/models/character.rs"
    description: "Defines CharData struct and related types for representing kana characters with stroke data and metadata"
  
  - path: "src/models/mod.rs"
    description: "Module declaration exposing character data structures"
  
  - path: "src/data/mod.rs"
    description: "Data module exposing character database and lookup functions"
  
  - path: "src/data/loader.rs"
    description: "Implements character data loading and deserialization from embedded RON files"
  
  - path: "src/data/lookup.rs"
    description: "Implements character lookup system using phf::Map for O(1) access"
  
  - path: "src/data/svg_parser.rs"
    description: "Parser utilities for SVG path strings and median point extraction"
  
  - path: "data/hiragana.ron"
    description: "RON-formatted data file containing all 46 hiragana characters with stroke paths and metadata"
  
  - path: "data/katakana.ron"
    description: "RON-formatted data file containing all 46 katakana characters with stroke paths and metadata"
  
  - path: "tests/character_data_tests.rs"
    description: "Comprehensive test suite for character data integrity and lookup functionality"

functions:
  - file: "src/models/character.rs"
    items:
      - type: "struct"
        name: "CharData"
        description: "Core data structure representing a single kana character with Unicode value, romanization, stroke information, and metadata"
        invariants: "Unicode value must be valid kana character; stroke_count must match length of stroke_paths; frequency_rank must be 1-46"
      
      - type: "struct"
        name: "StrokePath"
        description: "Represents a single stroke as an SVG path string with directional metadata"
        invariants: "SVG path string must be valid; start and end points must exist"
      
      - type: "function"
        name: "CharData::new"
        description: "Constructor for CharData with validation"
        preconditions: "All required fields provided; unicode is valid kana"
        postconditions: "Returns valid CharData instance"
      
      - type: "method"
        name: "CharData::stroke_count"
        description: "Returns the number of strokes for this character"
        postconditions: "Returns non-zero positive integer"
      
      - type: "method"
        name: "CharData::get_stroke"
        description: "Returns reference to stroke path at given index"
        preconditions: "Index must be less than stroke_count"
        postconditions: "Returns Some(StrokePath) if valid index, None otherwise"

  - file: "src/models/mod.rs"
    items:
      - type: "module_declaration"
        name: "pub mod character"
        description: "Declares the character module containing character data structures"

  - file: "src/data/loader.rs"
    items:
      - type: "constant"
        name: "HIRAGANA_DATA_STR"
        description: "Compile-time embedded hiragana.ron file contents"
        invariants: "Contains valid RON-formatted string embedded at compile time"
      
      - type: "constant"
        name: "KATAKANA_DATA_STR"
        description: "Compile-time embedded katakana.ron file contents"
        invariants: "Contains valid RON-formatted string embedded at compile time"
      
      - type: "function"
        name: "load_hiragana_data"
        description: "Parses and deserializes hiragana character data from embedded RON string"
        postconditions: "Returns HashMap<char, CharData> with 46 hiragana entries or error"
      
      - type: "function"
        name: "load_katakana_data"
        description: "Parses and deserializes katakana character data from embedded RON string"
        postconditions: "Returns HashMap<char, CharData> with 46 katakana entries or error"
      
      - type: "function"
        name: "load_all_kana_data"
        description: "Loads both hiragana and katakana data into a single combined map"
        postconditions: "Returns HashMap<char, CharData> with 92 total entries or error"

  - file: "src/data/lookup.rs"
    items:
      - type: "struct"
        name: "KanaDatabase"
        description: "Central database for O(1) character lookups using phf::Map or lazy_static HashMap"
        invariants: "Contains exactly 92 entries (46 hiragana + 46 katakana)"
      
      - type: "constant"
        name: "KANA_MAP"
        description: "Static compile-time perfect hash map for character lookups (phf::Map)"
        invariants: "Immutable; contains all 92 kana characters; initialized at compile time"
      
      - type: "function"
        name: "get_char_data"
        description: "Retrieves CharData for a given kana character"
        preconditions: "Input character is valid Unicode"
        postconditions: "Returns Some(CharData) for valid kana, None otherwise"
      
      - type: "function"
        name: "is_hiragana"
        description: "Checks if character is hiragana"
        postconditions: "Returns true if character in hiragana Unicode range (U+3040-U+309F)"
      
      - type: "function"
        name: "is_katakana"
        description: "Checks if character is katakana"
        postconditions: "Returns true if character in katakana Unicode range (U+30A0-U+30FF)"
      
      - type: "function"
        name: "get_all_hiragana"
        description: "Returns iterator over all hiragana characters in frequency order"
        postconditions: "Returns 46 hiragana CharData references sorted by frequency_rank"
      
      - type: "function"
        name: "get_all_katakana"
        description: "Returns iterator over all katakana characters in frequency order"
        postconditions: "Returns 46 katakana CharData references sorted by frequency_rank"

  - file: "src/data/mod.rs"
    items:
      - type: "module_declaration"
        name: "pub mod loader"
        description: "Declares the loader module for data deserialization"
      
      - type: "module_declaration"
        name: "pub mod lookup"
        description: "Declares the lookup module for character database access"
      
      - type: "module_declaration"
        name: "pub mod svg_parser"
        description: "Declares the svg_parser module for path processing utilities"

  - file: "src/data/svg_parser.rs"
    items:
      - type: "struct"
        name: "SvgPathParser"
        description: "Parser for converting SVG path strings to internal stroke representation"
      
      - type: "function"
        name: "parse_svg_path"
        description: "Parses SVG path string and extracts coordinate data"
        preconditions: "Input is valid SVG path syntax"
        postconditions: "Returns parsed stroke data or error"
      
      - type: "function"
        name: "extract_median_point"
        description: "Calculates the median point along a stroke path for direction visualization"
        preconditions: "Stroke path has at least 2 points"
        postconditions: "Returns (x, y) coordinate at approximate midpoint of stroke"

  - file: "tests/character_data_tests.rs"
    items:
      - type: "function"
        name: "test_all_hiragana_present"
        description: "Verifies all 46 hiragana characters exist in database"
        postconditions: "Asserts 46 hiragana entries found"
      
      - type: "function"
        name: "test_all_katakana_present"
        description: "Verifies all 46 katakana characters exist in database"
        postconditions: "Asserts 46 katakana entries found"
      
      - type: "function"
        name: "test_unicode_validity"
        description: "Checks all characters have valid Unicode code points"
        postconditions: "Asserts all unicode values are valid kana"
      
      - type: "function"
        name: "test_stroke_count_consistency"
        description: "Verifies stroke_count matches actual number of stroke paths"
        postconditions: "Asserts stroke_count equals stroke_paths.len() for all characters"
      
      - type: "function"
        name: "test_frequency_rank_range"
        description: "Checks frequency ranks are within valid range 1-46"
        postconditions: "Asserts all frequency_rank values are between 1 and 46 inclusive"
      
      - type: "function"
        name: "test_lookup_performance"
        description: "Benchmarks lookup performance to verify O(1) access"
        postconditions: "Asserts lookup completes in constant time"
      
      - type: "function"
        name: "test_svg_path_parsing"
        description: "Tests SVG path parser with valid and invalid inputs"
        postconditions: "Asserts valid paths parse successfully, invalid paths return errors"
      
      - type: "function"
        name: "test_character_uniqueness"
        description: "Ensures no duplicate characters in database"
        postconditions: "Asserts all 92 characters are unique"
      
      - type: "function"
        name: "test_romanization_present"
        description: "Verifies every character has non-empty romanization"
        postconditions: "Asserts all romanization fields are non-empty strings"
      
      - type: "function"
        name: "test_median_point_calculation"
        description: "Tests median point extraction for stroke direction"
        postconditions: "Asserts median points exist and are within stroke bounds"
      
      - type: "function"
        name: "prop_test_char_data_roundtrip"
        description: "Property test: CharData serialization/deserialization roundtrip"
        postconditions: "Asserts serialize then deserialize produces identical CharData"
      
      - type: "function"
        name: "prop_test_stroke_count_positive"
        description: "Property test: stroke_count is always positive"
        postconditions: "Asserts stroke_count > 0 for all randomly generated CharData"

formal_verification:
  needed: false
  level: "None"
  explanation: |
    Formal verification is not needed for this task because:
    
    1. Static Data Nature: The character data structures and loading system deal
       with static, well-defined data (hiragana and katakana characters). The data
       itself is fixed and deterministic - there are exactly 46 hiragana and 46
       katakana characters with known Unicode points and stroke information.
    
    2. Simple Operations: The core operations are straightforward:
       - Struct definitions with serialization/deserialization
       - HashMap or phf::Map lookups (O(1) operations with well-understood semantics)
       - Data file loading and parsing via RON/serde (established libraries)
       - Basic SVG path string storage and retrieval
    
    3. No Complex Invariants: Unlike concurrent systems, security-critical code,
       or complex state machines, this task has no intricate invariants to maintain.
       The primary properties (all characters present, valid Unicode, correct stroke
       counts) are easily verified through unit tests and property-based testing.
    
    4. Adequate Testing Coverage: The combination of unit tests (verifying all
       92 characters are present with correct data) and property-based tests (checking
       data integrity properties) provides sufficient confidence. The test count (12)
       covers critical properties listed in the task overview.
    
    5. Low Risk Profile: The risk assessment identifies this as low complexity,
       low integration risk, and low testing risk. The main concern is data extraction
       from external sources, which is a data quality issue rather than a correctness
       issue requiring formal methods.
    
    6. Established Libraries: Using serde for serialization, RON for data format,
       and phf for compile-time maps means relying on well-tested, production-grade
       libraries that don't require additional formal verification at the application
       level.
    
    Property-based testing is explicitly mentioned as needed and is sufficient for
    verifying data integrity properties without the overhead of formal verification
    tooling.

tests:
  strategy:
    approach: "mixed (unit tests + property-based tests)"
    rationale:
      - "Unit tests verify data integrity and completeness of the 92 static character entries"
      - "Property-based tests ensure lookup functions are deterministic and always return valid data"
      - "Unit tests validate SVG path parsing and stroke structure correctness"
      - "Character data is deterministic and static, making it ideal for comprehensive unit testing"
      - "Property tests catch edge cases in romanization mappings and Unicode handling"
      - "No concurrency or integration testing needed as data is read-only and self-contained"

  implementation:
    file: "tests/character_data_tests.rs"
    location: "create new"
    code: |
      use kana_app::data::{load_hiragana, load_katakana, lookup_character};
      use kana_app::models::character::CharData;
      
      #[cfg(test)]
      mod tests {
          use super::*;
          
          #[test]
          fn test_hiragana_count() {
              // Verify all 46 hiragana characters are present
              let hiragana = load_hiragana();
              assert_eq!(hiragana.len(), 46, "Expected 46 hiragana characters");
          }
          
          #[test]
          fn test_katakana_count() {
              // Verify all 46 katakana characters are present
              let katakana = load_katakana();
              assert_eq!(katakana.len(), 46, "Expected 46 katakana characters");
          }
          
          #[test]
          fn test_hiragana_unicode_validity() {
              // Verify all hiragana have valid Unicode code points in correct range
              let hiragana = load_hiragana();
              for (key, char_data) in hiragana.iter() {
                  assert!(char_data.unicode >= 0x3040 && char_data.unicode <= 0x309F,
                      "Hiragana '{}' has invalid Unicode: U+{:04X}", key, char_data.unicode);
              }
          }
          
          #[test]
          fn test_katakana_unicode_validity() {
              // Verify all katakana have valid Unicode code points in correct range
              let katakana = load_katakana();
              for (key, char_data) in katakana.iter() {
                  assert!(char_data.unicode >= 0x30A0 && char_data.unicode <= 0x30FF,
                      "Katakana '{}' has invalid Unicode: U+{:04X}", key, char_data.unicode);
              }
          }
          
          #[test]
          fn test_stroke_count_validity() {
              // Verify stroke counts are positive and reasonable (1-5 for kana)
              let hiragana = load_hiragana();
              let katakana = load_katakana();
              
              for (key, char_data) in hiragana.iter().chain(katakana.iter()) {
                  assert!(char_data.stroke_count > 0 && char_data.stroke_count <= 5,
                      "Character '{}' has invalid stroke count: {}", key, char_data.stroke_count);
                  assert_eq!(char_data.strokes.len(), char_data.stroke_count as usize,
                      "Character '{}' stroke count mismatch: declared {} but has {} paths",
                      key, char_data.stroke_count, char_data.strokes.len());
              }
          }
          
          #[test]
          fn test_romanization_not_empty() {
              // Verify all characters have non-empty romanization
              let hiragana = load_hiragana();
              let katakana = load_katakana();
              
              for (key, char_data) in hiragana.iter().chain(katakana.iter()) {
                  assert!(!char_data.romanization.is_empty(),
                      "Character '{}' has empty romanization", key);
                  assert!(char_data.romanization.chars().all(|c| c.is_ascii_lowercase()),
                      "Character '{}' romanization '{}' contains non-lowercase ASCII",
                      key, char_data.romanization);
              }
          }
          
          #[test]
          fn test_lookup_basic_hiragana() {
              // Test lookup of common hiragana characters
              assert!(lookup_character("あ").is_some(), "Failed to lookup 'あ'");
              assert!(lookup_character("か").is_some(), "Failed to lookup 'か'");
              assert!(lookup_character("さ").is_some(), "Failed to lookup 'さ'");
              assert!(lookup_character("た").is_some(), "Failed to lookup 'た'");
              assert!(lookup_character("な").is_some(), "Failed to lookup 'な'");
          }
          
          #[test]
          fn test_lookup_basic_katakana() {
              // Test lookup of common katakana characters
              assert!(lookup_character("ア").is_some(), "Failed to lookup 'ア'");
              assert!(lookup_character("カ").is_some(), "Failed to lookup 'カ'");
              assert!(lookup_character("サ").is_some(), "Failed to lookup 'サ'");
              assert!(lookup_character("タ").is_some(), "Failed to lookup 'タ'");
              assert!(lookup_character("ナ").is_some(), "Failed to lookup 'ナ'");
          }
          
          #[test]
          fn test_lookup_invalid_character() {
              // Test lookup returns None for invalid characters
              assert!(lookup_character("x").is_none(), "Invalid character should return None");
              assert!(lookup_character("漢").is_none(), "Kanji character should return None");
              assert!(lookup_character("").is_none(), "Empty string should return None");
              assert!(lookup_character("abc").is_none(), "Multi-char string should return None");
          }
          
          #[test]
          fn test_svg_path_format() {
              // Verify SVG paths are valid and non-empty
              let hiragana = load_hiragana();
              let katakana = load_katakana();
              
              for (key, char_data) in hiragana.iter().chain(katakana.iter()) {
                  for (idx, stroke) in char_data.strokes.iter().enumerate() {
                      assert!(!stroke.is_empty(),
                          "Character '{}' stroke {} has empty path", key, idx);
                      // SVG paths should start with M (moveto) command
                      assert!(stroke.trim().starts_with('M') || stroke.trim().starts_with('m'),
                          "Character '{}' stroke {} doesn't start with M command: '{}'",
                          key, idx, stroke);
                  }
              }
          }
          
          #[test]
          fn test_frequency_rank_uniqueness() {
              // Verify frequency ranks are unique within each character set
              let hiragana = load_hiragana();
              let katakana = load_katakana();
              
              let mut hiragana_ranks: Vec<u8> = hiragana.values()
                  .map(|cd| cd.frequency_rank)
                  .collect();
              hiragana_ranks.sort();
              let hiragana_unique = hiragana_ranks.len();
              hiragana_ranks.dedup();
              assert_eq!(hiragana_unique, hiragana_ranks.len(),
                  "Hiragana frequency ranks are not unique");
              
              let mut katakana_ranks: Vec<u8> = katakana.values()
                  .map(|cd| cd.frequency_rank)
                  .collect();
              katakana_ranks.sort();
              let katakana_unique = katakana_ranks.len();
              katakana_ranks.dedup();
              assert_eq!(katakana_unique, katakana_ranks.len(),
                  "Katakana frequency ranks are not unique");
          }
          
          #[test]
          fn test_character_roundtrip() {
              // Test that unicode value can be converted to char and looked up
              let hiragana = load_hiragana();
              
              for (key, char_data) in hiragana.iter() {
                  let unicode_char = char::from_u32(char_data.unicode)
                      .expect(&format!("Invalid unicode value for '{}'", key));
                  let looked_up = lookup_character(&unicode_char.to_string());
                  assert!(looked_up.is_some(),
                      "Failed to lookup character from its unicode value: '{}'", key);
                  assert_eq!(looked_up.unwrap().unicode, char_data.unicode,
                      "Unicode mismatch in roundtrip for '{}'", key);
              }
          }
      }
      
      #[cfg(test)]
      mod property_tests {
          use super::*;
          use proptest::prelude::*;
          
          proptest! {
              #[test]
              fn prop_lookup_deterministic(s in "[\u{3040}-\u{309F}\u{30A0}-\u{30FF}]") {
                  // Property: lookup should be deterministic (same input = same output)
                  let result1 = lookup_character(&s);
                  let result2 = lookup_character(&s);
                  assert_eq!(result1.is_some(), result2.is_some(),
                      "Lookup determinism violated for '{}'", s);
                  if let (Some(c1), Some(c2)) = (result1, result2) {
                      assert_eq!(c1.unicode, c2.unicode, "Unicode mismatch in repeated lookup");
                      assert_eq!(c1.romanization, c2.romanization, "Romanization mismatch");
                  }
              }
              
              #[test]
              fn prop_romanization_format(s in "[\u{3040}-\u{309F}\u{30A0}-\u{30FF}]") {
                  // Property: romanization should be lowercase ASCII, 1-3 chars
                  if let Some(char_data) = lookup_character(&s) {
                      let rom = &char_data.romanization;
                      prop_assert!(!rom.is_empty() && rom.len() <= 3,
                          "Romanization length out of range: '{}'", rom);
                      prop_assert!(rom.chars().all(|c| c.is_ascii_lowercase()),
                          "Romanization contains non-lowercase ASCII: '{}'", rom);
                  }
              }
              
              #[test]
              fn prop_stroke_count_matches_array(s in "[\u{3040}-\u{309F}\u{30A0}-\u{30FF}]") {
                  // Property: stroke_count field must equal length of strokes array
                  if let Some(char_data) = lookup_character(&s) {
                      prop_assert_eq!(char_data.stroke_count as usize, char_data.strokes.len(),
                          "Stroke count mismatch for character");
                  }
              }
              
              #[test]
              fn prop_invalid_input_returns_none(s in "[^\u{3040}-\u{309F}\u{30A0}-\u{30FF}]+") {
                  // Property: non-kana input should always return None
                  prop_assert!(lookup_character(&s).is_none(),
                      "Non-kana input '{}' should return None", s);
              }
          }
      }

  coverage:
    - "All 46 hiragana characters are present in database"
    - "All 46 katakana characters are present in database"
    - "Hiragana Unicode values are within valid range (U+3040-U+309F)"
    - "Katakana Unicode values are within valid range (U+30A0-U+30FF)"
    - "Stroke counts are positive and reasonable (1-5 for kana)"
    - "Stroke count field matches actual number of stroke paths"
    - "Romanization fields are non-empty and lowercase ASCII only"
    - "Lookup succeeds for common hiragana characters"
    - "Lookup succeeds for common katakana characters"
    - "Lookup returns None for invalid/non-kana characters"
    - "SVG paths are non-empty and start with valid moveto command"
    - "Frequency ranks are unique within each character set"
    - "Character unicode values can roundtrip through lookup"
    - "Property: Lookup is deterministic (same input produces same output)"
    - "Property: Romanization format is consistent (lowercase, 1-3 chars)"
    - "Property: Stroke count invariant (field equals array length)"
    - "Property: Invalid input always returns None"

dependencies:
  depends_on:
    - task_id: 1
      reason: "Requires models/ module structure to exist before defining CharData struct"

  depended_upon_by:
    - task_id: 3
      reason: "Font rendering needs character data to display kana characters"
    - task_id: 4
      reason: "Stroke animation requires stroke path data from CharData"
    - task_id: 7
      reason: "Flashcard system needs character database for selecting and presenting cards"

  external:
    - name: "serde"
      type: "crate"
      status: "to be imported"
    - name: "ron"
      type: "crate"
      status: "to be imported"
    - name: "phf"
      type: "crate"
      status: "to be imported"
    - name: "lazy_static"
      type: "crate"
      status: "to be imported"
    - name: "proptest"
      type: "crate"
      status: "to be imported"
    - name: "HashMap"
      type: "struct"
      status: "already exists"
---
task:
  id: 3
  name: "Japanese Font Integration and Text Rendering"

context:
  description: |
    Integrate a Japanese font (Noto Sans JP) into the iced application and configure
    cosmic-text for proper Unicode rendering of hiragana and katakana characters.
    Create a custom CharacterCard widget for flashcard-style character display with
    configurable sizing and styling.
    
    Proper Japanese text rendering is non-negotiable for a kana learning application.
    Iced's cosmic-text backend supports full Unicode, but requires explicit font loading
    and shaping configuration. A custom widget abstracts rendering complexity and provides
    consistent character presentation across the application.
    
    The CharacterCard widget serves as a fundamental building block for the flashcard
    system and practice modes. By embedding the font at compile time using include_bytes!(),
    we ensure portability across platforms without requiring users to install Japanese
    fonts separately.
    
    This task establishes the visual foundation for all character display throughout
    the application. The widget architecture allows for future enhancements like stroke
    order overlays, animation, and interactive touch/click handling without requiring
    changes to consumer code.

  key_points:
    - "Must use Shaping::Advanced in cosmic-text for proper Japanese character rendering"
    - "Font::with_name() reference must match exact font family name in embedded font metadata"
    - "Noto Sans JP Regular (400 weight) provides excellent readability for educational content"
    - "CharacterCard widget should center characters both horizontally and vertically"
    - "Embedded font approach trades ~900KB binary size for guaranteed cross-platform compatibility"
    - "Font subsetting could reduce size to ~100KB if binary size becomes a concern"
    - "Widget design supports future extensions for stroke order guides as overlay layer"

files:
  - path: "assets/fonts/NotoSansJP-Regular.otf"
    description: "Embedded Noto Sans JP Regular font file for Japanese kana rendering"
  - path: "src/main.rs"
    description: "Application entry point - modified to load and register Japanese font at startup"
  - path: "src/ui/widgets/character_card.rs"
    description: "Custom iced widget implementing flashcard-style character display with configurable sizing"
  - path: "src/ui/widgets/mod.rs"
    description: "Widget module declaration file - modified to expose character_card module"

functions:
  - file: "src/main.rs"
    items:
      - type: "function"
        name: "load_japanese_font"
        description: "Loads the embedded Noto Sans JP font using include_bytes! macro and registers it with iced's font system"
        preconditions: "Called during Application initialization before any rendering occurs"
        postconditions: "Japanese font is available for text rendering throughout the application"
        invariants: "Font data remains valid for the lifetime of the application"

  - file: "src/assets/fonts.rs"
    items:
      - type: "module_declaration"
        name: "fonts"
        description: "Module containing embedded font assets and font-related constants"
      
      - type: "constant"
        name: "NOTO_SANS_JP"
        description: "Embedded Noto Sans JP font data as static byte array using include_bytes! macro"
        invariants: "Font data is immutable and available at compile time"
      
      - type: "constant"
        name: "NOTO_SANS_JP_FAMILY"
        description: "Font family name string constant ('Noto Sans JP') for font references"
        invariants: "Must match exact family name in font file metadata"

  - file: "src/ui/widgets/character_card.rs"
    items:
      - type: "struct"
        name: "CharacterCard"
        description: "Custom iced widget for flashcard-style display of Japanese kana characters with configurable size and styling"
        invariants: "Character must be valid Unicode; size must be positive"
      
      - type: "struct"
        name: "CharacterCardStyle"
        description: "Styling configuration for CharacterCard including font size, colors, padding, and border properties"
        invariants: "Font size must be positive; colors must be valid RGBA values"
      
      - type: "method"
        name: "CharacterCard::new"
        description: "Creates a new CharacterCard widget with specified character and default styling"
        preconditions: "Character string must be valid UTF-8"
        postconditions: "Returns initialized CharacterCard with default style"
      
      - type: "method"
        name: "CharacterCard::with_size"
        description: "Builder method to set custom font size for the character"
        preconditions: "Size must be positive value"
        postconditions: "Returns self with updated font size"
      
      - type: "method"
        name: "CharacterCard::with_style"
        description: "Builder method to apply custom CharacterCardStyle"
        postconditions: "Returns self with custom styling applied"
      
      - type: "trait_impl"
        name: "Widget<Message> for CharacterCard"
        description: "Implements iced::Widget trait for CharacterCard to integrate with iced rendering system"
        invariants: "Must implement all required Widget trait methods"
      
      - type: "method"
        name: "CharacterCard::width"
        description: "Returns the width requirement for the widget layout"
        postconditions: "Returns Length value for width constraint"
      
      - type: "method"
        name: "CharacterCard::height"
        description: "Returns the height requirement for the widget layout"
        postconditions: "Returns Length value for height constraint"
      
      - type: "method"
        name: "CharacterCard::layout"
        description: "Calculates widget layout dimensions based on limits and renderer"
        preconditions: "Renderer must have Japanese font loaded"
        postconditions: "Returns Node with calculated layout bounds"
      
      - type: "method"
        name: "CharacterCard::draw"
        description: "Renders the character using cosmic-text with advanced shaping for proper Japanese glyph rendering"
        preconditions: "Font must be loaded; layout must be calculated"
        postconditions: "Character is drawn centered within bounds using advanced text shaping"
        invariants: "Uses Shaping::Advanced for proper Japanese character rendering"

  - file: "src/ui/widgets/mod.rs"
    items:
      - type: "module_declaration"
        name: "character_card"
        description: "Module declaration for character_card widget"
      
      - type: "function"
        name: "pub use character_card::{CharacterCard, CharacterCardStyle}"
        description: "Re-exports CharacterCard and CharacterCardStyle for public API"

  - file: "tests/japanese_font_integration_test.rs"
    items:
      - type: "function"
        name: "test_font_constant_defined"
        description: "Integration test verifying embedded font data is accessible and has valid format"
        postconditions: "Font data exists with valid OTF/TTF magic number and reasonable size"
      
      - type: "function"
        name: "test_all_hiragana_characters_defined"
        description: "Integration test verifying all 46 basic hiragana characters are in valid Unicode range"
        postconditions: "All hiragana characters validated in U+3040-U+309F range"
      
      - type: "function"
        name: "test_all_katakana_characters_defined"
        description: "Integration test verifying all 46 basic katakana characters are in valid Unicode range"
        postconditions: "All katakana characters validated in U+30A0-U+30FF range"
      
      - type: "function"
        name: "test_character_card_instantiation"
        description: "Integration test verifying CharacterCard can be instantiated at all required sizes without panicking"
        preconditions: "CharacterCard widget available"
        postconditions: "Cards created successfully at 48px, 64px, and 72px sizes"
      
      - type: "function"
        name: "test_character_card_builder_configurations"
        description: "Unit test verifying CharacterCard builder pattern and state storage"
        postconditions: "Character and size properties stored correctly"
      
      - type: "function"
        name: "test_character_card_with_stroke_order"
        description: "Unit test verifying optional stroke order overlay configuration"
        postconditions: "Stroke order flag can be enabled and queried"
      
      - type: "function"
        name: "test_character_card_centering"
        description: "Unit test verifying horizontal and vertical centering configuration"
        postconditions: "Centering flags can be set and queried"
      
      - type: "function"
        name: "test_character_card_required_sizes"
        description: "Unit test verifying all acceptance criteria sizes (48, 64, 72px)"
        postconditions: "Size parameter correctly stored for all required values"
      
      - type: "function"
        name: "test_font_loading_smoke_test"
        description: "Smoke test verifying font loading code path executes without panic"
        postconditions: "Font data accessible and non-empty"
      
      - type: "function"
        name: "test_comprehensive_kana_string_handling"
        description: "Integration test verifying comprehensive kana coverage including dakuten and handakuten"
        postconditions: "All kana strings validated as proper UTF-8 in correct Unicode ranges"

formal_verification:
  needed: false
  level: "None"
  explanation: |
    Formal verification is not needed for this task for several reasons:
    
    1. This task primarily involves integration with external libraries (iced, cosmic-text)
       rather than critical algorithmic logic. The correctness depends on proper API usage
       rather than complex invariants.
    
    2. Font loading and rendering are deterministic operations with well-defined behavior
       provided by the underlying libraries. The main risks are configuration errors
       (wrong font paths, incorrect shaping settings) rather than logical correctness issues.
    
    3. The CharacterCard widget is a presentation component with no complex state management
       or critical business logic. It's a thin wrapper around iced's rendering primitives.
    
    4. Failures in this component (missing glyphs, incorrect rendering) are immediately
       visible during manual testing and do not pose safety or correctness risks to the
       application's core functionality. They manifest as UI issues rather than silent
       data corruption or undefined behavior.
    
    5. Integration testing combined with visual verification provides adequate confidence
       for this type of UI rendering task. The test strategy already includes checking
       that all hiragana and katakana characters render without missing glyphs, which
       covers the critical correctness requirements.
    
    6. The embedded font data is static binary content loaded via include_bytes!(), with
       no runtime computation or transformation that could introduce correctness issues
       requiring formal proof.
    
    Standard integration tests verifying that characters render correctly at various sizes
    without missing glyphs are sufficient for this task's quality requirements.

tests:
  strategy:
    approach: "integration"
    rationale:
      - "Font loading and text rendering cannot be unit tested in isolation - requires full iced runtime and graphics backend"
      - "Japanese text rendering quality depends on cosmic-text integration, font metrics, and shaper configuration"
      - "Visual properties like centering and glyph presence require actual rendering pipeline execution"
      - "Focus on functional correctness (no panics, expected behavior) rather than visual regression for MVP"
      - "Test both programmatic assertions and manual verification points for rendering quality"

  implementation:
    file: "tests/japanese_font_integration_test.rs"
    location: "create new"
    code: |
      //! Integration tests for Japanese font loading and character rendering
      //! 
      //! These tests verify that:
      //! 1. The embedded Noto Sans JP font loads without errors
      //! 2. The CharacterCard widget can be instantiated and rendered
      //! 3. All kana characters can be processed without panics
      //! 4. Text rendering configuration is correct for Japanese
      
      #[cfg(test)]
      mod japanese_font_tests {
          use kana_master::ui::widgets::CharacterCard;
          use iced::{Font, Element, Sandbox, Settings};
          use iced::widget::Text;
          
          /// Test that the embedded Noto Sans JP font can be referenced
          #[test]
          fn test_font_constant_defined() {
              // Verify the font bytes are embedded and accessible
              const NOTO_SANS_JP_BYTES: &[u8] = include_bytes!("../assets/fonts/NotoSansJP-Regular.otf");
              assert!(NOTO_SANS_JP_BYTES.len() > 100_000, "Font file should be at least 100KB");
              assert!(NOTO_SANS_JP_BYTES.len() < 2_000_000, "Font file should be under 2MB");
              
              // Check OTF magic number (0x4F54544F = "OTTO" for OpenType with CFF)
              // or TTF magic number (0x00010000)
              let magic = u32::from_be_bytes([
                  NOTO_SANS_JP_BYTES[0],
                  NOTO_SANS_JP_BYTES[1],
                  NOTO_SANS_JP_BYTES[2],
                  NOTO_SANS_JP_BYTES[3],
              ]);
              assert!(
                  magic == 0x4F54544F || magic == 0x00010000 || magic == 0x74727565,
                  "Font file should have valid OTF/TTF magic number"
              );
          }
          
          /// Test all hiragana characters for glyph presence
          #[test]
          fn test_all_hiragana_characters_defined() {
              // All 46 basic hiragana characters (including を and ん)
              let hiragana_chars = vec![
                  'あ', 'い', 'う', 'え', 'お',
                  'か', 'き', 'く', 'け', 'こ',
                  'さ', 'し', 'す', 'せ', 'そ',
                  'た', 'ち', 'つ', 'て', 'と',
                  'な', 'に', 'ぬ', 'ね', 'の',
                  'は', 'ひ', 'ふ', 'へ', 'ほ',
                  'ま', 'み', 'む', 'め', 'も',
                  'や', 'ゆ', 'よ',
                  'ら', 'り', 'る', 'れ', 'ろ',
                  'わ', 'を', 'ん',
              ];
              
              // Verify all characters are in valid Unicode range
              for ch in hiragana_chars.iter() {
                  let unicode = *ch as u32;
                  assert!(
                      unicode >= 0x3040 && unicode <= 0x309F,
                      "Character {} should be in hiragana Unicode block (U+3040-U+309F)",
                      ch
                  );
              }
              
              assert_eq!(hiragana_chars.len(), 46, "Should have all 46 basic hiragana characters");
          }
          
          /// Test all katakana characters for glyph presence
          #[test]
          fn test_all_katakana_characters_defined() {
              // All 46 basic katakana characters
              let katakana_chars = vec![
                  'ア', 'イ', 'ウ', 'エ', 'オ',
                  'カ', 'キ', 'ク', 'ケ', 'コ',
                  'サ', 'シ', 'ス', 'セ', 'ソ',
                  'タ', 'チ', 'ツ', 'テ', 'ト',
                  'ナ', 'ニ', 'ヌ', 'ネ', 'ノ',
                  'ハ', 'ヒ', 'フ', 'ヘ', 'ホ',
                  'マ', 'ミ', 'ム', 'メ', 'モ',
                  'ヤ', 'ユ', 'ヨ',
                  'ラ', 'リ', 'ル', 'レ', 'ロ',
                  'ワ', 'ヲ', 'ン',
              ];
              
              // Verify all characters are in valid Unicode range
              for ch in katakana_chars.iter() {
                  let unicode = *ch as u32;
                  assert!(
                      unicode >= 0x30A0 && unicode <= 0x30FF,
                      "Character {} should be in katakana Unicode block (U+30A0-U+30FF)",
                      ch
                  );
              }
              
              assert_eq!(katakana_chars.len(), 46, "Should have all 46 basic katakana characters");
          }
          
          /// Test that CharacterCard can be instantiated without panicking
          #[test]
          fn test_character_card_instantiation() {
              // Test creating CharacterCard instances for various characters
              let test_chars = vec!['あ', 'か', 'さ', 'ア', 'カ', 'サ'];
              
              for ch in test_chars {
                  // This should not panic
                  let _card = CharacterCard::new(ch)
                      .size(48.0);
                  
                  let _card_medium = CharacterCard::new(ch)
                      .size(64.0);
                  
                  let _card_large = CharacterCard::new(ch)
                      .size(72.0);
              }
          }
      }
      
      #[cfg(test)]
      mod character_card_widget_tests {
          use kana_master::ui::widgets::CharacterCard;
          
          /// Test CharacterCard builder pattern with various configurations
          #[test]
          fn test_character_card_builder_configurations() {
              let card = CharacterCard::new('あ')
                  .size(64.0);
              
              // Verify the card stores the character correctly
              assert_eq!(card.character(), 'あ');
              assert_eq!(card.size(), 64.0);
          }
          
          /// Test CharacterCard with optional stroke order overlay
          #[test]
          fn test_character_card_with_stroke_order() {
              let card = CharacterCard::new('か')
                  .size(72.0)
                  .show_stroke_order(true);
              
              assert_eq!(card.character(), 'か');
              assert!(card.has_stroke_order_enabled());
          }
          
          /// Test CharacterCard centering configuration
          #[test]
          fn test_character_card_centering() {
              let card = CharacterCard::new('さ')
                  .size(48.0)
                  .center_horizontal(true)
                  .center_vertical(true);
              
              assert!(card.is_centered_horizontal());
              assert!(card.is_centered_vertical());
          }
          
          /// Test CharacterCard with all size variants required by acceptance criteria
          #[test]
          fn test_character_card_required_sizes() {
              let sizes = vec![48.0, 64.0, 72.0];
              
              for size in sizes {
                  let card = CharacterCard::new('あ').size(size);
                  assert_eq!(card.size(), size);
              }
          }
      }
      
      #[cfg(test)]
      mod font_loading_integration_tests {
          /// Test that font loading doesn't panic during application initialization
          /// This is a smoke test for the font loading system
          #[test]
          fn test_font_loading_smoke_test() {
              // Note: This test verifies that the font loading code path can be executed
              // Full integration with iced runtime requires a more complex test harness
              
              const NOTO_SANS_JP: &[u8] = include_bytes!("../assets/fonts/NotoSansJP-Regular.otf");
              
              // Simulate what the application does during startup
              let font_data = NOTO_SANS_JP;
              assert!(!font_data.is_empty(), "Font data should not be empty");
              
              // In the actual application, this would be passed to iced::Font::with_name()
              // Here we just verify the data is accessible
          }
          
          /// Test comprehensive kana coverage for rendering pipeline
          #[test]
          fn test_comprehensive_kana_string_handling() {
              // Test strings that combine hiragana and katakana
              let test_strings = vec![
                  "あいうえお",
                  "アイウエオ",
                  "かきくけこ",
                  "カキクケコ",
                  "さしすせそ",
                  "たちつてと",
                  "なにぬねの",
                  "はひふへほ",
                  "まみむめも",
                  "やゆよ",
                  "らりるれろ",
                  "わをん",
                  "がぎぐげご", // Dakuten
                  "ぱぴぷぺぽ", // Handakuten
              ];
              
              for s in test_strings {
                  // Verify strings are valid UTF-8 and contain only kana
                  assert!(s.is_ascii() == false, "Kana strings should not be ASCII");
                  assert!(s.chars().all(|c| {
                      let u = c as u32;
                      (u >= 0x3040 && u <= 0x309F) || (u >= 0x30A0 && u <= 0x30FF)
                  }), "String should contain only hiragana or katakana");
              }
          }
      }

  coverage:
    - "Embedded Noto Sans JP font file is present and accessible"
    - "Font file has valid OTF/TTF magic number and reasonable size"
    - "All 46 basic hiragana characters are defined in valid Unicode range"
    - "All 46 basic katakana characters are defined in valid Unicode range"
    - "CharacterCard widget can be instantiated without panicking"
    - "CharacterCard accepts size parameter for 48px rendering"
    - "CharacterCard accepts size parameter for 64px rendering"
    - "CharacterCard accepts size parameter for 72px rendering"
    - "CharacterCard builder pattern works correctly"
    - "CharacterCard stores character data correctly"
    - "CharacterCard optional stroke order overlay can be enabled"
    - "CharacterCard horizontal centering can be configured"
    - "CharacterCard vertical centering can be configured"
    - "Font loading code path executes without panic"
    - "Comprehensive kana strings (including dakuten/handakuten) are valid UTF-8"
    - "Mixed hiragana and katakana strings maintain proper Unicode ranges"

dependencies:
  depends_on:
    - task_id: 1
      reason: "Needs application foundation and ui/ module structure to exist before adding widgets"

  depended_upon_by:
    - task_id: 7
      reason: "Flashcard system needs CharacterCard widget for displaying characters in flashcard UI"
    - task_id: 8
      reason: "Practice mode displays characters using CharacterCard for quiz questions and feedback"

  external:
    - name: "iced"
      type: "crate"
      status: "already exists"
    - name: "iced::widget::Widget"
      type: "trait"
      status: "already exists"
    - name: "iced::Font"
      type: "struct"
      status: "already exists"
    - name: "cosmic-text"
      type: "crate"
      status: "already exists"
    - name: "include_bytes!"
      type: "macro"
      status: "already exists"
---
task:
  id: 4
  name: "Stroke Order Animation System"

context:
  description: |
    Implement a GPU-accelerated stroke-by-stroke animation system using iced's Canvas
    widget and Animation API. The system renders character strokes sequentially with
    smooth partial path drawing, configurable timing, and natural easing curves that
    mimic human handwriting motion.
    
    Stroke order animation is the primary visual teaching tool in the application. It must
    be smooth, accurate, and feel natural to be pedagogically effective. GPU acceleration
    via lyon tessellation ensures 60fps animation even on lower-end hardware. Sequential
    stroke rendering with proper timing helps learners internalize correct writing patterns.
    
    This system produces a reusable StrokeOrderAnimation component that takes stroke path
    data and produces smooth, timed animations. Each stroke draws progressively over
    500-800ms with 200-300ms pauses between strokes. Completed strokes render in black,
    current stroke in blue. Animation can be played, paused, and reset.

  key_points:
    - "Canvas-based rendering using iced's canvas::Program trait for custom drawing"
    - "lyon tessellation library provides GPU-accelerated path rendering for 60fps performance"
    - "SVG path parsing converts character stroke data into renderable path segments"
    - "Partial path calculation enables smooth progressive stroke drawing based on animation progress"
    - "EaseOutCubic easing function provides natural handwriting motion feel"
    - "Precomputed stroke lengths enable accurate progress-to-distance mapping"
    - "State machine manages animation lifecycle (play, pause, reset, complete)"
    - "Sequential stroke rendering with configurable timing between strokes"
    - "Color differentiation: black for completed strokes, blue for animating stroke"
    - "Animation timing controller manages multi-stroke sequences with pauses"

files:
  - path: "src/ui/canvas/stroke_animation.rs"
    description: "Core StrokeOrderAnimation component implementing canvas::Program trait for managing animation state, timing, and rendering"
  
  - path: "src/ui/canvas/stroke_path.rs"
    description: "StrokePath and PathSegment types for representing SVG path data with precomputed length calculations"
  
  - path: "src/ui/canvas/path_parser.rs"
    description: "SVG path string parser that converts path data into PathSegment enums"
  
  - path: "src/ui/canvas/partial_path.rs"
    description: "Partial path calculation utilities for rendering stroke segments based on animation progress"
  
  - path: "src/ui/canvas/mod.rs"
    description: "Canvas module declarations and re-exports for stroke animation components"
  
  - path: "tests/stroke_animation_tests.rs"
    description: "Integration and unit tests for stroke order animation system including timing, rendering, and state transitions"

functions:
  - file: "src/ui/canvas/stroke_animation.rs"
    items:
      - type: "module_declaration"
        name: "stroke_animation"
        description: "Module containing stroke order animation system with Canvas rendering and timing control"
      
      - type: "struct"
        name: "StrokeOrderAnimation"
        description: "Main animation component managing state, timing, and rendering for stroke order display"
        invariants: "current_stroke_index always <= strokes.len(); animation_progress always in [0.0, 1.0]"
      
      - type: "struct"
        name: "StrokePath"
        description: "Represents a single stroke with segments, precomputed length, and color state"
        invariants: "total_length >= 0.0; segments non-empty for valid strokes"
      
      - type: "enum"
        name: "PathSegment"
        description: "Individual SVG path commands (MoveTo, LineTo, CubicBezier, QuadraticBezier, SmoothCubic)"
      
      - type: "enum_variant"
        name: "PathSegment::MoveTo"
        description: "Move pen to absolute position without drawing"
      
      - type: "enum_variant"
        name: "PathSegment::LineTo"
        description: "Draw straight line to absolute position"
      
      - type: "enum_variant"
        name: "PathSegment::CubicBezier"
        description: "Draw cubic bezier curve with two control points"
      
      - type: "enum_variant"
        name: "PathSegment::QuadraticBezier"
        description: "Draw quadratic bezier curve with one control point"
      
      - type: "enum_variant"
        name: "PathSegment::SmoothCubic"
        description: "Draw smooth cubic bezier with reflected control point"
      
      - type: "enum"
        name: "StrokeState"
        description: "State of individual stroke: Pending, Animating, Complete"
      
      - type: "enum"
        name: "AnimationState"
        description: "Overall animation state: Stopped, Playing, Paused, Complete"
      
      - type: "struct"
        name: "AnimationConfig"
        description: "Configuration for animation timing (stroke_duration, pause_duration, easing_function)"
      
      - type: "method"
        name: "StrokeOrderAnimation::new"
        description: "Creates new animation from stroke path data and configuration"
        preconditions: "strokes vector is non-empty"
        postconditions: "Returns initialized animation in Stopped state with current_stroke_index = 0"
      
      - type: "method"
        name: "StrokeOrderAnimation::play"
        description: "Starts or resumes animation playback"
        preconditions: "Animation not in Complete state or reset before play"
        postconditions: "Animation state set to Playing; start_time recorded"
      
      - type: "method"
        name: "StrokeOrderAnimation::pause"
        description: "Pauses animation, preserving current progress"
        postconditions: "Animation state set to Paused; progress preserved"
      
      - type: "method"
        name: "StrokeOrderAnimation::reset"
        description: "Resets animation to initial state"
        postconditions: "current_stroke_index = 0; all strokes set to Pending; state = Stopped"
      
      - type: "method"
        name: "StrokeOrderAnimation::update"
        description: "Updates animation state based on elapsed time"
        preconditions: "Called on each frame with current time"
        postconditions: "Advances animation progress; transitions strokes between states; returns true if needs redraw"
      
      - type: "trait_impl"
        name: "canvas::Program for StrokeOrderAnimation"
        description: "Implements iced canvas::Program trait for rendering animation"
      
      - type: "method"
        name: "canvas::Program::draw"
        description: "Renders current animation frame to canvas"
        preconditions: "Canvas bounds are valid"
        postconditions: "Completed strokes rendered in black; current stroke partially rendered in blue"
      
      - type: "method"
        name: "canvas::Program::update"
        description: "Handles animation tick events and state updates"
        postconditions: "Returns appropriate Action (request_redraw while animating)"
      
      - type: "function"
        name: "parse_svg_path"
        description: "Parses SVG path string into vector of PathSegment enums"
        preconditions: "path_data is valid SVG path syntax"
        postconditions: "Returns Ok(Vec<PathSegment>) or Err with parse error"
      
      - type: "function"
        name: "calculate_segment_length"
        description: "Computes geometric length of a single path segment"
        postconditions: "Returns non-negative length value"
      
      - type: "function"
        name: "calculate_bezier_length"
        description: "Approximates cubic bezier curve length using adaptive subdivision"
        preconditions: "tolerance > 0.0"
        postconditions: "Returns length estimate within specified tolerance"
        invariants: "Result converges to true length as tolerance decreases"

  - file: "src/ui/canvas/stroke_path.rs"
    items:
      - type: "module_declaration"
        name: "path"
        description: "Path segment representation and manipulation utilities"
      
      - type: "method"
        name: "StrokePath::from_svg"
        description: "Creates StrokePath from SVG path data string"
        preconditions: "svg_data contains valid SVG path commands"
        postconditions: "Returns StrokePath with parsed segments and computed total_length"
      
      - type: "method"
        name: "StrokePath::compute_length"
        description: "Calculates total length of all segments in stroke"
        postconditions: "Returns sum of all segment lengths"
        invariants: "Result is deterministic for same path segments"
      
      - type: "method"
        name: "StrokePath::partial_path"
        description: "Generates partial path up to specified progress ratio"
        preconditions: "progress in [0.0, 1.0]"
        postconditions: "Returns path segments representing progress * total_length"
        invariants: "Maintains stroke continuity; no gaps or jumps"
      
      - type: "function"
        name: "interpolate_segment"
        description: "Interpolates partial segment at given t parameter"
        preconditions: "t in [0.0, 1.0]"
        postconditions: "Returns point and partial segment at parameter t"

  - file: "src/ui/canvas/timing.rs"
    items:
      - type: "module_declaration"
        name: "timing"
        description: "Animation timing control and easing functions"
      
      - type: "function"
        name: "ease_out_cubic"
        description: "Easing function providing natural deceleration curve"
        preconditions: "t in [0.0, 1.0]"
        postconditions: "Returns eased value in [0.0, 1.0]"
        invariants: "Monotonically increasing; smooth continuous derivative"
      
      - type: "function"
        name: "ease_in_out_cubic"
        description: "Easing function with acceleration then deceleration"
        preconditions: "t in [0.0, 1.0]"
        postconditions: "Returns eased value in [0.0, 1.0]"
      
      - type: "struct"
        name: "TimingController"
        description: "Manages timing state for multi-stroke animation sequence"
        invariants: "current_time >= start_time when active"
      
      - type: "method"
        name: "TimingController::new"
        description: "Creates timing controller with specified config"
        postconditions: "Returns controller initialized to start state"
      
      - type: "method"
        name: "TimingController::elapsed"
        description: "Calculates elapsed time since animation start"
        postconditions: "Returns Duration accounting for pauses"
      
      - type: "method"
        name: "TimingController::stroke_progress"
        description: "Calculates progress for current stroke based on elapsed time"
        preconditions: "stroke_index is valid"
        postconditions: "Returns progress in [0.0, 1.0] for current stroke"

  - file: "src/ui/canvas/renderer.rs"
    items:
      - type: "module_declaration"
        name: "renderer"
        description: "Canvas rendering implementation using lyon tessellation"
      
      - type: "function"
        name: "render_stroke"
        description: "Renders a complete stroke to canvas with specified color"
        preconditions: "stroke contains valid path segments; frame is valid canvas frame"
        postconditions: "Stroke drawn to canvas using GPU-accelerated tessellation"
      
      - type: "function"
        name: "render_partial_stroke"
        description: "Renders partial stroke up to progress point"
        preconditions: "progress in [0.0, 1.0]; stroke valid"
        postconditions: "Partial stroke rendered smoothly without artifacts"
      
      - type: "function"
        name: "build_lyon_path"
        description: "Converts PathSegment vector to lyon Path for tessellation"
        preconditions: "segments form valid path"
        postconditions: "Returns lyon::path::Path ready for tessellation"
      
      - type: "function"
        name: "tessellate_stroke"
        description: "Tessellates path into GPU-ready triangle mesh"
        preconditions: "path is valid lyon Path"
        postconditions: "Returns VertexBuffer for GPU rendering"

  - file: "src/ui/canvas/path_parser.rs"
    items:
      - type: "module_declaration"
        name: "parser"
        description: "SVG path data parser for stroke commands"
      
      - type: "struct"
        name: "PathParser"
        description: "State machine for parsing SVG path data"
      
      - type: "method"
        name: "PathParser::new"
        description: "Creates parser for given SVG path string"
        postconditions: "Returns parser initialized at start of input"
      
      - type: "method"
        name: "PathParser::parse"
        description: "Parses full path string into PathSegment vector"
        postconditions: "Returns Ok(segments) or Err with detailed parse error"
      
      - type: "method"
        name: "PathParser::parse_command"
        description: "Parses single SVG path command (M, L, C, S, Q)"
        preconditions: "Parser positioned at command character"
        postconditions: "Returns PathSegment or parse error; advances parser position"
      
      - type: "method"
        name: "PathParser::parse_coordinate_pair"
        description: "Parses x,y coordinate pair from path data"
        postconditions: "Returns Point or parse error"
      
      - type: "function"
        name: "normalize_path"
        description: "Converts relative commands to absolute coordinates"
        preconditions: "segments contains valid path"
        postconditions: "Returns equivalent path with all absolute commands"

  - file: "tests/stroke_animation_tests.rs"
    items:
      - type: "function"
        name: "test_svg_path_parsing"
        description: "Unit test verifying SVG path string parsing correctness"
      
      - type: "function"
        name: "test_stroke_length_calculation"
        description: "Unit test verifying accurate length computation for various path types"
      
      - type: "function"
        name: "test_partial_path_generation"
        description: "Unit test ensuring partial paths maintain continuity"
      
      - type: "function"
        name: "test_animation_state_transitions"
        description: "Integration test verifying play/pause/reset state machine"
      
      - type: "function"
        name: "test_timing_accuracy"
        description: "Integration test verifying animation completes in expected time"
      
      - type: "function"
        name: "test_stroke_sequencing"
        description: "Integration test ensuring strokes animate in correct order"
      
      - type: "function"
        name: "prop_bezier_length_monotonic"
        description: "Property test: bezier length increases monotonically with arc length"
      
      - type: "function"
        name: "prop_partial_path_progress"
        description: "Property test: partial_path(p1) + partial_path(p2) = partial_path(p1+p2)"

formal_verification:
  needed: false
  level: "None"
  explanation: |
    Formal verification is not needed for the stroke order animation system. This task
    involves visual animation and rendering logic that is best validated through property-based
    testing and integration testing rather than formal proofs.
    
    Key reasons:
    
    1. Nature of the domain: Animation rendering is fundamentally a visual, continuous
       domain with subjective quality aspects (smoothness, naturalness) that cannot be
       meaningfully expressed as formal logical properties.
    
    2. Non-critical failure modes: Errors in this system result in visual artifacts or
       incorrect animation timing, not safety violations or data corruption. These issues
       are immediately observable and non-catastrophic.
    
    3. Better testing alternatives: Property-based testing can effectively verify the
       mathematical invariants (path continuity, progress monotonicity, timing bounds) while
       integration tests validate state transitions and visual regression testing ensures
       rendering quality.
    
    4. Implementation characteristics: The core logic involves floating-point arithmetic
       for Bezier curve calculations and path length approximations, which are inherently
       imprecise and difficult to verify formally. Numerical approximation algorithms are
       better validated empirically.
    
    5. External dependencies: The rendering pipeline depends on iced's Canvas API and
       lyon tessellation library, which are outside our verification boundary. Formal
       verification would require assuming correctness of these external components.
    
    The identified risks (SVG parsing complexity, floating-point precision, Bezier length
    calculation) are better addressed through comprehensive unit tests, property-based
    tests (verifying continuity, monotonicity, bounds), and visual regression testing
    rather than formal verification.

tests:
  strategy:
    approach: "mixed"
    rationale:
      - "Unit tests for path parsing, segment length calculations, and animation progress to ensure correctness of core algorithms"
      - "Property-based tests for partial path rendering to verify continuity, monotonicity, and boundary conditions across diverse inputs"
      - "Integration tests for animation state machine transitions (play/pause/reset) and multi-stroke sequencing"
      - "Timing tests to verify animation duration, stroke intervals, and frame-accurate progression"
      - "Visual regression prevented through deterministic rendering tests that compare frame outputs"

  implementation:
    file: "tests/stroke_animation_tests.rs"
    location: "in existing test module"
    code: |
      #[cfg(test)]
      mod tests {
          use super::*;
          use std::time::Duration;

          // ===== Path Parsing Tests =====

          #[test]
          fn test_parse_simple_line_path() {
              // Test parsing of basic SVG path: MoveTo and LineTo
              let svg = "M 10 20 L 30 40";
              let stroke = StrokePath::from_svg(svg).unwrap();
              
              assert_eq!(stroke.segments.len(), 2);
              match &stroke.segments[0] {
                  PathSegment::MoveTo { x, y } => {
                      assert_eq!(*x, 10.0);
                      assert_eq!(*y, 20.0);
                  }
                  _ => panic!("Expected MoveTo segment"),
              }
              match &stroke.segments[1] {
                  PathSegment::LineTo { x, y } => {
                      assert_eq!(*x, 30.0);
                      assert_eq!(*y, 40.0);
                  }
                  _ => panic!("Expected LineTo segment"),
              }
          }

          #[test]
          fn test_parse_cubic_bezier_path() {
              // Test parsing of cubic Bezier curves
              let svg = "M 0 0 C 10 20 30 40 50 50";
              let stroke = StrokePath::from_svg(svg).unwrap();
              
              assert_eq!(stroke.segments.len(), 2);
              match &stroke.segments[1] {
                  PathSegment::CubicBezier { cp1_x, cp1_y, cp2_x, cp2_y, x, y } => {
                      assert_eq!(*cp1_x, 10.0);
                      assert_eq!(*cp1_y, 20.0);
                      assert_eq!(*cp2_x, 30.0);
                      assert_eq!(*cp2_y, 40.0);
                      assert_eq!(*x, 50.0);
                      assert_eq!(*y, 50.0);
                  }
                  _ => panic!("Expected CubicBezier segment"),
              }
          }

          #[test]
          fn test_parse_quadratic_bezier_path() {
              // Test parsing of quadratic Bezier curves
              let svg = "M 0 0 Q 20 30 40 40";
              let stroke = StrokePath::from_svg(svg).unwrap();
              
              assert_eq!(stroke.segments.len(), 2);
              match &stroke.segments[1] {
                  PathSegment::QuadraticBezier { cp_x, cp_y, x, y } => {
                      assert_eq!(*cp_x, 20.0);
                      assert_eq!(*cp_y, 30.0);
                      assert_eq!(*x, 40.0);
                      assert_eq!(*y, 40.0);
                  }
                  _ => panic!("Expected QuadraticBezier segment"),
              }
          }

          #[test]
          fn test_parse_smooth_cubic_path() {
              // Test parsing of smooth cubic Bezier (S command)
              let svg = "M 0 0 C 10 10 20 20 30 30 S 50 50 60 60";
              let stroke = StrokePath::from_svg(svg).unwrap();
              
              assert_eq!(stroke.segments.len(), 3);
              match &stroke.segments[2] {
                  PathSegment::SmoothCubic { cp2_x, cp2_y, x, y } => {
                      assert_eq!(*cp2_x, 50.0);
                      assert_eq!(*cp2_y, 50.0);
                      assert_eq!(*x, 60.0);
                      assert_eq!(*y, 60.0);
                  }
                  _ => panic!("Expected SmoothCubic segment"),
              }
          }

          #[test]
          fn test_parse_invalid_svg_path() {
              // Test error handling for malformed SVG paths
              let invalid_svg = "M 10 20 X 30 40";
              assert!(StrokePath::from_svg(invalid_svg).is_err());
          }

          #[test]
          fn test_parse_empty_path() {
              // Test error handling for empty SVG paths
              let empty_svg = "";
              assert!(StrokePath::from_svg(empty_svg).is_err());
          }

          // ===== Length Calculation Tests =====

          #[test]
          fn test_line_segment_length() {
              // Test accurate length calculation for straight lines
              let segment = PathSegment::LineTo { x: 3.0, y: 4.0 };
              let start = Point::new(0.0, 0.0);
              let length = segment.calculate_length(start);
              
              // 3-4-5 right triangle
              assert!((length - 5.0).abs() < 0.001);
          }

          #[test]
          fn test_stroke_total_length() {
              // Test cumulative length calculation for multi-segment strokes
              let svg = "M 0 0 L 10 0 L 10 10";
              let stroke = StrokePath::from_svg(svg).unwrap();
              stroke.precompute_lengths();
              
              // L shape: 10 + 10 = 20
              assert!((stroke.total_length - 20.0).abs() < 0.001);
          }

          #[test]
          fn test_bezier_length_approximation() {
              // Test Bezier curve length approximation accuracy
              let segment = PathSegment::CubicBezier {
                  cp1_x: 10.0, cp1_y: 0.0,
                  cp2_x: 20.0, cp2_y: 0.0,
                  x: 30.0, y: 0.0,
              };
              let start = Point::new(0.0, 0.0);
              let length = segment.calculate_length(start);
              
              // Nearly straight line from 0 to 30
              assert!(length >= 30.0 && length <= 32.0);
          }

          // ===== Partial Path Rendering Tests =====

          #[test]
          fn test_partial_path_at_zero_progress() {
              // Test that 0% progress renders nothing
              let svg = "M 0 0 L 100 0";
              let stroke = StrokePath::from_svg(svg).unwrap();
              stroke.precompute_lengths();
              
              let partial = stroke.calculate_partial_path(0.0);
              assert_eq!(partial.segments.len(), 1); // Only MoveTo
          }

          #[test]
          fn test_partial_path_at_full_progress() {
              // Test that 100% progress renders complete stroke
              let svg = "M 0 0 L 100 0 L 100 100";
              let stroke = StrokePath::from_svg(svg).unwrap();
              stroke.precompute_lengths();
              
              let partial = stroke.calculate_partial_path(1.0);
              assert_eq!(partial.segments.len(), stroke.segments.len());
          }

          #[test]
          fn test_partial_path_mid_segment() {
              // Test partial rendering stops midway through a segment
              let svg = "M 0 0 L 100 0";
              let stroke = StrokePath::from_svg(svg).unwrap();
              stroke.precompute_lengths();
              
              let partial = stroke.calculate_partial_path(0.5);
              assert_eq!(partial.segments.len(), 2); // MoveTo + partial LineTo
              
              match &partial.segments[1] {
                  PathSegment::LineTo { x, y } => {
                      assert!((x - 50.0).abs() < 1.0);
                      assert!((y - 0.0).abs() < 0.1);
                  }
                  _ => panic!("Expected LineTo segment"),
              }
          }

          #[test]
          fn test_partial_path_continuity() {
              // Test that incremental progress produces continuous paths
              let svg = "M 0 0 L 100 0 L 100 100";
              let stroke = StrokePath::from_svg(svg).unwrap();
              stroke.precompute_lengths();
              
              let mut last_endpoint = Point::new(0.0, 0.0);
              for i in 1..=20 {
                  let progress = i as f32 / 20.0;
                  let partial = stroke.calculate_partial_path(progress);
                  let endpoint = partial.get_last_point();
                  
                  // Endpoint should only move forward, never backward
                  let distance = endpoint.distance(last_endpoint);
                  assert!(distance >= 0.0);
                  last_endpoint = endpoint;
              }
          }

          // ===== Animation State Machine Tests =====

          #[test]
          fn test_animation_initial_state() {
              // Test animation starts in correct initial state
              let strokes = vec![
                  StrokePath::from_svg("M 0 0 L 10 10").unwrap(),
              ];
              let animation = StrokeOrderAnimation::new(strokes);
              
              assert_eq!(animation.state, AnimationState::Ready);
              assert_eq!(animation.current_stroke_index, 0);
              assert_eq!(animation.progress, 0.0);
          }

          #[test]
          fn test_animation_play_transitions_to_animating() {
              // Test play() transitions state to Animating
              let strokes = vec![
                  StrokePath::from_svg("M 0 0 L 10 10").unwrap(),
              ];
              let mut animation = StrokeOrderAnimation::new(strokes);
              
              animation.play();
              assert_eq!(animation.state, AnimationState::Animating);
          }

          #[test]
          fn test_animation_pause_and_resume() {
              // Test pause() and resume() work correctly
              let strokes = vec![
                  StrokePath::from_svg("M 0 0 L 10 10").unwrap(),
              ];
              let mut animation = StrokeOrderAnimation::new(strokes);
              
              animation.play();
              animation.update(Duration::from_millis(200));
              let progress_before_pause = animation.progress;
              
              animation.pause();
              assert_eq!(animation.state, AnimationState::Paused);
              
              animation.update(Duration::from_millis(100));
              assert_eq!(animation.progress, progress_before_pause); // No progress while paused
              
              animation.play();
              assert_eq!(animation.state, AnimationState::Animating);
          }

          #[test]
          fn test_animation_reset() {
              // Test reset() returns animation to initial state
              let strokes = vec![
                  StrokePath::from_svg("M 0 0 L 10 10").unwrap(),
                  StrokePath::from_svg("M 10 10 L 20 20").unwrap(),
              ];
              let mut animation = StrokeOrderAnimation::new(strokes);
              
              animation.play();
              animation.update(Duration::from_millis(500));
              animation.reset();
              
              assert_eq!(animation.state, AnimationState::Ready);
              assert_eq!(animation.current_stroke_index, 0);
              assert_eq!(animation.progress, 0.0);
          }

          #[test]
          fn test_animation_completes() {
              // Test animation transitions to Complete when all strokes finish
              let strokes = vec![
                  StrokePath::from_svg("M 0 0 L 10 10").unwrap(),
              ];
              let mut animation = StrokeOrderAnimation::new(strokes.clone());
              animation.set_stroke_duration(Duration::from_millis(100));
              animation.set_pause_duration(Duration::from_millis(0));
              
              animation.play();
              animation.update(Duration::from_millis(150)); // Beyond stroke duration
              
              assert_eq!(animation.state, AnimationState::Complete);
              assert_eq!(animation.current_stroke_index, strokes.len());
          }

          // ===== Multi-Stroke Sequencing Tests =====

          #[test]
          fn test_multi_stroke_progression() {
              // Test animation advances through multiple strokes sequentially
              let strokes = vec![
                  StrokePath::from_svg("M 0 0 L 10 10").unwrap(),
                  StrokePath::from_svg("M 10 10 L 20 20").unwrap(),
                  StrokePath::from_svg("M 20 20 L 30 30").unwrap(),
              ];
              let mut animation = StrokeOrderAnimation::new(strokes);
              animation.set_stroke_duration(Duration::from_millis(100));
              animation.set_pause_duration(Duration::from_millis(50));
              
              animation.play();
              
              // First stroke
              animation.update(Duration::from_millis(50));
              assert_eq!(animation.current_stroke_index, 0);
              assert!(animation.progress > 0.0 && animation.progress < 1.0);
              
              // Complete first stroke + pause
              animation.update(Duration::from_millis(100));
              assert_eq!(animation.current_stroke_index, 1);
              
              // Second stroke
              animation.update(Duration::from_millis(50));
              assert_eq!(animation.current_stroke_index, 1);
              
              // Complete second stroke + pause
              animation.update(Duration::from_millis(100));
              assert_eq!(animation.current_stroke_index, 2);
          }

          #[test]
          fn test_pause_duration_between_strokes() {
              // Test pause interval between strokes is respected
              let strokes = vec![
                  StrokePath::from_svg("M 0 0 L 10 10").unwrap(),
                  StrokePath::from_svg("M 10 10 L 20 20").unwrap(),
              ];
              let mut animation = StrokeOrderAnimation::new(strokes);
              animation.set_stroke_duration(Duration::from_millis(100));
              animation.set_pause_duration(Duration::from_millis(50));
              
              animation.play();
              animation.update(Duration::from_millis(100)); // Complete first stroke
              
              assert_eq!(animation.current_stroke_index, 0);
              assert_eq!(animation.state, AnimationState::Pausing);
              
              animation.update(Duration::from_millis(50)); // Complete pause
              assert_eq!(animation.current_stroke_index, 1);
              assert_eq!(animation.state, AnimationState::Animating);
          }

          // ===== Timing and Duration Tests =====

          #[test]
          fn test_stroke_duration_accuracy() {
              // Test stroke completes in configured duration
              let strokes = vec![
                  StrokePath::from_svg("M 0 0 L 100 0").unwrap(),
              ];
              let mut animation = StrokeOrderAnimation::new(strokes);
              animation.set_stroke_duration(Duration::from_millis(500));
              
              animation.play();
              animation.update(Duration::from_millis(250));
              assert!((animation.progress - 0.5).abs() < 0.05);
              
              animation.update(Duration::from_millis(250));
              assert!((animation.progress - 1.0).abs() < 0.05);
          }

          #[test]
          fn test_total_animation_time() {
              // Test total animation time matches expected duration
              let strokes = vec![
                  StrokePath::from_svg("M 0 0 L 10 10").unwrap(),
                  StrokePath::from_svg("M 10 10 L 20 20").unwrap(),
                  StrokePath::from_svg("M 20 20 L 30 30").unwrap(),
              ];
              let mut animation = StrokeOrderAnimation::new(strokes.clone());
              animation.set_stroke_duration(Duration::from_millis(600));
              animation.set_pause_duration(Duration::from_millis(200));
              
              // Expected: 3 strokes * 600ms + 2 pauses * 200ms = 2200ms
              let expected_duration = 3 * 600 + 2 * 200;
              
              animation.play();
              animation.update(Duration::from_millis(expected_duration as u64));
              
              assert_eq!(animation.state, AnimationState::Complete);
          }

          #[test]
          fn test_configurable_timing_parameters() {
              // Test animation respects custom timing configurations
              let strokes = vec![
                  StrokePath::from_svg("M 0 0 L 10 10").unwrap(),
              ];
              let mut animation = StrokeOrderAnimation::new(strokes);
              
              animation.set_stroke_duration(Duration::from_millis(800));
              animation.set_pause_duration(Duration::from_millis(300));
              
              assert_eq!(animation.stroke_duration, Duration::from_millis(800));
              assert_eq!(animation.pause_duration, Duration::from_millis(300));
          }

          // ===== Rendering and Color Tests =====

          #[test]
          fn test_completed_stroke_color() {
              // Test completed strokes render in black
              let strokes = vec![
                  StrokePath::from_svg("M 0 0 L 10 10").unwrap(),
                  StrokePath::from_svg("M 10 10 L 20 20").unwrap(),
              ];
              let mut animation = StrokeOrderAnimation::new(strokes);
              animation.set_stroke_duration(Duration::from_millis(100));
              animation.set_pause_duration(Duration::from_millis(0));
              
              animation.play();
              animation.update(Duration::from_millis(150)); // Complete first stroke
              
              let render_state = animation.get_render_state();
              assert_eq!(render_state.completed_strokes.len(), 1);
              assert_eq!(render_state.completed_stroke_color, Color::BLACK);
          }

          #[test]
          fn test_animating_stroke_color() {
              // Test current animating stroke renders in blue
              let strokes = vec![
                  StrokePath::from_svg("M 0 0 L 10 10").unwrap(),
              ];
              let mut animation = StrokeOrderAnimation::new(strokes);
              
              animation.play();
              animation.update(Duration::from_millis(50));
              
              let render_state = animation.get_render_state();
              assert!(render_state.current_stroke.is_some());
              assert_eq!(render_state.current_stroke_color, Color::BLUE);
          }

          #[test]
          fn test_no_rendering_artifacts_at_boundaries() {
              // Test stroke boundaries don't produce visual gaps or overlaps
              let strokes = vec![
                  StrokePath::from_svg("M 0 0 L 10 10").unwrap(),
                  StrokePath::from_svg("M 10 10 L 20 20").unwrap(),
              ];
              let mut animation = StrokeOrderAnimation::new(strokes);
              animation.set_stroke_duration(Duration::from_millis(100));
              animation.set_pause_duration(Duration::from_millis(0));
              
              animation.play();
              
              // At exactly 100ms, first stroke should be complete
              animation.update(Duration::from_millis(100));
              let state1 = animation.get_render_state();
              
              // At 101ms, second stroke should be starting
              animation.update(Duration::from_millis(1));
              let state2 = animation.get_render_state();
              
              assert_eq!(state1.completed_strokes.len(), 1);
              assert_eq!(state2.completed_strokes.len(), 1);
              assert!(state2.current_stroke.is_some());
          }

          // ===== Easing Function Tests =====

          #[test]
          fn test_ease_out_cubic_boundaries() {
              // Test easing function at boundaries
              let animation = StrokeOrderAnimation::new(vec![]);
              
              assert_eq!(animation.ease_out_cubic(0.0), 0.0);
              assert_eq!(animation.ease_out_cubic(1.0), 1.0);
          }

          #[test]
          fn test_ease_out_cubic_midpoint() {
              // Test easing function produces smooth deceleration
              let animation = StrokeOrderAnimation::new(vec![]);
              
              let mid_value = animation.ease_out_cubic(0.5);
              // EaseOutCubic at 0.5 should be > 0.5 (accelerated early phase)
              assert!(mid_value > 0.5 && mid_value < 1.0);
              
              // Should be monotonically increasing
              assert!(animation.ease_out_cubic(0.25) < animation.ease_out_cubic(0.5));
              assert!(animation.ease_out_cubic(0.5) < animation.ease_out_cubic(0.75));
          }
      }

      // ===== Property-Based Tests =====

      #[cfg(test)]
      mod property_tests {
          use super::*;
          use proptest::prelude::*;

          proptest! {
              #[test]
              fn prop_partial_path_progress_monotonic(progress in 0.0f32..=1.0f32) {
                  // Property: Partial path length increases monotonically with progress
                  let svg = "M 0 0 L 100 0 L 100 100 L 0 100";
                  let stroke = StrokePath::from_svg(svg).unwrap();
                  stroke.precompute_lengths();
                  
                  let partial1 = stroke.calculate_partial_path(progress);
                  let partial2 = stroke.calculate_partial_path((progress + 0.01).min(1.0));
                  
                  let len1 = partial1.calculate_total_length();
                  let len2 = partial2.calculate_total_length();
                  
                  prop_assert!(len2 >= len1);
              }

              #[test]
              fn prop_partial_path_at_boundaries(progress in 0.0f32..=1.0f32) {
                  // Property: Progress 0.0 has no segments beyond MoveTo, 1.0 has all segments
                  let svg = "M 0 0 L 50 50 L 100 0";
                  let stroke = StrokePath::from_svg(svg).unwrap();
                  stroke.precompute_lengths();
                  
                  let partial = stroke.calculate_partial_path(progress);
                  
                  if progress == 0.0 {
                      prop_assert_eq!(partial.segments.len(), 1);
                  } else if progress == 1.0 {
                      prop_assert_eq!(partial.segments.len(), stroke.segments.len());
                  } else {
                      prop_assert!(partial.segments.len() >= 1);
                      prop_assert!(partial.segments.len() <= stroke.segments.len());
                  }
              }

              #[test]
              fn prop_stroke_length_positive(x in -100.0f32..100.0, y in -100.0f32..100.0) {
                  // Property: All stroke lengths are non-negative
                  let svg = format!("M 0 0 L {} {}", x, y);
                  let stroke = StrokePath::from_svg(&svg).unwrap();
                  stroke.precompute_lengths();
                  
                  prop_assert!(stroke.total_length >= 0.0);
              }

              #[test]
              fn prop_animation_progress_bounded(
                  elapsed_ms in 0u64..10000u64,
                  stroke_duration_ms in 100u64..2000u64
              ) {
                  // Property: Animation progress stays within [0.0, 1.0] regardless of timing
                  let strokes = vec![
                      StrokePath::from_svg("M 0 0 L 100 100").unwrap(),
                  ];
                  let mut animation = StrokeOrderAnimation::new(strokes);
                  animation.set_stroke_duration(Duration::from_millis(stroke_duration_ms));
                  
                  animation.play();
                  animation.update(Duration::from_millis(elapsed_ms));
                  
                  prop_assert!(animation.progress >= 0.0);
                  prop_assert!(animation.progress <= 1.0);
              }

              #[test]
              fn prop_easing_function_bounded(t in 0.0f32..=1.0f32) {
                  // Property: Easing function output is always in [0.0, 1.0]
                  let animation = StrokeOrderAnimation::new(vec![]);
                  let eased = animation.ease_out_cubic(t);
                  
                  prop_assert!(eased >= 0.0);
                  prop_assert!(eased <= 1.0);
              }

              #[test]
              fn prop_multi_stroke_index_valid(
                  elapsed_ms in 0u64..20000u64,
                  num_strokes in 1usize..10usize
              ) {
                  // Property: Current stroke index never exceeds stroke count
                  let strokes: Vec<StrokePath> = (0..num_strokes)
                      .map(|i| StrokePath::from_svg(&format!("M {} {} L {} {}", 
                          i * 10, i * 10, (i + 1) * 10, (i + 1) * 10)).unwrap())
                      .collect();
                  
                  let mut animation = StrokeOrderAnimation::new(strokes.clone());
                  animation.set_stroke_duration(Duration::from_millis(500));
                  animation.set_pause_duration(Duration::from_millis(100));
                  
                  animation.play();
                  animation.update(Duration::from_millis(elapsed_ms));
                  
                  prop_assert!(animation.current_stroke_index <= strokes.len());
              }
          }
      }

  coverage:
    - "SVG path parsing for MoveTo, LineTo, CubicBezier, QuadraticBezier, and SmoothCubic commands"
    - "Error handling for malformed and empty SVG paths"
    - "Line segment length calculation with Euclidean distance"
    - "Cumulative stroke length calculation across multiple segments"
    - "Bezier curve length approximation using adaptive subdivision"
    - "Partial path rendering at 0%, 50%, and 100% progress"
    - "Partial path continuity across incremental progress updates"
    - "Partial path stops correctly mid-segment"
    - "Animation initial state (Ready, stroke index 0, progress 0)"
    - "Animation state transitions: Ready → Animating → Paused → Animating → Complete"
    - "Play, pause, and resume controls"
    - "Reset functionality returns to initial state"
    - "Animation completion detection when all strokes finish"
    - "Multi-stroke sequential progression through all strokes"
    - "Pause interval between strokes is respected"
    - "Stroke duration accuracy (progress matches elapsed time)"
    - "Total animation time calculation for multiple strokes with pauses"
    - "Configurable timing parameters (stroke duration and pause duration)"
    - "Completed strokes render in black color"
    - "Current animating stroke renders in blue color"
    - "No rendering artifacts or gaps at stroke boundaries"
    - "EaseOutCubic easing function at boundaries (0.0 and 1.0)"
    - "EaseOutCubic easing produces smooth deceleration curve"
    - "Property: Partial path length increases monotonically with progress"
    - "Property: Progress boundaries (0.0 has minimal segments, 1.0 has all segments)"
    - "Property: Stroke length is always non-negative"
    - "Property: Animation progress bounded to [0.0, 1.0] for all elapsed times"
    - "Property: Easing function output bounded to [0.0, 1.0] for all inputs"
    - "Property: Current stroke index never exceeds total stroke count"

dependencies:
  depends_on:
    - task_id: 1
      reason: "Needs Canvas widget support from iced foundation"
    - task_id: 2
      reason: "Requires stroke path data from character database"

  depended_upon_by:
    - task_id: 8
      reason: "Practice mode uses stroke animation for teaching"

  external:
    - name: "iced::canvas"
      type: "module"
      status: "already exists"
    - name: "iced::canvas::Program"
      type: "trait"
      status: "already exists"
    - name: "iced::Animation"
      type: "module"
      status: "already exists"
    - name: "lyon::path"
      type: "module"
      status: "to be imported"
    - name: "lyon::tessellation"
      type: "module"
      status: "to be imported"
    - name: "std::time::Duration"
      type: "struct"
      status: "already exists"
---
task:
  id: 5
  name: "Handwriting Canvas and Input System"

context:
  description: |
    This task implements an interactive drawing canvas that captures user handwriting
    input through mouse or touch interactions. The system records stroke sequences with
    precise timestamps, provides real-time visual feedback during drawing, and outputs
    normalized stroke data suitable for character recognition systems.
    
    The canvas is a core component of the handwriting practice system, enabling users
    to draw Chinese characters for recognition and feedback. It must feel responsive
    and natural, rendering smooth anti-aliased strokes that provide immediate visual
    confirmation of input. The implementation uses iced's canvas::Program trait to
    handle interactive drawing with proper state management.
    
    Stroke data is recorded as sequences of points with timestamps, enabling future
    enhancements like velocity analysis and stroke order validation. The system applies
    intelligent filtering (2px distance threshold) to reduce noise while maintaining
    stroke fidelity. Coordinate normalization to 0-1 range ensures recognition algorithms
    can process input independent of canvas size.
    
    The architecture separates concerns cleanly: HandwritingCanvas handles widget-level
    integration with iced, DrawingState manages stroke history and drawing state machine,
    and Stroke encapsulates individual stroke data with normalization capabilities.

  key_points:
    - "Implements iced canvas::Program trait for interactive drawing with mouse/touch events"
    - "State machine tracks drawing lifecycle: idle → drawing → stroke complete"
    - "Distance threshold (2px) prevents excessive point density from noisy input"
    - "Stroke rendering uses lyon Path with round caps/joins for natural appearance"
    - "Coordinate normalization to 0-1 range enables size-independent recognition"
    - "Timestamp recording per point enables future velocity-based analysis"
    - "Clear separation between drawing state management and widget presentation"
    - "Visual differentiation between active drawing stroke and completed strokes"

files:
  - path: "src/ui/handwriting_canvas.rs"
    description: "Implements HandwritingCanvas widget with canvas::Program trait for interactive drawing input"
  
  - path: "src/ui/drawing_state.rs"
    description: "Maintains stroke history, current drawing state, and stroke data structures"
  
  - path: "src/ui/mod.rs"
    description: "Module declaration file to expose handwriting_canvas and drawing_state modules"
  
  - path: "src/types/stroke.rs"
    description: "Defines Stroke and Point data structures for stroke recording and normalization"
  
  - path: "tests/handwriting_canvas_tests.rs"
    description: "Integration tests for canvas input handling, stroke recording, and rendering behavior"

functions:
  - file: "src/ui/canvas.rs"
    items:
      - type: "module_declaration"
        name: "canvas"
        description: "Module containing handwriting canvas implementation for capturing and rendering stroke input"
      
      - type: "struct"
        name: "HandwritingCanvas"
        description: "Canvas widget that captures mouse/touch input and renders handwriting strokes in real-time"
        invariants: "State is never null; strokes list is ordered chronologically"
      
      - type: "struct"
        name: "DrawingState"
        description: "Maintains the complete drawing state including stroke history and current active stroke"
        invariants: "current_stroke is Some only when is_drawing is true"
      
      - type: "struct"
        name: "Stroke"
        description: "Represents a single continuous stroke as a sequence of points with timestamp"
        invariants: "Points vector is never empty for a completed stroke; timestamps are monotonically increasing"
      
      - type: "struct"
        name: "Point"
        description: "Represents a single point in a stroke with x, y coordinates and timestamp"
        invariants: "Coordinates are within canvas bounds when recorded"
      
      - type: "enum"
        name: "Message"
        description: "Messages for canvas interaction events"
      
      - type: "enum_variant"
        name: "Message::StartStroke"
        description: "Initiates a new stroke at the given position"
        preconditions: "No stroke is currently active"
        postconditions: "A new stroke is started in DrawingState"
      
      - type: "enum_variant"
        name: "Message::AddPoint"
        description: "Adds a point to the current active stroke"
        preconditions: "A stroke is currently active (is_drawing is true)"
        postconditions: "Point is added to current stroke if distance threshold is met"
      
      - type: "enum_variant"
        name: "Message::EndStroke"
        description: "Completes the current stroke and adds it to stroke history"
        preconditions: "A stroke is currently active"
        postconditions: "Current stroke is moved to completed strokes list"
      
      - type: "enum_variant"
        name: "Message::Clear"
        description: "Removes all strokes from the canvas"
        postconditions: "All strokes are removed; canvas is blank"
      
      - type: "enum_variant"
        name: "Message::Undo"
        description: "Removes the most recently completed stroke"
        postconditions: "Last stroke is removed from strokes list if any exist"
      
      - type: "function"
        name: "HandwritingCanvas::new"
        description: "Creates a new HandwritingCanvas instance with empty state"
        postconditions: "Returns initialized canvas with no strokes"
      
      - type: "function"
        name: "HandwritingCanvas::clear"
        description: "Removes all strokes from the canvas"
        postconditions: "All stroke data is cleared"
      
      - type: "function"
        name: "HandwritingCanvas::undo"
        description: "Removes the last completed stroke"
        postconditions: "Most recent stroke is removed if strokes exist"
      
      - type: "function"
        name: "HandwritingCanvas::get_strokes"
        description: "Returns the current stroke data as a reference"
        postconditions: "Returns immutable reference to stroke vector"
      
      - type: "function"
        name: "HandwritingCanvas::export_normalized_strokes"
        description: "Exports stroke data normalized to 0-1 coordinate range"
        postconditions: "Returns Vec<Vec<(f32, f32)>> with normalized coordinates"
      
      - type: "trait_impl"
        name: "canvas::Program for HandwritingCanvas"
        description: "Implements iced canvas::Program trait for interactive drawing functionality"
      
      - type: "method"
        name: "canvas::Program::update"
        description: "Handles canvas messages and updates drawing state"
        preconditions: "Valid Message is provided"
        postconditions: "State is updated according to message type"
      
      - type: "method"
        name: "canvas::Program::draw"
        description: "Renders all strokes and current drawing stroke to the canvas"
        postconditions: "All strokes are rendered with anti-aliasing and round caps"
      
      - type: "method"
        name: "canvas::Program::mouse_interaction"
        description: "Provides cursor feedback based on canvas state"
        postconditions: "Returns appropriate cursor style"
      
      - type: "function"
        name: "DrawingState::new"
        description: "Creates a new empty drawing state"
        postconditions: "Returns initialized state with empty stroke list"
      
      - type: "function"
        name: "DrawingState::start_stroke"
        description: "Begins a new stroke at the given position with timestamp"
        preconditions: "No stroke is currently active"
        postconditions: "current_stroke is Some with initial point; is_drawing is true"
      
      - type: "function"
        name: "DrawingState::add_point"
        description: "Adds a point to the current stroke if distance threshold is met"
        preconditions: "A stroke is currently active"
        postconditions: "Point is added if distance from last point exceeds threshold (2px)"
      
      - type: "function"
        name: "DrawingState::end_stroke"
        description: "Completes the current stroke and adds it to the stroke history"
        preconditions: "A stroke is currently active"
        postconditions: "current_stroke is None; completed stroke is added to strokes list"
      
      - type: "function"
        name: "DrawingState::clear_all"
        description: "Removes all strokes and resets state"
        postconditions: "strokes is empty; current_stroke is None; is_drawing is false"
      
      - type: "function"
        name: "DrawingState::undo_last"
        description: "Removes the most recent completed stroke"
        postconditions: "Last element removed from strokes if list is non-empty"
      
      - type: "function"
        name: "Stroke::new"
        description: "Creates a new stroke starting at the given point"
        postconditions: "Returns stroke with single initial point"
      
      - type: "function"
        name: "Stroke::add_point"
        description: "Appends a point to the stroke"
        postconditions: "Point is added to points vector"
      
      - type: "function"
        name: "Stroke::to_path"
        description: "Converts stroke points into a lyon Path for rendering"
        preconditions: "Stroke has at least one point"
        postconditions: "Returns Path with line_to segments connecting all points"
      
      - type: "function"
        name: "Stroke::normalize"
        description: "Normalizes stroke coordinates to 0-1 range based on canvas bounds"
        preconditions: "canvas_width and canvas_height are positive"
        postconditions: "Returns vector of normalized (x, y) tuples"
      
      - type: "function"
        name: "Point::new"
        description: "Creates a new point with coordinates and timestamp"
        postconditions: "Returns initialized Point"
      
      - type: "function"
        name: "Point::distance_to"
        description: "Calculates Euclidean distance to another point"
        postconditions: "Returns non-negative distance value"
      
      - type: "function"
        name: "render_stroke"
        description: "Helper function to render a stroke with specified style to the frame"
        preconditions: "Stroke has at least 2 points for visible rendering"
        postconditions: "Stroke is drawn to frame with anti-aliasing, round caps and joins"
      
      - type: "constant"
        name: "DISTANCE_THRESHOLD"
        description: "Minimum distance (2.0 pixels) between consecutive points to reduce noise"
      
      - type: "constant"
        name: "STROKE_WIDTH"
        description: "Default width (3.0 pixels) for rendered strokes"
      
      - type: "constant"
        name: "DRAWING_COLOR"
        description: "Color used for the current active stroke being drawn"
      
      - type: "constant"
        name: "COMPLETED_COLOR"
        description: "Color used for completed strokes"

  - file: "tests/canvas_tests.rs"
    items:
      - type: "module_declaration"
        name: "canvas_tests"
        description: "Integration tests for handwriting canvas functionality"
      
      - type: "function"
        name: "test_stroke_creation"
        description: "Tests that strokes are created correctly with initial points"
        postconditions: "Stroke contains expected initial point"
      
      - type: "function"
        name: "test_distance_threshold"
        description: "Verifies that points closer than threshold are not added"
        postconditions: "Only points exceeding distance threshold are added to stroke"
      
      - type: "function"
        name: "test_stroke_completion"
        description: "Tests that ending a stroke moves it to completed list"
        postconditions: "Current stroke becomes None; strokes list grows by one"
      
      - type: "function"
        name: "test_clear_functionality"
        description: "Verifies clear removes all strokes"
        postconditions: "After clear, strokes list is empty"
      
      - type: "function"
        name: "test_undo_functionality"
        description: "Tests that undo removes most recent stroke"
        postconditions: "Last stroke is removed; count decreases by one"
      
      - type: "function"
        name: "test_normalization"
        description: "Verifies stroke coordinate normalization to 0-1 range"
        postconditions: "All normalized coordinates are between 0.0 and 1.0"
      
      - type: "function"
        name: "test_stroke_continuity"
        description: "Tests that strokes remain continuous without gaps"
        postconditions: "Each point connects to previous point in sequence"
      
      - type: "function"
        name: "test_multiple_strokes"
        description: "Verifies handling of multiple sequential strokes"
        postconditions: "All strokes are maintained in chronological order"

formal_verification:
  needed: false
  level: "None"
  explanation: |
    Formal verification is not required for the handwriting canvas system because:
    
    1. The system is primarily an interactive UI component with non-critical behavior.
       Errors in stroke rendering or input handling would be immediately visible to users
       and do not pose safety, security, or data integrity risks.
    
    2. The correctness properties (stroke continuity, point sampling, coordinate 
       normalization) can be effectively validated through integration testing with
       simulated input events and visual regression testing.
    
    3. The state machine (idle → drawing → stroke complete) is simple with only three
       states and deterministic transitions triggered by mouse/touch events. The logic
       is straightforward enough that standard unit and integration tests provide
       adequate confidence.
    
    4. The canvas operates on local user input data that can be easily regenerated.
       Unlike systems handling persistent data, financial transactions, or safety-critical
       operations, incorrect behavior here only affects the current drawing session.
    
    5. The distance threshold filtering and coordinate normalization are simple arithmetic
       operations that can be thoroughly tested with property-based testing if needed,
       but don't require formal proof of correctness.
    
    Standard testing approaches (unit tests for stroke data structures, integration tests
    for event handling, property tests for normalization invariants) are sufficient and
    more cost-effective than formal verification for this UI component.

tests:
  strategy:
    approach: "mixed (unit + integration + property-based)"
    rationale:
      - "Unit tests verify stroke data structures, point normalization, and distance thresholding logic independently"
      - "Integration tests validate the complete input-to-render pipeline with simulated mouse events"
      - "Canvas widget requires integration testing since it implements canvas::Program trait and depends on event handling state machine"
      - "Stroke rendering and visual feedback require integration with iced's canvas system"
      - "Property-based testing ensures distance threshold and normalization work correctly across all input ranges"

  implementation:
    file: "src/ui/handwriting_canvas.rs"
    location: "in existing test module"
    code: |
      #[cfg(test)]
      mod tests {
          use super::*;
          use iced::Point as IcedPoint;
          use std::time::{Duration, SystemTime};

          // Unit tests for Stroke data structure
          #[test]
          fn test_stroke_creation_empty() {
              let stroke = Stroke::new();
              assert!(stroke.points.is_empty());
              assert!(stroke.timestamps.is_empty());
          }

          #[test]
          fn test_stroke_add_point() {
              let mut stroke = Stroke::new();
              let point = IcedPoint::new(10.0, 20.0);
              stroke.add_point(point);
              
              assert_eq!(stroke.points.len(), 1);
              assert_eq!(stroke.timestamps.len(), 1);
              assert_eq!(stroke.points[0], point);
          }

          #[test]
          fn test_stroke_normalization() {
              let mut stroke = Stroke::new();
              stroke.add_point(IcedPoint::new(0.0, 0.0));
              stroke.add_point(IcedPoint::new(100.0, 50.0));
              stroke.add_point(IcedPoint::new(200.0, 200.0));
              
              let normalized = stroke.normalize(200.0, 200.0);
              
              assert_eq!(normalized.len(), 3);
              assert_eq!(normalized[0].x, 0.0);
              assert_eq!(normalized[0].y, 0.0);
              assert_eq!(normalized[1].x, 0.5);
              assert_eq!(normalized[1].y, 0.25);
              assert_eq!(normalized[2].x, 1.0);
              assert_eq!(normalized[2].y, 1.0);
          }

          #[test]
          fn test_distance_threshold_filtering() {
              let point1 = IcedPoint::new(10.0, 10.0);
              let point2 = IcedPoint::new(10.5, 10.5);
              let point3 = IcedPoint::new(15.0, 15.0);
              
              assert!(!should_add_point(point1, point2, 2.0));
              assert!(should_add_point(point1, point3, 2.0));
          }

          #[test]
          fn test_distance_calculation() {
              let p1 = IcedPoint::new(0.0, 0.0);
              let p2 = IcedPoint::new(3.0, 4.0);
              let distance = calculate_distance(p1, p2);
              
              assert!((distance - 5.0).abs() < 0.001);
          }

          #[test]
          fn test_drawing_state_initial() {
              let state = DrawingState::new();
              
              assert!(!state.is_drawing);
              assert!(state.current_stroke.is_none());
              assert!(state.completed_strokes.is_empty());
          }

          #[test]
          fn test_drawing_state_start_stroke() {
              let mut state = DrawingState::new();
              state.start_stroke(IcedPoint::new(10.0, 10.0));
              
              assert!(state.is_drawing);
              assert!(state.current_stroke.is_some());
              if let Some(ref stroke) = state.current_stroke {
                  assert_eq!(stroke.points.len(), 1);
              }
          }

          #[test]
          fn test_drawing_state_add_point_to_current_stroke() {
              let mut state = DrawingState::new();
              state.start_stroke(IcedPoint::new(10.0, 10.0));
              state.add_point(IcedPoint::new(15.0, 15.0));
              
              if let Some(ref stroke) = state.current_stroke {
                  assert_eq!(stroke.points.len(), 2);
              } else {
                  panic!("Current stroke should exist");
              }
          }

          #[test]
          fn test_drawing_state_complete_stroke() {
              let mut state = DrawingState::new();
              state.start_stroke(IcedPoint::new(10.0, 10.0));
              state.add_point(IcedPoint::new(15.0, 15.0));
              state.complete_stroke();
              
              assert!(!state.is_drawing);
              assert!(state.current_stroke.is_none());
              assert_eq!(state.completed_strokes.len(), 1);
              assert_eq!(state.completed_strokes[0].points.len(), 2);
          }

          #[test]
          fn test_drawing_state_clear() {
              let mut state = DrawingState::new();
              state.start_stroke(IcedPoint::new(10.0, 10.0));
              state.complete_stroke();
              state.start_stroke(IcedPoint::new(20.0, 20.0));
              state.complete_stroke();
              
              assert_eq!(state.completed_strokes.len(), 2);
              
              state.clear();
              
              assert!(state.completed_strokes.is_empty());
              assert!(!state.is_drawing);
              assert!(state.current_stroke.is_none());
          }

          #[test]
          fn test_drawing_state_undo() {
              let mut state = DrawingState::new();
              state.start_stroke(IcedPoint::new(10.0, 10.0));
              state.complete_stroke();
              state.start_stroke(IcedPoint::new(20.0, 20.0));
              state.complete_stroke();
              
              assert_eq!(state.completed_strokes.len(), 2);
              
              state.undo();
              
              assert_eq!(state.completed_strokes.len(), 1);
          }

          #[test]
          fn test_undo_empty_does_nothing() {
              let mut state = DrawingState::new();
              state.undo();
              
              assert!(state.completed_strokes.is_empty());
          }

          #[test]
          fn test_export_stroke_data_empty() {
              let state = DrawingState::new();
              let exported = state.export_stroke_data(200.0, 200.0);
              
              assert!(exported.is_empty());
          }

          #[test]
          fn test_export_stroke_data_multiple_strokes() {
              let mut state = DrawingState::new();
              
              state.start_stroke(IcedPoint::new(0.0, 0.0));
              state.add_point(IcedPoint::new(100.0, 100.0));
              state.complete_stroke();
              
              state.start_stroke(IcedPoint::new(50.0, 50.0));
              state.add_point(IcedPoint::new(150.0, 150.0));
              state.complete_stroke();
              
              let exported = state.export_stroke_data(200.0, 200.0);
              
              assert_eq!(exported.len(), 2);
              assert_eq!(exported[0].len(), 2);
              assert_eq!(exported[1].len(), 2);
              
              assert!(exported[0][0].x >= 0.0 && exported[0][0].x <= 1.0);
              assert!(exported[0][0].y >= 0.0 && exported[0][0].y <= 1.0);
          }

          #[test]
          fn test_multiple_strokes_maintain_sequence() {
              let mut state = DrawingState::new();
              
              state.start_stroke(IcedPoint::new(10.0, 10.0));
              state.complete_stroke();
              
              state.start_stroke(IcedPoint::new(20.0, 20.0));
              state.complete_stroke();
              
              state.start_stroke(IcedPoint::new(30.0, 30.0));
              state.complete_stroke();
              
              assert_eq!(state.completed_strokes.len(), 3);
              assert_eq!(state.completed_strokes[0].points[0].x, 10.0);
              assert_eq!(state.completed_strokes[1].points[0].x, 20.0);
              assert_eq!(state.completed_strokes[2].points[0].x, 30.0);
          }

          #[test]
          fn test_stroke_continuity_no_gaps() {
              let mut stroke = Stroke::new();
              let points = vec![
                  IcedPoint::new(10.0, 10.0),
                  IcedPoint::new(15.0, 15.0),
                  IcedPoint::new(20.0, 20.0),
                  IcedPoint::new(25.0, 25.0),
              ];
              
              for point in points.iter() {
                  stroke.add_point(*point);
              }
              
              assert_eq!(stroke.points.len(), 4);
              
              for (i, point) in points.iter().enumerate() {
                  assert_eq!(stroke.points[i], *point);
              }
          }

          #[test]
          fn test_timestamp_recording() {
              let mut stroke = Stroke::new();
              
              stroke.add_point(IcedPoint::new(10.0, 10.0));
              std::thread::sleep(Duration::from_millis(10));
              stroke.add_point(IcedPoint::new(20.0, 20.0));
              
              assert_eq!(stroke.timestamps.len(), 2);
              
              let t1 = stroke.timestamps[0];
              let t2 = stroke.timestamps[1];
              assert!(t2 > t1);
              
              let duration = t2.duration_since(t1).unwrap();
              assert!(duration.as_millis() >= 10);
          }

          #[test]
          fn test_distance_threshold_consistency() {
              let mut state = DrawingState::new();
              state.start_stroke(IcedPoint::new(10.0, 10.0));
              
              for i in 1..=20 {
                  let point = IcedPoint::new(10.0 + (i as f32) * 0.1, 10.0);
                  state.add_point_with_threshold(point, 2.0);
              }
              
              if let Some(ref stroke) = state.current_stroke {
                  assert!(stroke.points.len() < 20);
                  
                  for i in 1..stroke.points.len() {
                      let dist = calculate_distance(stroke.points[i-1], stroke.points[i]);
                      assert!(dist >= 1.9);
                  }
              }
          }

          #[test]
          fn test_normalization_preserves_aspect_ratio() {
              let mut stroke = Stroke::new();
              stroke.add_point(IcedPoint::new(0.0, 0.0));
              stroke.add_point(IcedPoint::new(100.0, 200.0));
              
              let normalized = stroke.normalize(200.0, 200.0);
              
              assert!((normalized[1].x - 0.5).abs() < 0.001);
              assert!((normalized[1].y - 1.0).abs() < 0.001);
          }

          #[test]
          fn test_canvas_bounds_normalization() {
              let mut stroke = Stroke::new();
              
              stroke.add_point(IcedPoint::new(0.0, 0.0));
              stroke.add_point(IcedPoint::new(200.0, 0.0));
              stroke.add_point(IcedPoint::new(200.0, 200.0));
              stroke.add_point(IcedPoint::new(0.0, 200.0));
              
              let normalized = stroke.normalize(200.0, 200.0);
              
              assert_eq!(normalized[0], IcedPoint::new(0.0, 0.0));
              assert_eq!(normalized[1], IcedPoint::new(1.0, 0.0));
              assert_eq!(normalized[2], IcedPoint::new(1.0, 1.0));
              assert_eq!(normalized[3], IcedPoint::new(0.0, 1.0));
          }

          fn simulate_mouse_drag(state: &mut DrawingState, start: IcedPoint, end: IcedPoint, steps: usize) {
              state.start_stroke(start);
              
              for i in 1..=steps {
                  let t = i as f32 / steps as f32;
                  let x = start.x + (end.x - start.x) * t;
                  let y = start.y + (end.y - start.y) * t;
                  state.add_point(IcedPoint::new(x, y));
              }
              
              state.complete_stroke();
          }

          #[test]
          fn test_integration_complete_drawing_flow() {
              let mut state = DrawingState::new();
              
              simulate_mouse_drag(
                  &mut state,
                  IcedPoint::new(10.0, 10.0),
                  IcedPoint::new(100.0, 100.0),
                  10
              );
              
              assert_eq!(state.completed_strokes.len(), 1);
              assert!(state.completed_strokes[0].points.len() > 0);
              
              let exported = state.export_stroke_data(200.0, 200.0);
              assert_eq!(exported.len(), 1);
              assert!(exported[0].len() > 0);
          }

          #[test]
          fn test_integration_multiple_stroke_sequence() {
              let mut state = DrawingState::new();
              
              simulate_mouse_drag(&mut state, IcedPoint::new(10.0, 10.0), IcedPoint::new(50.0, 50.0), 5);
              simulate_mouse_drag(&mut state, IcedPoint::new(60.0, 10.0), IcedPoint::new(100.0, 50.0), 5);
              simulate_mouse_drag(&mut state, IcedPoint::new(10.0, 60.0), IcedPoint::new(50.0, 100.0), 5);
              
              assert_eq!(state.completed_strokes.len(), 3);
              
              let exported = state.export_stroke_data(200.0, 200.0);
              assert_eq!(exported.len(), 3);
          }

          #[test]
          fn test_integration_clear_during_drawing() {
              let mut state = DrawingState::new();
              
              simulate_mouse_drag(&mut state, IcedPoint::new(10.0, 10.0), IcedPoint::new(50.0, 50.0), 5);
              state.start_stroke(IcedPoint::new(60.0, 60.0));
              state.add_point(IcedPoint::new(70.0, 70.0));
              
              state.clear();
              
              assert!(state.completed_strokes.is_empty());
              assert!(!state.is_drawing);
              assert!(state.current_stroke.is_none());
          }

          #[test]
          fn test_integration_undo_sequence() {
              let mut state = DrawingState::new();
              
              simulate_mouse_drag(&mut state, IcedPoint::new(10.0, 10.0), IcedPoint::new(50.0, 50.0), 5);
              simulate_mouse_drag(&mut state, IcedPoint::new(60.0, 10.0), IcedPoint::new(100.0, 50.0), 5);
              simulate_mouse_drag(&mut state, IcedPoint::new(10.0, 60.0), IcedPoint::new(50.0, 100.0), 5);
              
              assert_eq!(state.completed_strokes.len(), 3);
              
              state.undo();
              assert_eq!(state.completed_strokes.len(), 2);
              
              state.undo();
              assert_eq!(state.completed_strokes.len(), 1);
              
              state.undo();
              assert_eq!(state.completed_strokes.len(), 0);
              
              state.undo();
              assert_eq!(state.completed_strokes.len(), 0);
          }

          fn should_add_point(last_point: IcedPoint, new_point: IcedPoint, threshold: f32) -> bool {
              calculate_distance(last_point, new_point) >= threshold
          }

          fn calculate_distance(p1: IcedPoint, p2: IcedPoint) -> f32 {
              let dx = p2.x - p1.x;
              let dy = p2.y - p1.y;
              (dx * dx + dy * dy).sqrt()
          }
      }

      #[cfg(test)]
      mod property_tests {
          use super::*;
          use proptest::prelude::*;
          use iced::Point as IcedPoint;

          proptest! {
              #[test]
              fn prop_normalization_bounds(
                  x in 0.0f32..1000.0,
                  y in 0.0f32..1000.0,
                  width in 100.0f32..1000.0,
                  height in 100.0f32..1000.0
              ) {
                  let mut stroke = Stroke::new();
                  stroke.add_point(IcedPoint::new(x, y));
                  
                  let normalized = stroke.normalize(width, height);
                  
                  for point in normalized {
                      prop_assert!(point.x >= 0.0 && point.x <= 1.0);
                      prop_assert!(point.y >= 0.0 && point.y <= 1.0);
                  }
              }
          }

          proptest! {
              #[test]
              fn prop_distance_threshold_filters(
                  x1 in 0.0f32..200.0,
                  y1 in 0.0f32..200.0,
                  dx in -1.0f32..1.0,
                  dy in -1.0f32..1.0
              ) {
                  let p1 = IcedPoint::new(x1, y1);
                  let p2 = IcedPoint::new(x1 + dx, y1 + dy);
                  let threshold = 2.0;
                  
                  let distance = calculate_distance(p1, p2);
                  let should_add = distance >= threshold;
                  
                  prop_assert_eq!(should_add, should_add_point(p1, p2, threshold));
              }
          }

          proptest! {
              #[test]
              fn prop_timestamp_count_matches_points(
                  points in prop::collection::vec((0.0f32..200.0, 0.0f32..200.0), 1..50)
              ) {
                  let mut stroke = Stroke::new();
                  
                  for (x, y) in points {
                      stroke.add_point(IcedPoint::new(x, y));
                  }
                  
                  prop_assert_eq!(stroke.points.len(), stroke.timestamps.len());
              }
          }

          proptest! {
              #[test]
              fn prop_undo_reduces_count(
                  stroke_count in 1usize..10
              ) {
                  let mut state = DrawingState::new();
                  
                  for i in 0..stroke_count {
                      state.start_stroke(IcedPoint::new(i as f32 * 10.0, i as f32 * 10.0));
                      state.complete_stroke();
                  }
                  
                  let before = state.completed_strokes.len();
                  state.undo();
                  let after = state.completed_strokes.len();
                  
                  prop_assert_eq!(after, before - 1);
              }
          }

          fn calculate_distance(p1: IcedPoint, p2: IcedPoint) -> f32 {
              let dx = p2.x - p1.x;
              let dy = p2.y - p1.y;
              (dx * dx + dy * dy).sqrt()
          }

          fn should_add_point(last_point: IcedPoint, new_point: IcedPoint, threshold: f32) -> bool {
              calculate_distance(last_point, new_point) >= threshold
          }
      }

  coverage:
    - "Stroke creation and initialization"
    - "Adding points to strokes"
    - "Stroke normalization to 0-1 coordinate range"
    - "Distance threshold filtering for point sampling"
    - "Distance calculation between points"
    - "DrawingState initialization"
    - "Starting a new stroke"
    - "Adding points to current stroke"
    - "Completing a stroke"
    - "Clearing all strokes"
    - "Undo operation for last stroke"
    - "Undo on empty state does nothing"
    - "Exporting stroke data for empty canvas"
    - "Exporting multiple strokes with normalization"
    - "Multiple strokes maintain correct sequence"
    - "Stroke continuity without gaps"
    - "Timestamp recording for each point"
    - "Distance threshold maintains consistent spacing"
    - "Normalization preserves aspect ratio"
    - "Canvas boundary normalization"
    - "Complete drawing flow from start to export"
    - "Multiple stroke sequence handling"
    - "Clear operation during active drawing"
    - "Sequential undo operations"
    - "Property: Normalization always produces [0,1] bounds"
    - "Property: Distance threshold filters close points"
    - "Property: Timestamp count matches point count"
    - "Property: Undo reduces stroke count correctly"

dependencies:
  depends_on:
    - task_id: 1
      reason: "Requires iced framework foundation including Canvas widget support and canvas::Program trait"

  depended_upon_by:
    - task_id: 8
      reason: "Practice mode integrates HandwritingCanvas for user input during character practice exercises"
    - task_id: 9
      reason: "Recognition system consumes normalized stroke data exported from canvas for character matching"

  external:
    - name: "iced::widget::canvas"
      type: "module"
      status: "already exists"
    - name: "iced::widget::canvas::Program"
      type: "trait"
      status: "already exists"
    - name: "iced::Point"
      type: "struct"
      status: "already exists"
    - name: "lyon::path::Path"
      type: "struct"
      status: "already exists"
    - name: "lyon::path::Builder"
      type: "struct"
      status: "already exists"
    - name: "std::time::SystemTime"
      type: "struct"
      status: "already exists"
---
task:
  id: 6
  name: "Application State Management and Navigation"

context:
  description: |
    This task implements the core state management system for the Chinese character learning
    application using the Elm architecture pattern. The Elm architecture provides a clean,
    testable, and maintainable approach to managing application state through a unidirectional
    data flow: view produces messages, update handles messages and produces new state, and
    the cycle repeats.
    
    The state management system consists of four primary components:
    1. Screen enum - represents all application screens (MainMenu, Learning, Practice, Statistics,
       Settings) with each variant carrying screen-specific state
    2. Message enum - captures all possible user interactions and system events
    3. AppState struct - the root state container holding the current screen and shared data
    4. Application::update() - the pure state transition function that routes messages to handlers
    
    This architecture ensures predictable behavior, facilitates testing (state transitions are
    pure functions), and prevents common bugs like race conditions or inconsistent state. The
    implementation must handle complex interactions including learning sessions with SRS review
    queues, practice sessions with real-time drawing, and asynchronous operations like database
    persistence and character recognition.
    
    The Elm architecture's constraint of pure update functions means all side effects (database
    operations, API calls) are expressed as Tasks that eventually produce new Messages, maintaining
    referential transparency and testability throughout the application.

  key_points:
    - "State transitions are pure functions - no side effects in update(), all async operations via Task"
    - "Screen enum variants own their respective session state (LearningState, PracticeState, etc.)"
    - "Shared state (progress, settings) managed via Arc<RwLock> for thread-safe access"
    - "Navigation triggers screen transitions and proper state initialization/cleanup"
    - "Large update() function requires decomposition into screen-specific handlers for maintainability"
    - "Message enum must be comprehensive and descriptive to document all possible interactions"
    - "Type system should make invalid states unrepresentable where possible"
    - "Session data must persist correctly across screen transitions and be recoverable"

files:
  - path: "src/state/mod.rs"
    description: "Module declaration file exposing Screen, Message, and AppState types for state management"
  
  - path: "src/state/screen.rs"
    description: "Defines Screen enum with variants for all application screens (MainMenu, Learning, Practice, Statistics) and associated state"
  
  - path: "src/state/message.rs"
    description: "Defines Message enum covering all user interactions, navigation events, and system messages"
  
  - path: "src/state/app_state.rs"
    description: "Defines AppState struct as the root state container holding current screen, shared progress data, and settings"
  
  - path: "src/state/navigation.rs"
    description: "Helper functions for screen transitions, state initialization, and navigation stack management"
  
  - path: "src/application.rs"
    description: "Implementation of Application::update() function - the core state transition handler implementing Elm architecture"
  
  - path: "src/state/update_handlers.rs"
    description: "Screen-specific update handler functions to decompose the main update() logic into manageable pieces"
  
  - path: "tests/state_management_tests.rs"
    description: "Comprehensive unit tests for state transitions, message handling, and navigation flows"

functions:
  - file: "src/state/mod.rs"
    items:
      - type: "module_declaration"
        name: "pub mod screen"
        description: "Module containing Screen enum and screen-specific state types"
      - type: "module_declaration"
        name: "pub mod message"
        description: "Module containing Message enum for all application events"
      - type: "module_declaration"
        name: "pub mod navigation"
        description: "Module containing navigation helper functions"
      - type: "struct"
        name: "AppState"
        description: "Root application state container holding current screen, progress tracker, and settings"
        invariants: "Always contains valid screen state; progress and settings are thread-safe via Arc<RwLock>"
      - type: "method"
        name: "AppState::new"
        description: "Creates initial AppState with MainMenu screen and loads progress/settings from database"
        postconditions: "Returns AppState with initialized MainMenu screen and loaded user data"
      - type: "method"
        name: "AppState::current_screen"
        description: "Returns reference to current Screen variant"
      - type: "method"
        name: "AppState::current_screen_mut"
        description: "Returns mutable reference to current Screen variant"

  - file: "src/state/screen.rs"
    items:
      - type: "enum"
        name: "Screen"
        description: "Represents all application screens, each variant carrying screen-specific state"
        invariants: "Each variant maintains valid state for its screen type; state transitions preserve data integrity"
      - type: "enum_variant"
        name: "Screen::MainMenu"
        description: "Main menu screen with no additional state"
      - type: "enum_variant"
        name: "Screen::Learning(LearningState)"
        description: "Learning session screen with active session state"
      - type: "enum_variant"
        name: "Screen::Practice(PracticeState)"
        description: "Practice session screen with practice mode state"
      - type: "enum_variant"
        name: "Screen::Statistics(StatisticsState)"
        description: "Statistics and progress screen with loaded stats data"
      - type: "enum_variant"
        name: "Screen::Settings"
        description: "Settings configuration screen with no additional state"
      - type: "struct"
        name: "LearningState"
        description: "State for learning session including current character, review queue, and session progress"
        invariants: "Review queue never empty during active session; current_character always valid"
      - type: "method"
        name: "LearningState::new"
        description: "Creates new learning session state with initialized review queue"
        preconditions: "Review items available in database"
        postconditions: "Returns LearningState with populated review queue and first character loaded"
      - type: "method"
        name: "LearningState::current_character"
        description: "Returns reference to current character being learned"
      - type: "method"
        name: "LearningState::advance_to_next"
        description: "Advances to next character in review queue"
        preconditions: "Review queue not empty"
        postconditions: "Current character updated to next in queue or session complete"
      - type: "method"
        name: "LearningState::session_progress"
        description: "Returns (reviewed_count, total_count) for progress display"
      - type: "struct"
        name: "PracticeState"
        description: "State for practice session including mode, current character, and drawing canvas state"
        invariants: "Canvas state synchronized with current character; practice mode remains constant during session"
      - type: "method"
        name: "PracticeState::new"
        description: "Creates new practice session state for given mode and character set"
        postconditions: "Returns PracticeState with initialized canvas and first character"
      - type: "method"
        name: "PracticeState::current_character"
        description: "Returns reference to current character being practiced"
      - type: "method"
        name: "PracticeState::canvas_state"
        description: "Returns reference to drawing canvas state"
      - type: "method"
        name: "PracticeState::canvas_state_mut"
        description: "Returns mutable reference to drawing canvas state"
      - type: "method"
        name: "PracticeState::submit_drawing"
        description: "Submits current drawing for recognition and validation"
        postconditions: "Recognition result stored; feedback ready for display"
      - type: "struct"
        name: "StatisticsState"
        description: "State for statistics screen with loaded character progress and performance metrics"
      - type: "method"
        name: "StatisticsState::new"
        description: "Creates statistics state by loading all progress data from database"
        postconditions: "Returns StatisticsState with complete progress history and computed metrics"
      - type: "method"
        name: "StatisticsState::character_progress"
        description: "Returns progress data for all characters"
      - type: "method"
        name: "StatisticsState::overall_stats"
        description: "Returns aggregated statistics across all characters"

  - file: "src/state/message.rs"
    items:
      - type: "enum"
        name: "Message"
        description: "All possible user interactions and system events that trigger state changes"
      - type: "enum_variant"
        name: "Message::NavigateToMainMenu"
        description: "Navigate to main menu screen"
      - type: "enum_variant"
        name: "Message::NavigateToLearning"
        description: "Navigate to learning session screen and initialize session"
      - type: "enum_variant"
        name: "Message::NavigateToPractice(PracticeMode)"
        description: "Navigate to practice screen with specified mode"
      - type: "enum_variant"
        name: "Message::NavigateToStatistics"
        description: "Navigate to statistics screen and load data"
      - type: "enum_variant"
        name: "Message::NavigateToSettings"
        description: "Navigate to settings screen"
      - type: "enum_variant"
        name: "Message::LearningSessionStarted(Result<LearningState, String>)"
        description: "Learning session initialization completed (success or error)"
      - type: "enum_variant"
        name: "Message::ReviewResponse(ReviewRating)"
        description: "User rated current character in learning session"
      - type: "enum_variant"
        name: "Message::NextReviewItem"
        description: "Advance to next character in learning session"
      - type: "enum_variant"
        name: "Message::LearningSessionComplete"
        description: "All review items completed in learning session"
      - type: "enum_variant"
        name: "Message::PracticeSessionStarted(Result<PracticeState, String>)"
        description: "Practice session initialization completed (success or error)"
      - type: "enum_variant"
        name: "Message::DrawingStrokeStarted(Point)"
        description: "User started drawing stroke at point"
      - type: "enum_variant"
        name: "Message::DrawingStrokeContinued(Point)"
        description: "User continued drawing stroke to point"
      - type: "enum_variant"
        name: "Message::DrawingStrokeEnded"
        description: "User finished drawing stroke"
      - type: "enum_variant"
        name: "Message::ClearCanvas"
        description: "Clear all strokes from drawing canvas"
      - type: "enum_variant"
        name: "Message::UndoStroke"
        description: "Remove last stroke from canvas"
      - type: "enum_variant"
        name: "Message::SubmitDrawing"
        description: "Submit drawing for recognition"
      - type: "enum_variant"
        name: "Message::RecognitionResult(Result<RecognitionResponse, String>)"
        description: "Recognition engine returned result"
      - type: "enum_variant"
        name: "Message::NextPracticeCharacter"
        description: "Move to next character in practice session"
      - type: "enum_variant"
        name: "Message::StatisticsLoaded(Result<StatisticsState, String>)"
        description: "Statistics data loaded from database"
      - type: "enum_variant"
        name: "Message::SettingChanged(SettingKey, SettingValue)"
        description: "User changed application setting"
      - type: "enum_variant"
        name: "Message::ExitApplication"
        description: "User requested application exit"
      - type: "enum_variant"
        name: "Message::Noop"
        description: "No-op message for tasks that don't produce meaningful results"

  - file: "src/state/navigation.rs"
    items:
      - type: "function"
        name: "navigate_to_learning"
        description: "Creates Task to initialize learning session and return LearningSessionStarted message"
        postconditions: "Returns Task that loads review queue and creates LearningState"
      - type: "function"
        name: "navigate_to_practice"
        description: "Creates Task to initialize practice session and return PracticeSessionStarted message"
        preconditions: "Valid PracticeMode provided"
        postconditions: "Returns Task that loads character set and creates PracticeState"
      - type: "function"
        name: "navigate_to_statistics"
        description: "Creates Task to load statistics data and return StatisticsLoaded message"
        postconditions: "Returns Task that queries database for all progress data"
      - type: "function"
        name: "save_review_result"
        description: "Creates Task to persist review rating to database"
        preconditions: "Valid character and rating provided"
        postconditions: "Returns Task that updates character progress in database"
      - type: "function"
        name: "save_practice_result"
        description: "Creates Task to persist practice attempt to database"
        preconditions: "Valid character and recognition result provided"
        postconditions: "Returns Task that records practice session data"
      - type: "function"
        name: "save_setting"
        description: "Creates Task to persist setting change to database"
        preconditions: "Valid setting key and value provided"
        postconditions: "Returns Task that updates setting in database"

  - file: "src/application.rs"
    items:
      - type: "trait_impl"
        name: "impl Application for App"
        description: "iced::Application trait implementation for main app struct"
      - type: "method"
        name: "App::update"
        description: "Core state transition function implementing Elm architecture update logic; routes all messages to appropriate handlers"
        preconditions: "AppState is in valid state; Message is well-formed"
        postconditions: "Returns new AppState and optional Task for async operations; state remains consistent"
        invariants: "Pure function with no side effects; all state changes explicit; async operations via Task only"
      - type: "method"
        name: "App::update_learning"
        description: "Handles learning session messages (ReviewResponse, NextReviewItem, etc.)"
        preconditions: "Current screen is Learning"
        postconditions: "Learning state updated according to message; Task for database operations if needed"
      - type: "method"
        name: "App::update_practice"
        description: "Handles practice session messages (drawing, submission, recognition results)"
        preconditions: "Current screen is Practice"
        postconditions: "Practice state updated; canvas modified; Task for recognition if needed"
      - type: "method"
        name: "App::update_statistics"
        description: "Handles statistics screen messages"
        preconditions: "Current screen is Statistics"
        postconditions: "Statistics state refreshed if needed"
      - type: "method"
        name: "App::update_settings"
        description: "Handles settings screen messages (SettingChanged)"
        preconditions: "Current screen is Settings"
        postconditions: "Settings updated; Task to persist changes to database"
      - type: "method"
        name: "App::handle_navigation"
        description: "Handles navigation messages and screen transitions"
        postconditions: "Screen changed to target; initialization Task created if needed; previous screen state cleaned up"

  - file: "src/types.rs"
    items:
      - type: "enum"
        name: "PracticeMode"
        description: "Practice session mode selector"
      - type: "enum_variant"
        name: "PracticeMode::Timed"
        description: "Timed practice mode with countdown"
      - type: "enum_variant"
        name: "PracticeMode::Freestyle"
        description: "Freestyle practice without time limit"
      - type: "enum_variant"
        name: "PracticeMode::Specific(Vec<CharacterId>)"
        description: "Practice specific set of characters"
      - type: "enum"
        name: "ReviewRating"
        description: "User rating for review item (SRS)"
      - type: "enum_variant"
name: "ReviewRating::Again"
        description: "Failed - review again soon"
      - type: "enum_variant"
        name: "ReviewRating::Hard"
        description: "Difficult - shorter interval"
      - type: "enum_variant"
        name: "ReviewRating::Good"
        description: "Correct - normal interval"
      - type: "enum_variant"
        name: "ReviewRating::Easy"
        description: "Easy - longer interval"
      - type: "struct"
        name: "Point"
        description: "2D point for drawing coordinates"
      - type: "struct"
        name: "Stroke"
        description: "Collection of points representing single drawing stroke"
      - type: "struct"
        name: "CanvasState"
        description: "Drawing canvas state with stroke history and current stroke"
      - type: "method"
        name: "CanvasState::new"
        description: "Creates empty canvas state"
      - type: "method"
        name: "CanvasState::start_stroke"
        description: "Begins new stroke at given point"
        postconditions: "Current stroke initialized with starting point"
      - type: "method"
        name: "CanvasState::continue_stroke"
        description: "Adds point to current stroke"
        preconditions: "Stroke already started"
        postconditions: "Point appended to current stroke"
      - type: "method"
        name: "CanvasState::end_stroke"
        description: "Finalizes current stroke and adds to history"
        preconditions: "Stroke already started"
        postconditions: "Current stroke moved to history; no active stroke"
      - type: "method"
        name: "CanvasState::clear"
        description: "Removes all strokes from canvas"
        postconditions: "All strokes cleared; canvas empty"
      - type: "method"
        name: "CanvasState::undo"
        description: "Removes last completed stroke"
        postconditions: "Last stroke removed from history if present"
      - type: "method"
        name: "CanvasState::to_bitmap"
        description: "Converts strokes to bitmap for recognition"
        postconditions: "Returns bitmap representation of all strokes"
      - type: "enum"
        name: "SettingKey"
        description: "Application setting identifiers"
      - type: "enum_variant"
        name: "SettingKey::AnimationSpeed"
        description: "Stroke animation playback speed"
      - type: "enum_variant"
        name: "SettingKey::ShowHints"
        description: "Whether to show character hints"
      - type: "enum_variant"
        name: "SettingKey::DarkMode"
        description: "UI theme selection"
      - type: "enum"
        name: "SettingValue"
        description: "Setting value types"
      - type: "enum_variant"
        name: "SettingValue::Float(f32)"
        description: "Floating point setting value"
      - type: "enum_variant"
        name: "SettingValue::Bool(bool)"
        description: "Boolean setting value"
      - type: "enum_variant"
        name: "SettingValue::String(String)"
        description: "String setting value"

  - file: "tests/state_management_tests.rs"
    items:
      - type: "function"
        name: "test_initial_state"
        description: "Verifies AppState::new creates valid initial state with MainMenu screen"
      - type: "function"
        name: "test_navigate_to_learning"
        description: "Tests navigation from MainMenu to Learning screen"
      - type: "function"
        name: "test_navigate_to_practice"
        description: "Tests navigation from MainMenu to Practice screen with different modes"
      - type: "function"
        name: "test_learning_review_flow"
        description: "Tests complete learning session flow: start, rate characters, advance, complete"
      - type: "function"
        name: "test_practice_drawing_flow"
        description: "Tests practice session drawing: start stroke, continue, end, undo, clear"
      - type: "function"
        name: "test_practice_submission"
        description: "Tests drawing submission and recognition result handling"
      - type: "function"
        name: "test_navigation_stack"
        description: "Tests back/forward navigation maintains proper state"
      - type: "function"
        name: "test_session_state_preservation"
        description: "Verifies session state preserved when navigating away and back"
      - type: "function"
        name: "test_settings_persistence"
        description: "Tests setting changes trigger proper state updates and persistence"
      - type: "function"
        name: "test_invalid_state_transitions"
        description: "Verifies invalid message/state combinations handled gracefully"
      - type: "function"
        name: "test_canvas_state_operations"
        description: "Tests all CanvasState operations maintain invariants"
      - type: "function"
        name: "test_learning_state_queue_management"
        description: "Tests LearningState review queue advances correctly"
      - type: "function"
        name: "test_message_idempotency"
        description: "Verifies repeated messages don't corrupt state"
      - type: "function"
        name: "test_screen_cleanup"
        description: "Tests screen state properly cleaned up on navigation"
      - type: "function"
        name: "prop_state_transitions_deterministic"
        description: "Property test: same state + message always produces same result"

formal_verification:
  needed: true
  level: "Critical"
  explanation: |
    State management is the most critical component of the application as it controls
    all state transitions, data flow, and application behavior. Bugs in state management
    can lead to data loss, inconsistent UI states, crashes, or security issues. Given
    the complexity (large update() function, async operations, shared state with Arc<RwLock>),
    formal verification is essential to prove correctness properties that are difficult
    to exhaustively test.
    
    Key reasons verification is critical:
    1. State space explosion - with multiple screens and session states, the number
       of possible states grows combinatorially, making exhaustive testing impractical
    2. Concurrency concerns - Arc<RwLock> for shared state introduces potential for
       deadlocks and race conditions that are notoriously hard to catch with testing
    3. Data integrity - learning progress and statistics must never be corrupted or lost
    4. Safety-critical transitions - invalid state transitions could corrupt user data
       or make the application unusable
    5. Elm architecture guarantees - the update function must be pure and referentially
       transparent, which are properties that can be formally verified
    
    While unit tests (15 estimated) will cover common cases, formal verification provides
    mathematical guarantees about state transition correctness, unreachability of invalid
    states, and proper async operation handling that testing alone cannot provide.

  properties:
    - name: "State Consistency"
      formal_statement: |
        ∀ state: AppState, msg: Message. 
        let (new_state, _) = update(state, msg) in
        is_valid_state(new_state) = true
        
        Where is_valid_state ensures:
        - Screen state matches current Screen variant
        - Session state is properly initialized when entering Learning/Practice screens
        - Shared data (progress, settings) remains consistent
        - No dangling references or uninitialized fields

    - name: "Referential Transparency"
      formal_statement: |
        ∀ state: AppState, msg: Message.
        update(state.clone(), msg.clone()) = update(state.clone(), msg.clone())
        
        The update function must be pure - calling it multiple times with the same
        inputs produces identical results with no side effects.

    - name: "State Reachability"
      formal_statement: |
        ∀ screen: Screen. ∃ sequence: Vec<Message>.
        let final_state = sequence.iter().fold(initial_state(), update) in
        final_state.current_screen = screen
        
        All screens must be reachable from the initial state through some sequence
        of valid messages.

    - name: "No Invalid States"
      formal_statement: |
        ∀ state: AppState, msg: Message.
        update(state, msg) never produces a state where:
        - Screen variant data is None when it should be Some
        - Session data is inconsistent (e.g., current_index > items.len())
        - Arc<RwLock> is poisoned or deadlocked
        - Navigation stack contains unreachable screens

    - name: "Progress Preservation"
      formal_statement: |
        ∀ state: AppState, msg: Message.
        let (new_state, _) = update(state.clone(), msg) in
        msg ∉ [SaveProgress, CompleteReview, SubmitPractice] ⟹
        new_state.progress_data = state.progress_data
        
        User progress data must not be modified except by explicit save operations.

    - name: "Navigation Symmetry"
      formal_statement: |
        ∀ state: AppState.
        let (state2, _) = update(state.clone(), NavigateTo(screen)) in
        let (state3, _) = update(state2, NavigateBack) in
        state3.current_screen = state.current_screen ∨ state3.current_screen = MainMenu
        
        Navigation back after navigation forward returns to previous screen or main menu.

    - name: "Async Operation Safety"
      formal_statement: |
        ∀ state: AppState, msg: Message requiring async operation.
        let (new_state, task) = update(state, msg) in
        task.is_some() ⟹ 
        (∃ result_msg: Message. executing task produces result_msg ∧
         update(new_state, result_msg) is defined)
        
        All async Task operations must eventually produce a Message that the update
        function can handle, with no possibility of dropped messages or undefined handlers.

    - name: "Deadlock Freedom"
      formal_statement: |
        ∀ state: AppState with shared Arc<RwLock<T>>.
        No sequence of update() calls can produce a state where:
        - A lock is held indefinitely
        - Circular wait conditions exist
        - Lock acquisition order causes deadlock
        
        The update function must never cause deadlocks when accessing shared state.

  strategy:
    - "Use Rust's type system to encode state invariants - make invalid states unrepresentable through careful enum and struct design"
    - "Apply model checking tools (e.g., TLA+, Alloy) to verify state transition properties and detect unreachable or invalid states"
    - "Use property-based testing with proptest to verify properties across large input spaces - this bridges the gap between testing and formal verification"
    - "Employ static analysis tools (Miri, Loom) to detect undefined behavior, race conditions, and deadlocks in Arc<RwLock> usage"
    - "Implement runtime assertions in debug builds that check state invariants after every update() call"
    - "Use Rust's borrow checker and ownership system as a form of lightweight formal verification for memory safety and data race freedom"
    - "Document preconditions and postconditions for update() and all screen-specific handlers using function contracts (could use tools like Prusti or Creusot)"
    - "Create a finite state machine model of screen transitions and verify it separately before implementation"
    - "Apply theorem proving techniques (Coq, Lean) for critical properties if resources permit, particularly for progress preservation and state consistency"

tests:
  strategy:
    approach: "unit tests with property-based testing"
    rationale:
      - "State transitions are pure functions making them ideal for unit testing"
      - "Message handling logic can be tested in isolation without UI or database dependencies"
      - "Property-based testing ensures state consistency invariants hold across all transitions"
      - "Each Screen variant's state initialization can be verified independently"
      - "Navigation flows can be tested by chaining message sequences"
      - "Error cases and edge conditions in update() are deterministic and reproducible"
      - "Task-based async operations can be tested by verifying correct Task construction"

  implementation:
    file: "tests/state_management_tests.rs"
    location: "create new"
    code: |
      #[cfg(test)]
      mod state_tests {
          use super::super::*;
          use crate::models::{Character, ReviewItem, DrawingStroke, Point};
          use crate::database::Database;
          use std::sync::{Arc, RwLock};

          fn create_test_app_state() -> AppState {
              let db = Arc::new(RwLock::new(Database::new_in_memory().unwrap()));
              AppState {
                  screen: Screen::MainMenu,
                  db: db.clone(),
                  settings: Arc::new(RwLock::new(Default::default())),
                  progress: Arc::new(RwLock::new(Default::default())),
              }
          }

          fn create_test_character(character: char) -> Character {
              Character {
                  id: 1,
                  character: character.to_string(),
                  pinyin: "test".to_string(),
                  meaning: "test".to_string(),
                  stroke_count: 1,
                  frequency_rank: 1,
                  hsk_level: Some(1),
                  radical: None,
                  components: vec![],
              }
          }

          #[test]
          fn test_initial_state_is_main_menu() {
              let state = create_test_app_state();
              assert!(matches!(state.screen, Screen::MainMenu));
          }

          #[test]
          fn test_navigate_to_learning_session() {
              let mut state = create_test_app_state();
              let characters = vec![create_test_character('好')];
              
              let msg = Message::StartLearningSession { characters: characters.clone() };
              let _task = Application::update(&mut state, msg);
              
              match &state.screen {
                  Screen::Learning(session_state) => {
                      assert_eq!(session_state.characters.len(), 1);
                      assert_eq!(session_state.current_index, 0);
                      assert!(!session_state.completed);
                  }
                  _ => panic!("Expected Learning screen"),
              }
          }

          #[test]
          fn test_navigate_to_practice_mode() {
              let mut state = create_test_app_state();
              let character = create_test_character('好');
              
              let msg = Message::StartPractice { character: character.clone() };
              let _task = Application::update(&mut state, msg);
              
              match &state.screen {
                  Screen::Practice(practice_state) => {
                      assert_eq!(practice_state.character.character, "好");
                      assert_eq!(practice_state.strokes.len(), 0);
                      assert!(!practice_state.is_drawing);
                      assert!(practice_state.recognition_result.is_none());
                  }
                  _ => panic!("Expected Practice screen"),
              }
          }

          #[test]
          fn test_learning_session_advance_character() {
              let mut state = create_test_app_state();
              let characters = vec![
                  create_test_character('好'),
                  create_test_character('你'),
              ];
              state.screen = Screen::Learning(LearningSessionState {
                  characters: characters.clone(),
                  current_index: 0,
                  completed: false,
                  show_details: false,
              });
              
              let msg = Message::NextCharacter;
              let _task = Application::update(&mut state, msg);
              
              match &state.screen {
                  Screen::Learning(session_state) => {
                      assert_eq!(session_state.current_index, 1);
                      assert!(!session_state.completed);
                  }
                  _ => panic!("Expected Learning screen"),
              }
          }

          #[test]
          fn test_practice_start_drawing() {
              let mut state = create_test_app_state();
              let character = create_test_character('好');
              state.screen = Screen::Practice(PracticeState {
                  character: character.clone(),
                  strokes: vec![],
                  current_stroke: None,
                  is_drawing: false,
                  recognition_result: None,
                  show_stroke_order: false,
              });
              
              let msg = Message::StartStroke { point: Point { x: 100.0, y: 100.0 } };
              let _task = Application::update(&mut state, msg);
              
              match &state.screen {
                  Screen::Practice(practice_state) => {
                      assert!(practice_state.is_drawing);
                      assert!(practice_state.current_stroke.is_some());
                      assert_eq!(practice_state.current_stroke.as_ref().unwrap().points.len(), 1);
                  }
                  _ => panic!("Expected Practice screen"),
              }
          }
      }

      #[cfg(test)]
      mod property_tests {
          use super::super::*;
          use proptest::prelude::*;

          prop_compose! {
              fn arb_character()(
                  character in "[一-龥]",
                  pinyin in "[a-z]{1,6}",
                  meaning in "[a-z ]{1,20}",
                  stroke_count in 1u32..30,
                  frequency_rank in 1u32..10000,
                  hsk_level in prop::option::of(1u8..7),
              ) -> Character {
                  Character {
                      id: 1,
                      character,
                      pinyin,
                      meaning,
                      stroke_count,
                      frequency_rank,
                      hsk_level,
                      radical: None,
                      components: vec![],
                  }
              }
          }

          proptest! {
              #[test]
              fn prop_learning_session_index_never_exceeds_length(
                  characters in prop::collection::vec(arb_character(), 1..10)
              ) {
                  let db = Arc::new(RwLock::new(Database::new_in_memory().unwrap()));
                  let mut state = AppState {
                      screen: Screen::MainMenu,
                      db: db.clone(),
                      settings: Arc::new(RwLock::new(Default::default())),
                      progress: Arc::new(RwLock::new(Default::default())),
                  };
                  
                  let msg = Message::StartLearningSession { characters: characters.clone() };
                  let _task = Application::update(&mut state, msg);
                  
                  for _ in 0..characters.len() {
                      let msg = Message::NextCharacter;
                      let _task = Application::update(&mut state, msg);
                      
                      if let Screen::Learning(ref session) = state.screen {
                          prop_assert!(session.current_index <= characters.len());
                      }
                  }
              }

              #[test]
              fn prop_state_transitions_are_deterministic(
                  nav_sequence in prop::collection::vec(0usize..3, 1..10)
              ) {
                  let db = Arc::new(RwLock::new(Database::new_in_memory().unwrap()));
                  let mut state = AppState {
                      screen: Screen::MainMenu,
                      db: db.clone(),
                      settings: Arc::new(RwLock::new(Default::default())),
                      progress: Arc::new(RwLock::new(Default::default())),
                  };
                  
                  let messages = vec![
                      Message::NavigateToMainMenu,
                      Message::NavigateToStatistics,
                      Message::NavigateToSettings,
                  ];
                  
                  for &index in &nav_sequence {
                      let msg = messages[index % messages.len()].clone();
                      let _task = Application::update(&mut state, msg);
                      
                      match &state.screen {
                          Screen::MainMenu | Screen::Statistics | Screen::Settings => {},
                          _ => prop_assert!(false, "Invalid screen state after navigation"),
                      }
                  }
              }
          }
      }

  coverage:
    - "Initial state is MainMenu"
    - "Navigation to learning session initializes session state correctly"
    - "Navigation to practice mode initializes practice state correctly"
    - "Navigation to review session initializes review state correctly"
    - "Navigation to statistics screen"
    - "Navigation to settings screen"
    - "Navigation back to main menu from any screen"
    - "Learning session advances to next character"
    - "Learning session completes when reaching last character"
    - "Learning session toggles character details"
    - "Practice mode starts drawing stroke"
    - "Practice mode continues drawing stroke with additional points"
    - "Practice mode ends stroke and adds to stroke list"
    - "Practice mode clears all drawing and recognition results"
    - "Review session shows answer"
    - "Review session accepts user rating"
    - "Review session advances to next item resetting answer/rating state"
    - "Review session completes when reaching last item"
    - "Empty learning session initializes as completed"
    - "Navigation preserves shared state (settings, progress)"
    - "State transitions are deterministic for same message"
    - "Property: learning session index never exceeds character list length"
    - "Property: practice strokes accumulate correctly without loss"
    - "Property: review ratings are bounded to valid range"
    - "Property: navigation sequences always reach valid screen states"

dependencies:
  depends_on:
    - task_id: 1
      reason: "Requires application foundation and state/ module structure to be established"

  depended_upon_by:
    - task_id: 7
      reason: "Learning session screen requires state management framework with Screen::Learning variant and message routing"
    - task_id: 8
      reason: "Practice session screen requires state management framework with Screen::Practice variant and canvas state handling"
    - task_id: 10
      reason: "Statistics screen needs Screen::Statistics variant and navigation support from state system"

  external:
    - name: "iced::Application"
      type: "trait"
      status: "to be imported"
    - name: "iced::Task"
      type: "type"
      status: "to be imported"
    - name: "Database"
      type: "struct"
      status: "needs implementation"
    - name: "Character"
      type: "struct"
      status: "needs implementation"
    - name: "ReviewItem"
      type: "struct"
      status: "needs implementation"
    - name: "RecognitionResponse"
      type: "struct"
      status: "needs implementation"
    - name: "Arc"
      type: "type"
      status: "already exists"
    - name: "RwLock"
      type: "type"
      status: "already exists"
---
task:
  id: 7
  name: "SM-2 Spaced Repetition Algorithm and Review Queue"

context:
  description: |
    This task implements the SM-2 spaced repetition algorithm, a battle-tested pedagogical
    engine that optimizes learning through scientifically-backed interval scheduling. The SM-2
    algorithm tracks per-card ease factors, intervals, and repetition counts to determine optimal
    review timing based on learner performance. When combined with a priority-based review queue,
    this creates an effective system for long-term vocabulary retention.
    
    The implementation consists of two core components: (1) SM2Card, which encapsulates the
    mathematical SM-2 algorithm for individual flashcard scheduling, and (2) ReviewQueue, which
    manages card prioritization across learning states (new, learning, review) with configurable
    daily limits. Together, these components form the backbone of the spaced repetition system
    that will power the learning sessions.
    
    The SM-2 algorithm works by adjusting three key parameters after each review: ease factor
    (default 2.5, floor 1.3), interval in days, and repetition count. Quality ratings from 0-5
    map user performance to algorithm updates, with ratings below 3 resetting cards to learning
    state and ratings 3+ progressing through scheduled intervals (1 day, 6 days, then
    previous_interval * ease_factor). This mathematical precision ensures learners encounter
    material at the optimal moment for memory consolidation.

  key_points:
    - "SM-2 algorithm is deterministic and well-specified, making it ideal for comprehensive unit testing"
    - "Ease factor has a floor of 1.3 to prevent cards from becoming impossibly difficult"
    - "First two intervals are fixed (1 day, 6 days), then calculated dynamically based on ease factor"
    - "Queue prioritization follows learning > due reviews > new cards to reinforce recent material"
    - "Daily limits prevent cognitive overload while maintaining consistent learning habits"
    - "Failed cards (quality < 3) reset to learning state but retain modified ease factor"
    - "Implementation must handle floating-point precision carefully to maintain invariants"
    - "Quality ratings must be clearly documented: 5=perfect, 4=correct, 3=difficult, 2=incorrect, 1=barely, 0=blackout"

files:
  - path: "src/srs/mod.rs"
    description: "Module declaration file for spaced repetition system components"
  
  - path: "src/srs/sm2.rs"
    description: "Implementation of SM-2 algorithm including SM2Card struct and review logic"
  
  - path: "src/srs/queue.rs"
    description: "ReviewQueue implementation for managing card prioritization and daily limits"
  
  - path: "src/srs/types.rs"
    description: "Common types and enums for SRS system (CardState, QualityRating, etc.)"
  
  - path: "tests/srs/sm2_tests.rs"
    description: "Unit tests for SM-2 algorithm correctness and edge cases"
  
  - path: "tests/srs/queue_tests.rs"
    description: "Unit tests for ReviewQueue prioritization and daily limit logic"
  
  - path: "tests/srs/property_tests.rs"
    description: "Property-based tests for SM-2 invariants (ease factor bounds, interval monotonicity)"

functions:
  - file: "src/srs/sm2.rs"
    items:
      - type: "struct"
        name: "SM2Card"
        description: "Represents a flashcard with SM-2 scheduling parameters including ease factor, interval, repetition count, and next review date"
        invariants: "ease_factor >= 1.3; interval >= 0; repetitions >= 0"
      
      - type: "struct"
        name: "SM2Parameters"
        description: "Configuration parameters for SM-2 algorithm including initial ease factor and minimum ease factor threshold"
        invariants: "initial_ease >= min_ease >= 1.3"
      
      - type: "enum"
        name: "CardState"
        description: "Represents the current state of a card in the learning process"
        invariants: "Must be one of: New, Learning, Review, Relearning"
      
      - type: "enum"
        name: "QualityRating"
        description: "User's quality rating for a card review on 0-5 scale"
        invariants: "Must be one of: Blackout(0), Barely(1), Incorrect(2), Difficult(3), Correct(4), Perfect(5)"
      
      - type: "method"
        name: "SM2Card::new"
        description: "Creates a new SM2Card with default parameters (ease=2.5, interval=0, reps=0, state=New)"
        preconditions: "Valid card_id provided"
        postconditions: "Returns SM2Card with ease_factor=2.5, interval=0, repetitions=0, state=New"
      
      - type: "method"
        name: "SM2Card::review"
        description: "Updates card state based on quality rating using SM-2 algorithm; calculates new ease factor, interval, and next review date"
        preconditions: "quality must be 0-5; current_date is valid"
        postconditions: "ease_factor updated and bounded to [1.3, inf); interval updated according to SM-2; next_review_date set to future date; state updated based on performance"
        invariants: "ease_factor >= 1.3 after update; next_review_date > current_date"
      
      - type: "method"
        name: "SM2Card::calculate_ease_factor"
        description: "Calculates new ease factor based on quality rating using SM-2 formula: EF' = EF + (0.1 - (5-q)*(0.08+(5-q)*0.02))"
        preconditions: "quality in range 0-5; current ease_factor >= 1.3"
        postconditions: "Returns ease factor >= 1.3"
        invariants: "Result is always >= 1.3"
      
      - type: "method"
        name: "SM2Card::calculate_interval"
        description: "Calculates next interval in days based on repetition count and ease factor"
        preconditions: "repetitions >= 0; ease_factor >= 1.3"
        postconditions: "Returns interval: 1 for first rep, 6 for second rep, previous_interval * ease_factor for subsequent"
        invariants: "First interval = 1 day; second interval = 6 days; subsequent intervals increase monotonically for constant ease_factor"
      
      - type: "method"
        name: "SM2Card::is_due"
        description: "Checks if card is due for review based on current date and next review date"
        preconditions: "current_date is valid"
        postconditions: "Returns true if current_date >= next_review_date"
      
      - type: "method"
        name: "SM2Card::reset_to_learning"
        description: "Resets card to learning state when review quality is poor (< 3)"
        preconditions: "Card exists"
        postconditions: "interval=1, repetitions=0, state=Learning or Relearning"

  - file: "src/srs/queue.rs"
    items:
      - type: "struct"
        name: "ReviewQueue"
        description: "Manages card queues (new, learning, review) with prioritization logic and daily limits"
        invariants: "All cards in queues are unique; learning queue contains only Learning/Relearning cards; review queue contains only Review cards due today; new queue contains only New cards"
      
      - type: "struct"
        name: "QueueConfig"
        description: "Configuration for review queue including daily limits for new and review cards"
        invariants: "max_new_cards_per_day >= 0; max_reviews_per_day >= 0"
      
      - type: "struct"
        name: "QueueStatistics"
        description: "Statistics about current queue state including counts per queue type and cards remaining today"
      
      - type: "method"
        name: "ReviewQueue::new"
        description: "Creates a new ReviewQueue with specified configuration"
        preconditions: "Valid QueueConfig provided"
        postconditions: "Returns ReviewQueue with empty queues and provided config"
      
      - type: "method"
        name: "ReviewQueue::add_card"
        description: "Adds a card to appropriate queue based on its state"
        preconditions: "Card is valid SM2Card"
        postconditions: "Card added to correct queue (new/learning/review) based on state and due date; card not duplicated if already in queue"
      
      - type: "method"
        name: "ReviewQueue::get_next_card"
        description: "Returns next card to review based on priority rules: learning > due reviews > new cards"
        preconditions: "Queue is initialized; daily limits not exceeded"
        postconditions: "Returns Some(card) following priority order or None if no cards available or limits reached; returned card is removed from queue"
        invariants: "Priority order: Learning/Relearning cards first, then due Review cards, then New cards up to daily limit"
      
      - type: "method"
        name: "ReviewQueue::return_card"
        description: "Returns a card to the queue after review, placing it in appropriate queue based on updated state"
        preconditions: "Card has been reviewed and state updated"
        postconditions: "Card re-added to correct queue based on new state"
      
      - type: "method"
        name: "ReviewQueue::get_statistics"
        description: "Returns current queue statistics including counts and remaining daily allowance"
        postconditions: "Returns QueueStatistics with accurate counts"
      
      - type: "method"
        name: "ReviewQueue::reset_daily_limits"
        description: "Resets daily counters for new cards and reviews, typically called at start of new day"
        postconditions: "Daily counters reset to 0"
      
      - type: "method"
        name: "ReviewQueue::update_due_cards"
        description: "Updates review queue by checking all cards and moving due cards from future reviews to current review queue"
        preconditions: "current_date is valid"
        postconditions: "All cards with next_review_date <= current_date are in review queue"
      
      - type: "method"
        name: "ReviewQueue::is_empty"
        description: "Checks if all queues are empty or daily limits have been reached"
        postconditions: "Returns true if no more cards available to review today"

  - file: "src/srs/mod.rs"
    items:
      - type: "module_declaration"
        name: "mod sm2"
        description: "Module declaration for SM-2 algorithm implementation"
      
      - type: "module_declaration"
        name: "mod queue"
        description: "Module declaration for review queue management"
      
      - type: "module_declaration"
        name: "mod types"
        description: "Module declaration for common SRS types"
      
      - type: "module_declaration"
        name: "pub use sm2::{SM2Card, SM2Parameters}"
        description: "Re-exports for SM-2 types"
      
      - type: "module_declaration"
        name: "pub use queue::{ReviewQueue, QueueConfig, QueueStatistics}"
        description: "Re-exports for review queue types"
      
      - type: "module_declaration"
        name: "pub use types::{CardState, QualityRating}"
        description: "Re-exports for common types"

formal_verification:
  needed: true
  level: "Basic"
  explanation: |
    The SM-2 spaced repetition algorithm is mathematically specified and has
    critical correctness requirements that directly impact learning effectiveness.
    While not safety-critical in the sense of preventing crashes or data corruption,
    incorrect scheduling can severely degrade the pedagogical value of the system.
    
    Basic formal verification is warranted because:
    1. The algorithm has precise mathematical invariants (ease factor bounds,
       interval monotonicity) that must hold for correctness
    2. Floating-point arithmetic introduces precision concerns that could violate
       invariants over time
    3. The state machine for card transitions (new → learning → review) has
       well-defined properties that can be formally stated
    4. Incorrect implementation would silently produce poor learning outcomes
       rather than obvious failures
    
    However, full formal verification is unnecessary because:
    - The algorithm is not memory-unsafe or concurrency-sensitive
    - Property-based testing can catch most edge cases effectively
    - The state space is manageable for comprehensive testing
    - No security or safety-critical requirements exist

  properties:
    - name: "Ease Factor Lower Bound"
      formal_statement: "∀ card, quality ∈ [0,5]: card.review(quality) ⇒ card.ease_factor ≥ 1.3"
    
    - name: "Interval Monotonicity for Successful Reviews"
      formal_statement: "∀ card, quality ≥ 3: let old_interval = card.interval in card.review(quality) ⇒ card.interval ≥ old_interval"
    
    - name: "Failed Review Reset"
      formal_statement: "∀ card, quality < 3: card.review(quality) ⇒ (card.repetitions = 0 ∧ card.interval = 1)"
    
    - name: "Next Review Date Progress"
      formal_statement: "∀ card, now: DateTime: card.review(q) ⇒ card.next_review > now"
    
    - name: "Initial Interval Sequence"
      formal_statement: "∀ card: (card.repetitions = 0 ⇒ next_interval = 1) ∧ (card.repetitions = 1 ⇒ next_interval = 6)"
    
    - name: "Ease Factor Calculation Formula"
      formal_statement: "∀ card, q ∈ [0,5]: new_ease = max(1.3, old_ease + (0.1 - (5-q)*(0.08 + (5-q)*0.02)))"
    
    - name: "Queue Priority Invariant"
      formal_statement: "∀ queue: queue.get_next_card() returns learning cards before due reviews, and due reviews before new cards"
    
    - name: "Daily Limit Enforcement"
      formal_statement: "∀ queue, limit: queue.new_cards_today < limit ⇒ can_add_new_card(queue)"

  strategy:
    - "Use property-based testing (proptest) to verify invariants hold across thousands of random inputs"
    - "Implement unit tests with specific edge cases: quality extremes (0,5), ease factor boundary (1.3), repetition transitions"
    - "Add assertions in review() method to check postconditions (ease ≥ 1.3, interval > 0, next_review > now)"
    - "Create state machine tests verifying card transitions: new → learning → review → lapsed → relearning"
    - "Test floating-point stability by running 1000+ review cycles and verifying invariants still hold"
    - "Add debug_assert! macros for runtime verification of critical invariants during development"

tests:
  strategy:
    approach: "unit tests with property-based testing"
    rationale:
      - "SM-2 algorithm is deterministic and mathematical, making it ideal for unit testing with precise assertions"
      - "Property-based testing verifies critical invariants like ease factor bounds, interval monotonicity, and state transitions"
      - "Queue prioritization logic requires deterministic unit tests to verify correct ordering"
      - "Edge cases (boundary quality ratings, initial state, long intervals) need explicit coverage"
      - "No external dependencies or I/O needed - pure business logic testing"

  implementation:
    file: "tests/srs/sm2_tests.rs"
    location: "separate test file"
    code: |
      use chrono::{Duration, Utc};
      use your_crate::srs::{SM2Card, ReviewQueue, QualityRating, CardState};

      #[cfg(test)]
      mod sm2_tests {
          use super::*;

          fn new_test_card(card_id: u32) -> SM2Card {
              SM2Card::new(card_id)
          }

          #[test]
          fn test_sm2card_initial_state() {
              let card = new_test_card(1);
              assert_eq!(card.ease_factor, 2.5);
              assert_eq!(card.interval, 0);
              assert_eq!(card.repetitions, 0);
          }

          #[test]
          fn test_review_quality_5_perfect() {
              let mut card = new_test_card(1);
              let before = Utc::now();
              
              card.review(5);
              
              assert_eq!(card.ease_factor, 2.6);
              assert_eq!(card.interval, 1);
              assert_eq!(card.repetitions, 1);
              assert!(card.next_review > before);
          }

          #[test]
          fn test_review_quality_4_correct() {
              let mut card = new_test_card(1);
              
              card.review(4);
              
              assert_eq!(card.ease_factor, 2.5);
              assert_eq!(card.interval, 1);
              assert_eq!(card.repetitions, 1);
          }

          #[test]
          fn test_review_quality_3_difficult() {
              let mut card = new_test_card(1);
              
              card.review(3);
              
              assert_eq!(card.ease_factor, 2.36);
              assert_eq!(card.interval, 1);
              assert_eq!(card.repetitions, 1);
          }

          #[test]
          fn test_review_quality_2_incorrect_resets() {
              let mut card = new_test_card(1);
              card.ease_factor = 2.8;
              card.interval = 10;
              card.repetitions = 5;
              
              card.review(2);
              
              assert_eq!(card.interval, 1);
              assert_eq!(card.repetitions, 0);
              assert!(card.ease_factor < 2.8);
          }

          #[test]
          fn test_review_quality_1_barely() {
              let mut card = new_test_card(1);
              card.ease_factor = 2.5;
              
              card.review(1);
              
              assert_eq!(card.interval, 1);
              assert_eq!(card.repetitions, 0);
              assert!(card.ease_factor < 2.5);
          }

          #[test]
          fn test_review_quality_0_blackout() {
              let mut card = new_test_card(1);
              card.ease_factor = 2.5;
              card.interval = 20;
              card.repetitions = 10;
              
              card.review(0);
              
              assert_eq!(card.interval, 1);
              assert_eq!(card.repetitions, 0);
          }

          #[test]
          fn test_ease_factor_floor() {
              let mut card = new_test_card(1);
              card.ease_factor = 1.35;
              
              card.review(0);
              
              assert!(card.ease_factor >= 1.3);
              assert_eq!(card.ease_factor, 1.3);
          }

          #[test]
          fn test_first_interval_is_one_day() {
              let mut card = new_test_card(1);
              let now = Utc::now();
              
              card.review(4);
              
              assert_eq!(card.interval, 1);
              assert_eq!(card.repetitions, 1);
              let expected = now + Duration::days(1);
              let diff = (card.next_review - expected).num_seconds().abs();
              assert!(diff < 2);
          }

          #[test]
          fn test_second_interval_is_six_days() {
              let mut card = new_test_card(1);
              
              card.review(4);
              card.review(4);
              
              assert_eq!(card.interval, 6);
              assert_eq!(card.repetitions, 2);
          }

          #[test]
          fn test_subsequent_intervals_use_ease_factor() {
              let mut card = new_test_card(1);
              card.ease_factor = 2.5;
              
              card.review(4);
              card.review(4);
              card.review(4);
              
              assert_eq!(card.interval, 15);
              assert_eq!(card.repetitions, 3);
          }

          #[test]
          fn test_interval_progression_quality_5() {
              let mut card = new_test_card(1);
              
              card.review(5);
              assert_eq!(card.interval, 1);
              
              card.review(5);
              assert_eq!(card.interval, 6);
              
              card.review(5);
              assert_eq!(card.interval, 16);
              assert_eq!(card.ease_factor, 2.8);
          }

          #[test]
          fn test_failed_card_ease_factor_persists() {
              let mut card = new_test_card(1);
              
              card.review(5);
              card.review(5);
              let ef_before_fail = card.ease_factor;
              
              card.review(2);
              
              assert_eq!(card.interval, 1);
              assert_eq!(card.repetitions, 0);
              assert!(card.ease_factor < ef_before_fail);
              assert!(card.ease_factor >= 1.3);
          }

          #[test]
          fn test_next_review_always_future() {
              let mut card = new_test_card(1);
              let now = Utc::now();
              
              card.review(4);
              
              assert!(card.next_review > now);
          }
      }

      #[cfg(test)]
      mod queue_tests {
          use super::*;

          #[test]
          fn test_review_queue_init() {
              let queue = ReviewQueue::new(20);
              
              assert_eq!(queue.daily_new_limit, 20);
              assert_eq!(queue.new_cards_today, 0);
          }

          #[test]
          fn test_queue_add_new_card() {
              let mut queue = ReviewQueue::new(20);
              let card = new_test_card(1);
              
              queue.add_new_card(card);
              
              assert_eq!(queue.new_cards.len(), 1);
          }

          #[test]
          fn test_queue_prioritizes_learning_cards() {
              letmut queue = ReviewQueue::new(20);
              
              let mut learning_card = new_test_card(1);
              learning_card.repetitions = 0;
              learning_card.next_review = Utc::now() - Duration::hours(1);
              
              let mut review_card = new_test_card(2);
              review_card.repetitions = 5;
              review_card.next_review = Utc::now() - Duration::hours(1);
              
              queue.add_learning_card(learning_card);
              queue.add_review_card(review_card);
              
              let next = queue.get_next_card();
              assert!(next.is_some());
              assert_eq!(next.unwrap().card_id, 1);
          }

          #[test]
          fn test_queue_prioritizes_reviews_over_new() {
              let mut queue = ReviewQueue::new(20);
              
              let new_card = new_test_card(1);
              
              let mut due_card = new_test_card(2);
              due_card.next_review = Utc::now() - Duration::hours(1);
              due_card.repetitions = 3;
              
              queue.add_new_card(new_card);
              queue.add_review_card(due_card);
              
              let next = queue.get_next_card();
              assert!(next.is_some());
              assert_eq!(next.unwrap().card_id, 2);
          }

          #[test]
          fn test_daily_new_card_limit() {
              let mut queue = ReviewQueue::new(2);
              
              queue.add_new_card(new_test_card(1));
              queue.add_new_card(new_test_card(2));
              queue.add_new_card(new_test_card(3));
              
              let card1 = queue.get_next_card();
              assert!(card1.is_some());
              
              let card2 = queue.get_next_card();
              assert!(card2.is_some());
              
              let card3 = queue.get_next_card();
              assert!(card3.is_none());
          }

          #[test]
          fn test_empty_queue_returns_none() {
              let mut queue = ReviewQueue::new(20);
              
              let next = queue.get_next_card();
              assert!(next.is_none());
          }
      }

      #[cfg(test)]
      mod property_tests {
          use super::*;
          use proptest::prelude::*;

          fn arb_card() -> impl Strategy<Value = SM2Card> {
              (1u32..1000u32, 1.3f32..3.0f32, 0u32..100u32, 0u32..50u32).prop_map(
                  |(id, ef, interval, reps)| {
                      let mut card = SM2Card::new(id);
                      card.ease_factor = ef;
                      card.interval = interval;
                      card.repetitions = reps;
                      card
                  },
              )
          }

          proptest! {
              #[test]
              fn prop_ease_factor_has_floor(mut card in arb_card(), quality in 0u8..=5u8) {
                  card.review(quality);
                  prop_assert!(card.ease_factor >= 1.3);
              }

              #[test]
              fn prop_intervals_increase_monotonically(mut card in arb_card()) {
                  card.repetitions = 0;
                  card.interval = 0;
                  
                  card.review(4);
                  let interval1 = card.interval;
                  
                  card.review(4);
                  let interval2 = card.interval;
                  
                  card.review(4);
                  let interval3 = card.interval;
                  
                  prop_assert!(interval2 >= interval1);
                  prop_assert!(interval3 >= interval2);
              }

              #[test]
              fn prop_failed_cards_reset(mut card in arb_card(), quality in 0u8..3u8) {
                  card.review(quality);
                  prop_assert_eq!(card.interval, 1);
                  prop_assert_eq!(card.repetitions, 0);
              }

              #[test]
              fn prop_next_review_in_future(mut card in arb_card(), quality in 0u8..=5u8) {
                  let before = Utc::now();
                  card.review(quality);
                  prop_assert!(card.next_review > before);
              }

              #[test]
              fn prop_ease_factor_changes_correctly(quality in 0u8..=5u8) {
                  let mut card = SM2Card::new(1);
                  card.ease_factor = 2.5;
                  card.interval = 10;
                  card.repetitions = 5;
                  
                  let ef_before = card.ease_factor;
                  card.review(quality);
                  
                  match quality {
                      5 => prop_assert!(card.ease_factor > ef_before),
                      4 => prop_assert_eq!(card.ease_factor, ef_before),
                      _ => prop_assert!(card.ease_factor <= ef_before),
                  }
              }
          }
      }

  coverage:
    - "SM2Card initialization with correct default values"
    - "Review with quality rating 5 (perfect recall) increases ease factor"
    - "Review with quality rating 4 (correct) maintains ease factor"
    - "Review with quality rating 3 (difficult) decreases ease factor"
    - "Review with quality rating 2 (incorrect) resets card to learning state"
    - "Review with quality rating 1 (barely recalled) resets card"
    - "Review with quality rating 0 (blackout) resets card completely"
    - "Ease factor never falls below floor of 1.3"
    - "First interval is always 1 day"
    - "Second interval is always 6 days"
    - "Subsequent intervals calculated using ease factor formula"
    - "Interval progression with perfect reviews (quality 5)"
    - "Failed card resets interval and repetitions but modifies ease factor"
    - "ReviewQueue initialization with daily limit"
    - "Adding new cards to queue"
    - "Queue prioritizes learning cards over review cards"
    - "Queue prioritizes due review cards over new cards"
    - "Daily new card limit enforcement"
    - "Empty queue returns None"
    - "Next review date is always in the future after any review"
    - "Property: ease factor floor maintained across all quality ratings"
    - "Property: intervals increase monotonically for consecutive correct reviews"
    - "Property: failed cards always reset to initial learning state"
    - "Property: next review date invariant holds for all operations"
    - "Property: ease factor changes directionally correct based on quality rating"

dependencies:
  depends_on:
    - task_id: 2
      reason: "Needs character database to create flashcards for SM-2 scheduling"

  depended_upon_by:
    - task_id: 8
      reason: "Learning session uses SM-2 algorithm and ReviewQueue for scheduling and presenting cards to users"

  external:
    - name: "chrono"
      type: "crate"
      status: "to be imported"
    - name: "proptest"
      type: "crate"
      status: "to be imported"
---
task:
  id: 8
  name: "Learning Session and Practice Modes"

context:
  description: |
    This task implements the core learning experience workflows that bring together all
    previous system components into cohesive user-facing features. The learning session
    manages the review queue progression, presenting flashcards to users, collecting
    quality ratings, and updating spaced repetition state via the SM-2 algorithm. The
    practice session provides a four-stage progressive learning system that moves users
    from passive observation through guided practice to free recall.

    These systems are the culmination of the application's architecture, integrating
    character data (Task 2), UI components (Task 3), stroke animation (Task 4), handwriting
    recognition (Task 5), state management (Task 6), and the SM-2 scheduling algorithm
    (Task 7). The session workflows must feel polished, responsive, and provide immediate
    visual feedback to create effective learning conditions.

    The learning session implements a state machine that pulls cards from the review queue,
    displays them to the user, waits for quality ratings, updates card state through SM-2,
    and progresses to the next card. It includes batch saving for performance, pause/resume
    functionality for interrupted sessions, and comprehensive statistics tracking.

    The practice session implements a four-mode progression system: (1) WatchAnimation for
    passive observation, (2) TraceWithGuide for guided practice with visible overlay,
    (3) TraceWithoutGuide for practice with fading guides, and (4) FreeDrawing for free
    recall with full recognition validation. Each mode requires successful completion
    before advancing, with configurable confidence thresholds and hint systems for stuck
    users.

  key_points:
    - "Learning sessions orchestrate review queue, SM-2 updates, and user interaction flow"
    - "Practice sessions provide progressive difficulty with four distinct learning stages"
    - "Batch saving (every 5-10 cards) optimizes database performance during sessions"
    - "Session interruption/resume requires careful state serialization and restoration"
    - "Visual feedback (animations, overlays, success/failure indicators) enhances UX"
    - "Keyboard shortcuts (1-5 for ratings, space for next) improve review flow efficiency"
    - "Statistics tracking provides session summaries and performance insights"
    - "Recognition confidence thresholds ensure quality practice progression"

files:
  - path: "src/session/learning_session.rs"
    description: "Core learning session state machine managing review queue progression, card presentation, quality rating collection, and SM-2 state updates"
  
  - path: "src/session/practice_session.rs"
    description: "Practice mode state machine managing progression through four difficulty levels with stroke animation and recognition validation"
  
  - path: "src/session/practice_mode.rs"
    description: "Enum defining four practice stages: WatchAnimation, TraceWithGuide, TraceWithoutGuide, FreeDrawing with associated transition logic"
  
  - path: "src/session/session_statistics.rs"
    description: "Session statistics tracking including cards reviewed, accuracy rates, time per card, and success metrics"
  
  - path: "src/session/mod.rs"
    description: "Module declaration exposing LearningSession, PracticeSession, PracticeMode, and SessionStatistics types"
  
  - path: "src/ui/views/learning_session_view.rs"
    description: "UI view for learning session displaying flashcards, quality rating buttons (0-5), progress bar, and visual feedback"
  
  - path: "src/ui/views/practice_session_view.rs"
    description: "UI view for practice mode showing stroke animation, drawing canvas, tracing guides, and mode-specific controls"
  
  - path: "src/ui/views/session_summary_view.rs"
    description: "Session summary screen displaying statistics, accuracy, total time, cards reviewed, and performance breakdown"
  
  - path: "src/ui/components/quality_rating_buttons.rs"
    description: "Quality rating button component (0-5) with keyboard shortcuts and visual states"
  
  - path: "src/ui/components/session_progress_bar.rs"
    description: "Progress bar component showing cards remaining, current position, and session completion percentage"
  
  - path: "src/ui/components/practice_guide_overlay.rs"
    description: "Ghost overlay component for tracing modes displaying semi-transparent stroke guides"
  
  - path: "src/ui/views/mod.rs"
    description: "Module declaration for session-related UI views"
  
  - path: "tests/integration/learning_session_test.rs"
    description: "Integration tests for learning session workflow including queue progression, rating collection, and state persistence"
  
  - path: "tests/integration/practice_session_test.rs"
    description: "Integration tests for practice mode progression, recognition validation, and difficulty advancement"
  
  - path: "tests/unit/session_statistics_test.rs"
    description: "Unit tests for session statistics calculations and tracking accuracy"

functions:
  - file: "src/session/mod.rs"
    items:
      - type: "module_declaration"
        name: "learning"
        description: "Module containing learning session implementation"
      
      - type: "module_declaration"
        name: "practice"
        description: "Module containing practice session implementation"
      
      - type: "module_declaration"
        name: "statistics"
        description: "Module containing session statistics tracking"

  - file: "src/session/learning.rs"
    items:
      - type: "struct"
        name: "LearningSession"
        description: "Manages learning session state, review queue progression, and card presentation"
        invariants: "current_index <= cards.len(); cards remain sorted by review priority"
      
      - type: "struct"
        name: "SessionConfig"
        description: "Configuration for learning sessions including batch save interval and time limits"
      
      - type: "enum"
        name: "SessionState"
        description: "Current state of learning session: Presenting, AwaitingRating, Completed, Paused"
      
      - type: "struct"
        name: "SessionResult"
        description: "Result of a learning session including cards reviewed, time spent, and average quality"
      
      - type: "method"
        name: "LearningSession::new"
        description: "Creates new learning session from review queue"
        preconditions: "ReviewQueue contains cards to review"
        postconditions: "Session initialized with first card ready to present"
      
      - type: "method"
        name: "LearningSession::current_card"
        description: "Returns reference to current card being reviewed"
        preconditions: "Session state is Presenting or AwaitingRating"
        postconditions: "Returns Some(card) if cards remain, None if completed"
      
      - type: "method"
        name: "LearningSession::submit_rating"
        description: "Submits quality rating for current card, updates SM-2 state, advances to next card"
        preconditions: "Session state is AwaitingRating; rating in range 0-5"
        postconditions: "Card state updated; session advanced; batch saved if threshold reached"
      
      - type: "method"
        name: "LearningSession::skip_card"
        description: "Skips current card, moves it to end of session queue"
        preconditions: "Session has current card"
        postconditions: "Card moved to end; next card becomes current"
      
      - type: "method"
        name: "LearningSession::pause"
        description: "Pauses session and saves current state"
        postconditions: "Session state set to Paused; progress saved to database"
      
      - type: "method"
        name: "LearningSession::resume"
        description: "Resumes paused session from saved state"
        preconditions: "Session state is Paused"
        postconditions: "Session state restored; current card ready"
      
      - type: "method"
        name: "LearningSession::complete"
        description: "Completes session, performs final save, returns session result"
        postconditions: "All progress saved; session state set to Completed; returns SessionResult"
      
      - type: "method"
        name: "LearningSession::progress"
        description: "Returns current progress as (cards_completed, total_cards)"
        postconditions: "Returns tuple with accurate counts"
      
      - type: "method"
        name: "LearningSession::save_batch"
        description: "Saves accumulated card updates to database in batch"
        postconditions: "All pending card state updates persisted"

  - file: "src/session/practice.rs"
    items:
      - type: "enum"
        name: "PracticeMode"
        description: "Four progressive practice difficulty levels"
      
      - type: "enum_variant"
        name: "PracticeMode::WatchAnimation"
        description: "Passive observation of stroke animation"
      
      - type: "enum_variant"
        name: "PracticeMode::TraceWithGuide"
        description: "Active tracing with visible guide overlay"
      
      - type: "enum_variant"
        name: "PracticeMode::TraceWithoutGuide"
        description: "Active tracing with fading or hidden guide"
      
      - type: "enum_variant"
        name: "PracticeMode::FreeDrawing"
        description: "Free drawing without guides, full recognition validation"
      
      - type: "struct"
        name: "PracticeSession"
        description: "Manages practice session state and mode progression"
        invariants: "mode progresses only on successful recognition; character_id remains constant during session"
      
      - type: "struct"
        name: "PracticeConfig"
        description: "Configuration for practice sessions including recognition thresholds per mode"
      
      - type: "struct"
        name: "PracticeAttempt"
        description: "Record of single practice attempt with drawing data and recognition score"
      
      - type: "struct"
        name: "PracticeResult"
        description: "Result of practice session including attempts per mode and overall success rate"
      
      - type: "method"
        name: "PracticeSession::new"
        description: "Creates new practice session for given character starting at specified mode"
        preconditions: "Character exists in database"
        postconditions: "Session initialized at starting mode; character data loaded"
      
      - type: "method"
        name: "PracticeSession::current_mode"
        description: "Returns current practice mode"
        postconditions: "Returns current PracticeMode"
      
      - type: "method"
        name: "PracticeSession::submit_drawing"
        description: "Submits user drawing for validation, advances mode on success"
        preconditions: "Drawing contains valid stroke data"
        postconditions: "Drawing validated; mode advanced if recognition score meets threshold; attempt recorded"
      
      - type: "method"
        name: "PracticeSession::show_hint"
        description: "Shows hint for current mode (reveals one stroke or provides visual cue)"
        postconditions: "Hint displayed; hint count incremented in statistics"
      
      - type: "method"
        name: "PracticeSession::reset_mode"
        description: "Resets current mode allowing retry without advancing"
        postconditions: "Mode attempt count reset; drawing canvas cleared"
      
      - type: "method"
        name: "PracticeSession::advance_mode"
        description: "Manually advances to next practice mode"
        preconditions: "Not already at final mode"
        postconditions: "Mode advanced; canvas reset"
      
      - type: "method"
        name: "PracticeSession::complete"
        description: "Completes practice session and returns result summary"
        postconditions: "Session marked complete; PracticeResult returned with all attempts"
      
      - type: "method"
        name: "PracticeSession::get_guide_visibility"
        description: "Returns guide overlay visibility based on current mode"
        postconditions: "Returns visibility factor (0.0-1.0) for guide rendering"
      
      - type: "function"
        name: "validate_drawing"
        description: "Validates user drawing against target character using recognition threshold"
        preconditions: "Drawing and target character both have valid stroke data"
        postconditions: "Returns recognition score (0.0-1.0) and whether threshold met"
      
      - type: "function"
        name: "get_mode_threshold"
        description: "Returns recognition threshold for given practice mode"
        postconditions: "Returns threshold value appropriate for mode difficulty"

  - file: "src/session/statistics.rs"
    items:
      - type: "struct"
        name: "SessionStatistics"
        description: "Tracks statistics for learning or practice session"
        invariants: "total_time >= sum of per-card times; cards_reviewed >= 0"
      
      - type: "struct"
        name: "CardTiming"
        description: "Timing information for individual card review"
      
      - type: "method"
        name: "SessionStatistics::new"
        description: "Creates new statistics tracker"
        postconditions: "All counters initialized to zero"
      
      - type: "method"
        name: "SessionStatistics::start_card"
        description: "Marks start of card review timing"
        postconditions: "Timer started for current card"
      
      - type: "method"
        name: "SessionStatistics::complete_card"
        description: "Marks completion of card review and records timing"
        preconditions: "start_card was called for this card"
        postconditions: "Card timing recorded; cards_reviewed incremented"
      
      - type: "method"
        name: "SessionStatistics::record_rating"
        description: "Records quality rating for statistics calculation"
        preconditions: "rating in range 0-5"
        postconditions: "Rating added to history; average updated"
      
      - type: "method"
        name: "SessionStatistics::average_quality"
        description: "Calculates average quality rating across session"
        postconditions: "Returns mean quality rating or None if no ratings recorded"
      
      - type: "method"
        name: "SessionStatistics::average_time_per_card"
        description: "Calculates average time spent per card"
        postconditions: "Returns mean duration or zero if no cards completed"
      
      - type: "method"
        name: "SessionStatistics::total_duration"
        description: "Returns total session duration"
        postconditions: "Returns total elapsed time since session start"

  - file: "src/ui/session_view.rs"
    items:
      - type: "struct"
        name: "SessionView"
        description: "Root view component for learning session UI"
      
      - type: "struct"
        name: "SessionViewModel"
        description: "View model managing session UI state"
      
      - type: "method"
        name: "SessionView::new"
        description: "Creates new session view with given learning session"
        postconditions: "View initialized with session; first card displayed"
      
      - type: "method"
        name: "SessionView::build"
        description: "Builds session view UI tree"
        postconditions: "Returns widget tree with card display, quality buttons, progress bar"
      
      - type: "method"
        name: "SessionViewModel::handle_quality_rating"
        description: "Handles quality rating button press"
        preconditions: "rating in range 0-5"
        postconditions: "Rating submitted to session; UI updated to next card or completion"
      
      - type: "method"
        name: "SessionViewModel::handle_skip"
        description: "Handles skip button press"
        postconditions: "Current card skipped; next card displayed"
      
      - type: "method"
        name: "SessionViewModel::handle_pause"
        description: "Handles pause button press"
        postconditions: "Session paused; pause screen displayed"
      
      - type: "method"
        name: "SessionViewModel::handle_keyboard_shortcut"
        description: "Handles keyboard shortcuts for quality ratings and navigation"
        postconditions: "Appropriate action taken based on key press"
      
      - type: "function"
        name: "render_flashcard"
        description: "Renders flashcard UI showing character and prompt"
        postconditions: "Returns widget displaying character with appropriate styling"
      
      - type: "function"
        name: "render_quality_buttons"
        description: "Renders quality rating buttons (0-5)"
        postconditions: "Returns button row with keyboard hints"
      
      - type: "function"
        name: "render_progress_bar"
        description: "Renders session progress bar and card counter"
        postconditions: "Returns progress widget showing cards completed/remaining"
      
      - type: "function"
        name: "render_session_summary"
        description: "Renders session completion summary screen"
        postconditions: "Returns summary view with statistics and action buttons"

  - file: "src/ui/practice_view.rs"
    items:
      - type: "struct"
        name: "PracticeView"
        description: "Root view component for practice session UI"
      
      - type: "struct"
        name: "PracticeViewModel"
        description: "View model managing practice session UI state"
      
      - type: "method"
        name: "PracticeView::new"
        description: "Creates new practice view with given practice session"
        postconditions: "View initialized; animation or canvas displayed based on mode"
      
      - type: "method"
        name: "PracticeView::build"
        description: "Builds practice view UI tree"
        postconditions: "Returns widget tree appropriate for current practice mode"
      
      - type: "method"
        name: "PracticeViewModel::handle_drawing_complete"
        description: "Handles completion of user drawing"
        postconditions: "Drawing submitted to session; feedback displayed; mode advanced if successful"
      
      - type: "method"
        name: "PracticeViewModel::handle_hint_request"
        description: "Handles hint button press"
        postconditions: "Hint displayed; hint count updated"
      
      - type: "method"
        name: "PracticeViewModel::handle_reset"
        description: "Handles reset button press"
        postconditions: "Current mode reset; canvas cleared"
      
      - type: "method"
        name: "PracticeViewModel::handle_next_mode"
        description: "Handles manual mode advancement"
        postconditions: "Session advanced to next mode; UI updated"
      
      - type: "method"
        name: "PracticeViewModel::update_animation"
        description: "Updates animation state for watch mode"
        preconditions: "Current mode is WatchAnimation"
        postconditions: "Animation frame advanced; view refreshed"
      
      - type: "function"
        name: "render_watch_mode"
        description: "Renders watch animation mode UI"
        postconditions: "Returns widget with stroke animation player"
      
      - type: "function"
        name: "render_trace_mode"
        description: "Renders tracing mode UI with optional guide"
        postconditions: "Returns widget with drawing canvas and guide overlay"
      
      - type: "function"
        name: "render_free_drawing_mode"
        description: "Renders free drawing mode UI"
        postconditions: "Returns widget with blank drawing canvas"
      
      - type: "function"
        name: "render_feedback_overlay"
        description: "Renders visual feedback (check/X) after validation"
        postconditions: "Returns overlay widget with animated success/failure indicator"
      
      - type: "function"
        name: "render_mode_indicator"
        description: "Renders current practice mode indicator"
        postconditions: "Returns widget showing current mode and progress through modes"

  - file: "src/ui/feedback.rs"
    items:
      - type: "struct"
        name: "FeedbackAnimation"
        description: "Animated feedback overlay for success/failure indication"
      
      - type: "enum"
        name: "FeedbackType"
        description: "Type of feedback to display"
      
      - type: "enum_variant"
        name: "FeedbackType::Success"
        description: "Success feedback (green check)"
      
      - type: "enum_variant"
        name: "FeedbackType::Failure"
        description: "Failure feedback (red X)"
      
      - type: "enum_variant"
        name: "FeedbackType::Hint"
        description: "Hint indicator (lightbulb or info icon)"
      
      - type: "method"
        name: "FeedbackAnimation::new"
        description: "Creates new feedback animation"
        postconditions: "Animation initialized at frame 0"
      
      - type: "method"
        name: "FeedbackAnimation::show"
        description: "Triggers feedback animation display"
        postconditions: "Animation started; visible set to true"
      
      - type: "method"
        name: "FeedbackAnimation::update"
        description: "Updates animation frame"
        postconditions: "Frame advanced; animation completes after duration"
      
      - type: "method"
        name: "FeedbackAnimation::render"
        description: "Renders current animation frame"
        postconditions: "Returns widget with animated feedback indicator"

  - file: "tests/session_tests.rs"
    items:
      - type: "function"
        name: "test_learning_session_basic_flow"
        description: "Tests basic learning session flow through multiple cards"
      
      - type: "function"
        name: "test_learning_session_quality_ratings"
        description: "Tests quality rating submission and SM-2 state updates"
      
      - type: "function"
        name: "test_learning_session_skip_card"
        description: "Tests skipping cards moves them to end of queue"
      
      - type: "function"
        name: "test_learning_session_pause_resume"
        description: "Tests session pause and resume preserves state"
      
      - type: "function"
        name: "test_learning_session_batch_save"
        description: "Tests batch saving occurs at correct intervals"
      
      - type: "function"
        name: "test_learning_session_completion"
        description: "Tests session completion returns correct result summary"
      
      - type: "function"
        name: "test_practice_session_mode_progression"
        description: "Tests practice mode progression on successful recognition"
      
      - type: "function"
        name: "test_practice_session_watch_mode"
        description: "Tests watch animation mode behavior"
      
      - type: "function"
        name: "test_practice_session_trace_with_guide"
        description: "Tests tracing with guide overlay"
      
      - type: "function"
        name: "test_practice_session_trace_without_guide"
        description: "Tests tracing without visible guide"
      
      - type: "function"
        name: "test_practice_session_free_drawing"
        description: "Tests free drawing mode with recognition validation"
      
      - type: "function"
        name: "test_practice_session_hint_system"
        description: "Tests hint display and tracking"
      
      - type: "function"
        name: "test_practice_session_reset_mode"
        description: "Tests resetting current mode for retry"
      
      - type: "function"
        name: "test_practice_validation_thresholds"
        description: "Tests recognition threshold requirements per mode"
      
      - type: "function"
        name: "test_session_statistics_tracking"
        description: "Tests session statistics accurately track review data"
      
      - type: "function"
        name: "test_session_statistics_timing"
        description: "Tests timing tracking per card and session total"
      
      - type: "function"
        name: "test_session_keyboard_shortcuts"
        description: "Tests keyboard shortcut handling in session UI"
      
      - type: "function"
        name: "test_feedback_animation"
        description: "Tests feedback animation display and lifecycle"

formal_verification:
  needed: false
  level: "None"
  explanation: |
    Formal verification is not required for the learning session and practice mode
    implementation for several reasons:

    1. **UI and State Machine Logic**: This task primarily involves UI interactions,
       state transitions, and user experience flows. These are best validated through
       integration testing and user testing rather than formal methods, as the
       correctness criteria are largely behavioral and ergonomic rather than
       mathematical.

    2. **No Safety-Critical Operations**: While the session must correctly update
       spaced repetition state, there are no safety-critical operations that could
       cause data loss or system corruption. The SM-2 algorithm itself (Task 7)
       handles the mathematical correctness of review scheduling.

    3. **Testable Through Integration Tests**: The key properties (session
       progression, practice mode transitions, database saves) are effectively
       verified through integration tests that exercise the full state machine.
       The 18 planned integration tests provide comprehensive coverage of state
       transitions and user flows.

    4. **Soft Real-Time Constraints**: The animations and UI responsiveness have
       soft deadlines but no hard real-time requirements. Performance issues would
       degrade user experience but not cause system failures.

    5. **Recoverable State**: Session interruption and resume is designed with
       explicit state persistence. Any issues can be recovered by restarting the
       session from the last saved checkpoint without data loss.

    6. **Delegation of Complexity**: The complex algorithms (SM-2 scheduling,
       handwriting recognition, stroke animation) are handled by their respective
       modules (Tasks 4, 5, 7). This task primarily orchestrates these components,
       making its logic more suitable for behavioral testing than formal verification.

    The recommended approach is comprehensive integration testing combined with
    property-based tests for session statistics accuracy and state transition
    validity, which provides better value than formal verification for this
    UI-heavy, orchestration-focused component.

tests:
  strategy:
    approach: "mixed (unit tests + integration tests)"
    rationale:
      - "Session state machines have complex transitions requiring unit tests for logic isolation"
      - "Integration tests verify end-to-end flows across multiple components (ReviewQueue, SM2, animations, canvas)"
      - "Practice mode progression through four stages needs comprehensive state transition testing"
      - "Session interruption/resume scenarios require integration-level validation"
      - "Database batch save operations need integration testing with persistence layer"
      - "Statistical accuracy validation requires real session flow testing"
      - "User interaction flows (quality ratings, practice attempts) span multiple systems"

  implementation:
    file: "tests/learning_session_tests.rs"
    location: "create new"
    code: |
      #[cfg(test)]
      mod learning_session_tests {
          use super::*;
          use crate::sm2::{SM2Card, Quality, ReviewQueue};
          use crate::models::Character;
          use std::time::Duration;

          // Mock character for testing
          fn create_test_character(id: u32, character: &str) -> Character {
              Character {
                  id,
                  character: character.to_string(),
                  pinyin: "test".to_string(),
                  meaning: "test meaning".to_string(),
                  stroke_count: 5,
                  radical: "test".to_string(),
                  hsk_level: Some(1),
              }
          }

          // Mock SM2Card for testing
          fn create_test_card(character_id: u32) -> SM2Card {
              SM2Card::new(character_id)
          }

          #[test]
          fn test_learning_session_creation() {
              // Test that a new learning session initializes correctly
              let cards = vec![create_test_card(1), create_test_card(2)];
              let session = LearningSession::new(cards.clone());
              
              assert_eq!(session.total_cards(), 2);
              assert_eq!(session.current_index(), 0);
              assert_eq!(session.cards_remaining(), 2);
              assert!(!session.is_complete());
          }

          #[test]
          fn test_learning_session_progress_through_cards() {
              // Test session progresses through all cards
              let cards = vec![create_test_card(1), create_test_card(2), create_test_card(3)];
              let mut session = LearningSession::new(cards);
              
              assert_eq!(session.current_card_id(), Some(1));
              
              session.submit_quality(Quality::Good);
              assert_eq!(session.current_index(), 1);
              assert_eq!(session.current_card_id(), Some(2));
              assert_eq!(session.cards_remaining(), 2);
              
              session.submit_quality(Quality::Perfect);
              assert_eq!(session.current_index(), 2);
              assert_eq!(session.current_card_id(), Some(3));
              assert_eq!(session.cards_remaining(), 1);
              
              session.submit_quality(Quality::Hard);
              assert!(session.is_complete());
              assert_eq!(session.cards_remaining(), 0);
          }

          #[test]
          fn test_learning_session_quality_ratings_update_cards() {
              // Test that quality ratings properly update card state
              let mut card = create_test_card(1);
              let initial_interval = card.interval;
              
              let mut session = LearningSession::new(vec![card]);
              session.submit_quality(Quality::Good);
              
              let updated_card = session.get_card(0).unwrap();
              assert!(updated_card.interval > initial_interval);
              assert_eq!(updated_card.repetitions, 1);
          }

          #[test]
          fn test_learning_session_statistics_tracking() {
              // Test session statistics are calculated correctly
              let cards = vec![create_test_card(1), create_test_card(2)];
              let mut session = LearningSession::new(cards);
              
              session.submit_quality(Quality::Good);
              session.submit_quality(Quality::Perfect);
              
              let stats = session.statistics();
              assert_eq!(stats.cards_reviewed, 2);
              assert_eq!(stats.quality_distribution.get(&Quality::Good), Some(&1));
              assert_eq!(stats.quality_distribution.get(&Quality::Perfect), Some(&1));
              assert!(stats.average_quality() > 4.0);
          }

          #[test]
          fn test_learning_session_empty_queue() {
              // Test handling of empty card queue
              let session = LearningSession::new(vec![]);
              
              assert_eq!(session.total_cards(), 0);
              assert!(session.is_complete());
              assert_eq!(session.current_card_id(), None);
          }

          #[test]
          fn test_learning_session_pause_resume() {
              // Test session can be paused and resumed
              let cards = vec![create_test_card(1), create_test_card(2)];
              let mut session = LearningSession::new(cards);
              
              session.submit_quality(Quality::Good);
              let state = session.serialize();
              
              let mut resumed_session = LearningSession::deserialize(state);
              assert_eq!(resumed_session.current_index(), 1);
              assert_eq!(resumed_session.cards_remaining(), 1);
              
              resumed_session.submit_quality(Quality::Perfect);
              assert!(resumed_session.is_complete());
          }

          #[test]
          fn test_learning_session_batch_save_trigger() {
              // Test that batch saves trigger at correct intervals
              let cards: Vec<SM2Card> = (0..15).map(|i| create_test_card(i)).collect();
              let mut session = LearningSession::new(cards);
              session.set_batch_size(5);
              
              for i in 0..4 {
                  session.submit_quality(Quality::Good);
                  assert_eq!(session.pending_saves(), i + 1);
              }
              
              session.submit_quality(Quality::Good); // 5th card triggers save
              assert_eq!(session.pending_saves(), 0);
              assert_eq!(session.save_count(), 1);
          }

          #[test]
          fn test_learning_session_time_tracking() {
              // Test session tracks time per card
              let cards = vec![create_test_card(1), create_test_card(2)];
              let mut session = LearningSession::new(cards);
              
              std::thread::sleep(Duration::from_millis(100));
              session.submit_quality(Quality::Good);
              
              let stats = session.statistics();
              assert!(stats.time_per_card.len() == 1);
              assert!(stats.time_per_card[0] >= Duration::from_millis(100));
              assert!(stats.total_time() >= Duration::from_millis(100));
          }

          #[test]
          fn test_learning_session_again_quality_requeues_card() {
              // Test that Quality::Again requeues the card
              let cards = vec![create_test_card(1), create_test_card(2)];
              let mut session = LearningSession::new(cards);
              
              session.submit_quality(Quality::Again);
              
              // Card should be requeued and appear later
assert_eq!(session.cards_remaining(), 2);
              assert_eq!(session.total_cards(), 3); // Original 2 + 1 requeued
          }
      }

      #[cfg(test)]
      mod practice_session_tests {
          use super::*;
          use crate::models::Character;
          use crate::stroke_animation::StrokeOrderAnimation;
          use crate::handwriting::{HandwritingCanvas, RecognitionResult};

          fn create_test_character_with_strokes(id: u32) -> Character {
              Character {
                  id,
                  character: "一".to_string(),
                  pinyin: "yi".to_string(),
                  meaning: "one".to_string(),
                  stroke_count: 1,
                  radical: "一".to_string(),
                  hsk_level: Some(1),
              }
          }

          #[test]
          fn test_practice_session_starts_in_watch_mode() {
              // Test practice session begins with animation watching
              let character = create_test_character_with_strokes(1);
              let session = PracticeSession::new(character);
              
              assert_eq!(session.current_mode(), PracticeMode::WatchAnimation);
              assert_eq!(session.attempt_count(), 0);
              assert!(!session.is_complete());
          }

          #[test]
          fn test_practice_mode_progression_on_success() {
              // Test practice mode advances through stages on successful recognition
              let character = create_test_character_with_strokes(1);
              let mut session = PracticeSession::new(character);
              
              // Start in WatchAnimation
              assert_eq!(session.current_mode(), PracticeMode::WatchAnimation);
              session.complete_watch_mode();
              
              // Progress to TraceWithGuide
              assert_eq!(session.current_mode(), PracticeMode::TraceWithGuide);
              session.submit_drawing_with_result(RecognitionResult::Success { confidence: 0.95 });
              
              // Progress to TraceWithoutGuide
              assert_eq!(session.current_mode(), PracticeMode::TraceWithoutGuide);
              session.submit_drawing_with_result(RecognitionResult::Success { confidence: 0.90 });
              
              // Progress to FreeDrawing
              assert_eq!(session.current_mode(), PracticeMode::FreeDrawing);
              session.submit_drawing_with_result(RecognitionResult::Success { confidence: 0.85 });
              
              // Session complete
              assert!(session.is_complete());
          }

          #[test]
          fn test_practice_mode_stays_on_failure() {
              // Test practice mode doesn't advance on recognition failure
              let character = create_test_character_with_strokes(1);
              let mut session = PracticeSession::new(character);
              
              session.complete_watch_mode();
              assert_eq!(session.current_mode(), PracticeMode::TraceWithGuide);
              
              session.submit_drawing_with_result(RecognitionResult::Failure { confidence: 0.3 });
              
              // Should remain in TraceWithGuide mode
              assert_eq!(session.current_mode(), PracticeMode::TraceWithGuide);
              assert_eq!(session.attempt_count(), 1);
          }

          #[test]
          fn test_practice_session_tracks_attempts_per_mode() {
              // Test session tracks attempt count for each mode
              let character = create_test_character_with_strokes(1);
              let mut session = PracticeSession::new(character);
              
              session.complete_watch_mode();
              
              session.submit_drawing_with_result(RecognitionResult::Failure { confidence: 0.4 });
              session.submit_drawing_with_result(RecognitionResult::Failure { confidence: 0.5 });
              session.submit_drawing_with_result(RecognitionResult::Success { confidence: 0.9 });
              
              let stats = session.mode_statistics(PracticeMode::TraceWithGuide);
              assert_eq!(stats.attempts, 3);
              assert_eq!(stats.failures, 2);
              assert_eq!(stats.successes, 1);
          }

          #[test]
          fn test_practice_session_skip_functionality() {
              // Test skip button advances mode without recognition
              let character = create_test_character_with_strokes(1);
              let mut session = PracticeSession::new(character);
              
              session.complete_watch_mode();
              assert_eq!(session.current_mode(), PracticeMode::TraceWithGuide);
              
              session.skip_current_mode();
              assert_eq!(session.current_mode(), PracticeMode::TraceWithoutGuide);
              
              let stats = session.statistics();
              assert_eq!(stats.modes_skipped, 1);
          }

          #[test]
          fn test_practice_session_hint_system() {
              // Test hint button shows next stroke
              let character = create_test_character_with_strokes(1);
              let mut session = PracticeSession::new(character);
              
              session.complete_watch_mode();
              
              let hint = session.request_hint();
              assert!(hint.is_some());
              assert_eq!(session.hints_used(), 1);
              
              let stats = session.statistics();
              assert_eq!(stats.hints_used, 1);
          }

          #[test]
          fn test_practice_session_confidence_threshold() {
              // Test recognition requires minimum confidence threshold
              let character = create_test_character_with_strokes(1);
              let mut session = PracticeSession::new(character);
              session.complete_watch_mode();
              
              // Low confidence should fail even with "success" result
              session.submit_drawing_with_result(RecognitionResult::Success { confidence: 0.5 });
              assert_eq!(session.current_mode(), PracticeMode::TraceWithGuide);
              
              // High confidence should succeed
              session.submit_drawing_with_result(RecognitionResult::Success { confidence: 0.85 });
              assert_eq!(session.current_mode(), PracticeMode::TraceWithoutGuide);
          }

          #[test]
          fn test_practice_session_statistics() {
              // Test comprehensive statistics tracking
              let character = create_test_character_with_strokes(1);
              let mut session = PracticeSession::new(character);
              
              session.complete_watch_mode();
              session.submit_drawing_with_result(RecognitionResult::Success { confidence: 0.9 });
              session.submit_drawing_with_result(RecognitionResult::Success { confidence: 0.85 });
              session.submit_drawing_with_result(RecognitionResult::Success { confidence: 0.8 });
              
              let stats = session.statistics();
              assert_eq!(stats.total_attempts, 3);
              assert_eq!(stats.successful_attempts, 3);
              assert!(stats.average_confidence() > 0.8);
              assert_eq!(stats.modes_completed, 4);
          }
      }

      #[cfg(test)]
      mod integration_tests {
          use super::*;
          use crate::sm2::{SM2Card, Quality, ReviewQueue};
          use crate::models::Character;
          use crate::persistence::Database;

          #[test]
          fn test_full_learning_session_workflow() {
              // Integration test: Full session from queue to completion with database saves
              let mut db = Database::new_in_memory();
              
              // Setup characters and cards
              let characters = vec![
                  Character { id: 1, character: "一".to_string(), pinyin: "yi".to_string(), 
                             meaning: "one".to_string(), stroke_count: 1, radical: "一".to_string(), 
                             hsk_level: Some(1) },
                  Character { id: 2, character: "二".to_string(), pinyin: "er".to_string(), 
                             meaning: "two".to_string(), stroke_count: 2, radical: "二".to_string(), 
                             hsk_level: Some(1) },
              ];
              
              for char in &characters {
                  db.insert_character(char.clone()).unwrap();
              }
              
              let mut queue = ReviewQueue::new();
              queue.add_card(SM2Card::new(1));
              queue.add_card(SM2Card::new(2));
              
              let cards = queue.get_due_cards();
              let mut session = LearningSession::new(cards);
              session.set_database(&mut db);
              
              // Review first card
              session.submit_quality(Quality::Good);
              assert_eq!(session.current_index(), 1);
              
              // Review second card
              session.submit_quality(Quality::Perfect);
              assert!(session.is_complete());
              
              // Verify statistics
              let stats = session.statistics();
              assert_eq!(stats.cards_reviewed, 2);
              
              // Verify database persistence
              session.save_to_database().unwrap();
              let saved_card = db.get_card(1).unwrap();
              assert!(saved_card.interval > 0);
          }

          #[test]
          fn test_session_with_review_queue_integration() {
              // Integration test: Session pulls correctly from ReviewQueue
              let mut queue = ReviewQueue::new();
              
              let card1 = SM2Card::new(1);
              let card2 = SM2Card::new(2);
              let card3 = SM2Card::new(3);
              
              queue.add_card(card1);
              queue.add_card(card2);
              queue.add_card(card3);
              
              let due_cards = queue.get_due_cards();
              assert_eq!(due_cards.len(), 3);
              
              let mut session = LearningSession::new(due_cards);
              
              while !session.is_complete() {
                  session.submit_quality(Quality::Good);
              }
              
              assert_eq!(session.statistics().cards_reviewed, 3);
          }

          #[test]
          fn test_practice_to_learning_session_flow() {
              // Integration test: Complete practice session then review
              let character = Character {
                  id: 1,
                  character: "一".to_string(),
                  pinyin: "yi".to_string(),
                  meaning: "one".to_string(),
                  stroke_count: 1,
                  radical: "一".to_string(),
                  hsk_level: Some(1),
              };
              
              // Practice session
              let mut practice = PracticeSession::new(character.clone());
              practice.complete_watch_mode();
              practice.submit_drawing_with_result(RecognitionResult::Success { confidence: 0.9 });
              practice.submit_drawing_with_result(RecognitionResult::Success { confidence: 0.9 });
              practice.submit_drawing_with_result(RecognitionResult::Success { confidence: 0.9 });
              
              assert!(practice.is_complete());
              
              // Transition to learning session
              let card = SM2Card::new(character.id);
              let mut learning = LearningSession::new(vec![card]);
              learning.submit_quality(Quality::Good);
              
              assert!(learning.is_complete());
          }

          #[test]
          fn test_session_interruption_and_resume() {
              // Integration test: Session interrupted mid-flow and resumed
              let cards = vec![
                  SM2Card::new(1),
                  SM2Card::new(2),
                  SM2Card::new(3),
                  SM2Card::new(4),
              ];
              
              let mut session = LearningSession::new(cards);
              
              // Review some cards
              session.submit_quality(Quality::Good);
              session.submit_quality(Quality::Perfect);
              
              // Interrupt and serialize
              let serialized = session.serialize();
              drop(session);
              
              // Resume session
              let mut resumed = LearningSession::deserialize(serialized);
              assert_eq!(resumed.current_index(), 2);
              assert_eq!(resumed.cards_remaining(), 2);
              
              // Complete remaining cards
              resumed.submit_quality(Quality::Hard);
              resumed.submit_quality(Quality::Good);
              
              assert!(resumed.is_complete());
              assert_eq!(resumed.statistics().cards_reviewed, 4);
          }

          #[test]
          fn test_batch_save_persistence() {
              // Integration test: Verify batch saves work correctly
              let mut db = Database::new_in_memory();
              let cards: Vec<SM2Card> = (1..=12).map(|i| SM2Card::new(i)).collect();
              
              let mut session = LearningSession::new(cards);
              session.set_database(&mut db);
              session.set_batch_size(5);
              
              // Review cards and verify batch saves
              for _ in 0..5 {
                  session.submit_quality(Quality::Good);
              }
              
              // First batch should be saved
              assert_eq!(session.save_count(), 1);
              assert_eq!(db.count_cards().unwrap(), 5);
              
              for _ in 0..5 {
                  session.submit_quality(Quality::Good);
              }
              
              // Second batch should be saved
              assert_eq!(session.save_count(), 2);
              assert_eq!(db.count_cards().unwrap(), 10);
          }
      }

  coverage:
    - "LearningSession initializes with correct state (total cards, index, remaining)"
    - "Session progresses through all cards sequentially"
    - "Quality ratings correctly update SM2Card state (interval, repetitions)"
    - "Session statistics track cards reviewed, quality distribution, average quality"
    - "Empty card queue handled gracefully"
    - "Session pause/resume maintains correct state"
    - "Batch save triggers at configured intervals (every 5-10 cards)"
    - "Time tracking per card and total session time"
    - "Quality::Again requeues cards for later review"
    - "PracticeSession starts in WatchAnimation mode"
    - "Practice mode progresses through all four stages on success"
    - "Practice mode remains on current stage on recognition failure"
    - "Attempt count tracked per mode (successes and failures)"
    - "Skip functionality allows advancing without recognition"
    - "Hint system provides stroke guidance and tracks usage"
    - "Recognition confidence threshold enforced for progression"
    - "Practice session statistics (total attempts, average confidence, modes completed)"
    - "Full learning session workflow with database persistence"
    - "ReviewQueue integration with session card pulling"
    - "Practice-to-learning session transition flow"
    - "Session interruption and resume with state preservation"
    - "Batch save persistence to database verified"
    - "Progress bar calculation (cards remaining/total)"
    - "Session completion detection"
    - "Multiple quality ratings processed correctly"
    - "Session summary screen data accuracy"

dependencies:
  depends_on:
    - task_id: 2
      reason: "Needs character data for session display and practice modes"
    - task_id: 3
      reason: "Needs CharacterCard widget for flashcard presentation"
    - task_id: 4
      reason: "Needs stroke animation for watch mode in practice sessions"
    - task_id: 5
      reason: "Needs drawing canvas and recognition for practice trace/free modes"
    - task_id: 6
      reason: "Needs state management framework for session view models"
    - task_id: 7
      reason: "Needs SM-2 algorithm, ReviewQueue, and card state management"

  depended_upon_by:
    - task_id: 10
      reason: "Statistics module aggregates session data for analytics"
    - task_id: 11
      reason: "Persistence layer stores session state for pause/resume"

  external:
    - name: "Duration"
      type: "struct"
      status: "already exists"
    - name: "Instant"
      type: "struct"
      status: "already exists"
    - name: "Character"
      type: "struct"
      status: "already exists"
    - name: "SM2Card"
      type: "struct"
      status: "already exists"
    - name: "ReviewQueue"
      type: "struct"
      status: "already exists"
    - name: "StrokeOrderAnimation"
      type: "struct"
      status: "already exists"
    - name: "HandwritingCanvas"
      type: "struct"
      status: "already exists"
    - name: "Database"
      type: "struct"
      status: "already exists"
---
task:
  id: 9
  name: "Character Recognition Integration"

context:
  description: |
    This task implements the character recognition system that validates user-drawn
    characters in practice mode. The system accepts raw stroke data from the drawing
    canvas, normalizes it to a resolution-independent format, calls an external
    recognition engine (hanzi_lookup or similar), and validates results against
    expected characters.
    
    Recognition is critical for providing objective assessment of learning progress.
    Users draw characters from memory, and the system must accurately determine if
    their handwriting matches the target character while being tolerant of natural
    handwriting variation. The system must balance accuracy (preventing false positives
    that allow incorrect forms) with usability (preventing false negatives that
    frustrate learners with valid attempts).
    
    The implementation consists of four main components: stroke normalization (converts
    arbitrary coordinate spaces to 0-1 range, resamples for consistent density, smooths
    noise), recognition engine interface (FFI or WASM wrapper for external library),
    result validation (checks if expected character appears in top-N with sufficient
    confidence), and feedback generation (provides helpful guidance for failed attempts).
    
    This is a complex integration task with high risk due to external library dependencies,
    platform-specific FFI concerns, and the need for empirical threshold tuning based
    on real user data. The system's UX quality depends heavily on getting the balance
    right between strictness and tolerance.

  key_points:
    - "Normalization must be resolution-independent to work across devices and screen sizes"
    - "Stroke order and direction must be preserved as they are significant in Japanese writing"
    - "Recognition threshold tuning (top-N, confidence %) dramatically affects user experience"
    - "External recognition library may not support kana well - most focus on kanji"
    - "Performance budget of <200ms is critical for responsive practice mode feedback"
    - "False positive rate <5% prevents users from reinforcing incorrect character forms"
    - "Stroke count validation provides quick feedback for common errors before expensive recognition"
    - "System must handle platform-specific FFI bindings or WASM bridge for recognition engine"
    - "Feedback quality is essential for learning - must diagnose common error types"
    - "Statistical validation through integration testing more appropriate than formal verification"

files:
  - path: "src/recognition/mod.rs"
    description: "Main recognition module that exports normalization, recognition engine interface, and validation functionality"
  
  - path: "src/recognition/normalize.rs"
    description: "Stroke normalization functions including coordinate scaling, resampling, and smoothing"
  
  - path: "src/recognition/engine.rs"
    description: "Recognition engine interface and FFI/WASM wrapper for external recognition library (hanzi_lookup or similar)"
  
  - path: "src/recognition/validator.rs"
    description: "Validation logic to check recognition results against expected characters with confidence thresholding"
  
  - path: "src/recognition/feedback.rs"
    description: "Feedback generation for incorrect recognition attempts, including stroke count hints"
  
  - path: "tests/recognition_tests.rs"
    description: "Integration tests for recognition pipeline including normalization, recognition, and validation with sample stroke data"

functions:
  - file: "src/recognition/mod.rs"
    items:
      - type: "module_declaration"
        name: "recognition"
        description: "Root module for character recognition functionality, containing stroke normalization, recognition engine interface, and validation logic"
      
      - type: "function"
        name: "recognize_character"
        description: "High-level API function that performs full recognition pipeline: normalize, recognize, validate"
        preconditions: "Raw strokes from canvas, expected character known"
        postconditions: "Returns validation result with feedback, completes in <200ms"
        invariants: "Thread-safe, can be called concurrently"
      
      - type: "struct"
        name: "RecognitionPipeline"
        description: "Orchestrates the full recognition workflow from raw strokes to validation result"
      
      - type: "function"
        name: "new_pipeline"
        description: "Creates a new recognition pipeline with specified configuration"
        preconditions: "Recognition engine can be initialized"
        postconditions: "Pipeline ready to process recognition requests"

  - file: "src/recognition/normalize.rs"
    items:
      - type: "struct"
        name: "NormalizedStroke"
        description: "Represents a stroke normalized to 0-1 coordinate range with consistent point density"
        invariants: "All coordinates are in range [0.0, 1.0]"
      
      - type: "struct"
        name: "NormalizationConfig"
        description: "Configuration for stroke normalization including resampling point count and smoothing parameters"
      
      - type: "function"
        name: "normalize_strokes"
        description: "Normalizes a collection of raw strokes to unit square (0-1 range) while preserving relative positions and stroke order"
        preconditions: "Input strokes contain at least one point each"
        postconditions: "Output coordinates are in [0.0, 1.0] range, stroke count and order preserved"
        invariants: "Relative positioning between strokes maintained"
      
      - type: "function"
        name: "compute_bounding_box"
        description: "Computes the minimum bounding box containing all points in all strokes"
        preconditions: "At least one stroke with at least one point"
        postconditions: "Returns valid bounding box with min < max in both dimensions"
      
      - type: "function"
        name: "scale_to_unit_square"
        description: "Scales stroke coordinates from original bounding box to 0-1 range"
        preconditions: "Bounding box has non-zero width and height"
        postconditions: "All output coordinates in [0.0, 1.0] range"
      
      - type: "function"
        name: "resample_stroke"
        description: "Resamples a stroke to have a fixed number of evenly-spaced points along its path"
        preconditions: "Stroke has at least 2 points, target_points >= 2"
        postconditions: "Output stroke has exactly target_points points"
      
      - type: "function"
        name: "smooth_stroke"
        description: "Applies smoothing filter to reduce noise in stroke points while preserving overall shape"
        preconditions: "Stroke has at least 3 points"
        postconditions: "Output stroke has same number of points, reduced high-frequency noise"

  - file: "src/recognition/engine.rs"
    items:
      - type: "struct"
        name: "RecognitionEngine"
        description: "Interface to character recognition library (hanzi_lookup or similar), handles FFI/WASM calls"
      
      - type: "struct"
        name: "RecognitionResult"
        description: "Contains a candidate character match with its confidence score"
        invariants: "Confidence is in range [0.0, 1.0]"
      
      - type: "struct"
        name: "RecognitionConfig"
        description: "Configuration for recognition engine including model path, confidence thresholds, and top-N result count"
      
      - type: "function"
        name: "new"
        description: "Creates a new RecognitionEngine instance, initializing the underlying recognition library"
        preconditions: "Recognition library available and loadable"
        postconditions: "Engine ready to accept recognition requests"
      
      - type: "function"
        name: "recognize"
        description: "Performs character recognition on normalized strokes, returning ranked candidate matches"
        preconditions: "Engine initialized, strokes normalized"
        postconditions: "Returns sorted results by confidence (descending), completes in <200ms"
      
      - type: "function"
        name: "recognize_with_hint"
        description: "Performs recognition with a stroke count hint to improve accuracy"
        preconditions: "Engine initialized, strokes normalized, hint matches expected character"
        postconditions: "Returns results filtered or boosted by stroke count constraint"
      
      - type: "function"
        name: "format_strokes_for_engine"
        description: "Converts normalized strokes to the format expected by the recognition library"
        preconditions: "Strokes are normalized"
        postconditions: "Returns data structure compatible with recognition library input format"

  - file: "src/recognition/validator.rs"
    items:
      - type: "struct"
        name: "ValidationResult"
        description: "Result of validating recognition against expected character, includes success status and feedback"
      
      - type: "struct"
        name: "ValidationConfig"
        description: "Configuration for validation including confidence threshold, top-N count, and strict mode flag"
      
      - type: "function"
        name: "validate_recognition"
        description: "Checks if expected character appears in top-N recognition results with sufficient confidence"
        preconditions: "Recognition results non-empty, expected character is valid"
        postconditions: "Returns validation result with success boolean and feedback message"
      
      - type: "function"
        name: "check_stroke_count"
        description: "Validates that the number of strokes matches the expected count for the character"
        preconditions: "Expected character exists in stroke count database"
        postconditions: "Returns true if stroke count matches, false otherwise"
      
      - type: "function"
        name: "compute_false_positive_rate"
        description: "Computes false positive rate on a test dataset for threshold tuning"
        preconditions: "Test dataset contains labeled stroke samples"
        postconditions: "Returns false positive rate as percentage in [0.0, 100.0]"

  - file: "src/recognition/feedback.rs"
    items:
      - type: "struct"
        name: "FeedbackMessage"
        description: "Structured feedback message with error type, description, and improvement hints"
      
      - type: "enum"
        name: "ErrorType"
        description: "Categories of recognition errors: StrokeCount, StrokeOrder, StrokeShape, LowConfidence, NotRecognized"
      
      - type: "function"
        name: "generate_feedback"
        description: "Generates helpful feedback message based on recognition failure mode"
        preconditions: "Recognition was attempted and validation failed"
        postconditions: "Returns actionable feedback message"
      
      - type: "function"
        name: "detect_error_type"
        description: "Analyzes recognition results and actual strokes to determine likely error cause"
        preconditions: "Recognition results and expected character available"
        postconditions: "Returns most likely error type"
      
      - type: "function"
        name: "suggest_improvement"
        description: "Provides specific improvement suggestions based on error type"
        preconditions: "Error type has been detected"
        postconditions: "Returns 1-3 actionable improvement tips"

  - file: "tests/recognition_tests.rs"
    items:
      - type: "function"
        name: "test_normalize_single_stroke"
        description: "Tests that single stroke normalization produces 0-1 range coordinates"
      
      - type: "function"
        name: "test_normalize_preserves_order"
        description: "Tests that stroke order and point order are preserved during normalization"
      
      - type: "function"
        name: "test_resample_consistent_points"
        description: "Tests that resampling produces exactly the requested number of points"
      
      - type: "function"
        name: "test_recognition_with_sample_data"
        description: "Integration test using sample kana stroke data to verify end-to-end recognition"
      
      - type: "function"
        name: "test_validation_accepts_correct_match"
        description: "Tests that validation succeeds when expected character is in top results"
      
      - type: "function"
        name: "test_validation_rejects_wrong_character"
        description: "Tests that validation fails when expected character is not in results"
      
      - type: "function"
        name: "test_stroke_count_validation"
        description: "Tests that stroke count mismatch is detected"
      
      - type: "function"
        name: "test_feedback_generation"
        description: "Tests that appropriate feedback is generated for different error types"
      
      - type: "function"
        name: "test_recognition_performance"
        description: "Tests that recognition completes within 200ms time budget"
      
      - type: "function"
        name: "test_false_positive_rate"
        description: "Tests that false positive rate is below 5% threshold on test dataset"
      
      - type: "function"
        name: "test_bounding_box_computation"
        description: "Tests that bounding box correctly encompasses all stroke points"
      
      - type: "function"
        name: "test_smoothing_reduces_noise"
        description: "Tests that smoothing filter reduces point-to-point variance while preserving shape"

formal_verification:
  needed: false
  level: "None"
  explanation: |
    Formal verification is not required for the character recognition integration task
    for the following reasons:
    
    1. Recognition is inherently probabilistic: The character recognition system deals
       with imperfect user input and returns confidence scores. The correctness cannot
       be formally proven since it depends on statistical pattern matching rather than
       deterministic logic. The system is designed to handle ambiguity and uncertainty.
    
    2. External dependency behavior: The core recognition logic resides in external
       libraries (hanzi_lookup or similar). We cannot formally verify properties of
       third-party code, and the integration layer is primarily concerned with data
       transformation and result interpretation rather than critical correctness.
    
    3. Tolerance for false negatives acceptable: Unlike safety-critical systems, a
       recognition failure in a learning application has minimal consequences - the user
       simply tries again. The system provides educational feedback rather than making
       irreversible decisions.
    
    4. Empirical validation more appropriate: Recognition quality is best validated
       through integration testing with real handwriting samples and empirical measurement
       of accuracy, precision, and recall metrics. The acceptance criteria (false positive
       rate <5%, latency <200ms) are statistical properties requiring empirical testing.
    
    5. Preprocessing determinism is straightforward: While stroke normalization should
       be deterministic, the algorithms (coordinate scaling, resampling) are simple
       geometric transformations easily verified through standard unit and property-based
       tests without formal methods.
    
    6. Threshold tuning is empirical: The confidence thresholds (top-N results, >70%
       confidence) will be tuned based on user testing and data collection, not formal
       analysis. These are UX parameters rather than correctness invariants.
    
    Integration testing with diverse handwriting samples, property-based testing for
    normalization invariants, and statistical analysis of recognition accuracy provide
    more practical and cost-effective validation than formal verification for this
    ML-adjacent component.

tests:
  strategy:
    approach: "mixed (unit + integration + property-based)"
    rationale:
      - "Unit tests verify individual components (normalization, coordinate transformation, resampling) in isolation"
      - "Integration tests validate end-to-end recognition pipeline with real stroke data and external library interaction"
      - "Property-based tests ensure normalization invariants hold across arbitrary input ranges"
      - "Recognition accuracy and performance require integration testing with sample datasets"
      - "Validation logic needs both unit tests (threshold checking) and integration tests (real recognition results)"
      - "False positive rate measurement requires statistical testing across diverse test cases"

  implementation:
    file: "tests/recognition_tests.rs"
    location: "create new"
    code: |
      #[cfg(test)]
      mod tests {
          use super::*;
          use approx::assert_relative_eq;
          
          // ========== Stroke Normalization Tests ==========
          
          #[test]
          fn test_normalize_single_stroke_to_unit_square() {
              // Stroke with coordinates in pixel space (100x100 to 300x300)
              let stroke = vec![
                  Point { x: 100.0, y: 100.0 },
                  Point { x: 200.0, y: 200.0 },
                  Point { x: 300.0, y: 300.0 },
              ];
              
              let normalized = normalize_stroke(&stroke);
              
              // All coordinates should be in [0, 1] range
              assert_relative_eq!(normalized[0].x, 0.0, epsilon = 0.001);
              assert_relative_eq!(normalized[0].y, 0.0, epsilon = 0.001);
              assert_relative_eq!(normalized[1].x, 0.5, epsilon = 0.001);
              assert_relative_eq!(normalized[1].y, 0.5, epsilon = 0.001);
              assert_relative_eq!(normalized[2].x, 1.0, epsilon = 0.001);
              assert_relative_eq!(normalized[2].y, 1.0, epsilon = 0.001);
          }
          
          #[test]
          fn test_normalize_multiple_strokes_preserves_relative_positions() {
              let strokes = vec![
                  vec![Point { x: 0.0, y: 0.0 }, Point { x: 100.0, y: 0.0 }],
                  vec![Point { x: 0.0, y: 100.0 }, Point { x: 100.0, y: 100.0 }],
              ];
              
              let normalized = normalize_strokes(&strokes);
              
              // Verify bounding box encompasses all strokes
              assert!(normalized.iter().all(|stroke| {
                  stroke.iter().all(|p| p.x >= 0.0 && p.x <= 1.0 && p.y >= 0.0 && p.y <= 1.0)
              }));
              
              // Verify relative positions preserved (second stroke should be below first)
              assert!(normalized[1][0].y > normalized[0][0].y);
          }
          
          #[test]
          fn test_normalize_preserves_stroke_order() {
              let strokes = vec![
                  vec![Point { x: 0.0, y: 0.0 }, Point { x: 50.0, y: 50.0 }],
                  vec![Point { x: 100.0, y: 0.0 }, Point { x: 150.0, y: 50.0 }],
                  vec![Point { x: 0.0, y: 100.0 }, Point { x: 50.0, y: 150.0 }],
              ];
              
              let normalized = normalize_strokes(&strokes);
              
              assert_eq!(normalized.len(), 3);
              assert_eq!(normalized[0].len(), 2);
              assert_eq!(normalized[1].len(), 2);
              assert_eq!(normalized[2].len(), 2);
          }
          
          #[test]
          fn test_normalize_empty_stroke_returns_empty() {
              let stroke: Vec<Point> = vec![];
              let normalized = normalize_stroke(&stroke);
              assert!(normalized.is_empty());
          }
          
          #[test]
          fn test_normalize_single_point_stroke() {
              let stroke = vec![Point { x: 150.0, y: 200.0 }];
              let normalized = normalize_stroke(&stroke);
              
              // Single point should map to (0.5, 0.5) or similar neutral position
              assert_eq!(normalized.len(), 1);
              assert!(normalized[0].x >= 0.0 && normalized[0].x <= 1.0);
              assert!(normalized[0].y >= 0.0 && normalized[0].y <= 1.0);
          }
          
          // ========== Stroke Resampling Tests ==========
          
          #[test]
          fn test_resample_stroke_to_fixed_count() {
              let stroke = vec![
                  Point { x: 0.0, y: 0.0 },
                  Point { x: 0.25, y: 0.25 },
                  Point { x: 0.5, y: 0.5 },
                  Point { x: 0.75, y: 0.75 },
                  Point { x: 1.0, y: 1.0 },
              ];
              
              let resampled = resample_stroke(&stroke, 32);
              
              assert_eq!(resampled.len(), 32);
              // First and last points should be preserved
              assert_relative_eq!(resampled[0].x, 0.0, epsilon = 0.001);
              assert_relative_eq!(resampled[0].y, 0.0, epsilon = 0.001);
              assert_relative_eq!(resampled[31].x, 1.0, epsilon = 0.001);
              assert_relative_eq!(resampled[31].y, 1.0, epsilon = 0.001);
          }
          
          #[test]
          fn test_resample_preserves_general_shape() {
              // L-shaped stroke
              let stroke = vec![
                  Point { x: 0.0, y: 0.0 },
                  Point { x: 0.0, y: 0.5 },
                  Point { x: 0.0, y: 1.0 },
                  Point { x: 0.5, y: 1.0 },
                  Point { x: 1.0, y: 1.0 },
              ];
              
              let resampled = resample_stroke(&stroke, 16);
              
              // Check that resampled points still follow L-shape
              // Early points should have x ≈ 0
              assert!(resampled[0..8].iter().all(|p| p.x < 0.3));
              // Later points should have y ≈ 1.0
              assert!(resampled[8..16].iter().all(|p| p.y > 0.7));
          }
          
          // ========== Stroke Smoothing Tests ==========
          
          #[test]
          fn test_smooth_stroke_reduces_noise() {
              // Noisy zigzag stroke
              let stroke = vec![
                  Point { x: 0.0, y: 0.0 },
                  Point { x: 0.1, y: 0.05 },
                  Point { x: 0.09, y: 0.1 },
                  Point { x: 0.2, y: 0.15 },
                  Point { x: 0.19, y: 0.2 },
              ];
              
              let smoothed = smooth_stroke(&stroke, 3);
              
              // Smoothed stroke should have fewer direction changes
              assert!(smoothed.len() > 0);
              // Middle point should be averaged with neighbors
              assert!(smoothed[2].x > stroke[2].x && smoothed[2].x < stroke[3].x);
          }
          
          // ========== Recognition Interface Tests ==========
          
          #[test]
          fn test_recognition_returns_candidates() {
              let strokes = vec![
                  vec![Point { x: 0.2, y: 0.1 }, Point { x: 0.8, y: 0.9 }],
                  vec![Point { x: 0.8, y: 0.1 }, Point { x: 0.2, y: 0.9 }],
              ];
              
              let candidates = recognize_character(&strokes);
              
              assert!(candidates.len() > 0);
              assert!(candidates.len() <= 10); // Should limit to top N candidates
              
              // Verify candidates are sorted by confidence (descending)
              for i in 1..candidates.len() {
                  assert!(candidates[i-1].confidence >= candidates[i].confidence);
              }
          }
          
          #[test]
          fn test_recognition_candidates_have_valid_confidence() {
              let strokes = vec![
                  vec![Point { x: 0.0, y: 0.0 }, Point { x: 1.0, y: 1.0 }],
              ];
              
              let candidates = recognize_character(&strokes);
              
              for candidate in candidates {
                  assert!(candidate.confidence >= 0.0 && candidate.confidence <= 1.0);
                  assert!(!candidate.character.is_empty());
              }
          }
          
          #[test]
          fn test_recognition_empty_strokes_returns_empty() {
              let strokes: Vec<Vec<Point>> = vec![];
              let candidates = recognize_character(&strokes);
              assert!(candidates.is_empty());
          }
          
          // ========== Validation Tests ==========
          
          #[test]
          fn test_validate_exact_match_in_top_result() {
              let candidates = vec![
                  RecognitionCandidate { character: "あ".to_string(), confidence: 0.95 },
                  RecognitionCandidate { character: "お".to_string(), confidence: 0.75 },
                  RecognitionCandidate { character: "ん".to_string(), confidence: 0.60 },
              ];
              
              let result = validate_recognition(&candidates, "あ", 3, 0.7);
              
              assert!(result.is_match);
              assert_eq!(result.matched_character, Some("あ".to_string()));
              assert_eq!(result.rank, Some(0));
              assert_relative_eq!(result.confidence, 0.95, epsilon = 0.001);
          }
          
          #[test]
          fn test_validate_match_in_top_n() {
              let candidates = vec![
                  RecognitionCandidate { character: "お".to_string(), confidence: 0.85 },
                  RecognitionCandidate { character: "あ".to_string(), confidence: 0.82 },
                  RecognitionCandidate { character: "ん".to_string(), confidence: 0.60 },
              ];
              
              let result = validate_recognition(&candidates, "あ", 3, 0.7);
              
              assert!(result.is_match);
              assert_eq!(result.rank, Some(1));
          }
          
          #[test]
          fn test_validate_fails_below_confidence_threshold() {
              let candidates = vec![
                  RecognitionCandidate { character: "お".to_string(), confidence: 0.85 },
                  RecognitionCandidate { character: "あ".to_string(), confidence: 0.65 },
                  RecognitionCandidate { character: "ん".to_string(), confidence: 0.60 },
              ];
              
              let result = validate_recognition(&candidates, "あ", 3, 0.7);
              
              assert!(!result.is_match);
              assert_eq!(result.matched_character, None);
          }
          
          #[test]
          fn test_validate_fails_outside_top_n() {
              let candidates = vec![
                  RecognitionCandidate { character: "お".to_string(), confidence: 0.85 },
                  RecognitionCandidate { character: "か".to_string(), confidence: 0.82 },
                  RecognitionCandidate { character: "き".to_string(), confidence: 0.80 },
                  RecognitionCandidate { character: "あ".to_string(), confidence: 0.75 },
              ];
              
              let result = validate_recognition(&candidates, "あ", 3, 0.7);
              
              assert!(!result.is_match);
          }
          
          #[test]
          fn test_validate_no_candidates_returns_no_match() {
              let candidates: Vec<RecognitionCandidate> = vec![];
              let result = validate_recognition(&candidates, "あ", 3, 0.7);
              
              assert!(!result.is_match);
              assert_eq!(result.matched_character, None);
              assert_eq!(result.rank, None);
          }
          
          // ========== Feedback Generation Tests ==========
          
          #[test]
          fn test_feedback_for_wrong_character() {
              let candidates = vec![
                  RecognitionCandidate { character: "お".to_string(), confidence: 0.90 },
              ];
              let expected = "あ";
              
              let feedback = generate_feedback(&candidates, expected, 3);
              
              assert!(feedback.contains("お"));
              assert!(feedback.contains("あ"));
              assert!(feedback.contains("recognized") || feedback.contains("looks like"));
          }
          
          #[test]
          fn test_feedback_includes_stroke_count_hint() {
              let candidates = vec![];
              let expected = "あ";
              let stroke_count = 3;
              let expected_stroke_count = 3;
              
              let feedback = generate_feedback_with_stroke_hint(
                  &candidates, 
                  expected, 
                  stroke_count,
                  expected_stroke_count
              );
              
              if stroke_count != expected_stroke_count {
                  assert!(feedback.contains("stroke"));
              }
          }
          
          #[test]
          fn test_feedback_for_close_match() {
              let candidates = vec![
                  RecognitionCandidate { character: "あ".to_string(), confidence: 0.68 },
              ];
              let expected = "あ";
              
              let feedback = generate_feedback(&candidates, expected, 3);
              
              assert!(feedback.contains("close") || feedback.contains("almost"));
          }
          
          // ========== Performance Tests ==========
          
          #[test]
          fn test_recognition_completes_within_time_limit() {
              use std::time::Instant;
              
              let strokes = vec![
                  vec![
                      Point { x: 0.1, y: 0.1 },
                      Point { x: 0.5, y: 0.5 },
                      Point { x: 0.9, y: 0.9 },
                  ],
              ];
              
              let start = Instant::now();
              let _candidates = recognize_character(&strokes);
              let duration = start.elapsed();
              
              assert!(duration.as_millis() < 200, "Recognition took {}ms, expected <200ms", duration.as_millis());
          }
          
          // ========== Integration Tests ==========
          
          #[test]
          fn test_end_to_end_recognition_pipeline() {
              // Raw stroke data in pixel coordinates
              let raw_strokes = vec![
                  vec![
                      Point { x: 100.0, y: 50.0 },
                      Point { x: 150.0, y: 100.0 },
                      Point { x: 200.0, y: 150.0 },
                  ],
                  vec![
                      Point { x: 200.0, y: 50.0 },
                      Point { x: 150.0, y: 100.0 },
                      Point { x: 100.0, y: 150.0 },
                  ],
              ];
              
              // Normalize
              let normalized = normalize_strokes(&raw_strokes);
              
              // Resample
              let resampled: Vec<Vec<Point>> = normalized
                  .iter()
                  .map(|stroke| resample_stroke(stroke, 32))
                  .collect();
              
              // Smooth
              let smoothed: Vec<Vec<Point>> = resampled
                  .iter()
                  .map(|stroke| smooth_stroke(stroke, 3))
                  .collect();
              
              // Recognize
              let candidates = recognize_character(&smoothed);
              
              // Should return valid results
              assert!(candidates.len() > 0);
              assert!(candidates.iter().all(|c| !c.character.is_empty()));
          }
          
          #[test]
          fn test_recognition_with_real_hiragana_data() {
              // Sample stroke data for "あ" (a) - simplified
              let a_strokes = vec![
                  vec![
                      Point { x: 0.5, y: 0.1 },
                      Point { x: 0.5, y: 0.3 },
                  ],
                  vec![
                      Point { x: 0.2, y: 0.4 },
                      Point { x: 0.8, y: 0.4 },
                  ],
                  vec![
                      Point { x: 0.7, y: 0.3 },
                      Point { x: 0.7, y: 0.6 },
                      Point { x: 0.5, y: 0.8 },
                      Point { x: 0.3, y: 0.9 },
                  ],
              ];
              
              let candidates = recognize_character(&a_strokes);
              let result = validate_recognition(&candidates, "あ", 3, 0.7);
              
              // May not always match in unit tests without real recognition engine,
              // but should not crash and should return valid data structure
              assert!(candidates.len() >= 0);
          }
      }
      
      #[cfg(test)]
      mod property_tests {
          use super::*;
          use proptest::prelude::*;
          
          // Generate arbitrary points within reasonable bounds
          fn point_strategy() -> impl Strategy<Value = Point> {
              (0.0f64..1000.0, 0.0f64..1000.0)
                  .prop_map(|(x, y)| Point { x, y })
          }
          
          fn stroke_strategy() -> impl Strategy<Value = Vec<Point>> {
              prop::collection::vec(point_strategy(), 1..50)
          }
          
          fn strokes_strategy() -> impl Strategy<Value = Vec<Vec<Point>>> {
              prop::collection::vec(stroke_strategy(), 1..10)
          }
          
          proptest! {
              #[test]
              fn prop_normalize_always_produces_unit_range(strokes in strokes_strategy()) {
                  let normalized = normalize_strokes(&strokes);
                  
                  for stroke in normalized.iter() {
                      for point in stroke.iter() {
                          prop_assert!(point.x >= 0.0 && point.x <= 1.0);
                          prop_assert!(point.y >= 0.0 && point.y <= 1.0);
                      }
                  }
              }
              
              #[test]
              fn prop_normalize_preserves_stroke_count(strokes in strokes_strategy()) {
                  let normalized = normalize_strokes(&strokes);
                  prop_assert_eq!(normalized.len(), strokes.len());
              }
              
              #[test]
              fn prop_normalize_preserves_point_count_per_stroke(strokes in strokes_strategy()) {
                  let normalized = normalize_strokes(&strokes);
                  
                  for (original, norm) in strokes.iter().zip(normalized.iter()) {
                      prop_assert_eq!(norm.len(), original.len());
                  }
              }
              
              #[test]
              fn prop_resample_produces_exact_count(stroke in stroke_strategy(), count in 5usize..100) {
                  let resampled = resample_stroke(&stroke, count);
                  prop_assert_eq!(resampled.len(), count);
              }
              
              #[test]
              fn prop_smooth_preserves_endpoints(stroke in stroke_strategy()) {
                  if stroke.len() < 2 {
                      return Ok(());
                  }
                  
                  let smoothed = smooth_stroke(&stroke, 3);
                  
                  if !smoothed.is_empty() {
                      // First and last points should be close to originals
                      let epsilon = 0.1;
                      prop_assert!((smoothed[0].x - stroke[0].x).abs() < epsilon);
                      prop_assert!((smoothed[0].y - stroke[0].y).abs() < epsilon);
                      
                      let last_idx = smoothed.len() - 1;
                      let orig_last_idx = stroke.len() - 1;
                      prop_assert!((smoothed[last_idx].x - stroke[orig_last_idx].x).abs() < epsilon);
                      prop_assert!((smoothed[last_idx].y - stroke[orig_last_idx].y).abs() < epsilon);
                  }
                  
                  Ok(())
              }
              
              #[test]
              fn prop_recognition_candidates_sorted_by_confidence(strokes in strokes_strategy()) {
                  let candidates = recognize_character(&strokes);
                  
                  for i in 1..candidates.len() {
                      prop_assert!(candidates[i-1].confidence >= candidates[i].confidence);
                  }
              }
              
              #[test]
              fn prop_validation_consistent_with_candidate_list(
                  confidence in 0.0f64..1.0,
                  rank in 0usize..5
              ) {
                  let mut candidates = vec![];
                  for i in 0..=rank {
                      candidates.push(RecognitionCandidate {
                          character: format!("char{}", i),
                          confidence: 1.0 - (i as f64 * 0.1),
                      });
                  }
                  
                  let expected = format!("char{}", rank);
                  let result = validate_recognition(&candidates, &expected, rank + 1, 0.5);
                  
                  if candidates[rank].confidence >= 0.5 {
                      prop_assert!(result.is_match);
                      prop_assert_eq!(result.rank, Some(rank));
                  }
              }
          }
      }

  coverage:
    - "Stroke normalization to unit square (0-1 range)"
    - "Normalization preserves relative positions of multiple strokes"
    - "Normalization preserves stroke order and point count"
    - "Normalization handles edge cases (empty, single point)"
    - "Stroke resampling to fixed point count"
    - "Resampling preserves endpoints and general shape"
    - "Stroke smoothing reduces noise while preserving shape"
    - "Smoothing preserves stroke endpoints"
    - "Recognition returns ranked candidates with valid confidence scores"
    - "Recognition candidates sorted by confidence (descending)"
    - "Recognition handles empty input gracefully"
    - "Validation identifies exact matches in top position"
    - "Validation identifies matches within top-N results"
    - "Validation respects confidence threshold"
    - "Validation respects top-N limit"
    - "Validation handles empty candidate list"
    - "Feedback generation for incorrect characters"
    - "Feedback includes stroke count hints when applicable"
    - "Feedback distinguishes close matches from wrong attempts"
    - "Recognition completes within 200ms performance requirement"
    - "End-to-end pipeline (normalize → resample → smooth → recognize)"
    - "Integration with real hiragana stroke data"
    - "Property: normalization always produces coordinates in [0,1]"
    - "Property: normalization preserves stroke and point counts"
    - "Property: resampling produces exact requested point count"
    - "Property: smoothing preserves endpoints within tolerance"
    - "Property: recognition candidates always sorted by confidence"
    - "Property: validation results consistent with candidate rankings"

dependencies:
  depends_on:
    - task_id: 5
      reason: "Needs stroke data format from HandwritingCanvas component"
  
  depended_upon_by:
    - task_id: 8
      reason: "PracticeSession uses recognition to validate user attempts in practice mode"
  
  external:
    - name: "hanzi_lookup"
      type: "crate"
      status: "to be imported"
    - name: "Point"
      type: "struct"
      status: "already exists"
    - name: "Stroke"
      type: "struct"
      status: "already exists"
    - name: "approx"
      type: "crate"
      status: "to be imported"
    - name: "proptest"
      type: "crate"
      status: "to be imported"
---
task:
  id: 10
  name: "Statistics and Progress Visualization"

context:
  description: |
    This task implements comprehensive statistics tracking and visualization for user
    progress in the flashcard application. It provides users with meaningful metrics
    about their learning journey including accuracy rates, study streaks, cards mastered,
    and time-series data. The statistics system aggregates review data from learning
    sessions into actionable insights that motivate learners and reveal learning patterns.
    
    The implementation includes a Statistics struct that maintains aggregated metrics,
    a dedicated statistics screen UI with progress visualizations, and an achievement
    system that gamifies the learning experience. Study streaks with flame emoji indicators
    encourage daily practice habit formation, while accuracy trends help users identify
    areas needing improvement.
    
    Time-series data is stored using BTreeMap for efficient date range queries, enabling
    future analytics capabilities and personalized recommendations. The statistics are
    updated incrementally during learning sessions and persisted to the database layer
    for long-term tracking across sessions.

  key_points:
    - "Statistics are calculated incrementally during sessions and batch-saved at end to minimize I/O"
    - "BTreeMap provides O(log n) date-indexed lookups and efficient range queries for time-series data"
    - "Streak calculation uses HashSet of study dates to determine consecutive day sequences"
    - "Achievement system provides positive reinforcement at key milestones (first review, 7-day streak, 100 cards mastered)"
    - "Card maturity stages (new/learning/mature) based on SM-2 interval thresholds (21+ days = mature)"
    - "Timezone-aware date handling ensures correct day boundaries for streak tracking"
    - "Property-based testing verifies mathematical invariants across random input sequences"

files:
  - path: "src/statistics.rs"
    description: "Core Statistics struct with metrics aggregation, streak calculation, and achievement tracking logic"
  
  - path: "src/ui/statistics_screen.rs"
    description: "Statistics screen UI component displaying progress visualizations, metrics, and achievements"
  
  - path: "src/achievements.rs"
    description: "Achievement system module defining achievement types, unlock conditions, and milestone tracking"
  
  - path: "src/lib.rs"
    description: "Module declarations for statistics and achievements modules"
  
  - path: "src/ui/mod.rs"
    description: "Module declaration for statistics_screen submodule"
  
  - path: "src/learning.rs"
    description: "Update LearningSession to integrate statistics updates after each review"
  
  - path: "tests/statistics_tests.rs"
    description: "Comprehensive unit tests for statistics calculations, accuracy rates, and streak logic"
  
  - path: "tests/achievements_tests.rs"
    description: "Unit tests for achievement unlock conditions and milestone tracking"

functions:
  - file: "src/statistics.rs"
    items:
      - type: "module_declaration"
        name: "statistics"
        description: "Module containing statistics tracking, aggregation, and visualization logic"
      
      - type: "struct"
        name: "Statistics"
        description: "Aggregates review data into meaningful metrics including accuracy, streaks, and time-series data"
        invariants: "total_reviews >= correct_reviews; current_streak >= 0; longest_streak >= current_streak"
      
      - type: "struct"
        name: "DayStats"
        description: "Statistics for a single day including reviews, accuracy, and time spent"
        invariants: "total >= correct; time_spent_seconds >= 0"
      
      - type: "struct"
        name: "WeekStats"
        description: "Aggregated statistics for a week period"
        invariants: "total_reviews >= correct_reviews"
      
      - type: "enum"
        name: "CardStatus"
        description: "Represents the maturity status of a card: New, Learning, or Mature"
      
      - type: "enum_variant"
        name: "CardStatus::New"
        description: "Card has never been reviewed"
      
      - type: "enum_variant"
        name: "CardStatus::Learning"
        description: "Card has interval less than 21 days"
      
      - type: "enum_variant"
        name: "CardStatus::Mature"
        description: "Card has interval of 21 days or more"
      
      - type: "struct"
        name: "CardStatusCounts"
        description: "Counts of cards by their maturity status"
        invariants: "new_count >= 0; learning_count >= 0; mature_count >= 0"
      
      - type: "trait_impl"
        name: "impl Statistics"
        description: "Implementation block for Statistics struct methods"
      
      - type: "method"
        name: "Statistics::new"
        description: "Creates a new Statistics instance with default values"
        postconditions: "Returns Statistics with zero metrics and empty collections"
      
      - type: "method"
        name: "Statistics::record_review"
        description: "Records a single review result, updating accuracy and time metrics"
        preconditions: "time_spent >= 0"
        postconditions: "total_reviews incremented; correct_reviews incremented if correct; accuracy recalculated"
      
      - type: "method"
        name: "Statistics::update_streak"
        description: "Updates current and longest streaks based on study dates"
        preconditions: "date parameter is valid"
        postconditions: "current_streak updated; longest_streak updated if current exceeds it; study_days contains date"
      
      - type: "method"
        name: "Statistics::calculate_streak"
        description: "Calculates current streak from study_days set"
        postconditions: "Returns number of consecutive days up to today"
      
      - type: "method"
        name: "Statistics::accuracy_rate"
        description: "Calculates accuracy as percentage of correct reviews"
        postconditions: "Returns value between 0.0 and 100.0"
        invariants: "Result is 0.0 if total_reviews is 0"
      
      - type: "method"
        name: "Statistics::add_day_stats"
        description: "Adds or updates statistics for a specific day"
        preconditions: "date is valid; day_stats is valid"
        postconditions: "daily_stats contains entry for date"
      
      - type: "method"
        name: "Statistics::get_week_stats"
        description: "Aggregates daily statistics for a given week range"
        preconditions: "start_date <= end_date"
        postconditions: "Returns WeekStats aggregating all days in range"
      
      - type: "method"
        name: "Statistics::cards_by_status"
        description: "Counts cards grouped by their maturity status"
        preconditions: "cards slice is valid"
        postconditions: "Returns CardStatusCounts with accurate counts"
      
      - type: "method"
        name: "Statistics::total_time_spent"
        description: "Returns total study time across all reviews in seconds"
        postconditions: "Returns non-negative duration"
      
      - type: "trait_impl"
        name: "impl DayStats"
        description: "Implementation block for DayStats struct methods"
      
      - type: "method"
        name: "DayStats::new"
        description: "Creates a new DayStats instance for a specific date"
        postconditions: "Returns DayStats with zero counts for given date"
      
      - type: "method"
        name: "DayStats::record_review"
        description: "Records a review result in this day's statistics"
        preconditions: "time_spent >= 0"
        postconditions: "total incremented; correct incremented if correct; time_spent_seconds updated"
      
      - type: "method"
        name: "DayStats::accuracy_rate"
        description: "Calculates accuracy percentage for this day"
        postconditions: "Returns value between 0.0 and 100.0"
      
      - type: "trait_impl"
        name: "impl WeekStats"
        description: "Implementation block for WeekStats struct methods"
      
      - type: "method"
        name: "WeekStats::new"
        description: "Creates a new WeekStats instance"
        postconditions: "Returns WeekStats with zero counts"
      
      - type: "method"
        name: "WeekStats::add_day"
        description: "Adds a day's statistics to this week's totals"
        preconditions: "day_stats is valid"
        postconditions: "All counters incremented by day_stats values"
      
      - type: "method"
        name: "WeekStats::accuracy_rate"
        description: "Calculates accuracy percentage for this week"
        postconditions: "Returns value between 0.0 and 100.0"
      
      - type: "function"
        name: "calculate_streak_from_dates"
        description: "Helper function to calculate consecutive day streak from set of dates"
        preconditions: "study_days is valid set of dates"
        postconditions: "Returns count of consecutive days ending today or most recent study day"
      
      - type: "function"
        name: "determine_card_status"
        description: "Determines CardStatus based on card's review history and interval"
        preconditions: "card has valid review data"
        postconditions: "Returns New, Learning, or Mature status"

  - file: "src/achievements.rs"
    items:
      - type: "module_declaration"
        name: "achievements"
        description: "Module for tracking and unlocking user achievements based on milestones"
      
      - type: "enum"
        name: "Achievement"
        description: "Represents different achievement types that can be unlocked"
      
      - type: "enum_variant"
        name: "Achievement::FirstReview"
        description: "Unlocked after completing first review"
      
      - type: "enum_variant"
        name: "Achievement::Streak7Days"
        description: "Unlocked after maintaining 7-day study streak"
      
      - type: "enum_variant"
        name: "Achievement::Streak30Days"
        description: "Unlocked after maintaining 30-day study streak"
      
      - type: "enum_variant"
        name: "Achievement::Cards100Mastered"
        description: "Unlocked after mastering 100 cards"
      
      - type: "enum_variant"
        name: "Achievement::Cards500Mastered"
        description: "Unlocked after mastering 500 cards"
      
      - type: "enum_variant"
        name: "Achievement::Reviews1000"
        description: "Unlocked after completing 1000 total reviews"
      
      - type: "enum_variant"
        name: "Achievement::PerfectDay"
        description: "Unlocked after achieving 100% accuracy in a day with at least 10 reviews"
      
      - type: "struct"
        name: "AchievementTracker"
        description: "Tracks unlocked achievements and checks for new unlocks"
        invariants: "unlocked_achievements contains no duplicates"
      
      - type: "trait_impl"
        name: "impl Achievement"
        description: "Implementation block for Achievement enum methods"
      
      - type: "method"
        name: "Achievement::title"
        description: "Returns human-readable title for the achievement"
        postconditions: "Returns non-empty string"
      
      - type: "method"
        name: "Achievement::description"
        description: "Returns description of how to unlock the achievement"
        postconditions: "Returns non-empty string"
      
      - type: "method"
        name: "Achievement::icon"
        description: "Returns emoji icon representing the achievement"
        postconditions: "Returns emoji string"
      
      - type: "trait_impl"
        name: "impl AchievementTracker"
        description: "Implementation block for AchievementTracker methods"
      
      - type: "method"
        name: "AchievementTracker::new"
        description: "Creates a new AchievementTracker with empty unlocked set"
        postconditions: "Returns tracker with no unlocked achievements"
      
      - type: "method"
        name: "AchievementTracker::check_and_unlock"
        description: "Checks statistics against achievement criteria and unlocks newly earned achievements"
        preconditions: "statistics is valid and up-to-date"
        postconditions: "Returns vector of newly unlocked achievements; unlocked_achievements updated"
      
      - type: "method"
        name: "AchievementTracker::is_unlocked"
        description: "Checks if a specific achievement has been unlocked"
        postconditions: "Returns true if achievement is in unlocked_achievements"
      
      - type: "method"
        name: "AchievementTracker::unlock"
        description: "Unlocks a specific achievement if not already unlocked"
        postconditions: "Achievement added to unlocked_achievements if not present; returns true if newly unlocked"
      
      - type: "method"
        name: "AchievementTracker::unlocked_count"
        description: "Returns the number of unlocked achievements"
        postconditions: "Returns non-negative count"
      
      - type: "method"
        name: "AchievementTracker::all_achievements"
        description: "Returns a list of all possible achievements"
        postconditions: "Returns complete set of Achievement variants"

  - file: "src/ui/statistics_screen.rs"
    items:
      - type: "module_declaration"
        name: "statistics_screen"
        description: "UI module for displaying statistics and achievements screen"
      
      - type: "struct"
        name: "StatsScreen"
        description: "Screen component displaying user progress statistics and visualizations"
      
      - type: "enum"
        name: "Message"
        description: "Messages for stats screen interactions"
      
      - type: "enum_variant"
        name: "Message::BackPressed"
        description: "User pressed back button to return to main screen"
      
      - type: "enum_variant"
        name: "Message::RefreshStats"
        description: "User requested statistics refresh"
      
      - type: "trait_impl"
        name: "impl StatsScreen"
        description: "Implementation block for StatsScreen methods"
      
      - type: "method"
        name: "StatsScreen::new"
        description: "Creates a new stats screen with given statistics data"
        preconditions: "statistics and achievements data are valid"
        postconditions: "Returns initialized StatsScreen"
      
      - type: "method"
        name: "StatsScreen::view"
        description: "Renders the statistics screen UI layout"
        postconditions: "Returns iced Element containing all statistics visualizations"
      
      - type: "method"
        name: "StatsScreen::update"
        description: "Handles messages and updates screen state"
        preconditions: "message is valid"
        postconditions: "Screen state updated according to message"
      
      - type: "function"
        name: "render_accuracy_section"
        description: "Renders accuracy percentage with visual indicator"
        postconditions: "Returns Element displaying accuracy rate"
      
      - type: "function"
        name: "render_streak_section"
        description: "Renders current and longest streak with flame emoji"
        postconditions: "Returns Element displaying streak information"
      
      - type: "function"
        name: "render_cards_status_section"
        description: "Renders cards grouped by status (new/learning/mature)"
        postconditions: "Returns Element displaying card counts by status"
      
      - type: "function"
        name: "render_daily_history"
        description: "Renders daily review history for recent days"
        postconditions: "Returns Element displaying daily stats list or chart"
      
      - type: "function"
        name: "render_achievements_section"
        description: "Renders unlocked and locked achievements with icons"
        postconditions: "Returns Element displaying achievement grid"
      
      - type: "function"
        name: "render_time_spent_section"
        description: "Renders total time spent studying"
        postconditions: "Returns Element displaying formatted time duration"
      
      - type: "function"
        name: "format_duration"
        description: "Formats seconds into human-readable duration (hours, minutes)"
        preconditions: "seconds >= 0"
        postconditions: "Returns formatted string like '2h 15m'"
      
      - type: "function"
        name: "format_percentage"
        description: "Formats float percentage to string with one decimal place"
        postconditions: "Returns formatted string like '87.5%'"

  - file: "src/learning.rs"
    items:
      - type: "method"
        name: "LearningSession::update_statistics"
        description: "Updates statistics after each review during the learning session"
preconditions: "statistics is mutable reference; review result is valid"
        postconditions: "statistics updated with review result; streak updated if new day"
      
      - type: "method"
        name: "LearningSession::finalize_statistics"
        description: "Finalizes and returns statistics at end of learning session"
        postconditions: "Returns updated Statistics struct ready for persistence"

formal_verification:
  needed: false
  level: "None"
  explanation: |
    Formal verification is not needed for the Statistics and Progress Visualization task
    for the following reasons:

    1. Mathematical Correctness is Testable: The core calculations (accuracy rates,
       streak counting, aggregations) are straightforward arithmetic operations that
       can be thoroughly validated through property-based testing and unit tests.
       For example, accuracy = correct/total is a simple division that doesn't require
       formal proof.

    2. No Safety-Critical Requirements: Statistics visualization is not safety-critical.
       Incorrect calculations would result in misleading metrics but wouldn't cause
       data corruption, system failures, or harm to users. The worst-case scenario
       is displaying incorrect progress data.

    3. Deterministic and Pure Logic: Statistics calculations are deterministic functions
       with no concurrency, no complex state machines, and no intricate algorithmic
       invariants. The logic is:
       - Increment counters on events
       - Calculate percentages and averages
       - Check date consecutiveness for streaks
       All of these are easily verified through conventional testing.

    4. Observable Outputs: All statistics are directly observable in the UI, making
       bugs easily detectable during development and user testing. Users would quickly
       notice if their streak count or accuracy percentage was incorrect.

    5. Cost-Benefit Analysis: The effort required for formal verification would far
       exceed the benefit given the low complexity and low risk profile of statistics
       calculations. Property-based testing provides sufficient confidence at much
       lower cost.

    6. No Complex Invariants: Unlike the SM-2 algorithm (Task 7) which has carefully
       calibrated parameters and scheduling invariants, statistics are simple aggregations
       with no subtle correctness properties that would benefit from formal proof.

    Property-based testing is the recommended approach to achieve high confidence:
    - Generate random sequences of review results and verify accuracy calculations
    - Generate random date sequences and verify streak calculations
    - Verify time-series aggregations match individual data points
    - Verify monotonic properties (total reviews never decrease, etc.)

tests:
  strategy:
    approach: "mixed (unit tests + property-based testing)"
    rationale:
      - "Unit tests verify specific statistical calculations (accuracy, streak logic, aggregations) with known inputs and expected outputs"
      - "Property-based tests ensure mathematical invariants hold (e.g., accuracy always between 0-100%, counts never negative)"
      - "Statistics are deterministic calculations without external dependencies, making them ideal for comprehensive unit testing"
      - "Streak calculations involve date logic that benefits from property testing to cover edge cases (month boundaries, leap years, timezone handling)"
      - "Achievement unlock conditions can be exhaustively tested with parameterized unit tests"
      - "Time-series aggregation correctness verified through sum/count invariants"

  implementation:
    file: "src/statistics.rs"
    location: "in existing test module"
    code: |
      #[cfg(test)]
      mod tests {
          use super::*;
          use chrono::{NaiveDate, Duration, Utc};
          use std::collections::{BTreeMap, HashSet};

          // Helper function to create a test Statistics instance
          fn create_test_stats() -> Statistics {
              Statistics {
                  total_reviews: 0,
                  correct_reviews: 0,
                  current_streak: 0,
                  longest_streak: 0,
                  cards_new: 0,
                  cards_learning: 0,
                  cards_mature: 0,
                  study_days: HashSet::new(),
                  daily_stats: BTreeMap::new(),
                  total_study_time_seconds: 0,
                  achievements_unlocked: HashSet::new(),
              }
          }

          #[test]
          fn test_accuracy_calculation_zero_reviews() {
              let stats = create_test_stats();
              assert_eq!(stats.accuracy_rate(), 0.0, "Accuracy should be 0% with no reviews");
          }

          #[test]
          fn test_accuracy_calculation_all_correct() {
              let mut stats = create_test_stats();
              stats.total_reviews = 10;
              stats.correct_reviews = 10;
              assert_eq!(stats.accuracy_rate(), 100.0, "Accuracy should be 100% when all correct");
          }

          #[test]
          fn test_accuracy_calculation_partial() {
              let mut stats = create_test_stats();
              stats.total_reviews = 20;
              stats.correct_reviews = 15;
              assert_eq!(stats.accuracy_rate(), 75.0, "Accuracy should be 75% (15/20)");
          }

          #[test]
          fn test_accuracy_calculation_zero_correct() {
              let mut stats = create_test_stats();
              stats.total_reviews = 5;
              stats.correct_reviews = 0;
              assert_eq!(stats.accuracy_rate(), 0.0, "Accuracy should be 0% when none correct");
          }

          #[test]
          fn test_streak_increments_consecutive_days() {
              let mut stats = create_test_stats();
              let date1 = NaiveDate::from_ymd_opt(2024, 1, 1).unwrap();
              let date2 = NaiveDate::from_ymd_opt(2024, 1, 2).unwrap();
              let date3 = NaiveDate::from_ymd_opt(2024, 1, 3).unwrap();

              stats.record_study_day(date1);
              assert_eq!(stats.current_streak, 1, "Streak should be 1 on first day");

              stats.record_study_day(date2);
              assert_eq!(stats.current_streak, 2, "Streak should be 2 on consecutive day");

              stats.record_study_day(date3);
              assert_eq!(stats.current_streak, 3, "Streak should be 3 on third consecutive day");
          }

          #[test]
          fn test_streak_resets_on_skip() {
              let mut stats = create_test_stats();
              let date1 = NaiveDate::from_ymd_opt(2024, 1, 1).unwrap();
              let date2 = NaiveDate::from_ymd_opt(2024, 1, 2).unwrap();
              let date4 = NaiveDate::from_ymd_opt(2024, 1, 4).unwrap(); // Skipped day 3

              stats.record_study_day(date1);
              stats.record_study_day(date2);
              assert_eq!(stats.current_streak, 2);

              stats.record_study_day(date4);
              assert_eq!(stats.current_streak, 1, "Streak should reset to 1 after skipping a day");
          }

          #[test]
          fn test_longest_streak_tracking() {
              let mut stats = create_test_stats();
              
              // Build streak of 3
              stats.record_study_day(NaiveDate::from_ymd_opt(2024, 1, 1).unwrap());
              stats.record_study_day(NaiveDate::from_ymd_opt(2024, 1, 2).unwrap());
              stats.record_study_day(NaiveDate::from_ymd_opt(2024, 1, 3).unwrap());
              assert_eq!(stats.longest_streak, 3);

              // Break streak
              stats.record_study_day(NaiveDate::from_ymd_opt(2024, 1, 5).unwrap());
              assert_eq!(stats.current_streak, 1);
              assert_eq!(stats.longest_streak, 3, "Longest streak should remain 3");

              // Build new streak of 2 (doesn't exceed longest)
              stats.record_study_day(NaiveDate::from_ymd_opt(2024, 1, 6).unwrap());
              assert_eq!(stats.current_streak, 2);
              assert_eq!(stats.longest_streak, 3, "Longest streak should still be 3");
          }

          #[test]
          fn test_same_day_multiple_reviews_no_duplicate_streak() {
              let mut stats = create_test_stats();
              let date = NaiveDate::from_ymd_opt(2024, 1, 1).unwrap();

              stats.record_study_day(date);
              assert_eq!(stats.current_streak, 1);

              stats.record_study_day(date); // Same day again
              assert_eq!(stats.current_streak, 1, "Streak should not increment for same day");
              assert_eq!(stats.study_days.len(), 1, "Only one unique study day");
          }

          #[test]
          fn test_daily_stats_aggregation() {
              let mut stats = create_test_stats();
              let date = NaiveDate::from_ymd_opt(2024, 1, 1).unwrap();

              stats.add_review(date, true, 150);
              stats.add_review(date, false, 200);
              stats.add_review(date, true, 100);

              let day_stats = stats.daily_stats.get(&date).unwrap();
              assert_eq!(day_stats.total_reviews, 3);
              assert_eq!(day_stats.correct_reviews, 2);
              assert_eq!(day_stats.study_time_seconds, 450);
              assert_eq!(day_stats.accuracy_rate(), 66.66666666666666);
          }

          #[test]
          fn test_cards_by_maturity_count() {
              let mut stats = create_test_stats();
              stats.cards_new = 50;
              stats.cards_learning = 30;
              stats.cards_mature = 20;

              assert_eq!(stats.total_cards(), 100);
              assert_eq!(stats.cards_new, 50);
              assert_eq!(stats.cards_learning, 30);
              assert_eq!(stats.cards_mature, 20);
          }

          #[test]
          fn test_achievement_unlock_first_review() {
              let mut stats = create_test_stats();
              stats.check_achievements();
              assert!(!stats.achievements_unlocked.contains(&Achievement::FirstReview));

              stats.total_reviews = 1;
              stats.check_achievements();
              assert!(stats.achievements_unlocked.contains(&Achievement::FirstReview));
          }

          #[test]
          fn test_achievement_unlock_milestone_reviews() {
              let mut stats = create_test_stats();
              
              stats.total_reviews = 99;
              stats.check_achievements();
              assert!(!stats.achievements_unlocked.contains(&Achievement::Reviews100));

              stats.total_reviews = 100;
              stats.check_achievements();
              assert!(stats.achievements_unlocked.contains(&Achievement::Reviews100));

              stats.total_reviews = 500;
              stats.check_achievements();
              assert!(stats.achievements_unlocked.contains(&Achievement::Reviews500));
          }

          #[test]
          fn test_achievement_unlock_streak_milestones() {
              let mut stats = create_test_stats();
              
              stats.current_streak = 6;
              stats.check_achievements();
              assert!(!stats.achievements_unlocked.contains(&Achievement::Streak7));

              stats.current_streak = 7;
              stats.check_achievements();
              assert!(stats.achievements_unlocked.contains(&Achievement::Streak7));

              stats.current_streak = 30;
              stats.check_achievements();
              assert!(stats.achievements_unlocked.contains(&Achievement::Streak30));
          }

          #[test]
          fn test_achievement_unlock_accuracy_milestone() {
              let mut stats = create_test_stats();
              stats.total_reviews = 100;
              stats.correct_reviews = 89;
              stats.check_achievements();
              assert!(!stats.achievements_unlocked.contains(&Achievement::Accuracy90));

              stats.correct_reviews = 90;
              stats.check_achievements();
              assert!(stats.achievements_unlocked.contains(&Achievement::Accuracy90));
          }

          #[test]
          fn test_total_study_time_accumulation() {
              let mut stats = create_test_stats();
              let date = NaiveDate::from_ymd_opt(2024, 1, 1).unwrap();

              stats.add_review(date, true, 120);
              stats.add_review(date, true, 180);
              stats.add_review(date, false, 90);

              assert_eq!(stats.total_study_time_seconds, 390);
              assert_eq!(stats.average_review_time_seconds(), 130);
          }

          #[test]
          fn test_multiple_days_stats_separation() {
              let mut stats = create_test_stats();
              let date1 = NaiveDate::from_ymd_opt(2024, 1, 1).unwrap();
              let date2 = NaiveDate::from_ymd_opt(2024, 1, 2).unwrap();

              stats.add_review(date1, true, 100);
              stats.add_review(date1, true, 150);
              stats.add_review(date2, false, 200);

              assert_eq!(stats.daily_stats.len(), 2);
              assert_eq!(stats.daily_stats.get(&date1).unwrap().total_reviews, 2);
              assert_eq!(stats.daily_stats.get(&date2).unwrap().total_reviews, 1);
              assert_eq!(stats.total_reviews, 3);
          }

          #[test]
          fn test_streak_across_month_boundary() {
              let mut stats = create_test_stats();
              let jan31 = NaiveDate::from_ymd_opt(2024, 1, 31).unwrap();
              let feb1 = NaiveDate::from_ymd_opt(2024, 2, 1).unwrap();
              let feb2 = NaiveDate::from_ymd_opt(2024, 2, 2).unwrap();

              stats.record_study_day(jan31);
              stats.record_study_day(feb1);
              stats.record_study_day(feb2);

              assert_eq!(stats.current_streak, 3, "Streak should continue across month boundary");
          }

          #[test]
          fn test_streak_across_year_boundary() {
              let mut stats = create_test_stats();
              let dec31 = NaiveDate::from_ymd_opt(2023, 12, 31).unwrap();
              let jan1 = NaiveDate::from_ymd_opt(2024, 1, 1).unwrap();

              stats.record_study_day(dec31);
              stats.record_study_day(jan1);

              assert_eq!(stats.current_streak, 2, "Streak should continue across year boundary");
          }

          #[test]
          fn test_cards_mature_threshold() {
              let mut stats = create_test_stats();
              
              // Card with interval < 21 days is learning
              stats.update_card_status(20);
              assert_eq!(stats.cards_learning, 1);
              assert_eq!(stats.cards_mature, 0);

              // Card with interval >= 21 days is mature
              stats.update_card_status(21);
              assert_eq!(stats.cards_mature, 1);

              stats.update_card_status(100);
              assert_eq!(stats.cards_mature, 2);
          }

          #[test]
          fn test_btreemap_date_range_query() {
              let mut stats = create_test_stats();
              
              for day in 1..=10 {
                  let date = NaiveDate::from_ymd_opt(2024, 1, day).unwrap();
                  stats.add_review(date, true, 100);
              }

              let start = NaiveDate::from_ymd_opt(2024, 1, 3).unwrap();
              let end = NaiveDate::from_ymd_opt(2024, 1, 7).unwrap();
              
              let range_stats: Vec<_> = stats.daily_stats
                  .range(start..=end)
                  .collect();

              assert_eq!(range_stats.len(), 5, "Should retrieve 5 days in range");
          }
      }

      #[cfg(test)]
      mod property_tests {
          use super::*;
          use proptest::prelude::*;
          use chrono::NaiveDate;

          proptest! {
              #[test]
              fn prop_accuracy_always_between_0_and_100(
                  total in 1u32..1000,
                  correct in 0u32..1000
              ) {
                  let correct = correct.min(total); // Ensure correct <= total
                  let mut stats = Statistics::default();
                  stats.total_reviews = total;
                  stats.correct_reviews = correct;
                  
                  let accuracy = stats.accuracy_rate();
                  prop_assert!(accuracy >= 0.0 && accuracy <= 100.0);
              }

              #[test]
              fn prop_total_reviews_equals_sum_of_daily(
                  reviews in prop::collection::vec((1i32..31i32, 1u32..20u32), 1..30)
              ) {
                  let mut stats = Statistics::default();
                  
                  for (day, count) in reviews {
                      let date = NaiveDate::from_ymd_opt(2024, 1, day).unwrap();
                      for _ in 0..count {
                          stats.add_review(date, true, 100);
                      }
                  }

                  let daily_sum: u32 = stats.daily_stats.values()
                      .map(|ds| ds.total_reviews)
                      .sum();
                  
                  prop_assert_eq!(stats.total_reviews, daily_sum);
              }

              #[test]
              fn prop_current_streak_never_exceeds_study_days(
                  day_count in 1usize..100
              ) {
                  let mut stats = Statistics::default();
                  
                  for i in 0..day_count {
                      let date = NaiveDate::from_ymd_opt(2024, 1, 1).unwrap() + 
                                 chrono::Duration::days(i as i64);
                      stats.record_study_day(date);
                  }

                  prop_assert!(stats.current_streak as usize <= stats.study_days.len());
              }

              #[test]
              fn prop_longest_streak_never_less_than_current(
                  days in prop::collection::vec(1i32..365i32, 1..50)
              ) {
                  let mut stats = Statistics::default();
                  let base_date = NaiveDate::from_ymd_opt(2024, 1, 1).unwrap();
                  
                  for day_offset in days {
                      let date = base_date + chrono::Duration::days(day_offset as i64);
                      stats.record_study_day(date);
                  }

                  prop_assert!(stats.longest_streak >= stats.current_streak);
              }

              #[test]
              fn prop_correct_reviews_never_exceeds_total(
                  total in 0u32..1000,
                  correct in 0u32..1000
              ) {
                  let correct = correct.min(total);
                  let mut stats = Statistics::default();
                  stats.total_reviews = total;
                  stats.correct_reviews = correct;

                  prop_assert!(stats.correct_reviews <= stats.total_reviews);
              }

              #[test]
              fn prop_study_time_always_non_negative(
                  times in prop::collection::vec(0u32..3600, 1..100)
              ) {
                  let mut stats = Statistics::default();
                  let date = NaiveDate::from_ymd_opt(2024, 1, 1).unwrap();
                  
                  for time in times {
                      stats.add_review(date, true, time);
                  }

                  prop_assert!(stats.total_study_time_seconds >= 0);
              }

              #[test]
              fn prop_card_counts_non_negative(
                  new in 0u32..500,
                  learning in 0u32..500,
                  mature in 0u32..500
              ) {
                  let mut stats = Statistics::default();
                  stats.cards_new = new;
                  stats.cards_learning = learning;
                  stats.cards_mature = mature;

                  prop_assert!(stats.cards_new >= 0);
                  prop_assert!(stats.cards_learning >= 0);
                  prop_assert!(stats.cards_mature >= 0);
                  prop_assert!(stats.total_cards() == new + learning + mature);
              }
          }
      }

  coverage:
    - "Accuracy calculation returns 0% with zero reviews"
    - "Accuracy calculation returns 100% when all reviews correct"
    - "Accuracy calculation computes correct percentage (75%, 50%, etc.)"
    - "Accuracy calculation returns 0% when zero reviews correct"
    - "Streak increments by 1 for consecutive study days"
    - "Streak resets to 1 when a day is skipped"
    - "Longest streak tracks maximum consecutive days correctly"
    - "Longest streak persists after current streak is broken"
    - "Same day multiple reviews don't duplicate streak count"
    - "Study days HashSet prevents duplicate day entries"
    - "Daily stats aggregate reviews, correct count, and time per day"
    - "Daily stats calculate per-day accuracy correctly"
    - "Multiple days maintain separate DayStats entries"
    - "Total reviews equals sum of all daily review counts"
    - "Cards by maturity (new/learning/mature) count correctly"
    - "Cards with interval < 21 days classified as learning"
    - "Cards with interval >= 21 days classified as mature"
    - "Total cards equals sum of new + learning + mature"
    - "Achievement unlocks at first review milestone"
    - "Achievement unlocks at 100, 500, 1000 review milestones"
    - "Achievement unlocks at 7, 30, 100 day streak milestones"
    - "Achievement unlocks at 90% accuracy milestone"
    - "Total study time accumulates across all reviews"
    - "Average review time calculates correctly"
    - "Streak continues correctly across month boundaries"
    - "Streak continues correctly across year boundaries"
    - "BTreeMap enables efficient date range queries"
    - "Property: Accuracy always between 0.0 and 100.0"
    - "Property: Total reviews equals sum of daily reviews"
    - "Property: Current streak never exceeds total study days"
    - "Property: Longest streak always >= current streak"
    - "Property: Correct reviews never exceeds total reviews"
    - "Property: Study time always non-negative"
    - "Property: Card counts always non-negative"

dependencies:
  depends_on:
    - task_id: 6
      reason: "Needs navigation framework for statistics screen routing and UI integration"

  depended_upon_by:
    - task_id: 11
      reason: "Database layer persists Statistics struct and retrieves historical data for visualization"

  external:
    - name: "chrono"
      type: "crate"
      status: "to be imported"
    - name: "BTreeMap"
      type: "struct"
      status: "already exists"
    - name: "HashSet"
      type: "struct"
      status: "already exists"
    - name: "NaiveDate"
      type: "struct"
      status: "to be imported"
    - name: "proptest"
      type: "crate"
      status: "to be imported"
    - name: "iced"
      type: "crate"
      status: "already exists"
---
task:
  id: 11
  name: "Local Persistence and Database Layer"

context:
  description: |
    This task implements the foundational data persistence layer for the flashcard application
    using the redb embedded database. Persistence is critical for maintaining user trust and
    motivation - losing progress destroys the user experience. The database layer provides
    ACID-compliant transactional storage for all application data including card state,
    review history, user settings, and statistics.

    The implementation uses redb, a Rust-native embedded database that requires no external
    dependencies or server processes. This choice provides robust transactional guarantees
    while maintaining simplicity and portability. The architecture wraps redb with a type-safe
    API layer that handles serialization (using bincode for performance), transaction management,
    and platform-specific path resolution.

    Key architectural considerations include minimizing write transaction frequency through
    batch operations (critical for performance), providing backup/restore functionality for
    data portability and disaster recovery, and ensuring the database location follows
    platform conventions (XDG on Linux, AppData on Windows, Application Support on macOS).

    This layer serves as the foundation for all other components requiring persistence,
    including learning sessions, statistics tracking, and settings management. Its correctness
    and reliability directly impact user trust in the application.

  key_points:
    - "redb provides ACID transactions with no external dependencies, suitable for local-first architecture"
    - "Batch write operations minimize I/O overhead and transaction conflicts in concurrent scenarios"
    - "Platform-appropriate data directories ensure proper OS integration and user data management"
    - "Backup/restore functionality enables data portability and recovery from corruption"
    - "Type-safe wrapper API prevents serialization errors and enforces data integrity at compile time"
    - "Read transactions are cheap and non-blocking, enabling concurrent access patterns"
    - "Write transactions serialize access, requiring careful design to avoid bottlenecks"

files:
  - path: "src/persistence/mod.rs"
    description: "Module declaration and public exports for persistence layer"
  
  - path: "src/persistence/database.rs"
    description: "AppDatabase wrapper struct with connection management and transaction handling"
  
  - path: "src/persistence/schema.rs"
    description: "redb table definitions for cards, reviews, settings, and statistics"
  
  - path: "src/persistence/operations.rs"
    description: "CRUD operations for all data types with serialization/deserialization"
  
  - path: "src/persistence/batch.rs"
    description: "Batch save operations for efficient multi-record transactions"
  
  - path: "src/persistence/backup.rs"
    description: "Export and import functions for database backup and restore"
  
  - path: "src/persistence/path.rs"
    description: "Platform-appropriate database file path resolution using directories crate"
  
  - path: "tests/persistence_tests.rs"
    description: "Integration tests for database operations, ACID properties, and data integrity"

functions:
  - file: "src/database/mod.rs"
    items:
      - type: "module_declaration"
        name: "database"
        description: "Main database module exposing AppDatabase and related types"
      - type: "struct"
        name: "AppDatabase"
        description: "Wrapper around redb::Database providing type-safe, transactional operations for all persistent data"
        invariants: "Database connection remains valid throughout lifetime; all operations are ACID-compliant"
      - type: "function"
        name: "AppDatabase::new"
        description: "Creates or opens the database at the platform-appropriate path"
        preconditions: "File system access available; parent directory exists or can be created"
        postconditions: "Database file exists and is ready for operations; all tables initialized"
      - type: "function"
        name: "AppDatabase::open"
        description: "Opens an existing database at a specific path"
        preconditions: "Database file exists at given path"
        postconditions: "Database connection established and validated"
      - type: "function"
        name: "AppDatabase::get_database_path"
        description: "Returns the platform-appropriate path for the database file using directories crate"
        postconditions: "Returns PathBuf to data directory, creates directory if needed"
      - type: "function"
        name: "AppDatabase::close"
        description: "Explicitly closes the database connection and flushes pending writes"
        postconditions: "All pending transactions committed; database file closed"

  - file: "src/database/tables.rs"
    items:
      - type: "constant"
        name: "CARDS_TABLE"
        description: "TableDefinition for cards storage mapping CardId to SM2Card"
      - type: "constant"
        name: "REVIEWS_TABLE"
        description: "TableDefinition for review history mapping (CardId, Timestamp) to ReviewRecord"
      - type: "constant"
        name: "SETTINGS_TABLE"
        description: "TableDefinition for application settings mapping String key to serialized value"
      - type: "constant"
        name: "STATISTICS_TABLE"
        description: "TableDefinition for statistics data mapping String key to StatisticsData"
      - type: "struct"
        name: "ReviewRecord"
        description: "Serializable record of a single review event with timestamp, rating, and outcome"
      - type: "struct"
        name: "StatisticsData"
        description: "Serializable aggregate statistics data for persistence"

  - file: "src/database/operations.rs"
    items:
      - type: "function"
        name: "AppDatabase::save_card"
        description: "Saves a single card to the database in a write transaction"
        preconditions: "Card has valid CardId; card data is serializable"
        postconditions: "Card persisted to disk; previous version overwritten if exists"
      - type: "function"
        name: "AppDatabase::load_card"
        description: "Loads a single card by CardId from the database"
        preconditions: "CardId is valid format"
        postconditions: "Returns Some(card) if exists, None otherwise"
      - type: "function"
        name: "AppDatabase::delete_card"
        description: "Removes a card from the database"
        preconditions: "CardId exists in database"
        postconditions: "Card no longer exists in database; associated reviews optionally deleted"
      - type: "function"
        name: "AppDatabase::load_all_cards"
        description: "Loads all cards from the database into a Vec"
        postconditions: "Returns Vec of all cards; empty Vec if no cards exist"
      - type: "function"
        name: "AppDatabase::save_cards_batch"
        description: "Saves multiple cards in a single write transaction for efficiency"
        preconditions: "All cards have valid CardIds and are serializable"
        postconditions: "All cards persisted atomically; transaction fails if any card invalid"
      - type: "function"
        name: "AppDatabase::save_review"
        description: "Saves a review record to the review history"
        preconditions: "ReviewRecord has valid CardId and timestamp"
        postconditions: "Review persisted; can be queried by card or timestamp"
      - type: "function"
        name: "AppDatabase::load_reviews_for_card"
        description: "Loads all review history for a specific card"
        preconditions: "CardId is valid"
        postconditions: "Returns Vec of ReviewRecords in chronological order"
      - type: "function"
        name: "AppDatabase::load_reviews_in_range"
        description: "Loads reviews within a timestamp range for statistics"
        preconditions: "Start time <= end time"
        postconditions: "Returns Vec of ReviewRecords within range, sorted by timestamp"
      - type: "function"
        name: "AppDatabase::save_setting"
        description: "Persists a single setting key-value pair"
        preconditions: "Key is non-empty; value is serializable"
        postconditions: "Setting persisted; previous value overwritten if exists"
      - type: "function"
        name: "AppDatabase::load_setting"
        description: "Loads a setting by key, deserializing to specified type"
        preconditions: "Type parameter matches serialized type"
        postconditions: "Returns Some(value) if exists and deserializable, None otherwise"
      - type: "function"
        name: "AppDatabase::save_statistics"
        description: "Persists statistics data under a given key"
        preconditions: "StatisticsData is valid and serializable"
        postconditions: "Statistics persisted to disk"
      - type: "function"
        name: "AppDatabase::load_statistics"
        description: "Loads statistics data by key"
        postconditions: "Returns Some(StatisticsData) if exists, None otherwise"

  - file: "src/database/serialization.rs"
    items:
      - type: "function"
        name: "serialize_card"
        description: "Serializes SM2Card to bytes using bincode for storage"
        preconditions: "Card is complete and valid"
        postconditions: "Returns Vec<u8> containing serialized card"
      - type: "function"
        name: "deserialize_card"
        description: "Deserializes bytes back to SM2Card using bincode"
        preconditions: "Bytes are valid bincode-encoded SM2Card"
        postconditions: "Returns Result with SM2Card or deserialization error"
      - type: "function"
        name: "serialize_review"
        description: "Serializes ReviewRecord to bytes using bincode"
        preconditions: "ReviewRecord is valid"
        postconditions: "Returns Vec<u8> containing serialized review"
      - type: "function"
        name: "deserialize_review"
        description: "Deserializes bytes back to ReviewRecord"
        preconditions: "Bytes are valid bincode-encoded ReviewRecord"
        postconditions: "Returns Result with ReviewRecord or error"

  - file: "src/database/backup.rs"
    items:
      - type: "struct"
        name: "DatabaseBackup"
        description: "Serializable container for entire database contents in portable format"
      - type: "function"
        name: "AppDatabase::export_to_json"
        description: "Exports entire database to a JSON file for human-readable backup"
        preconditions: "Output path is writable"
        postconditions: "JSON file created with all database contents; file is valid JSON"
      - type: "function"
        name: "AppDatabase::export_to_bincode"
        description: "Exports entire database to bincode format for compact backup"
        preconditions: "Output path is writable"
        postconditions: "Bincode file created with all database contents; compressed if requested"
      - type: "function"
        name: "AppDatabase::import_from_json"
        description: "Imports database from JSON backup file, replacing current data"
        preconditions: "JSON file exists and is valid DatabaseBackup format; database is writable"
        postconditions: "Database contents replaced with imported data; old data lost"
      - type: "function"
        name: "AppDatabase::import_from_bincode"
        description: "Imports database from bincode backup file"
        preconditions: "Bincode file exists and is valid DatabaseBackup format"
        postconditions: "Database contents replaced with imported data"
      - type: "function"
        name: "AppDatabase::create_backup"
        description: "Creates a timestamped backup in the standard backup directory"
        postconditions: "Backup file created with timestamp; returns path to backup"
      - type: "function"
        name: "AppDatabase::list_backups"
        description: "Lists all available backups in the backup directory"
        postconditions: "Returns Vec of backup metadata including paths and timestamps"
      - type: "function"
        name: "AppDatabase::restore_from_backup"
        description: "Restores database from a specific backup file"
        preconditions: "Backup file exists and is valid"
        postconditions: "Database restored to backup state; current data backed up first"

  - file: "src/database/error.rs"
    items:
      - type: "enum"
        name: "DatabaseError"
        description: "Error types for database operations including IO, serialization, and corruption errors"
      - type: "trait_impl"
        name: "std::fmt::Display for DatabaseError"
        description: "Human-readable error messages for database errors"
      - type: "trait_impl"
        name: "std::error::Error for DatabaseError"
        description: "Standard Error trait implementation for DatabaseError"
      - type: "trait_impl"
        name: "From<redb::Error> for DatabaseError"
        description: "Conversion from redb errors to DatabaseError"
      - type: "trait_impl"
        name: "From<bincode::Error> for DatabaseError"
        description: "Conversion from bincode serialization errors"
      - type: "trait_impl"
        name: "From<std::io::Error> for DatabaseError"
        description: "Conversion from IO errors during backup/restore"

  - file: "src/database/compaction.rs"
    items:
      - type: "function"
        name: "AppDatabase::compact"
        description: "Performs database compaction to reclaim space from deleted records"
        preconditions: "Database is not corrupted"
        postconditions: "Database file size potentially reduced; all data preserved"
      - type: "function"
        name: "AppDatabase::needs_compaction"
        description: "Checks if database would benefit from compaction based on fragmentation"
        postconditions: "Returns true if compaction recommended, false otherwise"
      - type: "function"
        name: "AppDatabase::get_database_stats"
        description: "Returns statistics about database file size, record counts, and fragmentation"
        postconditions: "Returns DatabaseStats struct with current metrics"

formal_verification:
  needed: false
  level: "None"
  explanation: |
    Formal verification is not required for the database persistence layer for the following reasons:

    1. Delegated Correctness: The critical ACID properties (atomicity, consistency, isolation, durability)
       are provided by the underlying redb library, which is already tested and verified by its maintainers.
       Our code acts as a wrapper that delegates transactional guarantees to redb.

    2. Testable Through Integration: The key correctness properties (data survives restart, transactions
       are atomic, concurrent access is safe, serialization round-trips correctly) are effectively verified
       through integration testing with actual database instances. These properties are empirically observable
       and don't require formal proofs.

    3. Limited Logical Complexity: The persistence layer primarily performs CRUD operations with
       straightforward serialization/deserialization. There are no complex algorithms, concurrent data
       structures, or subtle invariants that would benefit from formal verification.

    4. Appropriate Risk Level: While data loss is catastrophic for users, the mitigation strategy
       (backup/restore functionality, transactional safety via redb, integration testing) provides
       adequate protection without formal verification. The "medium" complexity and integration risk
       ratings indicate this is not safety-critical infrastructure requiring mathematical proofs.

    5. Cost-Benefit Analysis: The development effort for formal verification would be substantial
       (requiring formal specifications of redb's guarantees, serialization correctness proofs, etc.)
       while the marginal safety improvement over comprehensive integration testing is minimal.

    The task acceptance criteria and testing strategy (15 integration tests covering persistence,
    atomicity, concurrency, and backup/restore) provide sufficient confidence in correctness without
    formal verification.

tests:
  strategy:
    approach: "mixed (unit + integration + concurrency)"
    rationale:
      - "Database operations require integration tests with real redb instances to verify ACID properties and persistence across restarts"
      - "Unit tests validate serialization/deserialization logic independently from database operations"
      - "Concurrency tests ensure thread-safety of read/write operations and proper transaction isolation"
      - "Integration tests verify platform-specific path resolution and backup/restore round-trip integrity"
      - "Performance tests validate batch operation efficiency meets acceptance criteria (<100ms for 50 cards)"

  implementation:
    file: "src/persistence/database.rs"
    location: "in existing test module"
    code: |
      #[cfg(test)]
      mod tests {
          use super::*;
          use crate::core::card::Card;
          use crate::algorithms::sm2::SM2Card;
          use tempfile::TempDir;
          use std::sync::Arc;
          use std::thread;
          use std::time::Instant;

          fn create_test_db() -> (AppDatabase, TempDir) {
              let temp_dir = TempDir::new().unwrap();
              let db = AppDatabase::new(temp_dir.path().join("test.db")).unwrap();
              (db, temp_dir)
          }

          fn create_sample_cards(count: usize) -> Vec<SM2Card> {
              (0..count)
                  .map(|i| SM2Card {
                      id: format!("card_{}", i),
                      front: format!("Front {}", i),
                      back: format!("Back {}", i),
                      easiness_factor: 2.5,
                      interval: 0,
                      repetitions: 0,
                      due_date: chrono::Utc::now(),
                  })
                  .collect()
          }

          #[test]
          fn test_database_initialization() {
              let temp_dir = TempDir::new().unwrap();
              let db_path = temp_dir.path().join("test.db");
              
              assert!(!db_path.exists());
              let db = AppDatabase::new(&db_path).unwrap();
              assert!(db_path.exists());
              
              let read_txn = db.begin_read().unwrap();
              assert!(read_txn.open_table(db.cards_table()).is_ok());
          }

          #[test]
          fn test_save_and_load_single_card() {
              let (db, _temp) = create_test_db();
              
              let card = SM2Card {
                  id: "test_card".to_string(),
                  front: "Question".to_string(),
                  back: "Answer".to_string(),
                  easiness_factor: 2.5,
                  interval: 1,
                  repetitions: 0,
                  due_date: chrono::Utc::now(),
              };
              
              db.save_card(&card).unwrap();
              let loaded = db.load_card(&card.id).unwrap();
              
              assert_eq!(loaded.id, card.id);
              assert_eq!(loaded.front, card.front);
              assert_eq!(loaded.back, card.back);
              assert_eq!(loaded.easiness_factor, card.easiness_factor);
              assert_eq!(loaded.interval, card.interval);
              assert_eq!(loaded.repetitions, card.repetitions);
          }

          #[test]
          fn test_update_existing_card() {
              let (db, _temp) = create_test_db();
              
              let mut card = SM2Card {
                  id: "test_card".to_string(),
                  front: "Original".to_string(),
                  back: "Answer".to_string(),
                  easiness_factor: 2.5,
                  interval: 1,
                  repetitions: 0,
                  due_date: chrono::Utc::now(),
              };
              
              db.save_card(&card).unwrap();
              
              card.front = "Updated".to_string();
              card.interval = 5;
              db.save_card(&card).unwrap();
              
              let loaded = db.load_card(&card.id).unwrap();
              assert_eq!(loaded.front, "Updated");
              assert_eq!(loaded.interval, 5);
          }

          #[test]
          fn test_load_nonexistent_card() {
              let (db, _temp) = create_test_db();
              let result = db.load_card("nonexistent");
              assert!(result.is_err());
          }

          #[test]
          fn test_delete_card() {
              let (db, _temp) = create_test_db();
              
              let card = create_sample_cards(1).into_iter().next().unwrap();
              db.save_card(&card).unwrap();
              
              assert!(db.load_card(&card.id).is_ok());
              db.delete_card(&card.id).unwrap();
              assert!(db.load_card(&card.id).is_err());
          }

          #[test]
          fn test_batch_save_cards() {
              let (db, _temp) = create_test_db();
              
              let cards = create_sample_cards(50);
              let start = Instant::now();
              db.save_cards_batch(&cards).unwrap();
              let duration = start.elapsed();
              
              assert!(duration.as_millis() < 100, "Batch save took {}ms", duration.as_millis());
              
              for card in &cards {
                  let loaded = db.load_card(&card.id).unwrap();
                  assert_eq!(loaded.id, card.id);
              }
          }

          #[test]
          fn test_batch_operation_atomicity() {
              let (db, _temp) = create_test_db();
              
              let mut cards = create_sample_cards(10);
              cards.push(SM2Card {
                  id: "".to_string(),
                  front: "Test".to_string(),
                  back: "Test".to_string(),
                  easiness_factor: 2.5,
                  interval: 0,
                  repetitions: 0,
                  due_date: chrono::Utc::now(),
              });
              
              let result = db.save_cards_batch(&cards);
              
              if result.is_err() {
                  for i in 0..10 {
                      assert!(db.load_card(&format!("card_{}", i)).is_err());
                  }
              }
          }

          #[test]
          fn test_load_all_cards() {
              let (db, _temp) = create_test_db();
              
              let cards = create_sample_cards(20);
              db.save_cards_batch(&cards).unwrap();
              
              let loaded = db.load_all_cards().unwrap();
              assert_eq!(loaded.len(), 20);
              
              let loaded_ids: std::collections::HashSet<_> = 
                  loaded.iter().map(|c| c.id.clone()).collect();
              for card in &cards {
                  assert!(loaded_ids.contains(&card.id));
              }
          }

          #[test]
          fn test_save_and_load_review_history() {
              let (db, _temp) = create_test_db();
              
              let review = ReviewRecord {
                  card_id: "card_1".to_string(),
                  timestamp: chrono::Utc::now(),
                  quality: 4,
                  interval_before: 1,
                  interval_after: 3,
                  easiness_before: 2.5,
                  easiness_after: 2.6,
              };
              
              db.save_review(&review).unwrap();
              let loaded = db.load_reviews_for_card(&review.card_id).unwrap();
              
              assert_eq!(loaded.len(), 1);
              assert_eq!(loaded[0].card_id, review.card_id);
              assert_eq!(loaded[0].quality, review.quality);
          }

          #[test]
          fn test_save_and_load_settings() {
              let (db, _temp) = create_test_db();
              
              let settings = AppSettings {
                  cards_per_session: 20,
                  enable_sound: true,
                  theme: "dark".to_string(),
                  backup_enabled: true,
              };
              
              db.save_settings(&settings).unwrap();
              let loaded = db.load_settings().unwrap();
              
              assert_eq!(loaded.cards_per_session, settings.cards_per_session);
              assert_eq!(loaded.enable_sound, settings.enable_sound);
              assert_eq!(loaded.theme, settings.theme);
              assert_eq!(loaded.backup_enabled, settings.backup_enabled);
          }

          #[test]
          fn test_save_and_load_statistics() {
              let (db, _temp) = create_test_db();
              
              let stats = Statistics {
                  total_reviews: 150,
                  cards_learned: 50,
                  study_time_seconds: 3600,
                  average_quality: 3.8,
                  streak_days: 7,
              };
              
              db.save_statistics(&stats).unwrap();
              let loaded = db.load_statistics().unwrap();
              
              assert_eq!(loaded.total_reviews, stats.total_reviews);
              assert_eq!(loaded.cards_learned, stats.cards_learned);
              assert_eq!(loaded.study_time_seconds, stats.study_time_seconds);
              assert_eq!(loaded.streak_days, stats.streak_days);
          }

          #[test]
          fn test_database_survives_restart() {
              let temp_dir = TempDir::new().unwrap();
              let db_path = temp_dir.path().join("test.db");
              
              let card = create_sample_cards(1).into_iter().next().unwrap();
              
              {
                  let db = AppDatabase::new(&db_path).unwrap();
                  db.save_card(&card).unwrap();
              }
              
              let db = AppDatabase::new(&db_path).unwrap();
              let loaded = db.load_card(&card.id).unwrap();
              assert_eq!(loaded.id, card.id);
          }

          #[test]
          fn test_concurrent_reads() {
              let (db, _temp) = create_test_db();
              let cards = create_sample_cards(10);
              db.save_cards_batch(&cards).unwrap();
              
              let db = Arc::new(db);
              let mut handles = vec![];
              
              for i in 0..5 {
                  let db_clone = Arc::clone(&db);
                  let card_id = format!("card_{}", i);
                  
                  let handle = thread::spawn(move || {
                      db_clone.load_card(&card_id).unwrap()
                  });
                  handles.push(handle);
              }
              
              let results: Vec<_> = handles.into_iter()
                  .map(|h| h.join().unwrap())
                  .collect();
              
              assert_eq!(results.len(), 5);
              for (i, result) in results.iter().enumerate() {
                  assert_eq!(result.id, format!("card_{}", i));
              }
          }

          #[test]
          fn test_concurrent_writes_serialize() {
              let (db, _temp) = create_test_db();
              let db = Arc::new(db);
              let mut handles = vec![];
              
              for i in 0..10 {
                  let db_clone = Arc::clone(&db);
                  
                  let handle = thread::spawn(move || {
                      let card = SM2Card {
                          id: format!("concurrent_card_{}", i),
                          front: format!("Front {}", i),
                          back: format!("Back {}", i),
                          easiness_factor: 2.5,
                          interval: 0,
                          repetitions: 0,
                          due_date: chrono::Utc::now(),
                      };
                      db_clone.save_card(&card).unwrap();
                  });
                  handles.push(handle);
              }
              
              for handle in handles {
                  handle.join().unwrap();
              }
              
              let all_cards = db.load_all_cards().unwrap();
              let concurrent_cards: Vec<_> = all_cards.iter()
                  .filter(|c| c.id.starts_with("concurrent_card_"))
                  .collect();
              assert_eq!(concurrent_cards.len(), 10);
          }

          #[test]
          fn test_export_to_json() {
              let (db, _temp) = create_test_db();
              let cards = create_sample_cards(5);
              db.save_cards_batch(&cards).unwrap();
              
              let export_path = _temp.path().join("backup.json");
              db.export_to_json(&export_path).unwrap();
              
              assert!(export_path.exists());
              let content = std::fs::read_to_string(&export_path).unwrap();
              let parsed: serde_json::Value = serde_json::from_str(&content).unwrap();
              assert!(parsed.is_object());
          }

          #[test]
          fn test_backup_restore_roundtrip() {
              let (db, temp) = create_test_db();
              
              let cards = create_sample_cards(10);
              db.save_cards_batch(&cards).unwrap();
              
              let stats = Statistics {
                  total_reviews: 100,
                  cards_learned: 10,
                  study_time_seconds: 1800,
                  average_quality: 4.0,
                  streak_days: 5,
              };
              db.save_statistics(&stats).unwrap();
              
              let backup_path = temp.path().join("backup.json");
              db.export_to_json(&backup_path).unwrap();
              
              let (db2, _temp2) = create_test_db();
              db2.import_from_json(&backup_path).unwrap();
              
              let restored_cards = db2.load_all_cards().unwrap();
              assert_eq!(restored_cards.len(), 10);
              
              let restored_stats = db2.load_statistics().unwrap();
              assert_eq!(restored_stats.total_reviews, stats.total_reviews);
              assert_eq!(restored_stats.streak_days, stats.streak_days);
          }

          #[test]
          fn test_platform_appropriate_path() {
              let db_path = AppDatabase::default_db_path().unwrap();
              
              #[cfg(target_os = "linux")]
              assert!(db_path.to_string_lossy().contains(".local/share") || 
                      db_path.to_string_lossy().contains(".config"));
              
              #[cfg(target_os = "windows")]
              assert!(db_path.to_string_lossy().contains("AppData"));
              
              #[cfg(target_os = "macos")]
              assert!(db_path.to_string_lossy().contains("Application Support"));
          }

          #[test]
          fn test_bincode_serialization() {
              let card = create_sample_cards(1).into_iter().next().unwrap();
              
              let encoded = bincode::serialize(&card).unwrap();
              let decoded: SM2Card = bincode::deserialize(&encoded).unwrap();
              
              assert_eq!(decoded.id, card.id);
              assert_eq!(decoded.front, card.front);
              assert_eq!(decoded.easiness_factor, card.easiness_factor);
          }

          #[test]
          fn test_handle_corrupted_data() {
              let (db, _temp) = create_test_db();
              
              let write_txn = db.begin_write().unwrap();
              let mut table = write_txn.open_table(db.cards_table()).unwrap();
              table.insert("corrupted_card", b"invalid_data").unwrap();
              write_txn.commit().unwrap();
              
              let result = db.load_card("corrupted_card");
              assert!(result.is_err());
          }

          #[test]
          fn test_empty_database_operations() {
              let (db, _temp) = create_test_db();
              
              let all_cards = db.load_all_cards().unwrap();
              assert_eq!(all_cards.len(), 0);
              
              let stats = db.load_statistics();
              assert!(stats.is_ok() || stats.is_err());
          }
      }

  coverage:
    - "Database initialization creates file and tables correctly"
    - "Single card save and load with data integrity"
    - "Card update replaces existing data"
    - "Loading non-existent card returns error"
    - "Card deletion removes data completely"
    - "Batch save of 50 cards completes in <100ms"
    - "Batch operations are atomic (all-or-nothing)"
    - "Loading all cards returns complete set"
    - "Review history persists accurately"
    - "Settings stored and loaded correctly"
    - "Statistics data survives restart"
    - "Data persists after database close and reopen"
    - "Concurrent reads don't block each other"
    - "Write transactions serialize correctly with concurrent access"
    - "Export produces valid JSON file"
    - "Import correctly restores all data (backup/restore roundtrip)"
    - "Database file location is platform-appropriate (Linux/Windows/macOS)"
    - "Bincode serialization/deserialization preserves data"
    - "Corrupted data handled gracefully without panic"
    - "Empty database operations return appropriate results"

dependencies:
  depends_on:
    - task_id: 2
      reason: "Needs Card data structure definition to persist card state"
    - task_id: 7
      reason: "Needs SM2Card structure with algorithm state to persist"

  depended_upon_by:
    - task_id: 8
      reason: "Learning session requires persistence layer to save and restore progress"
    - task_id: 9
      reason: "Statistics tracking requires database layer to persist metrics"
    - task_id: 10
      reason: "Settings management requires persistence for user preferences"

  external:
    - name: "redb"
      type: "crate"
      status: "to be imported"
    - name: "bincode"
      type: "crate"
      status: "to be imported"
    - name: "serde"
      type: "crate"
      status: "to be imported"
    - name: "serde_json"
      type: "crate"
      status: "to be imported"
    - name: "directories"
      type: "crate"
      status: "to be imported"
    - name: "chrono"
      type: "crate"
      status: "already exists"
    - name: "tempfile"
      type: "crate"
      status: "to be imported (dev dependency for tests)"
---
task:
  id: 12
  name: "Visual Feedback and Animation Polish"

context:
  description: |
    This task implements a comprehensive visual feedback and animation system that transforms
    the application from functional to delightful. Visual feedback is critical for learning
    applications because it provides immediate reinforcement of correct/incorrect responses,
    which accelerates learning and improves retention. The system includes success/error
    animations, shake effects for errors, progress indicators for sessions, and celebratory
    animations for achievement unlocks.
    
    The architecture follows a component-based approach with reusable animation primitives
    (easing functions, timing utilities) that can be composed into higher-level feedback
    components. All animations are designed to be fast (200-500ms for immediate feedback)
    and smooth (targeting 60fps), with longer durations (1-2s) reserved for celebratory
    moments like achievement unlocks.
    
    Accessibility is a first-class concern: all feedback uses both color and iconography
    (not color alone), all colors meet WCAG AA contrast requirements, and a reduced-motion
    mode disables or simplifies animations for users with motion sensitivity. The system
    integrates with the existing session management (LearningSession, PracticeSession) to
    trigger appropriate feedback based on user responses.

  key_points:
    - "Visual feedback dramatically improves learning effectiveness through immediate reinforcement"
    - "All animations target 60fps performance with duration-appropriate timing (fast for feedback, slower for celebration)"
    - "Accessibility is built-in: WCAG AA color contrast, reduced-motion support, color+icon feedback"
    - "Reusable animation primitives (easing, timing, state management) enable consistent behavior across components"
    - "Integration with session management ensures feedback triggers automatically on user interactions"
    - "Shake effect uses damped oscillation to return smoothly to center and avoid motion sickness"
    - "Progress indicators update smoothly rather than jumping, providing clear visual continuity"
    - "Achievement animations are celebratory (longer duration, playful easing) vs immediate feedback (short, responsive)"

files:
  - path: "src/ui/feedback.rs"
    description: "Core feedback animation system with FeedbackAnimation enum and animation state management"
  
  - path: "src/ui/effects.rs"
    description: "Visual effects implementation including shake, flash, and particle effects"
  
  - path: "src/ui/progress.rs"
    description: "Progress indicator components including circular progress and linear progress bars"
  
  - path: "src/ui/achievement_popup.rs"
    description: "Achievement celebration popup with slide-in and fade animations"
  
  - path: "src/ui/colors.rs"
    description: "Color palette module defining feedback states (success, error, warning, info) with WCAG AA compliant colors"
  
  - path: "src/ui/animations.rs"
    description: "Animation utilities including easing functions, timing, and animation state helpers"
  
  - path: "src/ui/accessibility.rs"
    description: "Accessibility features module including motion preference detection and animation adjustment"
  
  - path: "src/ui/mod.rs"
    description: "UI module declaration file, updated to export new feedback and animation modules"
  
  - path: "tests/ui/feedback_tests.rs"
    description: "Integration tests for feedback animations, effects, and visual polish components"

functions:
  - file: "src/ui/feedback.rs"
    items:
      - type: "module_declaration"
        name: "ui::feedback"
        description: "Module containing visual feedback and animation components for user interactions"
      
      - type: "enum"
        name: "FeedbackType"
        description: "Enum representing different types of feedback animations (Correct, Incorrect, Partial)"
      
      - type: "struct"
        name: "FeedbackAnimation"
        description: "Manages success/error/partial feedback animations with associated colors and timing"
      
      - type: "method"
        name: "FeedbackAnimation::new"
        description: "Creates a new feedback animation with the specified type"
        preconditions: "Valid FeedbackType provided"
        postconditions: "Returns initialized FeedbackAnimation with appropriate color and duration"
      
      - type: "method"
        name: "FeedbackAnimation::update"
        description: "Updates animation state based on elapsed time"
        preconditions: "Animation is active"
        postconditions: "Updates internal progress, returns true if animation complete"
        invariants: "Progress remains in range [0.0, 1.0]"
      
      - type: "method"
        name: "FeedbackAnimation::view"
        description: "Renders the feedback animation as an iced Element"
        postconditions: "Returns Element displaying current animation state"
      
      - type: "function"
        name: "feedback_color"
        description: "Returns the color associated with a given feedback type"
        postconditions: "Returns WCAG AA compliant color for feedback type"
      
      - type: "function"
        name: "feedback_icon"
        description: "Returns the icon (checkmark, X, or partial) for a feedback type"
        postconditions: "Returns appropriate unicode character or SVG path"

  - file: "src/ui/effects.rs"
    items:
      - type: "module_declaration"
        name: "ui::effects"
        description: "Module containing reusable visual effects for animations"
      
      - type: "struct"
        name: "ShakeEffect"
        description: "Implements oscillating shake animation with decay for error feedback"
      
      - type: "method"
        name: "ShakeEffect::new"
        description: "Creates a new shake effect with specified amplitude and duration"
        preconditions: "amplitude > 0.0, duration > 0.0"
        postconditions: "Returns initialized ShakeEffect ready to animate"
      
      - type: "method"
        name: "ShakeEffect::new_with_preferences"
        description: "Creates shake effect respecting motion preferences"
        preconditions: "amplitude > 0.0, duration > 0.0"
        postconditions: "Returns ShakeEffect that respects reduced motion setting"
      
      - type: "method"
        name: "ShakeEffect::offset_at"
        description: "Calculates horizontal offset at given time using damped sine wave"
        postconditions: "Returns current horizontal offset, decreases amplitude over time"
        invariants: "Final position returns to 0.0 when animation completes"
      
      - type: "method"
        name: "ShakeEffect::is_complete"
        description: "Checks if shake animation has finished"
        postconditions: "Returns true when animation time exceeds duration"

  - file: "src/ui/animations.rs"
    items:
      - type: "module_declaration"
        name: "ui::animations"
        description: "Module containing reusable animation utilities and easing functions"
      
      - type: "function"
        name: "ease_out_cubic"
        description: "Easing function for smooth deceleration"
        preconditions: "t in range [0.0, 1.0]"
        postconditions: "Returns eased value in range [0.0, 1.0]"
        invariants: "Monotonically increasing function"
      
      - type: "function"
        name: "ease_out_elastic"
        description: "Easing function with elastic overshoot for playful feedback"
        preconditions: "t in range [0.0, 1.0]"
        postconditions: "Returns eased value, may exceed 1.0 during overshoot"
      
      - type: "struct"
        name: "AnimationState"
        description: "Tracks animation timing and completion state"
      
      - type: "method"
        name: "AnimationState::new"
        description: "Creates new animation state for given animation type"
        postconditions: "Returns initialized state ready to track animation progress"
      
      - type: "method"
        name: "AnimationState::start"
        description: "Begins animation timing"
        postconditions: "Animation marked as running"
      
      - type: "method"
        name: "AnimationState::update"
        description: "Updates animation state based on elapsed time"
        preconditions: "Animation has been started"
        postconditions: "Updates progress and completion status"
      
      - type: "method"
        name: "AnimationState::reset"
        description: "Resets animation to initial state"
        postconditions: "Animation marked as not running, progress reset to 0"
      
      - type: "method"
        name: "AnimationState::is_complete"
        description: "Checks if animation has completed"
        postconditions: "Returns true if animation duration elapsed"

  - file: "src/ui/progress.rs"
    items:
      - type: "module_declaration"
        name: "ui::progress"
        description: "Module containing progress visualization components"
      
      - type: "struct"
        name: "ProgressCircle"
        description: "Circular progress indicator for session completion tracking"
      
      - type: "method"
        name: "ProgressCircle::new"
        description: "Creates a new progress circle with initial progress value and radius"
        preconditions: "progress in range [0.0, 1.0], radius > 0.0"
        postconditions: "Returns initialized ProgressCircle"
      
      - type: "method"
        name: "ProgressCircle::set_progress"
        description: "Updates the progress value with smooth interpolation"
        preconditions: "progress in range [0.0, 1.0]"
        postconditions: "Smoothly animates to new progress value"
        invariants: "Progress remains in valid range [0.0, 1.0]"
      
      - type: "method"
        name: "ProgressCircle::arc_angle"
        description: "Calculates arc angle in radians for current progress"
        postconditions: "Returns angle from 0 to 2π radians"
      
      - type: "method"
        name: "ProgressCircle::percentage"
        description: "Returns progress as percentage (0-100)"
        postconditions: "Returns value in range [0.0, 100.0]"
      
      - type: "method"
        name: "ProgressCircle::view"
        description: "Renders the progress circle as an iced Canvas element"
        postconditions: "Returns Element with circular arc representing progress"
      
      - type: "function"
        name: "draw_progress_arc"
        description: "Helper function to draw partial arc on canvas"
        preconditions: "progress in [0.0, 1.0], radius > 0.0"
        postconditions: "Draws arc from 0 to progress * 2π radians"

  - file: "src/ui/achievement_popup.rs"
    items:
      - type: "module_declaration"
        name: "ui::achievement_popup"
        description: "Module for achievement celebration animations and popups"
      
      - type: "struct"
        name: "AchievementPopup"
        description: "Displays celebratory animation when achievement is unlocked"
      
      - type: "method"
        name: "AchievementPopup::new"
        description: "Creates new achievement popup in hidden state"
        postconditions: "Returns initialized popup ready to display achievements"
      
      - type: "method"
        name: "AchievementPopup::new_with_preferences"
        description: "Creates popup respecting motion preferences"
        postconditions: "Returns popup that respects reduced motion setting"
      
      - type: "method"
        name: "AchievementPopup::show"
        description: "Shows popup for given achievement with slide-in animation"
        preconditions: "Valid Achievement reference provided"
        postconditions: "Popup becomes visible and begins animation"
      
      - type: "method"
        name: "AchievementPopup::update"
        description: "Updates animation state and handles auto-dismiss timing"
        postconditions: "Returns true if popup should be dismissed (after display duration)"
        invariants: "Animation progress in range [0.0, 1.0]"
      
      - type: "method"
        name: "AchievementPopup::is_visible"
        description: "Checks if popup is currently visible"
        postconditions: "Returns true if popup is showing"
      
      - type: "method"
        name: "AchievementPopup::is_animating"
        description: "Checks if animation is in progress"
        postconditions: "Returns true if animation running"
      
      - type: "method"
        name: "AchievementPopup::opacity_at"
        description: "Calculates opacity at given time for fade animation"
        postconditions: "Returns opacity value in range [0.0, 1.0]"
      
      - type: "method"
        name: "AchievementPopup::y_offset_at"
        description: "Calculates vertical offset at given time for slide animation"
        postconditions: "Returns offset from -100 (hidden) to 0 (visible)"
      
      - type: "method"
        name: "AchievementPopup::view"
        description: "Renders popup with icon, title, description, and animations"
        postconditions: "Returns Element with slide and fade animations applied"
      
      - type: "function"
        name: "calculate_slide_offset"
        description: "Calculates vertical offset for slide-in animation"
        preconditions: "progress in range [0.0, 1.0]"
        postconditions: "Returns offset from -100 (hidden) to 0 (visible)"

  - file: "src/ui/colors.rs"
    items:
      - type: "module_declaration"
        name: "ui::colors"
        description: "Module defining color palette for feedback states and UI"
      
      - type: "constant"
        name: "FEEDBACK_SUCCESS"
        description: "Green color for correct answers (WCAG AA compliant)"
      
      - type: "constant"
        name: "FEEDBACK_ERROR"
        description: "Red color for incorrect answers (WCAG AA compliant)"
      
      - type: "constant"
        name: "FEEDBACK_PARTIAL"
        description: "Yellow/orange color for partially correct (WCAG AA compliant)"
      
      - type: "constant"
        name: "PROGRESS_FOREGROUND"
        description: "Color for completed portion of progress indicators"
      
      - type: "constant"
        name: "PROGRESS_BACKGROUND"
        description: "Color for uncompleted portion of progress indicators"
      
      - type: "constant"
        name: "ACHIEVEMENT_GOLD"
        description: "Gold color for achievement celebrations"

  - file: "src/ui/accessibility.rs"
    items:
      - type: "module_declaration"
        name: "ui::accessibility"
        description: "Module for accessibility features including motion preferences"
      
      - type: "struct"
        name: "MotionPreference"
        description: "Tracks user's motion preference setting"
      
      - type: "method"
        name: "MotionPreference::should_reduce_motion"
        description: "Checks if animations should be reduced or disabled"
        postconditions: "Returns true if user prefers reduced motion"
      
      - type: "function"
        name: "adjust_duration_for_preference"
        description: "Adjusts animation duration based on motion preference"
        preconditions: "duration > 0.0"
        postconditions: "Returns reduced duration if motion should be reduced, otherwise original"

  - file: "src/ui/mod.rs"
    items:
      - type: "module_declaration"
        name: "ui::feedback"
        description: "Export feedback module"
      
      - type: "module_declaration"
        name: "ui::effects"
        description: "Export effects module"
      
      - type: "module_declaration"
        name: "ui::animations"
        description: "Export animations module"
      
      - type: "module_declaration"
        name: "ui::progress"
        description: "Export progress module"
      
      - type: "module_declaration"
        name: "ui::achievement_popup"
        description: "Export achievement_popup module"
      
      - type: "module_declaration"
        name: "ui::colors"
        description: "Export colors module"
      
      - type: "module_declaration"
        name: "ui::accessibility"
        description: "Export accessibility module"

  - file: "src/session/learning_session.rs"
    items:
      - type: "method"
        name: "LearningSession::trigger_feedback"
        description: "Triggers appropriate feedback animation after review response"
        preconditions: "Review has been evaluated"
        postconditions: "Feedback animation state updated, message sent to UI"

  - file: "src/session/practice_session.rs"
    items:
      - type: "method"
        name: "PracticeSession::trigger_feedback"
        description: "Triggers feedback animation for recognition practice result"
        preconditions: "Recognition evaluated as correct/incorrect"
        postconditions: "Feedback animation initiated with appropriate type"

formal_verification:
  needed: false
  level: "None"
  explanation: |
    Formal verification is not needed for visual feedback and animation polish because:
    
    1. Non-Critical Domain: Animation and visual feedback affect user experience quality
       but do not impact data integrity, correctness of learning algorithms, or system safety.
       Incorrect animations are immediately visible and easily fixable.
    
    2. Subjective Validation: Animation quality (smoothness, timing, visual appeal) is
       inherently subjective and best validated through user testing and visual inspection
       rather than formal proofs. Properties like "animation feels responsive" or "shake
       effect is pleasant" cannot be meaningfully expressed as formal specifications.
    
    3. Framework-Delegated Correctness: Core animation mechanics (frame timing, easing
       functions, rendering) are handled by the iced framework. We're composing existing
       primitives rather than implementing low-level animation algorithms that might benefit
       from verification.
    
    4. Integration Testing Sufficiency: The critical properties (animations complete,
       correct colors used, proper state transitions) are effectively verified through
       integration tests and visual inspection. Tests can verify animations trigger on
       correct events and complete without errors.
    
    5. Low Risk Profile: Animation bugs manifest as visual glitches or poor UX, not
       data corruption or crashes. The complexity risk is rated "low" and there are no
       safety-critical concerns requiring formal guarantees.
    
    6. Cost-Benefit Imbalance: The effort required to formally specify and verify
       animation properties (timing bounds, interpolation correctness, state machine
       transitions) would far exceed the value gained, especially given the ease of
       empirical validation.
    
    Appropriate validation approach: Integration tests for functional correctness (correct
    animation triggers on events, state transitions complete) combined with manual visual
    inspection for quality and accessibility considerations (motion sensitivity, contrast
    ratios, smoothness).

tests:
  strategy:
    approach: "mixed (unit + integration + property-based)"
    rationale:
      - "Animation timing and state transitions require unit tests for deterministic verification"
      - "Integration tests verify animations trigger correctly from user interactions and complete without errors"
      - "Visual aspects (colors, contrast, rendering) need property-based tests for accessibility compliance"
      - "Motion effects and frame timing require integration tests with the iced runtime"
      - "Reduced motion accessibility requires dedicated test coverage"
      - "Animation completion callbacks and state cleanup need unit verification"
      - "Property-based tests ensure mathematical invariants hold across all input ranges"

  implementation:
    file: "tests/ui/feedback_tests.rs"
    location: "create new"
    code: |
      #[cfg(test)]
      mod tests {
          use super::*;
          use iced::Color;
          use std::time::Duration;

          // ============================================
          // Unit Tests: FeedbackAnimation State Machine
          // ============================================

          #[test]
          fn test_feedback_animation_correct_state() {
              // Verify correct feedback uses green color and checkmark
              let feedback = FeedbackAnimation::Correct;
              assert_eq!(feedback.color(), Color::from_rgb(0.0, 0.8, 0.0));
              assert_eq!(feedback.icon(), FeedbackIcon::Checkmark);
              assert_eq!(feedback.duration(), Duration::from_millis(300));
          }

          #[test]
          fn test_feedback_animation_incorrect_state() {
              // Verify incorrect feedback uses red color and X icon
              let feedback = FeedbackAnimation::Incorrect;
              assert_eq!(feedback.color(), Color::from_rgb(0.9, 0.0, 0.0));
              assert_eq!(feedback.icon(), FeedbackIcon::Cross);
              assert_eq!(feedback.duration(), Duration::from_millis(400));
          }

          #[test]
          fn test_feedback_animation_partial_state() {
              // Verify partial feedback uses amber color and partial icon
              let feedback = FeedbackAnimation::Partial;
              assert_eq!(feedback.color(), Color::from_rgb(1.0, 0.7, 0.0));
              assert_eq!(feedback.icon(), FeedbackIcon::PartialCheck);
              assert_eq!(feedback.duration(), Duration::from_millis(350));
          }

          // ============================================
          // Unit Tests: Shake Effect Calculations
          // ============================================

          #[test]
          fn test_shake_effect_starts_at_zero() {
              // Shake should start at center position (0.0)
              let shake = ShakeEffect::new(10.0, Duration::from_millis(400));
              assert_eq!(shake.offset_at(Duration::ZERO), 0.0);
          }

          #[test]
          fn test_shake_effect_returns_to_zero() {
              // Shake must return to center at completion
              let shake = ShakeEffect::new(10.0, Duration::from_millis(400));
              let final_offset = shake.offset_at(Duration::from_millis(400));
              assert!(final_offset.abs() < 0.01, "Shake should return to center, got {}", final_offset);
          }

          #[test]
          fn test_shake_effect_amplitude_decay() {
              // Verify amplitude decays over time to avoid motion sickness
              let shake = ShakeEffect::new(15.0, Duration::from_millis(500));
              let offset_early = shake.offset_at(Duration::from_millis(50)).abs();
              let offset_mid = shake.offset_at(Duration::from_millis(250)).abs();
              let offset_late = shake.offset_at(Duration::from_millis(450)).abs();
              
              assert!(offset_early > offset_late, "Amplitude should decay");
              assert!(offset_mid > offset_late, "Decay should be continuous");
          }

          #[test]
          fn test_shake_effect_oscillation() {
              // Verify shake oscillates (changes direction)
              let shake = ShakeEffect::new(10.0, Duration::from_millis(400));
              let offset_25 = shake.offset_at(Duration::from_millis(100));
              let offset_50 = shake.offset_at(Duration::from_millis(200));
              
              // At different times, offset should have different signs (oscillation)
              assert_ne!(offset_25.signum(), offset_50.signum(), "Shake should oscillate");
          }

          #[test]
          fn test_shake_effect_respects_max_amplitude() {
              // No offset should exceed initial amplitude
              let max_amplitude = 12.0;
              let shake = ShakeEffect::new(max_amplitude, Duration::from_millis(400));
              
              for millis in (0..=400).step_by(10) {
                  let offset = shake.offset_at(Duration::from_millis(millis));
                  assert!(offset.abs() <= max_amplitude + 0.1, 
                          "Offset {} exceeds max amplitude {} at {}ms", 
                          offset, max_amplitude, millis);
              }
          }

          // ============================================
          // Unit Tests: Progress Circle Rendering
          // ============================================

          #[test]
          fn test_progress_circle_at_zero() {
              // Progress circle at 0% should render correctly
              let progress = ProgressCircle::new(0.0, 50.0);
              assert_eq!(progress.arc_angle(), 0.0);
              assert_eq!(progress.percentage(), 0.0);
          }

          #[test]
          fn test_progress_circle_at_fifty_percent() {
              // Progress circle at 50% should render half arc
              let progress = ProgressCircle::new(0.5, 50.0);
              assert!((progress.arc_angle() - std::f32::consts::PI).abs() < 0.01);
              assert_eq!(progress.percentage(), 50.0);
          }

          #[test]
          fn test_progress_circle_at_one_hundred() {
              // Progress circle at 100% should render full circle
              let progress = ProgressCircle::new(1.0, 50.0);
              assert!((progress.arc_angle() - 2.0 * std::f32::consts::PI).abs() < 0.01);
              assert_eq!(progress.percentage(), 100.0);
          }

          #[test]
          fn test_progress_circle_clamps_invalid_values() {
              // Progress should clamp values outside [0, 1] range
              let progress_negative = ProgressCircle::new(-0.5, 50.0);
              assert_eq!(progress_negative.percentage(), 0.0);
              
              let progress_over = ProgressCircle::new(1.5, 50.0);
              assert_eq!(progress_over.percentage(), 100.0);
          }

          #[test]
          fn test_progress_circle_smooth_updates() {
              // Verify smooth interpolation between progress values
              let progress1 = ProgressCircle::new(0.25, 50.0);
              let progress2 = ProgressCircle::new(0.26, 50.0);
              
              let angle_diff = (progress2.arc_angle() - progress1.arc_angle()).abs();
              assert!(angle_diff < 0.1, "Progress updates should be smooth");
          }

          // ============================================
          // Unit Tests: Achievement Popup State
          // ============================================

          #[test]
          fn test_achievement_popup_initial_state() {
              // Achievement popup should start hidden/inactive
              let popup = AchievementPopup::new();
              assert!(!popup.is_visible());
              assert_eq!(popup.opacity_at(Duration::ZERO), 0.0);
          }

          #[test]
          fn test_achievement_popup_show() {
              // Show should trigger animation and make popup visible
              let mut popup = AchievementPopup::new();
              popup.show(Achievement::FirstReview, Duration::from_millis(2000));
              
              assert!(popup.is_visible());
              assert!(popup.is_animating());
          }

          #[test]
          fn test_achievement_popup_fade_in() {
              // Opacity should increase during fade-in
              let mut popup = AchievementPopup::new();
              popup.show(Achievement::FirstReview, Duration::from_millis(1500));
              
              let opacity_start = popup.opacity_at(Duration::ZERO);
              let opacity_mid = popup.opacity_at(Duration::from_millis(200));
              let opacity_end = popup.opacity_at(Duration::from_millis(500));
              
              assert!(opacity_start < opacity_mid);
              assert!(opacity_mid < opacity_end);
              assert!((opacity_end - 1.0).abs() < 0.01, "Should reach full opacity");
          }

          #[test]
          fn test_achievement_popup_auto_dismiss() {
              // Popup should auto-dismiss after display duration
              let mut popup = AchievementPopup::new();
              let display_duration = Duration::from_millis(2000);
              popup.show(Achievement::FirstReview, display_duration);
              
              // Before auto-dismiss time
              popup.update(Duration::from_millis(1500));
              assert!(popup.is_visible());
              
              // After auto-dismiss time
              popup.update(Duration::from_millis(2500));
              assert!(!popup.is_visible());
          }

          #[test]
          fn test_achievement_popup_slide_animation() {
              // Verify slide-in from top animation
              let mut popup = AchievementPopup::new();
              popup.show(Achievement::FirstReview, Duration::from_millis(2000));
              
              let y_start = popup.y_offset_at(Duration::ZERO);
              let y_mid = popup.y_offset_at(Duration::from_millis(250));
              let y_end = popup.y_offset_at(Duration::from_millis(500));
              
              assert!(y_start < 0.0, "Should start above viewport");
              assert!(y_mid > y_start, "Should move down");
              assert!((y_end - 0.0).abs() < 1.0, "Should reach final position");
          }

          // ============================================
          // Unit Tests: Color Palette Accessibility
          // ============================================

          #[test]
          fn test_feedback_colors_meet_wcag_contrast() {
              // Verify all feedback colors meet WCAG AA contrast (4.5:1) on white background
              let white = Color::WHITE;
              
              let correct_color = FeedbackAnimation::Correct.color();
              assert!(calculate_contrast_ratio(correct_color, white) >= 4.5);
              
              let incorrect_color = FeedbackAnimation::Incorrect.color();
              assert!(calculate_contrast_ratio(incorrect_color, white) >= 4.5);
              
              let partial_color = FeedbackAnimation::Partial.color();
              assert!(calculate_contrast_ratio(partial_color, white) >= 4.5);
          }

          #[test]
          fn test_feedback_colors_distinct() {
              // Colors should be distinguishable for colorblind users
              let correct = FeedbackAnimation::Correct.color();
              let incorrect = FeedbackAnimation::Incorrect.color();
              let partial = FeedbackAnimation::Partial.color();
              
              assert!(color_distance(correct, incorrect) > 100.0);
              assert!(color_distance(correct, partial) > 100.0);
              assert!(color_distance(incorrect, partial) > 100.0);
          }

          // ============================================
          // Unit Tests: Reduced Motion Support
          // ============================================

          #[test]
          fn test_reduced_motion_disables_shake() {
              // Shake effect should be disabled when prefers-reduced-motion is set
              let shake = ShakeEffect::new_with_preferences(10.0, Duration::from_millis(400), true);
              
              // With reduced motion, offset should always be 0
              for millis in (0..=400).step_by(50) {
                  let offset = shake.offset_at(Duration::from_millis(millis));
                  assert_eq!(offset, 0.0, "Shake should be disabled with reduced motion");
              }
          }

          #[test]
          fn test_reduced_motion_simplifies_achievement_animation() {
              // Achievement animation should be simpler with reduced motion
              let mut popup = AchievementPopup::new_with_preferences(true);
              popup.show(Achievement::FirstReview, Duration::from_millis(2000));
              
              // Should fade in without slide animation
              let y_offset = popup.y_offset_at(Duration::from_millis(100));
              assert_eq!(y_offset, 0.0, "No slide animation with reduced motion");
          }

          // ============================================
          // Integration Tests: Animation Timing
          // ============================================

          #[test]
          fn test_feedback_animation_completes_in_time() {
              // Verify feedback animations complete within expected duration
              let feedback = FeedbackAnimation::Correct;
              let duration = feedback.duration();
              
              let mut state = AnimationState::new(feedback);
              state.start();
              
              // Update to completion time
              state.update(duration);
              assert!(state.is_complete());
          }

          #[test]
          fn test_animation_state_cleanup() {
              // Verify animation state is properly cleaned up after completion
              let mut state = AnimationState::new(FeedbackAnimation::Correct);
              state.start();
              state.update(Duration::from_millis(500));
              
              assert!(state.is_complete());
              state.reset();
              assert!(!state.is_running());
              assert!(!state.is_complete());
          }

          #[test]
          fn test_multiple_animations_dont_interfere() {
              // Multiple concurrent animations should not interfere
              let shake = ShakeEffect::new(10.0, Duration::from_millis(400));
              let mut popup = AchievementPopup::new();
              popup.show(Achievement::FirstReview, Duration::from_millis(2000));
              
              let time = Duration::from_millis(200);
              let shake_offset = shake.offset_at(time);
              let popup_opacity = popup.opacity_at(time);
              
              // Both should have valid values
              assert!(shake_offset.abs() > 0.0);
              assert!(popup_opacity > 0.0);
          }

          // ============================================
          // Helper Functions for Tests
          // ============================================

          fn calculate_contrast_ratio(color1: Color, color2: Color) -> f32 {
              // Simplified WCAG contrast ratio calculation
              let l1 = relative_luminance(color1);
              let l2 = relative_luminance(color2);
              
              let lighter = l1.max(l2);
              let darker = l1.min(l2);
              
              (lighter + 0.05) / (darker + 0.05)
          }

          fn relative_luminance(color: Color) -> f32 {
              // Simplified relative luminance calculation
              0.2126 * color.r + 0.7152 * color.g + 0.0722 * color.b
          }

          fn color_distance(color1: Color, color2: Color) -> f32 {
              // Euclidean distance in RGB space
              let dr = color1.r - color2.r;
              let dg = color1.g - color2.g;
              let db = color1.b - color2.b;
              
              ((dr * dr + dg * dg + db * db) * 255.0 * 255.0).sqrt()
          }
      }

      // ============================================
      // Property-Based Tests for Animation Properties
      // ============================================

      #[cfg(test)]
      mod property_tests {
          use super::*;
          use proptest::prelude::*;

          proptest! {
              #[test]
              fn prop_shake_always_returns_to_center(
                  amplitude in 1.0f32..50.0,
                  duration_ms in 100u64..1000
              ) {
                  let shake = ShakeEffect::new(amplitude, Duration::from_millis(duration_ms));
                  let final_offset = shake.offset_at(Duration::from_millis(duration_ms));
                  prop_assert!(final_offset.abs() < 0.1);
              }

              #[test]
              fn prop_progress_circle_monotonic(
                  progress1 in 0.0f32..1.0,
                  progress2 in 0.0f32..1.0
              ) {
                  let circle1 = ProgressCircle::new(progress1, 50.0);
                  let circle2 = ProgressCircle::new(progress2, 50.0);
                  
                  if progress1 < progress2 {
                      prop_assert!(circle1.arc_angle() < circle2.arc_angle());
                  }
              }

              #[test]
              fn prop_animation_duration_positive(
                  feedback in prop_oneof![
                      Just(FeedbackAnimation::Correct),
                      Just(FeedbackAnimation::Incorrect),
                      Just(FeedbackAnimation::Partial)
                  ]
              ) {
                  let duration = feedback.duration();
                  prop_assert!(duration.as_millis() > 0);
                  prop_assert!(duration.as_millis() <= 1000);
              }

              #[test]
              fn prop_achievement_opacity_bounded(
                  elapsed_ms in 0u64..5000
              ) {
                  let mut popup = AchievementPopup::new();
                  popup.show(Achievement::FirstReview, Duration::from_millis(2000));
                  
                  let opacity = popup.opacity_at(Duration::from_millis(elapsed_ms));
                  prop_assert!(opacity >= 0.0 && opacity <= 1.0);
              }

              #[test]
              fn prop_shake_amplitude_bounded(
                  max_amplitude in 1.0f32..100.0,
                  duration_ms in 100u64..1000,
                  elapsed_ms in 0u64..1000
              ) {
                  let shake = ShakeEffect::new(max_amplitude, Duration::from_millis(duration_ms));
                  let offset = shake.offset_at(Duration::from_millis(elapsed_ms));
                  prop_assert!(offset.abs() <= max_amplitude + 0.5);
              }
          }
      }

  coverage:
    - "Correct feedback uses green color and checkmark icon"
    - "Incorrect feedback uses red color and X icon"
    - "Partial feedback uses amber color and partial check icon"
    - "Feedback animation durations are within acceptable range (200-500ms)"
    - "ShakeEffect starts at center position (offset 0.0)"
    - "ShakeEffect returns to center at completion"
    - "ShakeEffect amplitude decays over time to avoid motion sickness"
    - "ShakeEffect oscillates (changes direction) during animation"
    - "ShakeEffect respects maximum amplitude bounds"
    - "ProgressCircle renders correctly at 0% completion"
    - "ProgressCircle renders correctly at 50% completion"
    - "ProgressCircle renders correctly at 100% completion"
    - "ProgressCircle clamps invalid progress values to [0, 1] range"
    - "ProgressCircle updates smoothly between values"
    - "AchievementPopup starts in hidden/inactive state"
    - "AchievementPopup becomes visible when shown"
    - "AchievementPopup fades in smoothly over time"
    - "AchievementPopup auto-dismisses after display duration"
    - "AchievementPopup slides in from top during animation"
    - "All feedback colors meet WCAG AA contrast ratio (4.5:1)"
    - "Feedback colors are sufficiently distinct for colorblind users"
    - "Reduced motion preference disables shake effect"
    - "Reduced motion preference simplifies achievement animation"
    - "Feedback animations complete within expected duration"
    - "Animation state is properly cleaned up after completion"
    - "Multiple concurrent animations do not interfere with each other"
    - "Shake effect always returns to center regardless of amplitude or duration (property)"
    - "Progress circle angle increases monotonically with progress (property)"
    - "Animation durations are always positive and reasonable (property)"
    - "Achievement popup opacity remains bounded [0, 1] at all times (property)"
    - "Shake offset never exceeds maximum amplitude (property)"

dependencies:
  depends_on:
    - task_id: 1
      reason: "Needs animation API and widget rendering from iced foundation"
    - task_id: 6
      reason: "Needs message system to trigger feedback animations from user interactions"

  depended_upon_by: []

  external:
    - name: "iced::Color"
      type: "struct"
      status: "already exists"
    - name: "iced::Element"
      type: "struct"
      status: "already exists"
    - name: "iced::Canvas"
      type: "trait"
      status: "already exists"
    - name: "std::time::Duration"
      type: "struct"
      status: "already exists"
    - name: "Achievement"
      type: "enum"
      status: "needs implementation"
---
task:
  id: 13
  name: "UI/UX Polish and Accessibility"

context:
  description: |
    This task implements comprehensive accessibility and UX polish to transform the
    flashcard application into a professional, inclusive tool that serves all users
    regardless of ability. Accessibility is both an ethical imperative and legal
    requirement (ADA, Section 508, EU Web Accessibility Directive). Beyond compliance,
    good accessibility design benefits everyone: keyboard shortcuts speed up power users,
    high contrast helps users in bright environments, and clear visual hierarchy reduces
    cognitive load for all learners.

    The implementation follows WCAG 2.1 Level AA standards, which require 4.5:1 contrast
    for normal text, minimum 48x48px touch targets, keyboard accessibility for all
    functionality, and screen reader support. This task creates a design system with
    consistent colors, typography, spacing, and components that enforce accessibility
    by default. Rather than retrofitting accessibility, the design system makes it
    impossible to create inaccessible UI.

    Key architectural decisions include: (1) Theme module with compile-time verified
    contrast ratios, (2) Component library that enforces minimum touch target sizes,
    (3) Keyboard event handling system integrated with iced's message architecture,
    (4) Responsive layout utilities using 8px grid system for visual consistency,
    (5) Accessibility metadata system for screen reader support.

    This polish work directly impacts learning effectiveness: proper contrast reduces
    eye strain during long study sessions, consistent spacing reduces cognitive load,
    keyboard shortcuts enable flow state for power users, and screen reader support
    makes spaced repetition accessible to blind students. The professional polish also
    builds trust and encourages continued use.

  key_points:
    - "WCAG 2.1 Level AA compliance is mandatory for 4.5:1 contrast, 48x48px targets, keyboard access"
    - "Design system enforces accessibility by default through type-safe API"
    - "8px grid system creates consistent visual rhythm reducing cognitive load"
    - "Keyboard shortcuts integrated with iced message system enable efficient navigation"
    - "Responsive layouts adapt from 320px mobile to 1920px+ desktop"
    - "Screen reader support requires platform-specific testing (NVDA/JAWS/VoiceOver)"
    - "Accessibility benefits all users, not just those with disabilities"
    - "Testing requires mix of automated property tests and manual verification"

files:
  - path: "src/ui/theme.rs"
    description: "WCAG-compliant color palette and theme constants with documented contrast ratios"
  
  - path: "src/ui/typography.rs"
    description: "Typography scale defining consistent font sizes, weights, and text styles"
  
  - path: "src/ui/spacing.rs"
    description: "Spacing constants and utilities for consistent 8px-based rhythm"
  
  - path: "src/ui/accessibility.rs"
    description: "Accessibility utilities including focus indicators and ARIA-like helpers"
  
  - path: "src/input/keyboard.rs"
    description: "Keyboard shortcut handlers and navigation logic"
  
  - path: "src/ui/components/button.rs"
    description: "Accessible button component with proper touch target sizing (48x48px minimum)"
  
  - path: "src/ui/components/text_input.rs"
    description: "Enhanced text input with keyboard navigation and focus management"
  
  - path: "src/ui/screens/practice_screen.rs"
    description: "Updated practice screen with responsive layouts and keyboard shortcuts"
  
  - path: "src/ui/screens/review_screen.rs"
    description: "Updated review screen with accessible controls and responsive design"
  
  - path: "src/ui/screens/deck_list_screen.rs"
    description: "Updated deck list with keyboard navigation and touch-friendly targets"
  
  - path: "src/ui/screens/settings_screen.rs"
    description: "Updated settings screen with accessible form controls"
  
  - path: "src/ui/screens/help_screen.rs"
    description: "Help screen documenting keyboard shortcuts and accessibility features"
  
  - path: "src/ui/layout.rs"
    description: "Responsive layout utilities and containers that adapt to window size"
  
  - path: "tests/accessibility_tests.rs"
    description: "Integration tests verifying contrast ratios, target sizes, and keyboard navigation"
  
  - path: "tests/keyboard_navigation_tests.rs"
    description: "Tests for keyboard shortcut functionality and focus management"

functions:
  - file: "src/ui/theme.rs"
    items:
      - type: "module_declaration"
        name: "theme"
        description: "Module containing color palette, typography scale, spacing constants, and WCAG-compliant theme definitions"
      
      - type: "struct"
        name: "ColorPalette"
        description: "Defines the application color scheme with WCAG AA-compliant colors"
        invariants: "All color combinations meet 4.5:1 contrast ratio for normal text"
      
      - type: "struct"
        name: "Typography"
        description: "Defines consistent font sizes and weights used throughout the application"
        invariants: "All font sizes are >= 12px, body text >= 14px"
      
      - type: "struct"
        name: "Spacing"
        description: "Defines consistent spacing units based on 8px grid system"
        invariants: "All spacing values are multiples of 8"
      
      - type: "constant"
        name: "MIN_TOUCH_TARGET_SIZE"
        description: "Minimum touch target size constant (48px) for accessibility"
      
      - type: "constant"
        name: "MIN_CONTRAST_RATIO"
        description: "Minimum WCAG AA contrast ratio (4.5:1) for normal text"
      
      - type: "function"
        name: "default_theme"
        description: "Returns the default application theme with all accessibility settings"
        postconditions: "Returns theme meeting WCAG 2.1 Level AA standards"

  - file: "src/ui/keyboard.rs"
    items:
      - type: "module_declaration"
        name: "keyboard"
        description: "Module handling keyboard shortcuts and navigation"
      
      - type: "enum_variant"
        name: "KeyboardAction"
        description: "Represents all keyboard-triggered actions in the application"
      
      - type: "struct"
        name: "KeyboardShortcuts"
        description: "Maps keyboard combinations to actions"
      
      - type: "function"
        name: "handle_keyboard_event"
        description: "Processes keyboard events and returns corresponding action"
        preconditions: "Valid keyboard event from iced"
        postconditions: "Returns Some(KeyboardAction) if shortcut matched, None otherwise"
      
      - type: "function"
        name: "register_shortcut"
        description: "Registers a new keyboard shortcut for an action"
        preconditions: "Shortcut not already registered"
        postconditions: "Shortcut added to mapping"
      
      - type: "function"
        name: "get_shortcuts_help"
        description: "Returns formatted list of all keyboard shortcuts for display"
        postconditions: "Returns human-readable shortcut descriptions"

  - file: "src/ui/accessible.rs"
    items:
      - type: "module_declaration"
        name: "accessible"
        description: "Module providing accessible UI component wrappers and utilities"
      
      - type: "struct"
        name: "AccessibleButton"
        description: "Button widget with proper touch target sizing and ARIA attributes"
        invariants: "Button size >= 48x48px"
      
      - type: "struct"
        name: "AccessibleText"
        description: "Text widget with proper contrast and screen reader support"
        invariants: "Text meets WCAG AA contrast requirements"
      
      - type: "struct"
        name: "FocusIndicator"
        description: "Visual focus indicator for keyboard navigation"
        invariants: "Border width >= 2px, high contrast color"
      
      - type: "function"
        name: "ensure_touch_target_size"
        description: "Ensures widget meets minimum touch target size by adding padding if needed"
        preconditions: "Widget size provided"
        postconditions: "Returns size >= 48x48px"
      
      - type: "function"
        name: "check_contrast_ratio"
        description: "Calculates and validates contrast ratio between two colors"
        preconditions: "Valid RGB color values"
        postconditions: "Returns contrast ratio and WCAG compliance level"
      
      - type: "function"
        name: "add_screen_reader_label"
        description: "Adds ARIA label or description to widget for screen readers"
        preconditions: "Widget and label text provided"
        postconditions: "Widget has screen reader accessible name"

  - file: "src/ui/responsive.rs"
    items:
      - type: "module_declaration"
        name: "responsive"
        description: "Module providing responsive layout utilities and breakpoints"
      
      - type: "enum_variant"
        name: "Breakpoint"
        description: "Defines responsive breakpoints (Small, Medium, Large, XLarge)"
      
      - type: "function"
        name: "get_breakpoint"
        description: "Determines current breakpoint based on window width"
        preconditions: "Valid window width provided"
        postconditions: "Returns appropriate Breakpoint variant"
      
      - type: "function"
        name: "responsive_spacing"
        description: "Returns appropriate spacing value for current breakpoint"
        preconditions: "Valid breakpoint"
        postconditions: "Returns spacing scaled to breakpoint"
      
      - type: "function"
        name: "responsive_layout"
        description: "Creates layout that adapts to window size"
        preconditions: "Valid breakpoint and content widgets"
        postconditions: "Returns layout optimized for current breakpoint"

  - file: "src/ui/components/button.rs"
    items:
      - type: "method"
        name: "Button::accessible"
        description: "Creates accessible button with proper sizing and contrast"
        postconditions: "Button meets WCAG AA standards and minimum touch target size"
      
      - type: "method"
        name: "Button::with_keyboard_shortcut"
        description: "Adds keyboard shortcut hint to button display"
        preconditions: "Valid shortcut provided"
        postconditions: "Button shows shortcut hint in UI"

  - file: "src/ui/components/text_input.rs"
    items:
      - type: "method"
        name: "TextInput::accessible"
        description: "Creates accessible text input with proper labels and ARIA attributes"
        postconditions: "Input has visible label and screen reader accessible name"
      
      - type: "method"
        name: "TextInput::with_error_message"
        description: "Adds error message with proper ARIA invalid state"
        preconditions: "Error message text provided"
        postconditions: "Error announced to screen readers"

  - file: "src/ui/components/rating.rs"
    items:
      - type: "method"
        name: "RatingButtons::with_keyboard_shortcuts"
        description: "Enables keyboard shortcuts (1-5) for quality ratings"
        postconditions: "Number keys 1-5 trigger corresponding rating"
      
      - type: "method"
        name: "RatingButtons::accessible_labels"
        description: "Adds screen reader labels to each rating button"
        postconditions: "Each button has descriptive label for screen readers"

  - file: "src/ui/screens/learn.rs"
    items:
      - type: "method"
        name: "LearnScreen::handle_keyboard_event"
        description: "Handles keyboard shortcuts for learning screen actions"
        preconditions: "Valid keyboard event"
        postconditions: "Returns Message for corresponding action or None"
      
      - type: "method"
        name: "LearnScreen::update_responsive_layout"
        description: "Updates layout based on current window size"
        preconditions: "Valid window dimensions"
        postconditions: "Layout optimized for current breakpoint"

  - file: "src/ui/screens/browse.rs"
    items:
      - type: "method"
        name: "BrowseScreen::handle_keyboard_event"
        description: "Handles keyboard shortcuts for browse screen actions"
        preconditions: "Valid keyboard event"
        postconditions: "Returns Message for corresponding action or None"
      
      - type: "method"
        name: "BrowseScreen::update_responsive_layout"
        description: "Updates layout based on current window size"
        preconditions: "Valid window dimensions"
        postconditions: "Layout optimized for current breakpoint"

  - file: "src/ui/screens/settings.rs"
    items:
      - type: "method"
        name: "SettingsScreen::handle_keyboard_event"
        description: "Handles keyboard shortcuts for settings screen actions"
        preconditions: "Valid keyboard event"
        postconditions: "Returns Message for corresponding action or None"
      
      - type: "method"
        name: "SettingsScreen::update_responsive_layout"
        description: "Updates layout based on current window size"
        preconditions: "Valid window dimensions"
        postconditions: "Layout optimized for current breakpoint"

  - file: "src/ui/app.rs"
    items:
      - type: "method"
        name: "App::subscription"
        description: "Subscribes to keyboard events for global shortcuts"
        postconditions: "Returns subscription to keyboard event stream"
      
      - type: "method"
        name: "App::update_keyboard_event"
        description: "Routes keyboard events to appropriate screen handler"
        preconditions: "Valid keyboard event"
        postconditions: "Event processed and state updated if action matched"
      
      - type: "method"
        name: "App::update_theme"
        description: "Updates application theme with accessibility settings"
        preconditions: "Valid theme configuration"
        postconditions: "All UI components use new theme"

  - file: "tests/accessibility_tests.rs"
    items:
      - type: "function"
        name: "test_color_contrast_ratios"
        description: "Verifies all color combinations meet WCAG AA contrast requirements"
        postconditions: "All contrasts >= 4.5:1"
      
      - type: "function"
        name: "test_touch_target_sizes"
        description: "Verifies all interactive elements meet minimum touch target size"
        postconditions: "All buttons >= 48x48px"
      
      - type: "function"
        name: "test_keyboard_shortcuts_registered"
        description: "Verifies all expected keyboard shortcuts are registered"
        postconditions: "All shortcuts present and non-conflicting"
      
      - type: "function"
        name: "test_font_sizes"
        description: "Verifies all font sizes meet minimum requirements"
        postconditions: "All fonts >= 12px, body >= 14px"
      
      - type: "function"
        name: "test_focus_indicator_visibility"
        description: "Verifies focus indicators are visible and properly styled"
        postconditions: "Focus indicators have sufficient contrast and size"
      
      - type: "function"
        name: "test_screen_reader_labels"
        description: "Verifies all interactive elements have screen reader labels"
        postconditions: "All elements have accessible names"
      
      - type: "function"
        name: "test_keyboard_navigation_order"
        description: "Verifies tab order follows logical flow through UI"
        postconditions: "Tab navigation visits elements in expected order"
      
      - type: "function"
        name: "test_responsive_breakpoints"
        description: "Verifies layout adapts correctly at different breakpoints"
        postconditions: "Layouts appropriate for each breakpoint"

formal_verification:
  needed: false
  level: "None"
  explanation: |
    UI/UX polish and accessibility features are primarily concerned with human
    perception, interaction patterns, and assistive technology compatibility.
    These qualities are not amenable to formal verification because:

    1. Subjective Quality: Visual polish, aesthetic consistency, and "feel" cannot
       be formally specified or verified - they require human judgment and user testing.

    2. External System Interaction: Accessibility depends on correct interaction with
       screen readers, operating system accessibility APIs, and assistive devices.
       Formal verification cannot prove correct behavior of these external systems.

    3. Empirical Standards: WCAG compliance (contrast ratios, target sizes) involves
       empirical measurements and human perception factors. While we can test that
       contrast ratio calculations meet thresholds, the actual user experience with
       various visual impairments requires empirical validation, not formal proof.

    4. Platform Variance: Keyboard navigation, focus management, and screen reader
       behavior vary significantly across platforms (Windows/NVDA vs macOS/VoiceOver).
       Formal verification cannot account for this platform-specific behavior.

    5. Testing Sufficiency: The acceptance criteria (contrast ratios, touch target
       dimensions, keyboard shortcuts) are readily verified through automated integration
       tests, manual testing with assistive technologies, and accessibility audits.
       The risk/benefit ratio does not justify formal verification overhead.

    The appropriate validation approach is comprehensive integration testing with
    automated checks for measurable properties (contrast ratios, dimensions) combined
    with manual testing using actual assistive technologies and ideally user testing
    with disabled users. This provides stronger validation than formal verification
    would for UX and accessibility concerns.

tests:
  strategy:
    approach: "mixed (unit tests + integration tests + manual verification checklist)"
    rationale:
      - "Unit tests verify quantifiable accessibility properties (contrast ratios, target sizes, color values)"
      - "Integration tests validate keyboard event handling and focus management across components"
      - "Manual verification checklist required for screen reader compatibility and actual user experience"
      - "Automated tests catch regressions in measurable properties while manual tests ensure real-world usability"
      - "Property-based testing for color contrast calculations ensures all palette combinations meet WCAG standards"

  implementation:
    file: "tests/accessibility_tests.rs"
    location: "create new"
    code: |
      #[cfg(test)]
      mod accessibility_tests {
          use super::*;

          mod color_contrast_tests {
              use crate::ui::theme::{ColorPalette, ContrastChecker};

              #[test]
              fn test_primary_text_meets_wcag_aa_contrast() {
                  let palette = ColorPalette::default();
                  let contrast = ContrastChecker::calculate_contrast(
                      palette.text_primary,
                      palette.background_primary
                  );
                  assert!(
                      contrast >= 4.5,
                      "Primary text contrast {:.2} does not meet WCAG AA (4.5:1)",
                      contrast
                  );
              }

              #[test]
              fn test_secondary_text_meets_wcag_aa_contrast() {
                  let palette = ColorPalette::default();
                  let contrast = ContrastChecker::calculate_contrast(
                      palette.text_secondary,
                      palette.background_primary
                  );
                  assert!(
                      contrast >= 4.5,
                      "Secondary text contrast {:.2} does not meet WCAG AA (4.5:1)",
                      contrast
                  );
              }

              #[test]
              fn test_button_text_meets_wcag_aa_contrast() {
                  let palette = ColorPalette::default();
                  let contrast = ContrastChecker::calculate_contrast(
                      palette.button_text,
                      palette.button_background
                  );
                  assert!(
                      contrast >= 4.5,
                      "Button text contrast {:.2} does not meet WCAG AA (4.5:1)",
                      contrast
                  );
              }

              #[test]
              fn test_error_text_meets_wcag_aa_contrast() {
                  let palette = ColorPalette::default();
                  let contrast = ContrastChecker::calculate_contrast(
                      palette.error_text,
                      palette.background_primary
                  );
                  assert!(
                      contrast >= 4.5,
                      "Error text contrast {:.2} does not meet WCAG AA (4.5:1)",
                      contrast
                  );
              }

              #[test]
              fn test_success_text_meets_wcag_aa_contrast() {
                  let palette = ColorPalette::default();
                  let contrast = ContrastChecker::calculate_contrast(
                      palette.success_text,
                      palette.background_primary
                  );
                  assert!(
                      contrast >= 4.5,
                      "Success text contrast {:.2} does not meet WCAG AA (4.5:1)",
                      contrast
                  );
              }

              #[test]
              fn test_large_text_meets_wcag_aa_contrast() {
                  let palette = ColorPalette::default();
                  let contrast = ContrastChecker::calculate_contrast(
                      palette.heading_text,
                      palette.background_primary
                  );
                  assert!(
                      contrast >= 3.0,
                      "Large text contrast {:.2} does not meet WCAG AA (3:1)",
                      contrast
                  );
              }

              #[test]
              fn test_focus_indicator_meets_wcag_contrast() {
                  let palette = ColorPalette::default();
                  let contrast = ContrastChecker::calculate_contrast(
                      palette.focus_indicator,
                      palette.background_primary
                  );
                  assert!(
                      contrast >= 3.0,
                      "Focus indicator contrast {:.2} does not meet WCAG (3:1)",
                      contrast
                  );
              }

              #[test]
              fn test_all_palette_colors_are_valid_rgb() {
                  let palette = ColorPalette::default();
                  for (name, color) in palette.all_colors() {
                      assert!(color.r <= 1.0 && color.r >= 0.0, "{} red out of range", name);
                      assert!(color.g <= 1.0 && color.g >= 0.0, "{} green out of range", name);
                      assert!(color.b <= 1.0 && color.b >= 0.0, "{} blue out of range", name);
                  }
              }
          }

          mod touch_target_tests {
              use crate::ui::components::{Button, IconButton, TouchTargetValidator};

              const MIN_TOUCH_TARGET_SIZE: u16 = 48;

              #[test]
              fn test_primary_button_meets_minimum_touch_target() {
                  let button = Button::primary("Test");
                  let size = button.minimum_size();
                  assert!(
                      size.width >= MIN_TOUCH_TARGET_SIZE,
                      "Button width {} below minimum {}",
                      size.width,
                      MIN_TOUCH_TARGET_SIZE
                  );
                  assert!(
                      size.height >= MIN_TOUCH_TARGET_SIZE,
                      "Button height {} below minimum {}",
                      size.height,
                      MIN_TOUCH_TARGET_SIZE
                  );
              }

              #[test]
              fn test_icon_button_meets_minimum_touch_target() {
                  let button = IconButton::new("icon_name");
                  let size = button.minimum_size();
                  assert!(
                      size.width >= MIN_TOUCH_TARGET_SIZE && size.height >= MIN_TOUCH_TARGET_SIZE,
                      "Icon button size {}x{} below minimum {}x{}",
                      size.width,
                      size.height,
                      MIN_TOUCH_TARGET_SIZE,
                      MIN_TOUCH_TARGET_SIZE
                  );
              }

              #[test]
              fn test_quality_rating_buttons_meet_touch_target() {
                  let rating_button = Button::quality_rating(5);
                  let size = rating_button.minimum_size();
                  assert!(
                      size.width >= MIN_TOUCH_TARGET_SIZE && size.height >= MIN_TOUCH_TARGET_SIZE,
                      "Quality rating button too small: {}x{}",
                      size.width,
                      size.height
                  );
              }

              #[test]
              fn test_close_button_meets_touch_target() {
                  let close_btn = IconButton::close();
                  let size = close_btn.minimum_size();
                  assert!(
                      size.width >= MIN_TOUCH_TARGET_SIZE,
                      "Close button too narrow: {}",
                      size.width
                  );
              }

              #[test]
              fn test_all_interactive_elements_validated() {
                  let validator = TouchTargetValidator::new();
                  let elements = validator.collect_interactive_elements();
                  
                  for element in elements {
                      let size = element.computed_size();
                      assert!(
                          size.width >= MIN_TOUCH_TARGET_SIZE && size.height >= MIN_TOUCH_TARGET_SIZE,
                          "Element '{}' fails touch target size: {}x{}",
                          element.name(),
                          size.width,
                          size.height
                      );
                  }
              }
          }

          mod typography_tests {
              use crate::ui::theme::Typography;

              #[test]
              fn test_minimum_font_sizes_meet_legibility_standards() {
                  let typo = Typography::default();
                  
                  assert!(
                      typo.body_size >= 16.0,
                      "Body text size {} below recommended 16px",
                      typo.body_size
                  );
                  
                  assert!(
                      typo.secondary_size >= 14.0,
                      "Secondary text size {} below recommended 14px",
                      typo.secondary_size
                  );
                  
                  assert!(
                      typo.minimum_size >= 12.0,
                      "Minimum text size {} below absolute minimum 12px",
                      typo.minimum_size
                  );
              }

              #[test]
              fn test_heading_hierarchy_is_logical() {
                  let typo = Typography::default();
                  
                  assert!(typo.h1_size > typo.h2_size, "H1 should be larger than H2");
                  assert!(typo.h2_size > typo.h3_size, "H2 should be larger than H3");
                  assert!(typo.h3_size > typo.body_size, "H3 should be larger than body");
              }

              #[test]
              fn test_line_height_meets_wcag_recommendations() {
                  let typo = Typography::default();
                  
                  assert!(
                      typo.body_line_height >= 1.5,
                      "Body line height {} below WCAG recommendation of 1.5",
                      typo.body_line_height
                  );
              }

              #[test]
              fn test_letter_spacing_is_adequate() {
                  let typo = Typography::default();
                  
                  assert!(
                      typo.body_letter_spacing >= 0.0,
                      "Negative letter spacing reduces readability"
                  );
              }
          }

          mod keyboard_navigation_tests {
              use crate::ui::keyboard::{KeyboardHandler, KeyboardShortcut};
              use iced::keyboard::{KeyCode, Modifiers};
              use crate::Message;

              #[test]
              fn test_quality_shortcuts_1_through_5_registered() {
                  let handler = KeyboardHandler::new();
                  
                  for quality in 1..=5 {
                      let key = match quality {
                          1 => KeyCode::Key1,
                          2 => KeyCode::Key2,
                          3 => KeyCode::Key3,
                          4 => KeyCode::Key4,
                          5 => KeyCode::Key5,
                          _ => unreachable!(),
                      };
                      
                      let result = handler.handle_key_press(key, Modifiers::empty());
                      assert!(
                          result.is_some(),
                          "Quality shortcut {} not registered",
                          quality
                      );
                  }
              }

              #[test]
              fn test_space_key_triggers_next_card() {
                  let handler = KeyboardHandler::new();
                  let result = handler.handle_key_press(KeyCode::Space, Modifiers::empty());
                  
                  assert!(result.is_some(), "Space key should trigger next card");
                  if let Some(Message::NextCard) = result {
                      // Expected
                  } else {
                      panic!("Space key should produce NextCard message");
                  }
              }

              #[test]
              fn test_escape_key_cancels_or_goes_back() {
                  let handler = KeyboardHandler::new();
                  let result = handler.handle_key_press(KeyCode::Escape, Modifiers::empty());
                  
                  assert!(result.is_some(), "Escape key should trigger cancel/back");
              }

              #[test]
              fn test_tab_navigation_cycles_through_elements() {
                  let handler = KeyboardHandler::new();

                  let result_forward = handler.handle_key_press(KeyCode::Tab, Modifiers::empty());
                  assert!(result_forward.is_some(), "Tab should move focus forward");
                  
                  let result_back = handler.handle_key_press(KeyCode::Tab, Modifiers::SHIFT);
                  assert!(result_back.is_some(), "Shift+Tab should move focus backward");
              }

              #[test]
              fn test_enter_key_activates_focused_element() {
                  let handler = KeyboardHandler::new();
                  let result = handler.handle_key_press(KeyCode::Enter, Modifiers::empty());
                  
                  assert!(result.is_some(), "Enter should activate focused element");
              }

              #[test]
              fn test_arrow_keys_navigate_lists() {
                  let handler = KeyboardHandler::new();
                  
                  let up = handler.handle_key_press(KeyCode::Up, Modifiers::empty());
                  let down = handler.handle_key_press(KeyCode::Down, Modifiers::empty());
                  
                  assert!(up.is_some(), "Up arrow should navigate");
                  assert!(down.is_some(), "Down arrow should navigate");
              }

              #[test]
              fn test_all_shortcuts_have_descriptions() {
                  let handler = KeyboardHandler::new();
                  let shortcuts = handler.get_all_shortcuts();
                  
                  for shortcut in shortcuts {
                      assert!(
                          !shortcut.description.is_empty(),
                          "Shortcut {:?} missing description",
                          shortcut.key
                      );
                  }
              }
          }

          mod focus_indicator_tests {
              use crate::ui::theme::FocusIndicator;

              #[test]
              fn test_focus_border_width_meets_minimum() {
                  let indicator = FocusIndicator::default();
                  
                  assert!(
                      indicator.border_width >= 2.0,
                      "Focus border width {} below minimum 2px",
                      indicator.border_width
                  );
              }

              #[test]
              fn test_focus_indicator_is_visible_style() {
                  let indicator = FocusIndicator::default();
                  
                  assert!(
                      indicator.style != BorderStyle::Hidden,
                      "Focus indicator must be visible"
                  );
              }

              #[test]
              fn test_focus_indicator_distinct_from_default_borders() {
                  let focus = FocusIndicator::default();
                  let normal = BorderStyle::default();
                  
                  assert_ne!(
                      focus.color, normal.color,
                      "Focus indicator should be visually distinct"
                  );
              }
          }

          mod responsive_layout_tests {
              use crate::ui::layout::{ResponsiveLayout, BreakPoint};

              #[test]
              fn test_layout_adapts_to_narrow_width() {
                  let layout = ResponsiveLayout::new();
                  let narrow = layout.compute_for_width(400);
                  
                  assert_eq!(
                      narrow.breakpoint,
                      BreakPoint::Mobile,
                      "Should use mobile layout for narrow width"
                  );
              }

              #[test]
              fn test_layout_adapts_to_wide_width() {
                  let layout = ResponsiveLayout::new();
                  let wide = layout.compute_for_width(1200);
                  
                  assert_eq!(
                      wide.breakpoint,
                      BreakPoint::Desktop,
                      "Should use desktop layout for wide width"
                  );
              }

              #[test]
              fn test_text_wraps_at_narrow_widths() {
                  let layout = ResponsiveLayout::new();
                  let narrow = layout.compute_for_width(320);
                  
                  assert!(
                      narrow.text_wrap_enabled,
                      "Text should wrap at narrow widths"
                  );
              }

              #[test]
              fn test_spacing_scales_with_screen_size() {
                  let layout = ResponsiveLayout::new();
                  
                  let mobile_spacing = layout.compute_for_width(400).base_spacing;
                  let desktop_spacing = layout.compute_for_width(1200).base_spacing;
                  
                  assert!(
                      desktop_spacing >= mobile_spacing,
                      "Desktop should have equal or more spacing"
                  );
              }
          }

          mod spacing_consistency_tests {
              use crate::ui::theme::Spacing;

              #[test]
              fn test_spacing_uses_8px_base_unit() {
                  let spacing = Spacing::default();
                  
                  assert_eq!(spacing.base_unit, 8, "Base unit should be 8px");
                  assert_eq!(spacing.xs % 8, 0, "XS spacing should be multiple of 8");
                  assert_eq!(spacing.sm % 8, 0, "SM spacing should be multiple of 8");
                  assert_eq!(spacing.md % 8, 0, "MD spacing should be multiple of 8");
                  assert_eq!(spacing.lg % 8, 0, "LG spacing should be multiple of 8");
                  assert_eq!(spacing.xl % 8, 0, "XL spacing should be multiple of 8");
              }

              #[test]
              fn test_spacing_scale_is_progressive() {
                  let spacing = Spacing::default();
                  
                  assert!(spacing.xs < spacing.sm);
                  assert!(spacing.sm < spacing.md);
                  assert!(spacing.md < spacing.lg);
                  assert!(spacing.lg < spacing.xl);
              }
          }

          mod screen_reader_tests {
              use crate::ui::accessibility::AriaLabel;

              #[test]
              fn test_all_buttons_have_aria_labels() {
                  let labels = AriaLabel::collect_all_interactive_elements();
                  
                  for element in labels {
                      assert!(
                          !element.label.is_empty(),
                          "Element '{}' missing ARIA label",
                          element.id
                      );
                  }
              }

              #[test]
              fn test_icon_only_buttons_have_descriptive_labels() {
                  let icon_buttons = AriaLabel::collect_icon_buttons();
                  
                  for button in icon_buttons {
                      assert!(
                          button.label.len() > 3,
                          "Icon button has insufficient label: '{}'",
                          button.label
                      );
                      assert!(
                          !button.label.contains("icon"),
                          "Label should describe action, not 'icon': '{}'",
                          button.label
                      );
                  }
              }

              #[test]
              fn test_form_inputs_have_associated_labels() {
                  let inputs = AriaLabel::collect_form_inputs();
                  
                  for input in inputs {
                      assert!(
                          input.has_label || input.has_aria_label,
                          "Input '{}' missing label",
                          input.id
                      );
                  }
              }

              #[test]
              fn test_images_have_alt_text() {
                  let images = AriaLabel::collect_images();
                  
                  for image in images {
                      assert!(
                          !image.alt_text.is_empty(),
                          "Image '{}' missing alt text",
                          image.src
                      );
                  }
              }
          }
      }

      #[cfg(test)]
      mod property_based_accessibility_tests {
          use proptest::prelude::*;
          use crate::ui::theme::ContrastChecker;

          proptest! {
              #[test]
              fn prop_contrast_calculation_is_commutative(
                  r1 in 0.0f32..=1.0f32,
                  g1 in 0.0f32..=1.0f32,
                  b1 in 0.0f32..=1.0f32,
                  r2 in 0.0f32..=1.0f32,
                  g2 in 0.0f32..=1.0f32,
                  b2 in 0.0f32..=1.0f32,
              ) {
                  let color1 = Color::from_rgb(r1, g1, b1);
                  let color2 = Color::from_rgb(r2, g2, b2);
                  
                  let contrast_a = ContrastChecker::calculate_contrast(color1, color2);
                  let contrast_b = ContrastChecker::calculate_contrast(color2, color1);
                  
                  prop_assert!((contrast_a - contrast_b).abs() < 0.01);
              }

              #[test]
              fn prop_contrast_ratio_always_positive(
                  r1 in 0.0f32..=1.0f32,
                  g1 in 0.0f32..=1.0f32,
                  b1 in 0.0f32..=1.0f32,
                  r2 in 0.0f32..=1.0f32,
                  g2 in 0.0f32..=1.0f32,
                  b2 in 0.0f32..=1.0f32,
              ) {
                  let color1 = Color::from_rgb(r1, g1, b1);
                  let color2 = Color::from_rgb(r2, g2, b2);
                  
                  let contrast = ContrastChecker::calculate_contrast(color1, color2);
                  prop_assert!(contrast > 0.0);
              }

              #[test]
              fn prop_contrast_ratio_bounded(
                  r1 in 0.0f32..=1.0f32,
                  g1 in 0.0f32..=1.0f32,
                  b1 in 0.0f32..=1.0f32,
                  r2 in 0.0f32..=1.0f32,
                  g2 in 0.0f32..=1.0f32,
                  b2 in 0.0f32..=1.0f32,
              ) {
                  let color1 = Color::from_rgb(r1, g1, b1);
                  let color2 = Color::from_rgb(r2, g2, b2);
                  
                  let contrast = ContrastChecker::calculate_contrast(color1, color2);
                  
                  prop_assert!(contrast >= 1.0 && contrast <= 21.0);
              }

              #[test]
              fn prop_touch_target_scaling_maintains_minimum(
                  width in 48u16..200u16,
                  height in 48u16..200u16,
                  scale in 0.5f32..2.0f32,
              ) {
                  let button = Button::with_size(width, height);
                  let scaled = button.scale(scale);
                  
                  let final_size = scaled.computed_size();
                  prop_assert!(final_size.width >= 48 && final_size.height >= 48);
              }
          }
      }

  coverage:
    - "Primary text meets WCAG AA 4.5:1 contrast ratio"
    - "Secondary text meets WCAG AA 4.5:1 contrast ratio"
    - "Button text meets WCAG AA 4.5:1 contrast ratio"
    - "Error text meets WCAG AA 4.5:1 contrast ratio"
    - "Success text meets WCAG AA 4.5:1 contrast ratio"
    - "Large text meets WCAG AA 3:1 contrast ratio"
    - "Focus indicator meets WCAG 3:1 contrast ratio"
    - "All color palette values are valid RGB (0-1 range)"
    - "Primary buttons meet 48x48px minimum touch target"
    - "Icon buttons meet 48x48px minimum touch target"
    - "Quality rating buttons meet 48x48px minimum touch target"
    - "Close button meets 48x48px minimum touch target"
    - "All interactive elements validated for touch target size"
    - "Body text is at least 16px"
    - "Secondary text is at least 14px"
    - "Minimum text size is at least 12px"
    - "Heading hierarchy is logical (H1 > H2 > H3 > body)"
    - "Line height meets WCAG recommendation of 1.5"
    - "Letter spacing allows for readability"
    - "Quality shortcuts 1-5 are registered"
    - "Space key triggers next card"
    - "Escape key triggers cancel/back"
    - "Tab key cycles focus forward"
    - "Shift+Tab cycles focus backward"
    - "Enter key activates focused element"
    - "Arrow keys navigate lists"
    - "All keyboard shortcuts have descriptions"
    - "Focus border width meets 2px minimum"
    - "Focus indicator uses visible style (not hidden)"
    - "Focus indicator is distinct from default borders"
    - "Layout adapts to narrow widths (400px)"
    - "Layout adapts to wide widths (1200px)"
    - "Text wraps at narrow widths (320px)"
    - "Spacing scales appropriately with screen size"
    - "Spacing uses 8px base unit"
    - "Spacing scale is progressive (xs < sm < md < lg < xl)"
    - "All buttons have ARIA labels"
    - "Icon-only buttons have descriptive labels"
    - "Form inputs have associated labels"
    - "Images have alt text"
    - "Contrast calculation is commutative (order-independent)"
    - "Contrast ratio is always positive"
    - "Contrast ratio is bounded between 1:1 and 21:1"
    - "Touch target scaling maintains minimum size after scaling"
    - "Manual screen reader testing checklist documented"
    - "Manual keyboard-only navigation checklist documented"
    - "Manual high contrast mode testing checklist documented"
    - "Manual color blindness testing checklist documented"
    - "Manual font scaling testing checklist documented"
    - "Manual responsive layout testing checklist documented"

dependencies:
  depends_on:
    - task_id: 6
      reason: "Needs complete UI structure to polish"
    - task_id: 8
      reason: "Needs all screens implemented to apply consistency"

  depended_upon_by:
    - task_id: 14
      reason: "Final polish and testing builds on accessibility foundation"

  external:
    - name: "iced::Color"
      type: "struct"
      status: "already exists"
    - name: "iced::keyboard"
      type: "module"
      status: "already exists"
    - name: "iced::subscription"
      type: "module"
      status: "already exists"
    - name: "proptest"
      type: "crate"
      status: "to be imported"
---
task:
  id: 14
  name: "Testing, Documentation, and Release Preparation"

context:
  description: |
    This task finalizes the application for production release by implementing comprehensive
    testing infrastructure, user-facing documentation, and platform-specific distribution
    packages. It transforms a working prototype into a professional, shippable product.
    
    The testing component establishes quality assurance through multiple layers: integration
    tests validate complete workflows, property-based tests verify algorithmic correctness
    across wide input ranges, and performance benchmarks ensure the application meets
    targets (60fps animation, <100ms database operations, <200ms recognition latency).
    
    Documentation provides user-facing content covering installation, features, and
    troubleshooting, reducing support burden and enabling users to maximize application value.
    
    Release preparation includes optimized Cargo build profiles with LTO and stripping,
    plus platform-specific packaging (AppImage/deb for Linux, .app bundle for macOS,
    MSI installer for Windows). CI/CD automation ensures consistent builds and testing.
    
    This task depends on all previous tasks being complete, as it tests and packages the
    entire feature set. It represents the final step before public release, establishing
    the quality bar and distribution mechanism for the finished product.

  key_points:
    - "Achieve >80% code coverage through mixed testing strategy (unit, integration, property-based)"
    - "Integration tests use temporary databases to avoid corrupting production data"
    - "Performance benchmarks establish baseline metrics and catch regressions in critical paths"
    - "User documentation focuses on user-facing features, not technical implementation details"
    - "Release build optimizations (opt-level=3, lto=true, strip=true) minimize binary size and maximize performance"
    - "Platform-specific packaging requires appropriate tooling (cargo-bundle, AppImage tools, WiX Toolset)"
    - "CI/CD pipeline automates testing and builds, ensuring consistent quality"
    - "Test release builds on clean VMs to catch missing dependencies before user deployment"
    - "Code signing certificates required for professional macOS and Windows distribution"
    - "Property-based tests for SM-2 algorithm verify correctness across infinite input space"

files:
  - path: "tests/integration_tests.rs"
    description: "Integration tests for complete learning workflows and practice modes"
  
  - path: "tests/sm2_tests.rs"
    description: "Property-based tests for SM-2 algorithm correctness and edge cases"
  
  - path: "tests/statistics_tests.rs"
    description: "Property-based tests for statistics calculations and aggregations"
  
  - path: "tests/database_tests.rs"
    description: "Integration tests for database operations with temporary test databases"
  
  - path: "benches/animation_benchmarks.rs"
    description: "Performance benchmarks for animation rendering and frame rate"
  
  - path: "benches/database_benchmarks.rs"
    description: "Performance benchmarks for database operations and batch saves"
  
  - path: "benches/recognition_benchmarks.rs"
    description: "Performance benchmarks for character recognition latency"
  
  - path: "docs/user_manual.md"
    description: "Comprehensive user manual with Getting Started, Features, and Troubleshooting sections"
  
  - path: "docs/installation.md"
    description: "Installation instructions for all supported platforms"
  
  - path: "docs/getting_started.md"
    description: "Quick start guide for new users"
  
  - path: "docs/features.md"
    description: "Detailed feature documentation with screenshots and examples"
  
  - path: "docs/troubleshooting.md"
    description: "Common issues and their solutions"
  
  - path: "Cargo.toml"
    description: "Updated with release profile configuration and build optimization settings"
  
  - path: ".github/workflows/ci.yml"
    description: "GitHub Actions CI/CD pipeline for automated testing and builds"
  
  - path: ".github/workflows/release.yml"
    description: "GitHub Actions workflow for automated release builds and distribution"
  
  - path: "build/linux/AppImage.yml"
    description: "AppImage configuration for Linux distribution"
  
  - path: "build/linux/debian/control"
    description: "Debian package control file for .deb distribution"
  
  - path: "build/macos/Info.plist"
    description: "macOS application bundle property list configuration"
  
  - path: "build/macos/bundle.sh"
    description: "Script to create macOS .app bundle"
  
  - path: "build/windows/wix_config.wxs"
    description: "WiX Toolset configuration for Windows MSI installer"
  
  - path: "build/windows/build.bat"
    description: "Windows build script for creating MSI installer"
  
  - path: "scripts/test_coverage.sh"
    description: "Script to generate test coverage reports"
  
  - path: "scripts/build_all_platforms.sh"
    description: "Script to build release packages for all platforms"
  
  - path: "tests/test_utils.rs"
    description: "Shared utilities and helpers for integration tests"
  
  - path: "tests/fixtures/mod.rs"
    description: "Test fixtures and sample data for integration tests"

functions:
  - file: "tests/integration_tests.rs"
    items:
      - type: "module_declaration"
        name: "integration_tests"
        description: "Integration test module for end-to-end workflow testing"
      
      - type: "function"
        name: "test_complete_learning_session"
        description: "Tests a full learning session from initialization through character practice to statistics update"
        preconditions: "Temporary test database is created and accessible"
        postconditions: "Session completes successfully, statistics are persisted, cleanup occurs"
      
      - type: "function"
        name: "test_practice_mode_flow"
        description: "Tests complete practice mode workflow including character selection, recognition, and feedback"
        preconditions: "Test character database with known entries exists"
        postconditions: "Practice session completes, user responses recorded, SM-2 intervals updated"
      
      - type: "function"
        name: "test_statistics_persistence"
        description: "Verifies statistics are correctly saved and loaded across sessions"
        preconditions: "Clean database state"
        postconditions: "Statistics match expected values after save/load cycle"
      
      - type: "function"
        name: "test_animation_rendering_pipeline"
        description: "Tests complete animation rendering from data loading through frame display"
        preconditions: "Valid animation data files available"
        postconditions: "All frames render without errors, timing is accurate"
      
      - type: "function"
        name: "test_handwriting_recognition_workflow"
        description: "Tests stroke capture, normalization, and recognition against known characters"
        preconditions: "Recognition model loaded, test stroke data prepared"
        postconditions: "Recognition produces expected results within confidence thresholds"
      
      - type: "function"
        name: "test_database_migration"
        description: "Tests database schema migration from older versions"
        preconditions: "Old schema database exists"
        postconditions: "Data migrated correctly to new schema without loss"
      
      - type: "function"
        name: "test_concurrent_database_access"
        description: "Tests thread-safe database operations under concurrent access"
        preconditions: "Database connection pool configured"
        postconditions: "No data corruption, all operations complete successfully"
      
      - type: "function"
        name: "test_error_recovery_scenarios"
        description: "Tests application behavior under error conditions (missing files, corrupted data)"
        preconditions: "Error scenarios reproducible in test environment"
        postconditions: "Graceful error handling, no panics, appropriate error messages"
      
      - type: "function"
        name: "setup_test_database"
        description: "Helper function to create and populate temporary test database"
        postconditions: "Returns path to initialized test database with sample data"
      
      - type: "function"
        name: "teardown_test_database"
        description: "Helper function to clean up test database and temporary files"
        preconditions: "Test database path provided"
        postconditions: "All test artifacts removed from filesystem"
      
      - type: "function"
        name: "create_test_character_set"
        description: "Helper to create a predefined set of characters for testing"
        postconditions: "Returns vector of test characters with known properties"
      
      - type: "function"
        name: "simulate_user_input"
        description: "Helper to programmatically simulate user input events"
        postconditions: "Input events injected into test application instance"

  - file: "benches/performance_benchmarks.rs"
    items:
      - type: "module_declaration"
        name: "performance_benchmarks"
        description: "Performance benchmark suite for critical code paths"
      
      - type: "function"
        name: "bench_animation_frame_rate"
        description: "Benchmarks animation rendering to ensure 60fps target is met"
        postconditions: "Measures average frame time and reports fps metric"
      
      - type: "function"
        name: "bench_database_batch_save"
        description: "Benchmarks batch saving of character statistics to database"
        postconditions: "Measures time to save varying batch sizes (<100ms target)"
      
      - type: "function"
        name: "bench_database_query_performance"
        description: "Benchmarks common database query patterns"
        postconditions: "Reports query execution times for optimization analysis"
      
      - type: "function"
        name: "bench_handwriting_recognition"
        description: "Benchmarks stroke recognition latency"
        postconditions: "Measures recognition time for various stroke complexities"
      
      - type: "function"
        name: "bench_stroke_normalization"
        description: "Benchmarks stroke preprocessing and normalization"
        postconditions: "Reports normalization overhead for performance profiling"
      
      - type: "function"
        name: "bench_sm2_algorithm"
        description: "Benchmarks SM-2 spaced repetition calculations"
        postconditions: "Measures calculation time for large character sets"
      
      - type: "function"
        name: "bench_ui_rendering"
        description: "Benchmarks UI rendering performance under various loads"
        postconditions: "Reports frame times and identifies rendering bottlenecks"
      
      - type: "function"
        name: "criterion_configuration"
        description: "Configures Criterion benchmark runner with appropriate settings"
        postconditions: "Returns configured Criterion instance"

  - file: "tests/property_tests.rs"
    items:
      - type: "module_declaration"
        name: "property_tests"
        description: "Property-based tests using proptest for algorithmic correctness"
      
      - type: "function"
        name: "prop_sm2_intervals_monotonic"
        description: "Property test: SM-2 intervals increase with quality >= 3, decrease with quality < 3"
        invariants: "For quality >= 3, new_interval >= old_interval; for quality < 3, new_interval < old_interval"
      
      - type: "function"
        name: "prop_sm2_easiness_bounds"
        description: "Property test: SM-2 easiness factor remains within valid bounds (1.3 to 2.5)"
        invariants: "1.3 <= easiness_factor <= 2.5 for all valid inputs"
      
      - type: "function"
        name: "prop_statistics_consistency"
        description: "Property test: Statistics calculations are consistent (seen + unseen = total)"
        invariants: "Sum of character states equals total character count"
      
      - type: "function"
        name: "prop_stroke_normalization_preserves_shape"
        description: "Property test: Normalized strokes preserve relative point relationships"
        invariants: "Point ordering preserved, shape topology unchanged"
      
      - type: "function"
        name: "prop_database_roundtrip"
        description: "Property test: Data serialization/deserialization is lossless"
        invariants: "serialize(deserialize(x)) == x for all valid data"
      
      - type: "function"
        name: "prop_animation_timing_accuracy"
        description: "Property test: Animation timing calculations are accurate within tolerance"
        invariants: "Calculated frame times within 5% of expected values"
      
      - type: "function"
        name: "prop_character_selection_fairness"
        description: "Property test: Character selection algorithm provides fair distribution"
        invariants: "Over large sample, selection distribution matches expected probabilities"

  - file: "src/testing_utils.rs"
    items:
      - type: "module_declaration"
        name: "testing_utils"
        description: "Utility functions and helpers for testing infrastructure"
      
      - type: "struct"
        name: "TestEnvironment"
        description: "Encapsulates a complete test environment with database, config, and temporary directories"
      
      - type: "method"
        name: "TestEnvironment::new"
        description: "Creates a new isolated test environment"
        postconditions: "Returns fully initialized test environment with temporary resources"
      
      - type: "method"
        name: "TestEnvironment::cleanup"
        description: "Cleans up test environment and releases resources"
        postconditions: "All temporary files and database connections closed and removed"
      
      - type: "struct"
        name: "MockRecognitionModel"
        description: "Mock implementation of recognition model for testing"
      
      - type: "trait_impl"
        name: "RecognitionModel for MockRecognitionModel"
        description: "Implements recognition model trait with predictable test behavior"
      
      - type: "struct"
        name: "TestCharacterGenerator"
        description: "Generates test character data with configurable properties"
      
      - type: "method"
        name: "TestCharacterGenerator::generate_set"
        description: "Generates a set of test characters with specified characteristics"
        postconditions: "Returns vector of characters matching generation parameters"
      
      - type: "function"
        name: "create_temp_database"
        description: "Creates a temporary SQLite database for testing"
        postconditions: "Returns path to initialized temporary database"
      
      - type: "function"
        name: "assert_statistics_equal"
        description: "Custom assertion for comparing statistics structures with tolerance"
      
      - type: "function"
        name: "load_test_animation_data"
        description: "Loads canned animation data for testing"
        postconditions: "Returns parsed animation data structure"

  - file: "Cargo.toml"
    items:
      - type: "constant"
        name: "[profile.release]"
        description: "Release build profile with optimizations for production"
      
      - type: "constant"
        name: "opt-level"
        description: "Optimization level set to 3 for maximum performance"
      
      - type: "constant"
        name: "lto"
        description: "Link-time optimization enabled for smaller binaries and better performance"
      
      - type: "constant"
        name: "strip"
        description: "Strip symbols from binary for smaller distribution size"
      
      - type: "constant"
        name: "codegen-units"
        description: "Single codegen unit for better optimization at cost of compile time"
      
      - type: "constant"
        name: "[dev-dependencies]"
        description: "Development and testing dependencies"
      
      - type: "constant"
        name: "criterion"
        description: "Benchmarking framework dependency"
      
      - type: "constant"
        name: "proptest"
        description: "Property-based testing framework dependency"
      
      - type: "constant"
        name: "tempfile"
        description: "Temporary file management for tests"

  - file: "build_scripts/build_release.sh"
    items:
      - type: "function"
        name: "build_linux_release"
        description: "Builds optimized Linux release binary and creates AppImage package"
        preconditions: "Rust toolchain installed, AppImage tools available"
        postconditions: "AppImage created in dist/ directory"
      
      - type: "function"
        name: "build_macos_release"
        description: "Builds macOS app bundle with proper structure and signing"
        preconditions: "macOS environment, code signing certificate available"
        postconditions: "Signed .app bundle created in dist/ directory"
      
      - type: "function"
        name: "build_windows_release"
        description: "Builds Windows executable and creates MSI installer"
        preconditions: "Cross-compilation setup or Windows environment, WiX toolset"
        postconditions: "Signed MSI installer created in dist/ directory"
      
      - type: "function"
        name: "verify_build"
        description: "Runs basic smoke tests on release builds"
        preconditions: "Release binary exists"
        postconditions: "Returns 0 on success, non-zero on failure"
      
      - type: "function"
        name: "package_distribution"
        description: "Creates distribution archives with documentation and assets"
        postconditions: "tar.gz/zip archives created with all distribution files"

  - file: ".github/workflows/ci.yml"
    items:
      - type: "constant"
        name: "test_workflow"
        description: "GitHub Actions workflow for automated testing on push/PR"
      
      - type: "constant"
        name: "build_workflow"
        description: "GitHub Actions workflow for building release artifacts"
      
      - type: "constant"
        name: "benchmark_workflow"
        description: "GitHub Actions workflow for running performance benchmarks"

  - file: "docs/user_manual/getting_started.md"
    items:
      - type: "constant"
        name: "installation_instructions"
        description: "Step-by-step installation guide for each platform"
      
      - type: "constant"
        name: "first_launch_guide"
        description: "Walkthrough of first application launch and setup"
      
      - type: "constant"
        name: "basic_workflow_tutorial"
        description: "Tutorial covering basic learning workflow"

  - file: "docs/user_manual/features.md"
    items:
      - type: "constant"
        name: "learning_mode_documentation"
        description: "Comprehensive documentation of learning mode features"
      
      - type: "constant"
        name: "practice_mode_documentation"
        description: "Documentation of practice mode and spaced repetition"
      
      - type: "constant"
        name: "handwriting_recognition_guide"
        description: "Guide to using handwriting recognition effectively"
      
      - type: "constant"
        name: "statistics_documentation"
        description: "Explanation of statistics and progress tracking"
      
      - type: "constant"
        name: "customization_options"
        description: "Documentation of configuration and customization options"

  - file: "docs/user_manual/troubleshooting.md"
    items:
      - type: "constant"
        name: "common_issues"
        description: "List of common issues and solutions"
      
      - type: "constant"
        name: "performance_tips"
        description: "Tips for optimizing performance"
      
      - type: "constant"
        name: "faq"
        description: "Frequently asked questions and answers"
      
      - type: "constant"
        name: "support_resources"
        description: "Links to additional support resources"

  - file: "packaging/linux/AppImage.yml"
    items:
      - type: "constant"
        name: "appimage_config"
        description: "AppImage configuration for Linux distribution"

  - file: "packaging/macos/Info.plist"
    items:
      - type: "constant"
        name: "bundle_configuration"
        description: "macOS app bundle configuration and metadata"

  - file: "packaging/windows/installer.wxs"
    items:
      - type: "constant"
        name: "wix_installer_config"
        description: "WiX toolset configuration for Windows MSI installer"

  - file: "scripts/test_on_vm.sh"
    items:
      - type: "function"
        name: "test_linux_vm"
        description: "Deploys and tests release build on clean Linux VM"
        preconditions: "VM available, SSH access configured"
        postconditions: "Returns test results, logs saved"
      
      - type: "function"
        name: "test_macos_vm"
        description: "Deploys and tests release build on clean macOS VM"
        preconditions: "macOS VM available"
        postconditions: "Returns test results, logs saved"
      
      - type: "function"
        name: "test_windows_vm"
        description: "Deploys and tests release build on clean Windows VM"
        preconditions: "Windows VM available"
        postconditions: "Returns test results, logs saved"

  - file: "tests/smoke_tests.rs"
    items:
      - type: "function"
        name: "test_application_launches"
        description: "Smoke test verifying application launches without crashing"
        postconditions: "Application starts and exits cleanly"
      
      - type: "function"
        name: "test_database_initialization"
        description: "Smoke test for database initialization on first launch"
        postconditions: "Database created with proper schema"
      
      - type: "function"
        name: "test_basic_navigation"
        description: "Smoke test for basic UI navigation"
        postconditions: "All major screens accessible"
      
      - type: "function"
        name: "test_critical_features"
        description: "Smoke test for critical user-facing features"
        postconditions: "Core functionality works without errors"

  - file: "src/test_coverage.rs"
    items:
      - type: "function"
        name: "generate_coverage_report"
        description: "Generates code coverage report using tarpaulin or similar tool"
        postconditions: "Coverage report generated in reports/ directory"
      
      - type: "function"
        name: "check_coverage_threshold"
        description: "Verifies code coverage meets 80% threshold"
        postconditions: "Returns success if threshold met, failure otherwise"

formal_verification:
  needed: false
  level: "None"
  explanation: |
    Formal verification is not needed for this task. This is a meta-task focused on
    testing infrastructure, documentation, and release engineering rather than implementing
    critical algorithms or safety-critical code paths.
    
    The task's primary purpose is quality assurance through conventional testing methods
    (unit tests, integration tests, property-based tests) rather than formal proof of
    correctness. The components being added are:
    
    1. Test suites - These verify other code but don't require verification themselves
    2. Documentation - User-facing content that cannot be formally verified
    3. Build configurations - Declarative settings that don't contain logic
    4. Distribution packages - Packaging scripts and metadata
    
    The property-based tests mentioned in the task (for SM-2 algorithm and statistics)
    provide probabilistic verification of properties across large input spaces, which is
    appropriate for those domains. However, these property tests are part of the task
    deliverables, not subjects requiring formal verification.
    
    Performance benchmarks establish empirical baselines rather than formal guarantees,
    and CI/CD pipeline configuration is declarative infrastructure code.
    
    All critical algorithms (SM-2, recognition, animation) were implemented in previous
    tasks where formal verification decisions were already made. This task only tests
    and packages existing functionality.
    
    The risk assessment indicates low testing risk and medium complexity risk primarily
    around platform-specific packaging concerns, which are operational issues rather
    than correctness concerns amenable to formal methods.

tests:
  strategy:
    approach: "mixed"
    rationale:
      - "Integration tests validate end-to-end workflows including learning sessions, practice modes, and data persistence"
      - "Property-based tests ensure SM-2 algorithm correctness and statistical calculations across wide input ranges"
      - "Unit tests verify individual components like animation rendering, database operations, and recognition handling"
      - "Performance benchmarks establish baseline metrics for animation frame rates, database batch operations, and recognition latency"
      - "Manual testing on clean VMs validates distribution packages and platform-specific behavior"
      - "Mixed approach provides comprehensive coverage for production readiness with >80% code coverage target"

  implementation:
    file: "tests/integration_tests.rs"
    location: "create new"
    code: |
      #[cfg(test)]
      mod integration_tests {
          use tempfile::TempDir;
          use std::path::PathBuf;
          use std::time::Duration;
          
          fn setup_test_env() -> (TempDir, PathBuf) {
              let temp_dir = TempDir::new().unwrap();
              let db_path = temp_dir.path().join("test.db");
              (temp_dir, db_path)
          }
          
          #[test]
          fn test_complete_learning_session() {
              let (_temp, db_path) = setup_test_env();
          }
          
          #[test]
          fn test_practice_session_with_recognition() {
              let (_temp, db_path) = setup_test_env();
          }
          
          #[test]
          fn test_practice_session_with_typing() {
              let (_temp, db_path) = setup_test_env();
          }
          
          #[test]
          fn test_mixed_character_sets() {
              let (_temp, db_path) = setup_test_env();
          }
          
          #[test]
          fn test_statistics_tracking() {
              let (_temp, db_path) = setup_test_env();
          }
          
          #[test]
          fn test_animation_state_transitions() {
          }
          
          #[test]
          fn test_database_concurrent_access() {
              use std::thread;
              use std::sync::Arc;
              
              let (_temp, db_path) = setup_test_env();
          }
          
          #[test]
          fn test_data_persistence_across_restarts() {
              let (_temp, db_path) = setup_test_env();
          }
          
          #[test]
          fn test_error_recovery() {
              let (_temp, db_path) = setup_test_env();
          }
          
          #[test]
          fn test_settings_persistence() {
              let (_temp, db_path) = setup_test_env();
          }
      }
      
      #[cfg(test)]
      mod property_tests {
          use proptest::prelude::*;
          
          proptest! {
              #[test]
              fn prop_sm2_interval_increases_with_quality(
                  easiness in 1.3f32..2.5f32,
                  interval in 1u32..100u32,
                  quality in 3u8..5u8
              ) {
              }
              
              #[test]
              fn prop_sm2_interval_decreases_with_poor_quality(
                  easiness in 1.3f32..2.5f32,
                  interval in 2u32..100u32,
                  quality in 0u8..3u8
              ) {
              }
              
              #[test]
              fn prop_sm2_easiness_bounded(
                  easiness in 1.3f32..2.5f32,
                  interval in 1u32..100u32,
                  quality in 0u8..5u8
              ) {
              }
              
              #[test]
              fn prop_statistics_accuracy_in_range(
                  correct in 0u32..1000u32,
                  total in 1u32..1000u32
              ) {
              }
              
              #[test]
              fn prop_recognition_confidence_normalized(
                  raw_score in -100.0f32..100.0f32
              ) {
              }
              
              #[test]
              fn prop_stroke_validation(
                  points in proptest::collection::vec((0.0f32..1.0f32, 0.0f32..1.0f32), 2..100)
              ) {
              }
              
              #[test]
              fn prop_character_filter_subset(
                  learned in proptest::collection::hash_set(0u32..100u32, 0..100),
                  filter_type in prop::sample::select(vec!["all", "learned", "unlearned"])
              ) {
              }
          }
      }

  coverage:
    - "Complete learning session workflow from initialization to completion"
    - "Practice session with drawing recognition including stroke capture and evaluation"
    - "Practice session with typing input and answer validation"
    - "Mixed character set learning and practice with filters"
    - "Statistics tracking including accuracy, reviews, and streak calculations"
    - "Animation state machine transitions through all states"
    - "Database concurrent access from multiple threads"
    - "Data persistence across application restarts"
    - "Error recovery and graceful handling of invalid inputs"
    - "User settings persistence and retrieval"
    - "SM-2 algorithm interval increases with high quality scores"
    - "SM-2 algorithm interval decreases with poor quality scores"
    - "SM-2 easiness factor remains within valid bounds"
    - "Statistics accuracy calculation returns values in valid range"
    - "Recognition confidence scores are properly normalized"
    - "Stroke validation ensures all strokes have valid properties"
    - "Character filtering produces correct subsets"
    - "Animation maintains 60fps frame rate under load"
    - "Database batch operations complete within 100ms"
    - "Recognition latency stays below 200ms"
    - "Platform-specific package installation on clean VMs"

dependencies:
  depends_on:
    - task_id: 1
      reason: "All features must be implemented before final testing"
    - task_id: 2
      reason: "All features must be implemented before final testing"
    - task_id: 3
      reason: "All features must be implemented before final testing"
    - task_id: 4
      reason: "All features must be implemented before final testing"
    - task_id: 5
      reason: "All features must be implemented before final testing"
    - task_id: 6
      reason: "All features must be implemented before final testing"
    - task_id: 7
      reason: "All features must be implemented before final testing"
    - task_id: 8
      reason: "All features must be implemented before final testing"
    - task_id: 9
      reason: "All features must be implemented before final testing"
    - task_id: 10
      reason: "All features must be implemented before final testing"
    - task_id: 11
      reason: "All features must be implemented before final testing"
    - task_id: 12
      reason: "All features must be implemented before final testing"
    - task_id: 13
      reason: "All features must be implemented before final testing"

  depended_upon_by: []

  external:
    - name: "tempfile"
      type: "crate"
      status: "to be imported"
    - name: "proptest"
      type: "crate"
      status: "to be imported"
    - name: "criterion"
      type: "crate"
      status: "to be imported"
task:
  id: 1
  name: "Project Structure and Application Foundation"

context:
  description: |
    This foundational task establishes the complete Rust project structure for a Chinese character
    spaced repetition application using the iced GUI framework. It creates the architectural skeleton
    that all subsequent features will build upon, implementing a modular design that separates concerns
    across UI rendering, state management, data models, persistence, and scheduling logic.
    
    The task sets up the iced framework (version 0.13) with proper feature flags for canvas rendering,
    tokio async runtime, and advanced GUI capabilities. It implements the Elm architecture pattern
    through iced's Application trait, establishing the Message -> Update -> View cycle that will drive
    all UI interactions.
    
    A well-organized module structure is critical for maintainability and parallel development. By
    separating concerns into discrete modules (state/, ui/, models/, persistence/, scheduler/, data/),
    we enable different features to be developed independently while maintaining clear boundaries and
    interfaces between components.
    
    The project also configures cross-platform support from the start, using the directories crate for
    platform-specific data path detection and embedding fonts via include_bytes!() for portability.
    Release build optimizations are configured in Cargo.toml to ensure production builds are optimized
    for size and performance.

  key_points:
    - "Implements iced 0.13 with Elm architecture pattern for predictable state management"
    - "Modular structure enables parallel development of features with clear separation of concerns"
    - "Cross-platform support through directories crate and embedded font assets"
    - "Foundation for all future tasks - all components depend on this structure"
    - "Minimal viable implementation with placeholder methods to establish compilation baseline"
    - "Release build optimizations configured early to avoid performance surprises"

files:
  - path: "Cargo.toml"
    description: "Project manifest defining dependencies, metadata, and build configuration"
  
  - path: "src/main.rs"
    description: "Application entry point implementing iced::Application trait and main function"
  
  - path: "src/lib.rs"
    description: "Library root exposing public modules for internal and test access"
  
  - path: "src/state/mod.rs"
    description: "State management module declaration and exports"
  
  - path: "src/ui/mod.rs"
    description: "UI components module declaration and exports"
  
  - path: "src/models/mod.rs"
    description: "Data models module declaration and exports"
  
  - path: "src/persistence/mod.rs"
    description: "Data persistence module declaration and exports"
  
  - path: "src/scheduler/mod.rs"
    description: "Scheduling logic module declaration and exports"
  
  - path: "src/data/mod.rs"
    description: "Data handling utilities module declaration and exports"
  
  - path: "tests/integration_test.rs"
    description: "Integration tests for structural verification and smoke tests"
  
  - path: ".gitignore"
    description: "Git ignore file for Rust projects"

functions:
  - file: "src/main.rs"
    items:
      - type: "function"
        name: "main"
        description: "Application entry point that configures and launches the iced application"
        preconditions: "None"
        postconditions: "Application window is created and event loop is started, or error is returned"
        invariants: "Must call iced::application() with proper settings and run the SpacedRepApp"
      
      - type: "struct"
        name: "SpacedRepApp"
        description: "Main application struct implementing iced::Application trait, holds application state"
        preconditions: "None"
        postconditions: "Instance ready to be run by iced runtime"
        invariants: "Maintains application state throughout lifecycle"
      
      - type: "trait_impl"
        name: "impl iced::Application for SpacedRepApp"
        description: "Implementation of iced Application trait providing update, view, and lifecycle methods"
        preconditions: "SpacedRepApp struct exists"
        postconditions: "SpacedRepApp can be used as an iced application"
        invariants: "Follows Elm architecture pattern: Message -> Update -> View cycle"
      
      - type: "enum"
        name: "Message"
        description: "Application-wide message type for event handling in the Elm architecture"
        preconditions: "None"
        postconditions: "Provides type-safe message passing for UI events"
        invariants: "Must implement Send + Sync for iced compatibility"
      
      - type: "method"
        name: "SpacedRepApp::new"
        description: "Creates new instance of SpacedRepApp with default/initial state"
        preconditions: "None"
        postconditions: "Returns initialized SpacedRepApp instance"
        invariants: "Always succeeds with valid initial state"
      
      - type: "method"
        name: "SpacedRepApp::title"
        description: "Returns window title string for the application"
        preconditions: "None"
        postconditions: "Returns static string for window title"
        invariants: "Always returns same title string"
      
      - type: "method"
        name: "SpacedRepApp::update"
        description: "Handles Message events and updates application state"
        preconditions: "Valid Message variant"
        postconditions: "Application state updated according to message, Command returned"
        invariants: "Pure function for given state and message"
      
      - type: "method"
        name: "SpacedRepApp::view"
        description: "Renders current application state to iced Element tree"
        preconditions: "Valid application state"
        postconditions: "Returns Element tree representing current UI"
        invariants: "Pure function - same state produces same view"

  - file: "src/lib.rs"
    items:
      - type: "module_declaration"
        name: "pub mod state"
        description: "Public module declaration exposing state module"
        preconditions: "src/state/mod.rs exists"
        postconditions: "state module accessible from library root"
      
      - type: "module_declaration"
        name: "pub mod ui"
        description: "Public module declaration exposing ui module"
        preconditions: "src/ui/mod.rs exists"
        postconditions: "ui module accessible from library root"
      
      - type: "module_declaration"
        name: "pub mod models"
        description: "Public module declaration exposing models module"
        preconditions: "src/models/mod.rs exists"
        postconditions: "models module accessible from library root"
      
      - type: "module_declaration"
        name: "pub mod persistence"
        description: "Public module declaration exposing persistence module"
        preconditions: "src/persistence/mod.rs exists"
        postconditions: "persistence module accessible from library root"
      
      - type: "module_declaration"
        name: "pub mod scheduler"
        description: "Public module declaration exposing scheduler module"
        preconditions: "src/scheduler/mod.rs exists"
        postconditions: "scheduler module accessible from library root"
      
      - type: "module_declaration"
        name: "pub mod data"
        description: "Public module declaration exposing data module"
        preconditions: "src/data/mod.rs exists"
        postconditions: "data module accessible from library root"

  - file: "src/state/mod.rs"
    items:
      - type: "module_declaration"
        name: "state"
        description: "Module for application state management and state transitions"
        preconditions: "None"
        postconditions: "Exports state-related types and functions"
        invariants: "Encapsulates all state management logic"

  - file: "src/ui/mod.rs"
    items:
      - type: "module_declaration"
        name: "ui"
        description: "Module for UI components, widgets, and view rendering logic"
        preconditions: "None"
        postconditions: "Exports UI components and helper functions"
        invariants: "Contains only view layer logic, no business logic"

  - file: "src/models/mod.rs"
    items:
      - type: "module_declaration"
        name: "models"
        description: "Module for data models including Character, Deck, Review structures"
        preconditions: "None"
        postconditions: "Exports core data structures"
        invariants: "Contains only data definitions and associated methods"

  - file: "src/persistence/mod.rs"
    items:
      - type: "module_declaration"
        name: "persistence"
        description: "Module for data persistence, serialization, and file I/O operations"
        preconditions: "None"
        postconditions: "Exports persistence functions and types"
        invariants: "Handles all file system operations in isolated module"

  - file: "src/scheduler/mod.rs"
    items:
      - type: "module_declaration"
        name: "scheduler"
        description: "Module for spaced repetition scheduling algorithms (FSRS/SM-2)"
        preconditions: "None"
        postconditions: "Exports scheduling logic and types"
        invariants: "Contains algorithm implementations separate from UI and data"

  - file: "src/data/mod.rs"
    items:
      - type: "module_declaration"
        name: "data"
        description: "Module for embedded character data, HSK levels, and example sentences"
        preconditions: "None"
        postconditions: "Exports character datasets and lookup functions"
        invariants: "Provides read-only access to embedded character data"

  - file: "Cargo.toml"
    items:
      - type: "constant"
        name: "[package] section"
        description: "Project metadata including name, version, edition, and authors"
        preconditions: "Valid TOML syntax"
        postconditions: "Package metadata configured for cargo build"
        invariants: "name = 'hanzi-spaced-rep', edition = '2021'"
      
      - type: "constant"
        name: "[dependencies.iced] section"
        description: "iced GUI framework dependency with version 0.13 and required features"
        preconditions: "None"
        postconditions: "iced available with canvas, tokio, advanced features enabled"
        invariants: "version = '0.13', features include canvas, tokio, advanced"
      
      - type: "constant"
        name: "[dependencies.serde] section"
        description: "Serialization framework with derive macro support"
        preconditions: "None"
        postconditions: "serde available for data serialization"
        invariants: "derive feature enabled"
      
      - type: "constant"
        name: "[dependencies.serde_json] section"
        description: "JSON serialization support for serde"
        preconditions: "None"
        postconditions: "JSON persistence capability available"
        invariants: "Compatible with serde version"
      
      - type: "constant"
        name: "[dependencies.directories] section"
        description: "Cross-platform user directory path detection"
        preconditions: "None"
        postconditions: "Platform-specific data directory paths available"
        invariants: "Provides XDG/AppData directory support"
      
      - type: "constant"
        name: "[dependencies.time] section"
        description: "Date and time handling for review scheduling"
        preconditions: "None"
        postconditions: "Time manipulation and formatting available"
        invariants: "Provides UTC and local time support"
      
      - type: "constant"
        name: "[profile.release] section"
        description: "Release build optimization settings"
        preconditions: "Valid TOML syntax"
        postconditions: "Optimized release builds with smaller binary size"
        invariants: "opt-level = 3 or 'z', lto enabled for production builds"

formal_verification:
  needed: false
  level: "None"
  explanation: |
    Formal verification is not needed for this foundational scaffolding task because:
    
    1. No Complex Logic: The task involves creating project structure, module stubs,
       and a minimal "Hello World" iced application. There are no algorithms, state
       transitions, or invariants that require mathematical proof.
    
    2. No Safety-Critical Behavior: This is purely structural code - organizing
       directories, creating empty module files, and implementing a trivial
       Application trait with placeholder methods. No data corruption, memory safety
       issues, or concurrency concerns exist at this stage.
    
    3. Compilation as Verification: The primary correctness criteria (project compiles,
       window opens) are verified by the Rust compiler and runtime behavior. If the
       structure is incorrect, the code won't compile.
    
    4. No Stateful Invariants: The task creates stateless scaffolding. There are no
       complex state machines, resource management patterns, or concurrent operations
       that would benefit from formal property verification.
    
    5. Low Risk Profile: The task is marked as "simple" complexity with "low" risk
       across all categories. The acceptance criteria are straightforward (build
       succeeds, window displays) and easily validated through basic testing.
    
    Standard unit testing (cargo build, smoke tests) is sufficient to verify the
    structural correctness of this foundation task. Formal verification would add
    unnecessary overhead with no meaningful safety or correctness benefits.

tests:
  strategy:
    approach: "unit tests with integration smoke test"
    rationale:
      - "Primary focus is on structural correctness - verifying project compiles and modules are properly organized"
      - "Unit tests validate module system integrity and basic type definitions"
      - "Integration smoke test confirms the iced application can initialize and would render"
      - "No complex business logic at this stage, so extensive property-based testing is unnecessary"
      - "Tests establish foundation for future test infrastructure"

  implementation:
    file: "src/lib.rs and tests/integration_test.rs"
    location: "create new"
    code: |
      // In src/lib.rs - Add at the bottom after module declarations
      #[cfg(test)]
      mod tests {
          use super::*;

          #[test]
          fn test_module_structure_exists() {
              // Verify all core modules are accessible
              // This test ensures the module tree is properly structured
              
              // These imports will fail to compile if modules aren't properly declared
              let _ = std::any::type_name::<state::State>();
              let _ = std::any::type_name::<models::character::Character>();
          }

          #[test]
          fn test_application_struct_exists() {
              // Verify the main application struct is defined and implements requiredtraits
              // This is a compile-time check that the Application trait is properly implemented
              
              fn assert_application<T: iced::Application>() {}
              assert_application::<crate::SpacedRepApp>();
          }

          #[test]
          fn test_message_enum_exhaustive() {
              // Verify Message enum can be instantiated (basic sanity check)
              
              use crate::Message;
              
              let _msg = Message::default();
              
              // Ensure Message is Send + Sync for iced requirements
              fn assert_send_sync<T: Send + Sync>() {}
              assert_send_sync::<Message>();
          }
      }

      // In tests/integration_test.rs - Create new file
      #[cfg(test)]
      mod integration_tests {
          use hanzi_spaced_rep::*;

          #[test]
          fn test_application_initialization() {
              // Test that the application can be initialized without panicking
              
              let settings = iced::Settings {
                  window: iced::window::Settings {
                      size: (800, 600),
                      ..Default::default()
                  },
                  ..Default::default()
              };

              assert_eq!(settings.window.size.0, 800);
              assert_eq!(settings.window.size.1, 600);
          }

          #[test]
          fn test_cargo_dependencies_available() {
              // Verify key dependencies are accessible
              
              let _ = iced::Color::BLACK;
              let _ = time::OffsetDateTime::now_utc();
              
              use serde::{Serialize, Deserialize};
              
              #[derive(Serialize, Deserialize, Debug, PartialEq)]
              struct TestStruct {
                  value: i32,
              }
              
              let test = TestStruct { value: 42 };
              let json = serde_json::to_string(&test).unwrap();
              let deserialized: TestStruct = serde_json::from_str(&json).unwrap();
              assert_eq!(test.value, deserialized.value);
          }

          #[test]
          fn test_module_visibility() {
              // Verify public modules are accessible from outside the crate
              
              let _state_ref: Option<&state::State> = None;
              let _char_ref: Option<&models::character::Character> = None;
          }

          #[test]
          fn test_default_state_creation() {
              // Test that the default state can be created
              
              let state = state::State::default();
              
              assert!(state.characters.is_empty());
          }

          #[test]
          fn test_embedded_fonts_accessible() {
              // Verify fonts are embedded and accessible
              
              const FONT_DATA: &[u8] = include_bytes!("../assets/fonts/NotoSans-Regular.ttf");
              
              assert!(!FONT_DATA.is_empty(), "Font data should be embedded");
              
              assert_eq!(&FONT_DATA[0..4], &[0x00, 0x01, 0x00, 0x00], 
                         "Font should have valid TTF header");
          }

          #[test]
          fn test_cross_platform_data_directory() {
              // Test that directories crate can resolve data paths
              
              use directories::ProjectDirs;
              
              let proj_dirs = ProjectDirs::from("com", "organization", "hanzi-spaced-rep");
              assert!(proj_dirs.is_some(), "Should be able to determine project directories");
              
              if let Some(dirs) = proj_dirs {
                  let data_dir = dirs.data_dir();
                  assert!(data_dir.to_string_lossy().len() > 0, "Data directory path should not be empty");
              }
          }
      }

      // In src/main.rs - Add minimal test at bottom
      #[cfg(test)]
      mod main_tests {
          #[test]
          fn test_main_compiles() {
              assert!(true);
          }
      }

  coverage:
    - "Project compiles without errors"
    - "All module declarations are accessible and properly structured"
    - "Application struct exists and implements iced::Application trait"
    - "Message enum is properly defined and meets iced requirements (Send + Sync)"
    - "Cargo.toml dependencies are available (iced, time, serde, directories)"
    - "Serde serialization/deserialization works for basic structures"
    - "Default State can be instantiated"
    - "Embedded font assets are accessible via include_bytes!()"
    - "Font data has valid TTF format header"
    - "Cross-platform data directory resolution works via directories crate"
    - "Module visibility is correctly configured (public modules exposed)"
    - "iced Settings can be created with window configuration"
    - "Application initialization parameters are valid"

dependencies:
  depends_on: []

  depended_upon_by:
    - task_id: 2
      reason: "Character data structures need module structure to exist"
    - task_id: 3
      reason: "Font loading requires application foundation"
    - task_id: 6
      reason: "State management builds on application structure"

  external:
    - name: "iced"
      type: "crate"
      status: "to be imported"
    - name: "serde"
      type: "crate"
      status: "to be imported"
    - name: "serde_json"
      type: "crate"
      status: "to be imported"
    - name: "time"
      type: "crate"
      status: "to be imported"
    - name: "directories"
      type: "crate"
      status: "to be imported"
---
task:
  id: 2
  name: "Character Data Structures and Loading System"

context:
  description: |
    This task establishes the foundational data layer for the Japanese kana learning application
    by defining core data structures to represent hiragana and katakana characters and implementing
    an efficient character database system. Each character is represented with complete metadata
    including Unicode values, romanization mappings, stroke-by-stroke SVG path data for animations,
    and frequency rankings for intelligent presentation ordering.
    
    The character database serves as the single source of truth for all 92 basic kana characters
    (46 hiragana + 46 katakana) and powers critical application features including flashcard
    generation, stroke-order animations, handwriting recognition, and spaced repetition scheduling.
    
    The implementation uses compile-time perfect hash maps (phf) for zero-cost O(1) lookups,
    with character data serialized in RON (Rusty Object Notation) format for human readability
    and maintainability. RON files are embedded directly into the binary at compile time using
    include_str!(), eliminating runtime I/O overhead while preserving the ability to update
    character data by editing text files.
    
    This architectural choice balances performance (compile-time initialization, zero runtime cost),
    maintainability (human-readable data files), and correctness (static data validated at build time).

  key_points:
    - "RON format enables human-readable character data that can be version-controlled and easily updated"
    - "phf crate provides compile-time perfect hashing for O(1) lookups with zero runtime initialization cost"
    - "SVG path strings stored as-is enable lazy parsing only when animation is needed, reducing memory footprint"
    - "Frequency ranking metadata enables pedagogically-sound character ordering (teach common characters first)"
    - "Separation of hiragana and katakana datasets mirrors pedagogical practice of learning scripts separately"
    - "Character data is immutable after initialization, eliminating synchronization concerns"
    - "Stroke count validation ensures animation system receives well-formed data"
    - "Unicode representation enables seamless integration with font rendering and text input systems"

files:
  - path: "src/models/character.rs"
    description: "Defines the CharData struct and associated types for representing kana characters with stroke data, Unicode values, romanization, and metadata"
  
  - path: "src/models/stroke.rs"
    description: "Defines stroke-related data structures including StrokePath, Point, and stroke direction information used by CharData"
  
  - path: "src/data/hiragana.ron"
    description: "RON-serialized database of all 46 hiragana characters with complete stroke path data, romanization, and metadata"
  
  - path: "src/data/katakana.ron"
    description: "RON-serialized database of all 46 katakana characters with complete stroke path data, romanization, and metadata"
  
  - path: "src/db/character_db.rs"
    description: "Character database module implementing compile-time phf::Map for O(1) lookups of CharData by character or romanization"
  
  - path: "src/db/mod.rs"
    description: "Database module declaration exposing character_db and lookup functions"
  
  - path: "src/utils/svg_parser.rs"
    description: "SVG path parsing utilities to convert SVG path strings into internal stroke representation for animation"
  
  - path: "Cargo.toml"
    description: "Updated to add dependencies: phf, serde, ron for character database and serialization"

functions:
  - file: "src/models/character.rs"
    items:
      - type: "struct"
        name: "CharData"
        description: "Core data structure representing a single kana character with Unicode value, romanization, stroke paths, and metadata"
        invariants: "stroke_count matches number of elements in stroke_paths; unicode is valid Japanese kana codepoint"
      
      - type: "struct"
        name: "StrokePath"
        description: "Represents a single stroke as an SVG path string with optional median point for direction visualization"
        invariants: "svg_path is non-empty; median_point if present is within path bounds"
      
      - type: "enum"
        name: "KanaType"
        description: "Discriminates between hiragana and katakana character types"
      
      - type: "trait_impl"
        name: "impl Serialize for CharData"
        description: "Serde serialization implementation for CharData to enable RON format export"
      
      - type: "trait_impl"
        name: "impl Deserialize for CharData"
        description: "Serde deserialization implementation for CharData to enable RON format loading"

  - file: "src/data/mod.rs"
    items:
      - type: "module_declaration"
        name: "pub mod character_db"
        description: "Module containing character database functionality"
      
      - type: "constant"
        name: "HIRAGANA_DATA"
        description: "Compile-time embedded hiragana character data from RON file using include_str!()"
        postconditions: "Contains valid RON string with 46 hiragana characters"
      
      - type: "constant"
        name: "KATAKANA_DATA"
        description: "Compile-time embedded katakana character data from RON file using include_str!()"
        postconditions: "Contains valid RON string with 46 katakana characters"
      
      - type: "function"
        name: "init_character_db"
        description: "Initializes the character database by parsing RON data and building phf::Map or HashMap"
        preconditions: "HIRAGANA_DATA and KATAKANA_DATA are valid RON strings"
        postconditions: "Returns Map containing all 92 kana characters indexed by Unicode char"
      
      - type: "function"
        name: "get_char_data"
        description: "Retrieves CharData for a given kana character with O(1) lookup"
        preconditions: "Character database is initialized; input char is valid kana"
        postconditions: "Returns Some(CharData) for valid kana, None otherwise"

  - file: "src/db/character_db.rs"
    items:
      - type: "struct"
        name: "CharacterDatabase"
        description: "Wrapper around phf::Map or lazy_static HashMap providing character lookup functionality"
        invariants: "Contains exactly 92 entries (46 hiragana + 46 katakana)"
      
      - type: "method"
        name: "CharacterDatabase::new"
        description: "Constructs character database from embedded RON data"
        postconditions: "Database contains all hiragana and katakana characters"
      
      - type: "method"
        name: "CharacterDatabase::get"
        description: "Looks up CharData by Unicode character"
        preconditions: "Database is initialized"
        postconditions: "Returns Option<&CharData>"
      
      - type: "method"
        name: "CharacterDatabase::all_hiragana"
        description: "Returns iterator over all hiragana characters"
        postconditions: "Iterator yields exactly 46 hiragana CharData entries"
      
      - type: "method"
        name: "CharacterDatabase::all_katakana"
        description: "Returns iterator over all katakana characters"
        postconditions: "Iterator yields exactly 46 katakana CharData entries"
      
      - type: "method"
        name: "CharacterDatabase::by_frequency"
        description: "Returns characters sorted by frequency rank for ordered presentation"
        postconditions: "Returns Vec<&CharData> sorted by frequency_rank field"
      
      - type: "function"
        name: "parse_ron_data"
        description: "Parses RON string into Vec<CharData>"
        preconditions: "Input string is valid RON format"
        postconditions: "Returns Result<Vec<CharData>, Error>"

  - file: "src/utils/svg_parser.rs"
    items:
      - type: "function"
        name: "parse_svg_path"
        description: "Validates and parses SVG path string to ensure correct format"
        preconditions: "Input is SVG path command string (M, L, C, Q, Z commands)"
        postconditions: "Returns Result<ParsedPath, ParseError> with validated path data"
      
      - type: "function"
        name: "calculate_median_point"
        description: "Computes median point along SVG path for stroke direction visualization"
        preconditions: "SVG path is valid and non-empty"
        postconditions: "Returns (f32, f32) coordinate at approximate path midpoint"
      
      - type: "struct"
        name: "ParsedPath"
        description: "Internal representation of parsed SVG path with command segments"
      
      - type: "enum"
        name: "PathCommand"
        description: "Represents SVG path commands (MoveTo, LineTo, CurveTo, etc.)"

  - file: "src/models/mod.rs"
    items:
      - type: "module_declaration"
        name: "pub mod character"
        description: "Module containing character data structures"

  - file: "data/hiragana.ron"
    items:
      - type: "constant"
        name: "hiragana_dataset"
        description: "RON file containing array of 46 hiragana CharData entries with Unicode values, romanization, stroke paths, and metadata"
        invariants: "Contains exactly 46 entries; all Unicode values in hiragana block (U+3040-U+309F)"

  - file: "data/katakana.ron"
    items:
      - type: "constant"
        name: "katakana_dataset"
        description: "RON file containing array of 46 katakana CharData entries with Unicode values, romanization, stroke paths, and metadata"
        invariants: "Contains exactly 46 entries; all Unicode values in katakana block (U+30A0-U+30FF)"

formal_verification:
  needed: false
  level: "None"
  explanation: |
    Formal verification is not needed for this task because:
    
    1. The character data structures are static, read-only data representations
       with no complex invariants to maintain. The CharData struct is essentially
       a plain data container with no behavioral logic that could violate safety
       properties.
    
    2. The loading system uses well-tested standard library components (HashMap)
       or proven compile-time solutions (phf crate) that have already been
       extensively verified. The lookup operations are simple key-value retrievals
       with no state mutations or concurrency concerns.
    
    3. Data integrity can be comprehensively validated through property-based
       testing (verifying all 92 characters exist, Unicode values are valid,
       stroke counts are positive, etc.) without requiring formal proofs.
    
    4. The SVG path parsing is delegated to existing, well-tested libraries or
       simple string storage. Any parsing errors will be caught during testing
       and do not pose memory safety or correctness risks that require formal
       verification.
    
    5. The task involves no unsafe code, no complex algorithms with non-obvious
       correctness properties, no concurrent access patterns, and no security-
       critical operations that would benefit from formal verification.
    
    Standard unit tests and property-based tests provide sufficient confidence
    in correctness for this foundational but straightforward data layer.

tests:
  strategy:
    approach: "unit tests with property-based testing"
    rationale:
      - "Character data is static and deterministic, making unit tests ideal for verification"
      - "Property-based tests ensure data integrity across all 92 characters without manual enumeration"
      - "No concurrency or external I/O involved - pure data structure validation"
      - "SVG path parsing correctness critical for stroke animation - needs edge case testing"
      - "Lookup performance is O(1) with phf - focus on correctness not performance testing"
      - "Data completeness (all 46+46 characters) verified through property tests"

  implementation:
    file: "src/models/character.rs"
    location: "in existing test module"
    code: |
      #[cfg(test)]
      mod tests {
          use super::*;
          
          #[test]
          fn test_chardata_deserialization() {
              let ron_data = r#"
                  CharData(
                      unicode: "あ",
                      romanization: "a",
                      strokes: [
                          "M 10 20 L 30 40",
                          "M 15 25 Q 35 45 50 60"
                      ],
                      stroke_count: 2,
                      frequency_rank: 1
                  )
              "#;
              
              let result: Result<CharData, _> = ron::from_str(ron_data);
              assert!(result.is_ok(), "Failed to deserialize valid CharData");
              
              let char_data = result.unwrap();
              assert_eq!(char_data.unicode, "あ");
              assert_eq!(char_data.romanization, "a");
              assert_eq!(char_data.stroke_count, 2);
              assert_eq!(char_data.strokes.len(), 2);
              assert_eq!(char_data.frequency_rank, 1);
          }
          
          #[test]
          fn test_hiragana_database_completeness() {
              let hiragana_chars = vec![
                  "あ", "い", "う", "え", "お",
                  "か", "き", "く", "け", "こ",
                  "さ", "し", "す", "せ", "そ",
                  "た", "ち", "つ", "て", "と",
                  "な", "に", "ぬ", "ね", "の",
                  "は", "ひ", "ふ", "へ", "ほ",
                  "ま", "み", "む", "め", "も",
                  "や", "ゆ", "よ",
                  "ら", "り", "る", "れ", "ろ",
                  "わ", "を", "ん"
              ];
              
              assert_eq!(hiragana_chars.len(), 46, "Expected 46 hiragana characters");
              
              for ch in &hiragana_chars {
                  let result = lookup_hiragana(ch);
                  assert!(result.is_some(), "Missing hiragana character: {}", ch);
                  assert_eq!(result.unwrap().unicode, *ch);
              }
          }
          
          #[test]
          fn test_katakana_database_completeness() {
              let katakana_chars = vec![
                  "ア", "イ", "ウ", "エ", "オ",
                  "カ", "キ", "ク", "ケ", "コ",
                  "サ", "シ", "ス", "セ", "ソ",
                  "タ", "チ", "ツ", "テ", "ト",
                  "ナ", "ニ", "ヌ", "ネ", "ノ",
                  "ハ", "ヒ", "フ", "ヘ", "ホ",
                  "マ", "ミ", "ム", "メ", "モ",
                  "ヤ", "ユ", "ヨ",
                  "ラ", "リ", "ル", "レ", "ロ",
                  "ワ", "ヲ", "ン"
              ];
              
              assert_eq!(katakana_chars.len(), 46, "Expected 46 katakana characters");
              
              for ch in &katakana_chars {
                  let result = lookup_katakana(ch);
                  assert!(result.is_some(), "Missing katakana character: {}", ch);
                  assert_eq!(result.unwrap().unicode, *ch);
              }
          }
          
          #[test]
          fn test_lookup_nonexistent_character() {
              assert!(lookup_hiragana("X").is_none());
              assert!(lookup_katakana("あ").is_none());
              assert!(lookup_hiragana("ア").is_none());
              assert!(lookup_katakana("").is_none());
              assert!(lookup_hiragana("漢").is_none());
          }
          
          #[test]
          fn test_stroke_count_validity() {
              let test_data = CharData {
                  unicode: "あ".to_string(),
                  romanization: "a".to_string(),
                  strokes: vec![
                      "M 10 20 L 30 40".to_string(),
                      "M 15 25 L 35 45".to_string(),
                      "M 20 30 L 40 50".to_string(),
                  ],
                  stroke_count: 3,
                  frequency_rank: 1,
              };
              
              assert_eq!(test_data.stroke_count, test_data.strokes.len());
              assert!(test_data.stroke_count > 0);
          }
          
          #[test]
          fn test_romanization_format() {
              if let Some(char_data) = lookup_hiragana("あ") {
                  assert!(!char_data.romanization.is_empty());
                  assert_eq!(char_data.romanization, char_data.romanization.to_lowercase());
              }
              
              if let Some(char_data) = lookup_katakana("ア") {
                  assert!(!char_data.romanization.is_empty());
                  assert_eq!(char_data.romanization, char_data.romanization.to_lowercase());
              }
          }
          
          #[test]
          fn test_svg_path_basic_parsing() {
              let valid_commands = vec!['M', 'L', 'Q', 'C', 'Z', 'H', 'V', 'S', 'T', 'A'];
              
              if let Some(char_data) = lookup_hiragana("あ") {
                  for stroke in &char_data.strokes {
                      assert!(!stroke.is_empty(), "Empty stroke path");
                      
                      let first_char = stroke.trim().chars().next().unwrap();
                      assert!(
                          valid_commands.contains(&first_char) || 
                          valid_commands.contains(&first_char.to_ascii_uppercase()),
                          "Invalid SVG command: {}", first_char
                      );
                  }
              }
          }
          
          #[test]
          fn test_frequency_rank_uniqueness() {
              let mut hiragana_ranks = std::collections::HashSet::new();
              let mut katakana_ranks = std::collections::HashSet::new();
              
              for ch in ["あ", "い", "う", "え", "お"] {
                  if let Some(char_data) = lookup_hiragana(ch) {
                      assert!(
                          char_data.frequency_rank > 0,
                          "Invalid frequency rank for {}", ch
                      );
                      hiragana_ranks.insert(char_data.frequency_rank);
                  }
              }
              
              for ch in ["ア", "イ", "ウ", "エ", "オ"] {
                  if let Some(char_data) = lookup_katakana(ch) {
                      assert!(
                          char_data.frequency_rank > 0,
                          "Invalid frequency rank for {}", ch
                      );
                      katakana_ranks.insert(char_data.frequency_rank);
                  }
              }
          }
          
          #[test]
          fn test_unicode_validity() {
              if let Some(char_data) = lookup_hiragana("あ") {
                  assert_eq!(char_data.unicode.chars().count(), 1);
                  assert!(char_data.unicode.is_char_boundary(0));
              }
              
              if let Some(char_data) = lookup_katakana("ア") {
                  assert_eq!(char_data.unicode.chars().count(), 1);
                  assert!(char_data.unicode.is_char_boundary(0));
              }
          }
          
          #[test]
          fn test_ron_file_loading() {
              let hiragana_ron = include_str!("../../data/hiragana.ron");
              let katakana_ron = include_str!("../../data/katakana.ron");
              
              assert!(!hiragana_ron.is_empty(), "hiragana.ron is empty");
              assert!(!katakana_ron.is_empty(), "katakana.ron is empty");
              
              assert!(hiragana_ron.contains("CharData"));
              assert!(katakana_ron.contains("CharData"));
          }
          
          #[test]
          fn test_lookup_performance_characteristic() {
              let start = std::time::Instant::now();
              
              for _ in 0..1000 {
                  let _ = lookup_hiragana("あ");
                  let _ = lookup_katakana("ア");
              }
              
              let elapsed = start.elapsed();
              
              assert!(
                  elapsed.as_millis() < 10,
                  "Lookup performance degraded: {:?}", elapsed
              );
          }
      }
      
      #[cfg(test)]
      mod property_tests {
          use super::*;
          use proptest::prelude::*;
          
          proptest! {
              #[test]
              fn prop_all_hiragana_have_positive_stroke_count(ch in hiragana_char_strategy()) {
                  if let Some(char_data) = lookup_hiragana(&ch.to_string()) {
                      prop_assert!(char_data.stroke_count > 0);
                      prop_assert!(char_data.stroke_count <= 10);
                  }
              }
              
              #[test]
              fn prop_all_katakana_have_positive_stroke_count(ch in katakana_char_strategy()) {
                  if let Some(char_data) = lookup_katakana(&ch.to_string()) {
                      prop_assert!(char_data.stroke_count > 0);
                      prop_assert!(char_data.stroke_count <= 10);
                  }
              }
              
              #[test]
              fn prop_stroke_count_matches_array_length(ch in hiragana_char_strategy()) {
                  if let Some(char_data) = lookup_hiragana(&ch.to_string()) {
                      prop_assert_eq!(char_data.stroke_count, char_data.strokes.len());
                  }
              }
              
              #[test]
              fn prop_all_strokes_non_empty(ch in hiragana_char_strategy()) {
                  if let Some(char_data) = lookup_hiragana(&ch.to_string()) {
                      for stroke in &char_data.strokes {
                          prop_assert!(!stroke.is_empty());
                          prop_assert!(stroke.trim().len() > 0);
                      }
                  }
              }
              
              #[test]
              fn prop_romanization_is_ascii(ch in hiragana_char_strategy()) {
                  if let Some(char_data) = lookup_hiragana(&ch.to_string()) {
                      prop_assert!(char_data.romanization.is_ascii());
                      prop_assert!(!char_data.romanization.is_empty());
                  }
              }
              
              #[test]
              fn prop_frequency_rank_in_valid_range(ch in hiragana_char_strategy()) {
                  if let Some(char_data) = lookup_hiragana(&ch.to_string()) {
                      prop_assert!(char_data.frequency_rank >= 1);
                      prop_assert!(char_data.frequency_rank <= 46);
                  }
              }
          }
          
          fn hiragana_char_strategy() -> impl Strategy<Value = char> {
              prop::sample::select(vec![
                  'あ', 'い', 'う', 'え', 'お',
                  'か', 'き', 'く', 'け', 'こ',
                  'さ', 'し', 'す', 'せ', 'そ',
                  'た', 'ち', 'つ', 'て', 'と',
                  'な', 'に', 'ぬ', 'ね', 'の',
                  'は', 'ひ', 'ふ', 'へ', 'ほ',
                  'ま', 'み', 'む', 'め', 'も',
                  'や', 'ゆ', 'よ',
                  'ら', 'り', 'る', 'れ', 'ろ',
                  'わ', 'を', 'ん'
              ])
          }
          
          fn katakana_char_strategy() -> impl Strategy<Value = char> {
              prop::sample::select(vec![
                  'ア', 'イ', 'ウ', 'エ', 'オ',
                  'カ', 'キ', 'ク', 'ケ', 'コ',
                  'サ', 'シ', 'ス', 'セ', 'ソ',
                  'タ', 'チ', 'ツ', 'テ', 'ト',
                  'ナ', 'ニ', 'ヌ', 'ネ', 'ノ',
                  'ハ', 'ヒ', 'フ', 'ヘ', 'ホ',
                  'マ', 'ミ', 'ム', 'メ', 'モ',
                  'ヤ', 'ユ', 'ヨ',
                  'ラ', 'リ', 'ル', 'レ', 'ロ',
                  'ワ', 'ヲ', 'ン'
              ])
          }
      }

  coverage:
    - "CharData struct deserialization from RON format"
    - "All 46 hiragana characters present in database"
    - "All 46 katakana characters present in database"
    - "Lookup returns None for non-existent characters"
    - "Lookup returns None for wrong script type (hiragana vs katakana)"
    - "Stroke count matches stroke array length"
    - "Stroke counts are positive and within reasonable bounds (1-10)"
    - "Romanization is lowercase ASCII and non-empty"
    - "SVG paths contain valid command characters"
    - "SVG stroke paths are non-empty strings"
    - "Frequency ranks are positive and within valid range (1-46)"
    - "Frequency ranks are unique within each character set"
    - "Unicode values are valid UTF-8 single characters"
    - "RON data files load successfully and contain expected structure"
    - "Lookup operations complete efficiently (O(1) characteristic)"
    - "All hiragana characters have valid stroke data"
    - "All katakana characters have valid stroke data"
    - "Property: stroke count invariant holds across all characters"
    - "Property: romanization format invariant holds across all characters"

dependencies:
  depends_on:
    - task_id: 1
      reason: "Requires models/ module structure to exist before defining CharData struct"

  depended_upon_by:
    - task_id: 3
      reason: "Font rendering needs character data to display kana correctly"
    - task_id: 4
      reason: "Stroke animation requires stroke path data from CharData"
    - task_id: 7
      reason: "Flashcard system needs character database for card generation"

  external:
    - name: "phf"
      type: "crate"
      status: "to be imported"
    - name: "serde"
      type: "crate"
      status: "to be imported"
    - name: "ron"
      type: "crate"
      status: "to be imported"
    - name: "proptest"
      type: "crate"
      status: "to be imported"
---
task:
  id: 3
  name: "Japanese Font Integration and Text Rendering"

context:
  description: |
    This task establishes the foundation for Japanese text rendering in the kana learning
    application by integrating the Noto Sans JP font and implementing a custom CharacterCard
    widget for flashcard-style character display. Proper Japanese text rendering is critical
    for a kana learning application - without correct glyph shaping and font support, hiragana
    and katakana characters will display as missing glyph boxes or with incorrect appearance.
    
    Iced's underlying text rendering engine, cosmic-text, provides full Unicode support and
    sophisticated text shaping capabilities, but requires explicit font loading and configuration.
    This task leverages iced's font loading API to embed the Noto Sans JP font directly in
    the application binary using include_bytes!(), ensuring consistent rendering across all
    platforms without requiring users to install fonts separately.
    
    The CharacterCard widget abstracts the complexity of text rendering configuration and
    provides a reusable, consistent interface for displaying individual kana characters
    throughout the application. By centralizing character display logic in a custom widget,
    we ensure that all Japanese text uses proper shaping configuration (Shaping::Advanced)
    and maintains consistent styling and sizing across flashcards, practice modes, and
    other UI components.

  key_points:
    - "Noto Sans JP is embedded at compile time using include_bytes!() for portability"
    - "cosmic-text requires Shaping::Advanced for proper Japanese glyph rendering"
    - "CharacterCard widget implements iced::Widget trait for integration with iced's layout and rendering pipeline"
    - "Font loading occurs at application startup in Application::new() before any rendering"
    - "Widget provides configurable sizing (48px, 64px, 72px) for different UI contexts"
    - "Embedded font adds ~900KB to binary size; subsetting to kana-only could reduce to ~100KB if needed"
    - "Custom widget approach enables future enhancement with stroke order overlays"

files:
  - path: "assets/fonts/NotoSansJP-Regular.otf"
    description: "Embedded Noto Sans JP Regular font file for Japanese character rendering"
  - path: "src/main.rs"
    description: "Application entry point, modified to load Japanese font at startup"
  - path: "src/ui/widgets/character_card.rs"
    description: "Custom widget implementation for flashcard-style kana character display"
  - path: "src/ui/widgets/mod.rs"
    description: "Widget module declaration file, updated to export CharacterCard widget"

functions:
  - file: "src/main.rs"
    items:
      - type: "function"
        name: "load_japanese_font"
        description: "Loads the embedded Noto Sans JP font using include_bytes! and returns font data for iced"
        preconditions: "Font file exists at compile time in assets/"
        postconditions: "Font data is loaded into memory and ready for registration"
        invariants: "Font data is valid OTF format"

  - file: "src/assets/fonts.rs"
    items:
      - type: "module_declaration"
        name: "assets::fonts"
        description: "Module containing embedded font assets"
        
      - type: "constant"
        name: "NOTO_SANS_JP_REGULAR"
        description: "Embedded Noto Sans JP Regular font bytes using include_bytes! macro"
        invariants: "Points to valid OTF font file at compile time"
        
      - type: "constant"
        name: "NOTO_SANS_JP_BOLD"
        description: "Embedded Noto Sans JP Bold font bytes using include_bytes! macro (optional for emphasis)"
        invariants: "Points to valid OTF font file at compile time"

  - file: "src/ui/widgets/character_card.rs"
    items:
      - type: "struct"
        name: "CharacterCard"
        description: "Custom widget for displaying a single kana character in flashcard style with configurable size and styling"
        invariants: "Character must be valid Unicode string; size must be positive"
        
      - type: "struct"
        name: "CharacterCardStyle"
        description: "Style configuration for CharacterCard including background color, text color, border, and padding"
        
      - type: "enum_variant"
        name: "CharacterSize"
        description: "Enumeration of predefined character display sizes (Small=48px, Medium=64px, Large=72px)"
        
      - type: "method"
        name: "CharacterCard::new"
        description: "Constructor for CharacterCard widget"
        preconditions: "Character string is non-empty"
        postconditions: "Returns initialized CharacterCard with default styling"
        
      - type: "method"
        name: "CharacterCard::character"
        description: "Builder method to set the character to display"
        preconditions: "Character string contains valid UTF-8"
        postconditions: "Returns self with updated character"
        
      - type: "method"
        name: "CharacterCard::size"
        description: "Builder method to set character display size"
        postconditions: "Returns self with updated size"
        
      - type: "method"
        name: "CharacterCard::style"
        description: "Builder method to set card styling"
        postconditions: "Returns self with updated style"
        
      - type: "method"
        name: "CharacterCard::show_stroke_order"
        description: "Builder method to toggle stroke order overlay display"
        postconditions: "Returns self with stroke order flag updated"
        
      - type: "trait_impl"
        name: "Widget<Message> for CharacterCard"
        description: "Implementation of iced::Widget trait for CharacterCard"
        preconditions: "Font is loaded in application"
        postconditions: "Widget can be rendered by iced runtime"
        invariants: "Rendering is deterministic for given state"
        
      - type: "method"
        name: "Widget::width"
        description: "Returns the width of the widget based on size configuration"
        postconditions: "Returns Length value appropriate for character size"
        
      - type: "method"
        name: "Widget::height"
        description: "Returns the height of the widget based on size configuration"
        postconditions: "Returns Length value appropriate for character size"
        
      - type: "method"
        name: "Widget::layout"
        description: "Computes layout for the character card given available space"
        preconditions: "Renderer and limits are valid"
        postconditions: "Returns Node with centered character layout"
        
      - type: "method"
        name: "Widget::draw"
        description: "Renders the character card using cosmic-text with Advanced shaping"
        preconditions: "Font is loaded; renderer state is valid"
        postconditions: "Character is rendered centered with proper glyph shaping"
        invariants: "Uses Shaping::Advanced for Japanese text"

  - file: "src/ui/widgets/mod.rs"
    items:
      - type: "module_declaration"
        name: "character_card"
        description: "Module declaration for character_card widget"
        
      - type: "function"
        name: "pub use character_card::CharacterCard"
        description: "Re-export CharacterCard for public API"

  - file: "tests/font_integration.rs"
    items:
      - type: "function"
        name: "test_font_loads_successfully"
        description: "Integration test verifying Japanese font data is embedded and non-empty"
        postconditions: "Font data is present and has expected size"
        
      - type: "function"
        name: "test_font_contains_hiragana_range"
        description: "Sanity check that font file has valid OTF/TTF header format"
        preconditions: "Font data is embedded"
        postconditions: "Font starts with valid magic bytes"
        
      - type: "function"
        name: "test_hiragana_characters_render_without_panic"
        description: "Integration test verifying CharacterCard can be created with hiragana characters"
        preconditions: "CharacterCard widget is available"
        postconditions: "No panics occur for valid hiragana characters"
        
      - type: "function"
        name: "test_katakana_characters_render_without_panic"
        description: "Integration test verifying CharacterCard can be created with katakana characters"
        preconditions: "CharacterCard widget is available"
        postconditions: "No panics occur for valid katakana characters"
        
      - type: "function"
        name: "test_character_card_at_multiple_sizes"
        description: "Integration test verifying CharacterCard widget handles required font sizes (48px, 64px, 72px)"
        preconditions: "CharacterCard widget is available"
        postconditions: "Widget construction succeeds at all required sizes"

  - file: "src/ui/widgets/character_card.rs"
    items:
      - type: "function"
        name: "test_character_card_creation"
        description: "Unit test verifying CharacterCard constructor works with valid parameters"
        postconditions: "CharacterCard stores character and size correctly"
        
      - type: "function"
        name: "test_character_card_sizing"
        description: "Unit test verifying CharacterCard respects size constraints"
        postconditions: "All test sizes are accepted and stored correctly"
        
      - type: "function"
        name: "test_character_card_with_hiragana"
        description: "Unit test verifying CharacterCard accepts all basic hiragana characters"
        postconditions: "All 46 hiragana characters can be used in CharacterCard"
        
      - type: "function"
        name: "test_character_card_with_katakana"
        description: "Unit test verifying CharacterCard accepts all basic katakana characters"
        postconditions: "All 46 katakana characters can be used in CharacterCard"

formal_verification:
  needed: false
  level: "None"
  explanation: |
    Formal verification is not required for this task because:
    
    1. Font loading and text rendering are primarily UI concerns with no critical
       safety or correctness properties that demand mathematical proof. Failures
       manifest as visual bugs (missing glyphs, incorrect rendering) rather than
       safety violations or data corruption.
    
    2. The underlying rendering system (cosmic-text and iced) is already tested
       and verified by its maintainers. This task is integration work - loading
       a font file and configuring existing, proven rendering infrastructure.
    
    3. The CharacterCard widget is a presentation component with no complex state
       management, concurrency, or algorithmic logic. Its correctness can be
       adequately verified through integration testing and visual inspection.
    
    4. Font loading errors are runtime I/O issues (file not found, invalid format)
       that cannot be prevented by compile-time verification. They are better
       handled through error handling and integration tests.
    
    5. The risk assessment categorizes complexity as low and identifies integration
       risks (platform-specific behavior, configuration tuning) rather than logical
       correctness issues that would benefit from formal methods.
    
    Integration testing with actual font rendering at various sizes and characters
    provides sufficient validation for this UI-focused task. The acceptance criteria
    (no missing glyphs, correct rendering at specific sizes) are testable properties
    but do not require formal proof techniques.

tests:
  strategy:
    approach: "mixed (unit + integration)"
    rationale:
      - "Font loading is an integration concern requiring actual font data and iced runtime"
      - "CharacterCard widget rendering requires integration with iced's rendering pipeline"
      - "Character glyph presence can be tested via integration tests that verify no missing glyphs"
      - "Widget layout and sizing logic can be unit tested independently of rendering"
      - "Text rendering quality and visual correctness require manual verification or snapshot tests (deferred for MVP)"

  implementation:
    file: "src/ui/widgets/character_card.rs"
    location: "in existing test module"
    code: |
      #[cfg(test)]
      mod tests {
          use super::*;
          use iced::{Size, Point};
          
          #[test]
          fn test_character_card_creation() {
              // Test that CharacterCard can be constructed with valid parameters
              let card = CharacterCard::new('あ', 64.0);
              assert_eq!(card.character(), 'あ');
              assert_eq!(card.font_size(), 64.0);
          }
          
          #[test]
          fn test_character_card_sizing() {
              // Test that CharacterCard respects size constraints
              let sizes = [48.0, 64.0, 72.0, 96.0];
              for size in sizes.iter() {
                  let card = CharacterCard::new('カ', *size);
                  assert_eq!(card.font_size(), *size);
                  assert!(*size >= 48.0 && *size <= 128.0, "Size should be in reasonable range");
              }
          }
          
          #[test]
          fn test_character_card_with_hiragana() {
              // Test CharacterCard accepts all hiragana characters
              let hiragana = "あいうえおかきくけこさしすせそたちつてとなにぬねのはひふへほまみむめもやゆよらりるれろわをん";
              for ch in hiragana.chars() {
                  let card = CharacterCard::new(ch, 64.0);
                  assert_eq!(card.character(), ch);
              }
          }
          
          #[test]
          fn test_character_card_with_katakana() {
              // Test CharacterCard accepts all katakana characters
              let katakana = "アイウエオカキクケコサシスセソタチツテトナニヌネノハヒフヘホマミムメモヤユヨラリルレロワヲン";
              for ch in katakana.chars() {
                  let card = CharacterCard::new(ch, 64.0);
                  assert_eq!(card.character(), ch);
              }
          }
      }

    file_2: "tests/font_integration.rs"
    location_2: "create new"
    code_2: |
      use iced::Application;
      
      #[test]
      fn test_font_loads_successfully() {
          // Test that Noto Sans JP font loads without panicking
          // This requires application initialization
          const NOTO_SANS_JP: &[u8] = include_bytes!("../assets/fonts/NotoSansJP-Regular.otf");
          assert!(!NOTO_SANS_JP.is_empty(), "Font data should be embedded");
          assert!(NOTO_SANS_JP.len() > 100_000, "Font file should be substantial size (>100KB)");
      }
      
      #[test]
      fn test_font_contains_hiragana_range() {
          // Verify font file contains data in hiragana Unicode range
          // This is a basic sanity check without full TTF parsing
          const NOTO_SANS_JP: &[u8] = include_bytes!("../assets/fonts/NotoSansJP-Regular.otf");
          
          // OTF/TTF files should start with specific magic bytes
          assert!(
              NOTO_SANS_JP.starts_with(&[0x4F, 0x54, 0x54, 0x4F]) || // OTTO (CFF/OpenType)
              NOTO_SANS_JP.starts_with(&[0x00, 0x01, 0x00, 0x00]), // TrueType
              "Font should have valid OTF/TTF header"
          );
      }
      
      #[test]
      fn test_hiragana_characters_render_without_panic() {
          // Integration test that exercises rendering path for hiragana
          // Note: Full visual verification requires running application
          use kana_trainer::ui::CharacterCard;
          
          let hiragana = ['あ', 'い', 'う', 'え', 'お', 'ん'];
          for ch in hiragana.iter() {
              let card = CharacterCard::new(*ch, 64.0);
              // Construction should not panic
              assert_eq!(card.character(), *ch);
          }
      }
      
      #[test]
      fn test_katakana_characters_render_without_panic() {
          // Integration test that exercises rendering path for katakana
          use kana_trainer::ui::CharacterCard;
          
          let katakana = ['ア', 'イ', 'ウ', 'エ', 'オ', 'ン'];
          for ch in katakana.iter() {
              let card = CharacterCard::new(*ch, 64.0);
              // Construction should not panic
              assert_eq!(card.character(), *ch);
          }
      }
      
      #[test]
      fn test_character_card_at_multiple_sizes() {
          // Test that CharacterCard handles different font sizes
          use kana_trainer::ui::CharacterCard;
          
          let test_char = 'あ';
          let sizes = [48.0, 64.0, 72.0];
          
          for size in sizes.iter() {
              let card = CharacterCard::new(test_char, *size);
              assert_eq!(card.font_size(), *size);
              // Widget should be constructible at all required sizes
          }
      }

  coverage:
    - "Font data is embedded in binary and non-empty"
    - "Font file has valid OTF/TTF format header"
    - "CharacterCard widget can be constructed with hiragana characters"
    - "CharacterCard widget can be constructed with katakana characters"
    - "CharacterCard accepts and stores character correctly"
    - "CharacterCard accepts and stores font size correctly"
    - "CharacterCard handles all required sizes (48px, 64px, 72px)"
    - "All basic hiragana characters (あ-ん) can be used with CharacterCard"
    - "All basic katakana characters (ア-ン) can be used with CharacterCard"
    - "Widget construction does not panic for valid Japanese characters"
    - "Font file size is reasonable (>100KB for full font)"

dependencies:
  depends_on:
    - task_id: 1
      reason: "Requires application foundation and ui/ module structure to exist before adding character rendering widgets"

  depended_upon_by:
    - task_id: 7
      reason: "Flashcard system needs CharacterCard widget to display kana characters in flashcard UI"
    - task_id: 8
      reason: "Practice mode displays characters using CharacterCard for consistent rendering across modes"

  external:
    - name: "iced::Widget"
      type: "trait"
      status: "already exists"
    - name: "iced::Application"
      type: "trait"
      status: "already exists"
    - name: "cosmic-text"
      type: "crate"
      status: "already exists"
    - name: "NotoSansJP-Regular.otf"
      type: "font file"
      status: "needs download and placement in assets/fonts/"
---
task:
  id: 4
  name: "Stroke Order Animation System"

context:
  description: |
    Implement a GPU-accelerated stroke-by-stroke animation system using iced's Canvas
    widget and Animation API. The system renders character strokes sequentially with
    smooth partial path drawing, configurable timing, and natural easing curves that
    mimic human handwriting motion.
    
    Stroke order animation is the primary visual teaching tool for character learning.
    It must be smooth, accurate, and feel natural to be pedagogically effective. GPU
    acceleration via lyon tessellation ensures 60fps animation even on lower-end hardware.
    Sequential stroke rendering with proper timing helps learners internalize correct
    writing patterns.
    
    This task produces a reusable StrokeOrderAnimation component that takes stroke path
    data and produces smooth, timed animations. Each stroke draws progressively over
    500-800ms with 200-300ms pauses between strokes. Completed strokes render in black,
    current stroke in blue. Animation can be played, paused, and reset.

  key_points:
    - "Implements Canvas-based animation with lyon path rendering, timing control, and partial path calculation"
    - "SVG path parsing is complex and error-prone for edge cases requiring robust error handling"
    - "Partial path length calculations may have floating-point precision issues requiring tolerance-based validation"
    - "Bezier curve length calculation requires numerical approximation using adaptive subdivision"
    - "Animation timing uses EaseOutCubic easing for natural handwriting feel"
    - "Performance critical - must maintain 60fps on lower-end hardware"
    - "Precompute total stroke length for accurate partial path rendering"
    - "Color differentiation: black for complete strokes, blue for animating strokes"
    - "Integration point for practice mode teaching functionality"

files:
  - path: "src/ui/components/stroke_order_animation.rs"
    description: "Main StrokeOrderAnimation component implementing canvas::Program trait for stroke-by-stroke rendering"
  
  - path: "src/ui/components/mod.rs"
    description: "Module declaration file to export StrokeOrderAnimation component"
  
  - path: "src/animation/stroke_path.rs"
    description: "StrokePath struct with SVG path parsing and length calculation utilities"
  
  - path: "src/animation/path_segment.rs"
    description: "PathSegment enum representing SVG path commands (MoveTo, LineTo, CubicBezier, etc.) with length computation"
  
  - path: "src/animation/mod.rs"
    description: "Animation module declaration and controller functions for play/pause/reset lifecycle management"
  
  - path: "tests/stroke_animation_tests.rs"
    description: "Integration and unit tests for stroke animation timing, path rendering, and state transitions"

functions:
  - file: "src/ui/widgets/stroke_animation.rs"
    items:
      - type: "module_declaration"
        name: "stroke_animation"
        description: "Module containing stroke order animation implementation and related types"
      
      - type: "struct"
        name: "StrokeOrderAnimation"
        description: "Main animation component managing state, timing, and rendering for stroke order display"
        invariants: "current_stroke_index <= strokes.len(); animation_progress in [0.0, 1.0]"
      
      - type: "struct"
        name: "StrokePath"
        description: "Represents a single stroke containing path segments and precomputed total length"
        invariants: "total_length >= 0.0; segments.len() > 0"
      
      - type: "enum"
        name: "PathSegment"
        description: "Individual SVG path commands (MoveTo, LineTo, CubicBezier, QuadraticBezier, SmoothCubic)"
      
      - type: "enum_variant"
        name: "PathSegment::MoveTo"
        description: "SVG M command - move pen to absolute position without drawing"
      
      - type: "enum_variant"
        name: "PathSegment::LineTo"
        description: "SVG L command - draw straight line to absolute position"
      
      - type: "enum_variant"
        name: "PathSegment::CubicBezier"
        description: "SVG C command - draw cubic Bezier curve with two control points"
      
      - type: "enum_variant"
        name: "PathSegment::SmoothCubic"
        description: "SVG S command - draw smooth cubic Bezier with reflected first control point"
      
      - type: "enum_variant"
        name: "PathSegment::QuadraticBezier"
        description: "SVG Q command - draw quadratic Bezier curve with one control point"
      
      - type: "enum"
        name: "AnimationState"
        description: "Current state of the animation (Playing, Paused, Completed, Reset)"
      
      - type: "enum_variant"
        name: "AnimationState::Playing"
        description: "Animation is actively running and progressing"
      
      - type: "enum_variant"
        name: "AnimationState::Paused"
        description: "Animation is paused at current progress point"
      
      - type: "enum_variant"
        name: "AnimationState::Completed"
        description: "All strokes have been fully animated"
      
      - type: "enum_variant"
        name: "AnimationState::Reset"
        description: "Animation has been reset to initial state"
      
      - type: "struct"
        name: "AnimationConfig"
        description: "Configuration parameters for animation timing and appearance"
      
      - type: "method"
        name: "StrokeOrderAnimation::new"
        description: "Creates new animation instance with given strokes and configuration"
        preconditions: "strokes vector is not empty"
        postconditions: "Returns initialized animation in Reset state"
      
      - type: "method"
        name: "StrokeOrderAnimation::play"
        description: "Starts or resumes animation playback"
        postconditions: "state transitions to Playing if not Completed"
      
      - type: "method"
        name: "StrokeOrderAnimation::pause"
        description: "Pauses animation at current progress"
        postconditions: "state transitions to Paused"
      
      - type: "method"
        name: "StrokeOrderAnimation::reset"
        description: "Resets animation to initial state"
        postconditions: "current_stroke_index = 0; animation_progress = 0.0; state = Reset"
      
      - type: "method"
        name: "StrokeOrderAnimation::update"
        description: "Updates animation state based on elapsed time, advances strokes and progress"
        preconditions: "delta_time >= 0.0"
        postconditions: "animation_progress and current_stroke_index updated according to timing"
      
      - type: "trait_impl"
        name: "canvas::Program for StrokeOrderAnimation"
        description: "Implements iced canvas Program trait for custom rendering behavior"
      
      - type: "method"
        name: "<StrokeOrderAnimation as canvas::Program>::update"
        description: "Handles animation state updates and timing progression"
        postconditions: "Returns appropriate message for frame redraws"
      
      - type: "method"
        name: "<StrokeOrderAnimation as canvas::Program>::draw"
        description: "Renders completed and in-progress strokes using lyon tessellation"
        preconditions: "bounds.width > 0.0 && bounds.height > 0.0"
        postconditions: "All completed strokes rendered in black, current stroke in blue with partial path"
      
      - type: "function"
        name: "parse_svg_path"
        description: "Parses SVG path data string into vector of PathSegment enums"
        preconditions: "path_data contains valid SVG path syntax"
        postconditions: "Returns Ok(Vec<PathSegment>) or Err with parse error"
      
      - type: "function"
        name: "compute_segment_length"
        description: "Calculates geometric length of a single path segment"
        postconditions: "Returns non-negative length value"
      
      - type: "function"
        name: "compute_bezier_length"
        description: "Approximates cubic Bezier curve length using adaptive subdivision"
        preconditions: "control points form valid Bezier curve"
        postconditions: "Returns approximation within specified tolerance"
        invariants: "Result accuracy improves with subdivision depth"
      
      - type: "function"
        name: "compute_quadratic_bezier_length"
        description: "Approximates quadratic Bezier curve length using numerical integration"
        preconditions: "control points form valid quadratic Bezier"
        postconditions: "Returns approximation within specified tolerance"
      
      - type: "function"
        name: "calculate_partial_path"
        description: "Computes partial path up to specified progress ratio (0.0-1.0)"
        preconditions: "progress in [0.0, 1.0]; segments is non-empty"
        postconditions: "Returns segments and final point representing partial path"
      
      - type: "function"
        name: "ease_out_cubic"
        description: "Applies cubic easing function for natural animation feel"
        preconditions: "t in [0.0, 1.0]"
        postconditions: "Returns eased value in [0.0, 1.0]"
        invariants: "Monotonically increasing; ease_out_cubic(0.0) = 0.0; ease_out_cubic(1.0) = 1.0"
      
      - type: "method"
        name: "StrokePath::new"
        description: "Creates StrokePath from segments, precomputing total length"
        preconditions: "segments vector is not empty"
        postconditions: "total_length equals sum of all segment lengths"
      
      - type: "method"
        name: "StrokePath::total_length"
        description: "Returns precomputed total length of the stroke path"
        postconditions: "Returns non-negative float value"
      
      - type: "method"
        name: "StrokePath::segments"
        description: "Returns reference to vector of path segments"
      
      - type: "method"
        name: "AnimationConfig::default"
        description: "Creates default configuration with 600ms per stroke, 250ms pause"
        postconditions: "stroke_duration = 600ms; pause_duration = 250ms; animating_color = blue; complete_color = black"
      
      - type: "function"
        name: "render_stroke"
        description: "Renders a complete or partial stroke using lyon path builder and tessellation"
        preconditions: "frame and stroke are valid; progress in [0.0, 1.0]"
        postconditions: "Stroke is tessellated and drawn to canvas frame"
      
      - type: "function"
        name: "point_at_bezier"
        description: "Calculates point on cubic Bezier curve at parameter t"
        preconditions: "t in [0.0, 1.0]"
        postconditions: "Returns point on curve between start and end"
      
      - type: "function"
        name: "point_at_quadratic_bezier"
        description: "Calculates point on quadratic Bezier curve at parameter t"
        preconditions: "t in [0.0, 1.0]"
        postconditions: "Returns point on curve between start and end"
      
      - type: "function"
        name: "subdivide_bezier"
        description: "Recursively subdivides Bezier curve for length approximation"
        preconditions: "max_depth > 0; tolerance > 0.0"
        postconditions: "Returns length approximation or subdivides further if needed"

  - file: "src/ui/widgets/mod.rs"
    items:
      - type: "module_declaration"
        name: "mod stroke_animation"
        description: "Declares stroke_animation module for visibility in widgets namespace"
      
      - type: "constant"
        name: "pub use stroke_animation::StrokeOrderAnimation"
        description: "Re-exports StrokeOrderAnimation for external use"
      
      - type: "constant"
        name: "pub use stroke_animation::AnimationConfig"
        description: "Re-exports AnimationConfig for external use"

  - file: "src/data/character.rs"
    items:
      - type: "method"
        name: "Character::stroke_paths"
        description: "Returns vector of stroke path data strings in SVG format for animation"
        postconditions: "Returns vector with one SVG path string per stroke"
      
      - type: "method"
        name: "Character::stroke_count"
        description: "Returns total number of strokes in the character"
        postconditions: "Returns non-negative integer matching stroke_paths length"

  - file: "src/ui/practice_mode.rs"
    items:
      - type: "method"
        name: "PracticeMode::initialize_animation"
        description: "Creates and configures StrokeOrderAnimation for current character"
        preconditions: "current_character is Some"
        postconditions: "animation instance is created and ready to play"
      
      - type: "method"
        name: "PracticeMode::handle_animation_message"
        description: "Processes animation control messages (play, pause, reset)"
        postconditions: "Animation state updated according to message"

  - file: "tests/stroke_animation_tests.rs"
    items:
      - type: "function"
        name: "test_parse_simple_svg_path"
        description: "Unit test: Verifies parsing of simple SVG path with M and L commands"
      
      - type: "function"
        name: "test_parse_bezier_svg_path"
        description: "Unit test: Verifies parsing of SVG path with C and S Bezier commands"
      
      - type: "function"
        name: "test_compute_line_segment_length"
        description: "Unit test: Validates length calculation for straight line segments"
      
      - type: "function"
        name: "test_compute_bezier_length_approximation"
        description: "Unit test: Checks Bezier length approximation is within tolerance"
      
      - type: "function"
        name: "test_partial_path_calculation"
        description: "Unit test: Verifies partial path at 0.0, 0.5, 1.0 progress values"
      
      - type: "function"
        name: "test_animation_state_transitions"
        description: "Integration test: Validates play/pause/reset state machine"
      
      - type: "function"
        name: "test_animation_timing"
        description: "Integration test: Verifies stroke timing and pause durations"
      
      - type: "function"
        name: "test_ease_out_cubic"
        description: "Unit test: Validates easing function boundary conditions and monotonicity"
      
      - type: "function"
        name: "prop_segment_length_non_negative"
        description: "Property test: All segment lengths are non-negative"
      
      - type: "function"
        name: "prop_partial_path_continuity"
        description: "Property test: Partial paths are continuous as progress increases"
      
      - type: "function"
        name: "prop_easing_function_bounds"
        description: "Property test: Easing function output is always in [0.0, 1.0]"

  - file: "src/utils/svg_parser.rs"
    items:
      - type: "module_declaration"
        name: "svg_parser"
        description: "Utility module for SVG path parsing functionality"
      
      - type: "struct"
        name: "PathParser"
description: "Stateful parser for SVG path data with tokenization"
      
      - type: "method"
        name: "PathParser::new"
        description: "Creates parser instance from SVG path data string"
      
      - type: "method"
        name: "PathParser::parse"
        description: "Parses entire path data into PathSegment vector"
        postconditions: "Returns Ok(Vec<PathSegment>) or Err with detailed parse error"
      
      - type: "method"
        name: "PathParser::parse_command"
        description: "Parses single SVG command with its parameters"
        preconditions: "Parser position is at valid command character"
        postconditions: "Returns parsed PathSegment or error"
      
      - type: "method"
        name: "PathParser::read_number"
        description: "Reads and parses floating point number from current position"
        postconditions: "Returns parsed f32 or parse error"
      
      - type: "method"
        name: "PathParser::skip_whitespace"
        description: "Advances parser position past whitespace and commas"
        postconditions: "Parser positioned at next non-whitespace character"
      
      - type: "enum"
        name: "ParseError"
        description: "Error types for SVG path parsing failures"
      
      - type: "enum_variant"
        name: "ParseError::UnexpectedEnd"
        description: "Unexpected end of input while parsing"
      
      - type: "enum_variant"
        name: "ParseError::InvalidCommand"
        description: "Unrecognized SVG path command character"
      
      - type: "enum_variant"
        name: "ParseError::InvalidNumber"
        description: "Failed to parse numeric parameter"
      
      - type: "enum_variant"
        name: "ParseError::MissingParameter"
        description: "Expected parameter not found for command"

formal_verification:
  needed: false
  level: "None"
  explanation: |
    Formal verification is not needed for the stroke order animation system for several reasons:
    
    1. Visual/Perceptual Domain: The primary correctness criteria are visual smoothness,
       timing feel, and aesthetic quality - properties that cannot be formally verified but
       must be validated through visual inspection and user testing.
    
    2. No Safety-Critical Requirements: Animation glitches or timing errors do not pose
       safety risks, data corruption risks, or system stability issues. The worst-case
       failure is a poorly rendered animation that can be immediately observed and fixed.
    
    3. Deterministic but Tolerance-Based: While path calculations are deterministic,
       correctness is tolerance-based (e.g., "smooth enough", "60fps target"). Formal
       verification works best with exact properties, not perceptual thresholds.
    
    4. Floating-Point Arithmetic: Extensive use of floating-point calculations for
       Bezier curves, path lengths, and animation interpolation makes formal verification
       impractical. Numerical approximation errors are acceptable within visual tolerances.
    
    5. Appropriate Testing Strategy: The mixed testing approach (unit tests for path
       parsing/calculation, property-based tests for interpolation bounds, integration tests
       for state transitions, visual inspection for quality) provides adequate confidence
       without formal methods overhead.
    
    6. Rapid Iteration Domain: Animation timing and easing require experimentation and
       user feedback. Formal verification would slow iteration on parameters that need tuning.
    
    Property-based testing is sufficient to verify invariants like:
    - Animation progress stays in [0.0, 1.0] bounds
    - Stroke sequence ordering is maintained
    - Path segment calculations don't produce NaN/Inf values
    - State transitions follow valid FSM rules
    
    These can be validated with proptest without full formal verification tooling.

tests:
  strategy:
    approach: "mixed"
    rationale:
      - "Unit tests verify SVG path parsing correctness, segment length calculations, and partial path computation which are pure, deterministic functions"
      - "Property-based tests ensure path length calculations are monotonic, continuous, and maintain invariants across different input shapes"
      - "Integration tests verify animation state machine transitions (play, pause, reset) and multi-stroke sequencing"
      - "Visual/timing tests needed for easing curves and frame timing require manual verification but we can test timing boundaries programmatically"
      - "GPU rendering via lyon is tested through iced's own test suite, we focus on animation logic and path mathematics"

  implementation:
    file: "src/animation/stroke_order.rs"
    location: "in existing test module"
    code: |
      #[cfg(test)]
      mod tests {
          use super::*;
          use iced::time::Instant;
          use std::time::Duration;

          // ============================================================================
          // Path Segment Parsing Tests
          // ============================================================================

          #[test]
          fn test_parse_simple_moveto_lineto() {
              // Parse basic SVG path: M 10,20 L 30,40
              let path_data = "M 10,20 L 30,40";
              let segments = PathSegment::parse(path_data).unwrap();
              
              assert_eq!(segments.len(), 2);
              assert!(matches!(segments[0], PathSegment::MoveTo { x: 10.0, y: 20.0 }));
              assert!(matches!(segments[1], PathSegment::LineTo { x: 30.0, y: 40.0 }));
          }

          #[test]
          fn test_parse_cubic_bezier() {
              // Parse cubic bezier: M 0,0 C 10,10 20,20 30,0
              let path_data = "M 0,0 C 10,10 20,20 30,0";
              let segments = PathSegment::parse(path_data).unwrap();
              
              assert_eq!(segments.len(), 2);
              assert!(matches!(segments[0], PathSegment::MoveTo { x: 0.0, y: 0.0 }));
              match segments[1] {
                  PathSegment::CubicBezier { x1, y1, x2, y2, x, y } => {
                      assert_eq!(x1, 10.0);
                      assert_eq!(y1, 10.0);
                      assert_eq!(x2, 20.0);
                      assert_eq!(y2, 20.0);
                      assert_eq!(x, 30.0);
                      assert_eq!(y, 0.0);
                  },
                  _ => panic!("Expected CubicBezier segment"),
              }
          }

          #[test]
          fn test_parse_smooth_cubic_bezier() {
              // Parse smooth cubic: M 0,0 C 10,10 20,20 30,0 S 50,10 60,0
              let path_data = "M 0,0 C 10,10 20,20 30,0 S 50,10 60,0";
              let segments = PathSegment::parse(path_data).unwrap();
              
              assert_eq!(segments.len(), 3);
              assert!(matches!(segments[2], PathSegment::SmoothCubic { .. }));
          }

          #[test]
          fn test_parse_quadratic_bezier() {
              // Parse quadratic: M 0,0 Q 10,10 20,0
              let path_data = "M 0,0 Q 10,10 20,0";
              let segments = PathSegment::parse(path_data).unwrap();
              
              assert_eq!(segments.len(), 2);
              match segments[1] {
                  PathSegment::QuadraticBezier { x1, y1, x, y } => {
                      assert_eq!(x1, 10.0);
                      assert_eq!(y1, 10.0);
                      assert_eq!(x, 20.0);
                      assert_eq!(y, 0.0);
                  },
                  _ => panic!("Expected QuadraticBezier segment"),
              }
          }

          #[test]
          fn test_parse_multiple_strokes() {
              // Parse multi-stroke path with move commands
              let path_data = "M 0,0 L 10,10 M 20,20 L 30,30";
              let segments = PathSegment::parse(path_data).unwrap();
              
              assert_eq!(segments.len(), 4);
              assert!(matches!(segments[0], PathSegment::MoveTo { .. }));
              assert!(matches!(segments[1], PathSegment::LineTo { .. }));
              assert!(matches!(segments[2], PathSegment::MoveTo { .. }));
              assert!(matches!(segments[3], PathSegment::LineTo { .. }));
          }

          #[test]
          fn test_parse_relative_commands() {
              // Parse relative commands: M 10,10 l 20,20 (lowercase = relative)
              let path_data = "M 10,10 l 20,20";
              let segments = PathSegment::parse(path_data).unwrap();
              
              // Relative l should be converted to absolute LineTo at (30, 30)
              assert_eq!(segments.len(), 2);
              assert!(matches!(segments[1], PathSegment::LineTo { x: 30.0, y: 30.0 }));
          }

          #[test]
          fn test_parse_invalid_path_data() {
              // Invalid SVG path should return error
              let path_data = "INVALID PATH DATA";
              let result = PathSegment::parse(path_data);
              
              assert!(result.is_err());
          }

          // ============================================================================
          // Stroke Path Length Calculation Tests
          // ============================================================================

          #[test]
          fn test_stroke_length_simple_line() {
              // Horizontal line from (0,0) to (100,0)
              let segments = vec![
                  PathSegment::MoveTo { x: 0.0, y: 0.0 },
                  PathSegment::LineTo { x: 100.0, y: 0.0 },
              ];
              let stroke = StrokePath::new(segments);
              
              assert_eq!(stroke.total_length(), 100.0);
          }

          #[test]
          fn test_stroke_length_diagonal_line() {
              // Diagonal line from (0,0) to (3,4) - length should be 5 (3-4-5 triangle)
              let segments = vec![
                  PathSegment::MoveTo { x: 0.0, y: 0.0 },
                  PathSegment::LineTo { x: 3.0, y: 4.0 },
              ];
              let stroke = StrokePath::new(segments);
              
              assert!((stroke.total_length() - 5.0).abs() < 0.001);
          }

          #[test]
          fn test_stroke_length_multi_segment() {
              // Path with multiple line segments
              let segments = vec![
                  PathSegment::MoveTo { x: 0.0, y: 0.0 },
                  PathSegment::LineTo { x: 10.0, y: 0.0 },
                  PathSegment::LineTo { x: 10.0, y: 10.0 },
                  PathSegment::LineTo { x: 0.0, y: 10.0 },
              ];
              let stroke = StrokePath::new(segments);
              
              // Total length: 10 + 10 + 10 = 30
              assert!((stroke.total_length() - 30.0).abs() < 0.001);
          }

          #[test]
          fn test_bezier_length_approximation() {
              // Simple cubic bezier - verify length is computed (not zero)
              let segments = vec![
                  PathSegment::MoveTo { x: 0.0, y: 0.0 },
                  PathSegment::CubicBezier {
                      x1: 10.0, y1: 10.0,
                      x2: 20.0, y2: 10.0,
                      x: 30.0, y: 0.0,
                  },
              ];
              let stroke = StrokePath::new(segments);
              
              // Length should be greater than straight-line distance (30)
              // but less than control polygon perimeter
              let length = stroke.total_length();
              assert!(length > 30.0);
              assert!(length < 50.0);
          }

          // ============================================================================
          // Partial Path Calculation Tests
          // ============================================================================

          #[test]
          fn test_partial_path_at_start() {
              // Partial path at progress 0.0 should be just MoveTo
              let segments = vec![
                  PathSegment::MoveTo { x: 0.0, y: 0.0 },
                  PathSegment::LineTo { x: 100.0, y: 0.0 },
              ];
              let stroke = StrokePath::new(segments);
              let partial = stroke.partial_path(0.0);
              
              assert_eq!(partial.len(), 1);
              assert!(matches!(partial[0], PathSegment::MoveTo { .. }));
          }

          #[test]
          fn test_partial_path_at_end() {
              // Partial path at progress 1.0 should be complete path
              let segments = vec![
                  PathSegment::MoveTo { x: 0.0, y: 0.0 },
                  PathSegment::LineTo { x: 100.0, y: 0.0 },
              ];
              let stroke = StrokePath::new(segments.clone());
              let partial = stroke.partial_path(1.0);
              
              assert_eq!(partial.len(), segments.len());
          }

          #[test]
          fn test_partial_path_midpoint() {
              // Partial path at progress 0.5 on simple line
              let segments = vec![
                  PathSegment::MoveTo { x: 0.0, y: 0.0 },
                  PathSegment::LineTo { x: 100.0, y: 0.0 },
              ];
              let stroke = StrokePath::new(segments);
              let partial = stroke.partial_path(0.5);
              
              // Should have MoveTo and partial LineTo to (50, 0)
              assert_eq!(partial.len(), 2);
              match partial[1] {
                  PathSegment::LineTo { x, y } => {
                      assert!((x - 50.0).abs() < 0.001);
                      assert!((y - 0.0).abs() < 0.001);
                  },
                  _ => panic!("Expected LineTo segment"),
              }
          }

          #[test]
          fn test_partial_path_continuity() {
              // Verify partial paths form continuous progression
              let segments = vec![
                  PathSegment::MoveTo { x: 0.0, y: 0.0 },
                  PathSegment::LineTo { x: 100.0, y: 100.0 },
              ];
              let stroke = StrokePath::new(segments);
              
              let partial_25 = stroke.partial_path(0.25);
              let partial_50 = stroke.partial_path(0.50);
              let partial_75 = stroke.partial_path(0.75);
              
              // Extract endpoints
              let end_25 = extract_endpoint(&partial_25);
              let end_50 = extract_endpoint(&partial_50);
              let end_75 = extract_endpoint(&partial_75);
              
              // Verify monotonic progression
              assert!(end_25.0 < end_50.0);
              assert!(end_50.0 < end_75.0);
              assert!(end_25.1 < end_50.1);
              assert!(end_50.1 < end_75.1);
          }

          // Helper function to extract endpoint from path segments
          fn extract_endpoint(segments: &[PathSegment]) -> (f32, f32) {
              match segments.last() {
                  Some(PathSegment::LineTo { x, y }) => (*x, *y),
                  Some(PathSegment::CubicBezier { x, y, .. }) => (*x, *y),
                  Some(PathSegment::QuadraticBezier { x, y, .. }) => (*x, *y),
                  Some(PathSegment::MoveTo { x, y }) => (*x, *y),
                  _ => (0.0, 0.0),
              }
          }

          // ============================================================================
          // Animation State Machine Tests
          // ============================================================================

          #[test]
          fn test_animation_initial_state() {
              let strokes = vec![create_simple_stroke()];
              let animation = StrokeOrderAnimation::new(strokes);
              
              assert_eq!(animation.current_state(), AnimationState::Idle);
              assert_eq!(animation.current_stroke_index(), 0);
              assert_eq!(animation.current_progress(), 0.0);
          }

          #[test]
          fn test_animation_play_transition() {
              let strokes = vec![create_simple_stroke()];
              let mut animation = StrokeOrderAnimation::new(strokes);
              
              animation.play();
              
              assert_eq!(animation.current_state(), AnimationState::Playing);
          }

          #[test]
          fn test_animation_pause_transition() {
              let strokes = vec![create_simple_stroke()];
              let mut animation = StrokeOrderAnimation::new(strokes);
              
              animation.play();
              animation.pause();
              
              assert_eq!(animation.current_state(), AnimationState::Paused);
          }

          #[test]
          fn test_animation_reset() {
              let strokes = vec![create_simple_stroke()];
              let mut animation = StrokeOrderAnimation::new(strokes);
              
              animation.play();
              animation.update(Duration::from_millis(300));
              animation.reset();
              
              assert_eq!(animation.current_state(), AnimationState::Idle);
              assert_eq!(animation.current_stroke_index(), 0);
              assert_eq!(animation.current_progress(), 0.0);
          }

          #[test]
          fn test_animation_single_stroke_completion() {
              let strokes = vec![create_simple_stroke()];
              let mut animation = StrokeOrderAnimation::new(strokes);
              animation.set_stroke_duration(Duration::from_millis(500));
              
              animation.play();
              
              // Update past stroke duration
              animation.update(Duration::from_millis(600));
              
              assert_eq!(animation.current_state(), AnimationState::Completed);
              assert_eq!(animation.current_progress(), 1.0);
          }

          #[test]
          fn test_animation_multi_stroke_sequencing() {
              let strokes = vec![
                  create_simple_stroke(),
                  create_simple_stroke(),
                  create_simple_stroke(),
              ];
              let mut animation = StrokeOrderAnimation::new(strokes);
              animation.set_stroke_duration(Duration::from_millis(500));
              animation.set_pause_duration(Duration::from_millis(200));
              
              animation.play();
              
              // First stroke in progress
              animation.update(Duration::from_millis(250));
              assert_eq!(animation.current_stroke_index(), 0);
              assert!(animation.current_progress() > 0.0 && animation.current_progress() < 1.0);
              
              // First stroke complete, in pause
              animation.update(Duration::from_millis(300)); // Total: 550ms
              assert_eq!(animation.current_stroke_index(), 0);
              assert_eq!(animation.current_progress(), 1.0);
              
              // Second stroke in progress
              animation.update(Duration::from_millis(250)); // Total: 800ms (past pause)
              assert_eq!(animation.current_stroke_index(), 1);
              assert!(animation.current_progress() > 0.0);
              
              // Complete all strokes
              animation.update(Duration::from_millis(2000)); // Total: well past end
              assert_eq!(animation.current_state(), AnimationState::Completed);
              assert_eq!(animation.current_stroke_index(), 2);
          }

          #[test]
          fn test_animation_timing_accuracy() {
              let strokes = vec![create_simple_stroke()];
              let mut animation = StrokeOrderAnimation::new(strokes);
              let duration = Duration::from_millis(600);
              animation.set_stroke_duration(duration);
              
              animation.play();
              
              // At 50% of duration, progress should be approximately 0.5
              // (accounting for easing curve deviation)
              animation.update(Duration::from_millis(300));
              let progress = animation.current_progress();
              
              // With EaseOutCubic, midpoint won't be exactly 0.5, but should be in range
              assert!(progress > 0.3 && progress < 0.7);
          }

          #[test]
          fn test_animation_pause_resume_preserves_progress() {
              let strokes = vec![create_simple_stroke()];
              let mut animation = StrokeOrderAnimation::new(strokes);
              animation.set_stroke_duration(Duration::from_millis(1000));
              
              animation.play();
              animation.update(Duration::from_millis(400));
              let progress_before_pause = animation.current_progress();
              
              animation.pause();
              animation.update(Duration::from_millis(500)); // Time passes while paused
              
              animation.play();
              let progress_after_resume = animation.current_progress();
              
              // Progress should be preserved across pause/resume
              assert!((progress_before_pause - progress_after_resume).abs() < 0.001);
          }

          // ============================================================================
          // Stroke Rendering State Tests
          // ============================================================================

          #[test]
          fn test_completed_strokes_identification() {
              let strokes = vec![
                  create_simple_stroke(),
                  create_simple_stroke(),
                  create_simple_stroke(),
              ];
              let mut animation = StrokeOrderAnimation::new(strokes);
              animation.set_stroke_duration(Duration::from_millis(500));
              animation.set_pause_duration(Duration::from_millis(200));
              
              animation.play();
              animation.update(Duration::from_millis(1500)); // Complete first stroke + pause + partway through second
              
              let completed = animation.completed_stroke_indices();
              assert_eq!(completed.len(), 1);
              assert_eq!(completed[0], 0);
          }

          #[test]
          fn test_current_animating_stroke() {
              let strokes = vec![
                  create_simple_stroke(),
                  create_simple_stroke(),
              ];
              let mut animation = StrokeOrderAnimation::new(strokes);
              animation.set_stroke_duration(Duration::from_millis(500));
              
              animation.play();
              animation.update(Duration::from_millis(250));
              
              let (current_idx, progress) = animation.current_animating_stroke();
              assert_eq!(current_idx, 0);
              assert!(progress > 0.0 && progress < 1.0);
          }

          #[test]
          fn test_stroke_color_state() {
              let strokes = vec![
                  create_simple_stroke(),
                  create_simple_stroke(),
              ];
              let mut animation = StrokeOrderAnimation::new(strokes);
              animation.set_stroke_duration(Duration::from_millis(500));
              animation.set_pause_duration(Duration::from_millis(200));
              
              animation.play();
              animation.update(Duration::from_millis(900)); // First complete, second animating
              
              // First stroke should be black (complete)
              assert_eq!(animation.stroke_color(0), StrokeColor::Complete);
              
              // Second stroke should be blue (animating)
              assert_eq!(animation.stroke_color(1), StrokeColor::Animating);
          }

          // ============================================================================
          // Configuration Tests
          // ============================================================================

          #[test]
          fn test_configurable_stroke_duration() {
              let strokes = vec![create_simple_stroke()];
              let mut animation = StrokeOrderAnimation::new(strokes);
              
              animation.set_stroke_duration(Duration::from_millis(800));
              
              animation.play();
              animation.update(Duration::from_millis(400));
              
              // Should be approximately halfway (accounting for easing)
              let progress = animation.current_progress();
              assert!(progress > 0.3 && progress < 0.7);
          }

          #[test]
          fn test_configurable_pause_duration() {
              let strokes = vec![create_simple_stroke(), create_simple_stroke()];
              let mut animation = StrokeOrderAnimation::new(strokes);
              animation.set_stroke_duration(Duration::from_millis(500));
              animation.set_pause_duration(Duration::from_millis(300));
              
              animation.play();
              
              // Complete first stroke
              animation.update(Duration::from_millis(500));
              assert_eq!(animation.current_stroke_index(), 0);
              
              // Still in pause
              animation.update(Duration::from_millis(150)); // Total: 650ms
              assert_eq!(animation.current_stroke_index(), 0);
              
              // Past pause, into second stroke
              animation.update(Duration::from_millis(200)); // Total: 850ms
              assert_eq!(animation.current_stroke_index(), 1);
          }

          #[test]
          fn test_total_animation_duration() {
              let strokes = vec![
                  create_simple_stroke(),
                  create_simple_stroke(),
                  create_simple_stroke(),
              ];
              let animation = StrokeOrderAnimation::new(strokes);
              
              // 3 strokes * 600ms + 2 pauses * 250ms = 2300ms
              let expected = Duration::from_millis(2300);
              assert_eq!(animation.total_duration(), expected);
          }

          // ============================================================================
          // Helper Functions
          // ============================================================================

          fn create_simple_stroke() -> StrokePath {
              let segments = vec![
                  PathSegment::MoveTo { x: 0.0, y: 0.0 },
                  PathSegment::LineTo { x: 100.0, y: 100.0 },
              ];
              StrokePath::new(segments)
          }
      }

      // ============================================================================
      // Property-Based Tests
      // ============================================================================

      #[cfg(test)]
      mod property_tests {
          use super::*;
          use proptest::prelude::*;

          proptest! {
              #[test]
              fn prop_partial_path_length_monotonic(progress in 0.0f32..1.0f32) {
                  // Property: Partial path length increases monotonically with progress
                  let segments = vec![
                      PathSegment::MoveTo { x: 0.0, y: 0.0 },
                      PathSegment::LineTo { x: 100.0, y: 0.0 },
                  ];
                  let stroke = StrokePath::new(segments);
                  
                  let partial = stroke.partial_path(progress);
                  let partial_length = calculate_path_length(&partial);
                  let expected_length = stroke.total_length() * progress;
                  
                  // Should be approximately equal (within numerical precision)
                  prop_assert!((partial_length - expected_length).abs() < 1.0);
              }

              #[test]
              fn prop_progress_always_in_bounds(elapsed_ms in 0u64..5000u64) {
                  // Property: Animation progress always stays in [0.0, 1.0]
                  let strokes = vec![
                      create_simple_stroke(),
                      create_simple_stroke(),
                  ];
                  let mut animation = StrokeOrderAnimation::new(strokes);
                  animation.play();
                  
                  animation.update(Duration::from_millis(elapsed_ms));
                  let progress = animation.current_progress();
                  
                  prop_assert!(progress >= 0.0 && progress <= 1.0);
              }

              #[test]
              fn prop_stroke_index_never_exceeds_count(elapsed_ms in 0u64..10000u64) {
                  // Property: Current stroke index never exceeds stroke count
                  let strokes = vec![
                      create_simple_stroke(),
                      create_simple_stroke(),
                      create_simple_stroke(),
                  ];
                  let stroke_count = strokes.len();
                  let mut animation = StrokeOrderAnimation::new(strokes);
                  animation.play();
                  
                  animation.update(Duration::from_millis(elapsed_ms));
                  let index = animation.current_stroke_index();
                  
                  prop_assert!(index < stroke_count);
              }

              #[test]
              fn prop_pause_resume_idempotent(pause_count in 1usize..5usize) {
                  // Property: Multiple pause/resume cycles don't affect final state
                  let strokes = vec![create_simple_stroke()];
                  let mut animation = StrokeOrderAnimation::new(strokes);
                  animation.play();
                  
                  for _ in 0..pause_count {
                      animation.pause();
                      animation.play();
                  }
                  
                  animation.update(Duration::from_millis(1000));
                  
                  // Should reach completed state regardless of pause cycles
                  prop_assert_eq!(animation.current_state(), AnimationState::Completed);
              }

              #[test]
              fn prop_line_segment_length_euclidean(x1 in -1000.0f32..1000.0f32, 
                                                     y1 in -1000.0f32..1000.0f32,
                                                     x2 in -1000.0f32..1000.0f32,
                                                     y2 in -1000.0f32..1000.0f32) {
                  // Property: Line segment length equals Euclidean distance
                  let segments = vec![
                      PathSegment::MoveTo { x: x1, y: y1 },
                      PathSegment::LineTo { x: x2, y: y2 },
                  ];
                  let stroke = StrokePath::new(segments);
                  
                  let expected = ((x2 - x1).powi(2) + (y2 - y1).powi(2)).sqrt();
                  let actual = stroke.total_length();
                  
                  prop_assert!((actual - expected).abs() < 0.01);
              }
          }

          fn create_simple_stroke() -> StrokePath {
              let segments = vec![
                  PathSegment::MoveTo { x: 0.0, y: 0.0 },
                  PathSegment::LineTo { x: 100.0, y: 100.0 },
              ];
              StrokePath::new(segments)
          }

          fn calculate_path_length(segments: &[PathSegment]) -> f32 {
              let mut length = 0.0;
              let mut current_pos = (0.0, 0.0);
              
              for segment in segments {
                  match segment {
                      PathSegment::MoveTo { x, y } => {
                          current_pos = (*x, *y);
                      },
                      PathSegment::LineTo { x, y } => {
                          let dx = x - current_pos.0;
                          let dy = y - current_pos.1;
                          length += (dx * dx + dy * dy).sqrt();
                          current_pos = (*x, *y);
                      },
                      _ => {}, // Simplified for property testing
                  }
              }
              
              length
          }
      }

  coverage:
    - "SVG path parsing for MoveTo commands"
    - "SVG path parsing for LineTo commands"
    - "SVG path parsing for CubicBezier curves"
    - "SVG path parsing for SmoothCubic curves"
    - "SVG path parsing for QuadraticBezier curves"
    - "SVG path parsing for multiple strokes"
    - "SVG path parsing for relative commands"
    - "SVG path parsing error handling for invalid input"
    - "Stroke length calculation for simple horizontal lines"
    - "Stroke length calculation for diagonal lines"
    - "Stroke length calculation for multi-segment paths"
    - "Bezier curve length approximation accuracy"
    - "Partial path calculation at animation start (progress = 0.0)"
    - "Partial path calculation at animation end (progress = 1.0)"
    - "Partial path calculation at midpoint (progress = 0.5)"
    - "Partial path continuity across progress values"
    - "Animation state machine initial state (Idle)"
    - "Animation state transition from Idle to Playing"
    - "Animation state transition from Playing to Paused"
    - "Animation reset functionality"
    - "Single stroke animation completion"
    - "Multi-stroke sequential animation"
    - "Animation timing accuracy with easing curves"
    - "Pause/resume progress preservation"
    - "Completed strokes identification during animation"
    - "Current animating stroke tracking"
    - "Stroke color state differentiation (complete vs animating)"
    - "Configurable stroke duration"
    - "Configurable pause duration between strokes"
    - "Total animation duration calculation"
    - "Property: Partial path length monotonicity"
    - "Property: Animation progress bounds [0.0, 1.0]"
    - "Property: Stroke index bounds checking"
    - "Property: Pause/resume idempotence"
    - "Property: Line segment Euclidean distance correctness"

dependencies:
  depends_on:
    - task_id: 1
      reason: "Needs Canvas widget support from iced foundation"
    - task_id: 2
      reason: "Requires stroke path data from character database"

  depended_upon_by:
    - task_id: 8
      reason: "Practice mode uses stroke animation for teaching"

  external:
    - name: "iced::widget::canvas"
      type: "module"
      status: "already exists"
    - name: "iced::widget::canvas::Program"
      type: "trait"
      status: "already exists"
    - name: "lyon::path::Path"
      type: "struct"
      status: "already exists"
    - name: "lyon::tessellation"
      type: "module"
      status: "already exists"
    - name: "std::time::Duration"
      type: "struct"
      status: "already exists"
    - name: "std::time::Instant"
      type: "struct"
      status: "already exists"
---
task:
  id: 5
  name: "Handwriting Canvas and Input System"

context:
  description: |
    This task implements the core handwriting input system for the Chinese character
    learning application. It provides an interactive canvas widget that captures user
    drawing input through mouse or touch interactions, records stroke sequences with
    precise timing information, and renders strokes with smooth anti-aliased paths.
    
    The canvas serves as the primary interface for handwriting practice exercises,
    enabling users to trace characters, practice stroke order, and generate handwriting
    samples for recognition validation. The system must feel responsive and natural,
    with smooth rendering and appropriate point sampling to balance data quality with
    performance.
    
    Built on iced's canvas::Program trait, the implementation maintains a clean state
    machine for drawing interactions (idle → drawing → stroke complete) and exports
    normalized stroke data suitable for character recognition systems. The architecture
    supports both freehand practice mode and stroke-order-enforced tracing exercises
    through optional guide image overlays.

  key_points:
    - "Implements iced::canvas::Program for event-driven drawing with proper state management"
    - "Applies 2px distance threshold between points to reduce noise while maintaining stroke fidelity"
    - "Uses round line caps and joins with anti-aliasing for natural handwriting appearance"
    - "Normalizes coordinates to [0,1] range for device-independent recognition input"
    - "Records timestamps for each point enabling future velocity-based recognition enhancements"
    - "Provides clear visual differentiation between active drawing and completed strokes"
    - "Supports undo/clear operations for iterative practice workflow"
    - "Exports stroke data in format compatible with recognition system (Task 9)"

files:
  - path: "src/ui/handwriting_canvas.rs"
    description: "Core handwriting canvas widget implementing iced::canvas::Program for interactive drawing with stroke capture and rendering"
  
  - path: "src/ui/drawing_state.rs"
    description: "Drawing state management for stroke history, current stroke tracking, and canvas interaction state"
  
  - path: "src/models/stroke.rs"
    description: "Stroke data structure representing a sequence of points with timestamps for handwriting recognition"
  
  - path: "src/ui/mod.rs"
    description: "UI module declarations - add handwriting_canvas and drawing_state module exports"
  
  - path: "src/models/mod.rs"
    description: "Models module declarations - add stroke module export"

functions:
  - file: "src/ui/handwriting_canvas.rs"
    items:
      - type: "module_declaration"
        name: "ui::handwriting_canvas"
        description: "Module containing handwriting canvas widget and drawing state management"
      
      - type: "struct"
        name: "HandwritingCanvas"
        description: "Main canvas widget that implements iced::canvas::Program for interactive drawing"
        invariants: "Always maintains valid DrawingState reference"
      
      - type: "struct"
        name: "DrawingState"
        description: "Maintains stroke history, current drawing state, and canvas configuration"
        invariants: "Stroke history order is preserved; current_stroke is Some only when actively drawing"
      
      - type: "struct"
        name: "Stroke"
        description: "Represents a single stroke as a sequence of normalized points with timestamp"
        invariants: "Points are in chronological order; all coordinates normalized to 0-1 range; timestamp is monotonically increasing"
      
      - type: "struct"
        name: "Point"
        description: "A single point in a stroke with x, y coordinates and timestamp"
        invariants: "x and y coordinates are normalized to 0-1 range; timestamp is non-negative"
      
      - type: "enum"
        name: "CanvasMessage"
        description: "Messages for canvas interaction events (start stroke, add point, end stroke, clear, undo)"
      
      - type: "enum_variant"
        name: "CanvasMessage::StartStroke"
        description: "Signals the beginning of a new stroke at given position"
      
      - type: "enum_variant"
        name: "CanvasMessage::AddPoint"
        description: "Adds a point to the current stroke if distance threshold is met"
      
      - type: "enum_variant"
        name: "CanvasMessage::EndStroke"
        description: "Completes the current stroke and adds it to history"
      
      - type: "enum_variant"
        name: "CanvasMessage::Clear"
        description: "Clears all strokes from the canvas"
      
      - type: "enum_variant"
        name: "CanvasMessage::Undo"
        description: "Removes the most recent stroke from history"
      
      - type: "function"
        name: "HandwritingCanvas::new"
        description: "Creates a new handwriting canvas with default or specified dimensions"
        postconditions: "Returns HandwritingCanvas with empty DrawingState"
      
      - type: "function"
        name: "HandwritingCanvas::with_guide_image"
        description: "Creates a canvas with an optional guide image for tracing practice"
        postconditions: "Returns HandwritingCanvas configured with guide image overlay"
      
      - type: "method"
        name: "HandwritingCanvas::view"
        description: "Creates the iced widget view of the canvas"
        postconditions: "Returns iced::Element containing canvas widget"
      
      - type: "method"
        name: "HandwritingCanvas::get_strokes"
        description: "Exports captured stroke data as Vec<Vec<Point>>"
        postconditions: "Returns deep copy of all completed strokes in chronological order"
      
      - type: "method"
        name: "HandwritingCanvas::clear"
        description: "Removes all strokes from the canvas"
        postconditions: "DrawingState contains no strokes; current_stroke is None"
      
      - type: "trait_impl"
        name: "canvas::Program for HandwritingCanvas"
        description: "Implementation of iced canvas::Program trait for drawing interaction"
      
      - type: "method"
        name: "canvas::Program::update"
        description: "Handles canvas events (mouse/touch input) and updates drawing state"
        preconditions: "Valid event from iced framework"
        postconditions: "DrawingState updated according to event type; redraw requested if state changed"
      
      - type: "method"
        name: "canvas::Program::draw"
        description: "Renders all strokes and current drawing to canvas frame"
        postconditions: "All completed strokes rendered with one visual style; current stroke rendered with distinct visual style"
      
      - type: "method"
        name: "canvas::Program::mouse_interaction"
        description: "Returns appropriate cursor style based on canvas state"
        postconditions: "Returns Crosshair cursor when hovering over canvas"
      
      - type: "function"
        name: "DrawingState::new"
        description: "Creates empty drawing state with specified canvas dimensions"
        postconditions: "Returns DrawingState with empty stroke history and no current stroke"
      
      - type: "method"
        name: "DrawingState::start_stroke"
        description: "Begins a new stroke at the given canvas position"
        preconditions: "No current stroke is in progress"
        postconditions: "current_stroke is Some with initial point; timestamp recorded"
      
      - type: "method"
        name: "DrawingState::add_point"
        description: "Adds a point to current stroke if distance threshold is met"
        preconditions: "current_stroke is Some (stroke in progress)"
        postconditions: "Point added to current_stroke if distance from last point >= threshold; timestamp recorded"
      
      - type: "method"
        name: "DrawingState::end_stroke"
        description: "Completes current stroke and moves it to stroke history"
        preconditions: "current_stroke is Some with at least one point"
        postconditions: "current_stroke moved to completed_strokes; current_stroke is None; callback invoked if registered"
      
      - type: "method"
        name: "DrawingState::clear_all"
        description: "Removes all strokes from history and cancels current stroke"
        postconditions: "completed_strokes is empty; current_stroke is None"
      
      - type: "method"
        name: "DrawingState::undo_last"
        description: "Removes the most recently completed stroke"
        postconditions: "Last stroke removed from completed_strokes if any existed"
      
      - type: "method"
        name: "DrawingState::normalize_point"
        description: "Converts canvas pixel coordinates to normalized 0-1 range"
        preconditions: "Canvas dimensions are positive"
        postconditions: "Returns Point with x, y in range [0.0, 1.0]"
      
      - type: "method"
        name: "DrawingState::should_add_point"
        description: "Checks if new point meets distance threshold from last point"
        preconditions: "current_stroke has at least one existing point"
        postconditions: "Returns true if distance >= DISTANCE_THRESHOLD (2px), false otherwise"
      
      - type: "function"
        name: "Stroke::new"
        description: "Creates a new stroke with initial point and timestamp"
        postconditions: "Returns Stroke with one point and start timestamp"
      
      - type: "method"
        name: "Stroke::add_point"
        description: "Appends a point to the stroke sequence"
        postconditions: "Point added to end of points vector; timestamps are monotonically increasing"
      
      - type: "method"
        name: "Stroke::to_path"
        description: "Converts stroke points to iced::canvas::Path for rendering"
        preconditions: "Stroke contains at least one point"
        postconditions: "Returns Path with smooth line segments connecting all points"
      
      - type: "method"
        name: "Stroke::get_normalized_points"
        description: "Returns the normalized point sequence for recognition"
        postconditions: "Returns Vec<Point> where all coordinates are in range [0.0, 1.0]"
      
      - type: "constant"
        name: "DISTANCE_THRESHOLD"
        description: "Minimum pixel distance between consecutive points (2.0px) to reduce noise"
      
      - type: "constant"
        name: "DEFAULT_CANVAS_SIZE"
        description: "Default canvas dimensions (200x200px)"
      
      - type: "constant"
        name: "STROKE_WIDTH"
        description: "Width of rendered strokes in pixels (2.0px for completed, 2.5px for current)"
      
      - type: "function"
        name: "render_stroke"
        description: "Helper function to render a single stroke with specified style"
        preconditions: "Stroke contains at least 2 points for visible line"
        postconditions: "Stroke rendered to frame with round caps/joins and anti-aliasing"
      
      - type: "function"
        name: "calculate_distance"
        description: "Calculates Euclidean distance between two points"
        postconditions: "Returns non-negative distance value"

  - file: "src/ui/mod.rs"
    items:
      - type: "module_declaration"
        name: "pub mod handwriting_canvas"
        description: "Exports handwriting_canvas module from ui module"

  - file: "tests/handwriting_canvas_tests.rs"
    items:
      - type: "function"
        name: "test_stroke_creation_and_point_addition"
        description: "Tests creating a stroke and adding points maintains order and timestamps"
      
      - type: "function"
        name: "test_distance_threshold_filtering"
        description: "Verifies that points below distance threshold are not added"
      
      - type: "function"
        name: "test_stroke_normalization"
        description: "Tests that coordinates are properly normalized to 0-1 range"
      
      - type: "function"
        name: "test_drawing_state_lifecycle"
        description: "Tests complete drawing lifecycle: start stroke, add points, end stroke"
      
      - type: "function"
        name: "test_clear_and_undo_operations"
        description: "Verifies clear removes all strokes and undo removes last stroke"
      
      - type: "function"
        name: "test_multiple_stroke_sequence"
        description: "Tests that multiple strokes are maintained in correct chronological order"
      
      - type: "function"
        name: "test_stroke_export"
        description: "Verifies get_strokes returns correct data structure for recognition"
      
      - type: "function"
        name: "test_canvas_event_handling"
        description: "Integration test simulating mouse events through canvas::Program"

formal_verification:
  needed: false
  level: "None"
  explanation: |
    Formal verification is not required for the handwriting canvas input system because:
    
    1. UI Interaction Domain: This task primarily deals with user input capture and 
       visual rendering, which are inherently non-deterministic and depend on external 
       user actions. Formal verification is most valuable for algorithmic correctness 
       and safety-critical systems, not interactive UI components.
    
    2. Testing Sufficiency: The correctness properties that matter (stroke continuity, 
       point sampling consistency, proper event state machine transitions) are effectively 
       verifiable through integration testing with simulated mouse events. The acceptance 
       criteria can be thoroughly validated through standard testing approaches.
    
    3. Low Criticality: Drawing input errors (e.g., missed points, visual glitches) 
       result in poor user experience but pose no safety risks, data corruption threats, 
       or system stability issues. Users can simply clear and redraw strokes.
    
    4. Simple State Machine: The drawing state machine (not drawing → drawing → 
       stroke complete) is straightforward with clear transitions. The complexity is 
       low enough that code review and integration tests provide adequate assurance.
    
    5. Framework Dependencies: The task relies heavily on iced's canvas::Program 
       trait and event handling, which are external dependencies already tested by the 
       framework. Formal verification would need to extend to these dependencies to be 
       meaningful, which is impractical.
    
    The medium complexity and integration risks noted in the task are appropriately 
    addressed through the planned integration testing strategy with 6 tests covering 
    critical properties like stroke continuity and point sampling.

tests:
  strategy:
    approach: "mixed (unit tests + integration tests + property-based tests)"
    rationale:
      - "Unit tests verify core data structures (Stroke, Point) and utility functions (normalization, distance threshold) in isolation"
      - "Integration tests verify the canvas event handling state machine with simulated mouse/touch events"
      - "Mock-basedintegration tests validate stroke completion callbacks and data export format"
      - "Property-based testing ensures distance threshold and normalization maintain mathematical invariants"
      - "Visual rendering validation through snapshot testing or render verification (optional for CI)"
      - "Touch and mouse input require separate integration test scenarios to ensure cross-platform compatibility"

  implementation:
    file: "src/ui/handwriting_canvas.rs"
    location: "in existing test module"
    code: |
      #[cfg(test)]
      mod tests {
          use super::*;
          use iced::Point as IcedPoint;
          use std::time::{Duration, Instant};

          fn point(x: f32, y: f32) -> Point {
              Point { x, y, timestamp: Instant::now() }
          }

          fn create_stroke(points: Vec<(f32, f32)>) -> Stroke {
              let base_time = Instant::now();
              Stroke {
                  points: points.into_iter().enumerate().map(|(i, (x, y))| Point {
                      x,
                      y,
                      timestamp: base_time + Duration::from_millis(i as u64 * 10),
                  }).collect(),
              }
          }

          #[test]
          fn test_stroke_creation_empty() {
              let stroke = Stroke { points: vec![] };
              assert_eq!(stroke.points.len(), 0);
          }

          #[test]
          fn test_stroke_creation_with_points() {
              let stroke = create_stroke(vec![(10.0, 20.0), (30.0, 40.0), (50.0, 60.0)]);
              assert_eq!(stroke.points.len(), 3);
              assert_eq!(stroke.points[0].x, 10.0);
              assert_eq!(stroke.points[0].y, 20.0);
              assert_eq!(stroke.points[2].x, 50.0);
              assert_eq!(stroke.points[2].y, 60.0);
          }

          #[test]
          fn test_distance_threshold_filters_close_points() {
              let mut state = DrawingState::new();
              state.start_stroke(IcedPoint::new(10.0, 10.0));
              
              state.add_point(IcedPoint::new(10.5, 10.5));
              assert_eq!(state.current_stroke.as_ref().unwrap().points.len(), 1);
              
              state.add_point(IcedPoint::new(15.0, 15.0));
              assert_eq!(state.current_stroke.as_ref().unwrap().points.len(), 2);
          }

          #[test]
          fn test_distance_threshold_calculation() {
              let p1 = IcedPoint::new(0.0, 0.0);
              let p2 = IcedPoint::new(3.0, 4.0);
              let distance = ((p2.x - p1.x).powi(2) + (p2.y - p1.y).powi(2)).sqrt();
              assert_eq!(distance, 5.0);
              assert!(distance > 2.0);
          }

          #[test]
          fn test_normalize_coordinates_to_unit_square() {
              let stroke = create_stroke(vec![
                  (0.0, 0.0),
                  (100.0, 0.0),
                  (100.0, 200.0),
                  (0.0, 200.0),
              ]);
              
              let normalized = stroke.normalize(100.0, 200.0);
              
              assert_eq!(normalized[0].x, 0.0);
              assert_eq!(normalized[0].y, 0.0);
              assert_eq!(normalized[1].x, 1.0);
              assert_eq!(normalized[1].y, 0.0);
              assert_eq!(normalized[2].x, 1.0);
              assert_eq!(normalized[2].y, 1.0);
              assert_eq!(normalized[3].x, 0.0);
              assert_eq!(normalized[3].y, 1.0);
          }

          #[test]
          fn test_normalize_handles_zero_dimensions() {
              let stroke = create_stroke(vec![(50.0, 50.0)]);
              let normalized = stroke.normalize(100.0, 100.0);
              assert_eq!(normalized[0].x, 0.5);
              assert_eq!(normalized[0].y, 0.5);
          }

          #[test]
          fn test_drawing_state_machine_initialization() {
              let state = DrawingState::new();
              assert!(state.current_stroke.is_none());
              assert_eq!(state.completed_strokes.len(), 0);
              assert!(!state.is_drawing());
          }

          #[test]
          fn test_drawing_state_machine_start_stroke() {
              let mut state = DrawingState::new();
              state.start_stroke(IcedPoint::new(10.0, 20.0));
              
              assert!(state.is_drawing());
              assert!(state.current_stroke.is_some());
              assert_eq!(state.current_stroke.as_ref().unwrap().points.len(), 1);
              assert_eq!(state.completed_strokes.len(), 0);
          }

          #[test]
          fn test_drawing_state_machine_complete_stroke() {
              let mut state = DrawingState::new();
              state.start_stroke(IcedPoint::new(10.0, 20.0));
              state.add_point(IcedPoint::new(30.0, 40.0));
              state.end_stroke();
              
              assert!(!state.is_drawing());
              assert!(state.current_stroke.is_none());
              assert_eq!(state.completed_strokes.len(), 1);
              assert_eq!(state.completed_strokes[0].points.len(), 2);
          }

          #[test]
          fn test_drawing_state_machine_multiple_strokes() {
              let mut state = DrawingState::new();
              
              state.start_stroke(IcedPoint::new(10.0, 10.0));
              state.add_point(IcedPoint::new(20.0, 20.0));
              state.end_stroke();
              
              state.start_stroke(IcedPoint::new(30.0, 30.0));
              state.add_point(IcedPoint::new(40.0, 40.0));
              state.end_stroke();
              
              assert_eq!(state.completed_strokes.len(), 2);
              assert_eq!(state.completed_strokes[0].points.len(), 2);
              assert_eq!(state.completed_strokes[1].points.len(), 2);
          }

          #[test]
          fn test_clear_removes_all_strokes() {
              let mut state = DrawingState::new();
              state.start_stroke(IcedPoint::new(10.0, 10.0));
              state.add_point(IcedPoint::new(20.0, 20.0));
              state.end_stroke();
              state.start_stroke(IcedPoint::new(30.0, 30.0));
              state.end_stroke();
              
              state.clear();
              
              assert_eq!(state.completed_strokes.len(), 0);
              assert!(state.current_stroke.is_none());
              assert!(!state.is_drawing());
          }

          #[test]
          fn test_undo_removes_last_completed_stroke() {
              let mut state = DrawingState::new();
              
              state.start_stroke(IcedPoint::new(10.0, 10.0));
              state.end_stroke();
              state.start_stroke(IcedPoint::new(20.0, 20.0));
              state.end_stroke();
              
              assert_eq!(state.completed_strokes.len(), 2);
              
              state.undo();
              assert_eq!(state.completed_strokes.len(), 1);
              
              state.undo();
              assert_eq!(state.completed_strokes.len(), 0);
          }

          #[test]
          fn test_undo_does_not_affect_current_stroke() {
              let mut state = DrawingState::new();
              state.start_stroke(IcedPoint::new(10.0, 10.0));
              state.add_point(IcedPoint::new(20.0, 20.0));
              
              state.undo();
              
              assert!(state.is_drawing());
              assert_eq!(state.current_stroke.as_ref().unwrap().points.len(), 2);
          }

          #[test]
          fn test_export_stroke_data_empty() {
              let state = DrawingState::new();
              let exported = state.export_strokes();
              assert_eq!(exported.len(), 0);
          }

          #[test]
          fn test_export_stroke_data_multiple_strokes() {
              let mut state = DrawingState::new();
              
              state.start_stroke(IcedPoint::new(10.0, 10.0));
              state.add_point(IcedPoint::new(20.0, 20.0));
              state.end_stroke();
              
              state.start_stroke(IcedPoint::new(30.0, 30.0));
              state.add_point(IcedPoint::new(40.0, 40.0));
              state.add_point(IcedPoint::new(50.0, 50.0));
              state.end_stroke();
              
              let exported = state.export_strokes();
              assert_eq!(exported.len(), 2);
              assert_eq!(exported[0].len(), 2);
              assert_eq!(exported[1].len(), 3);
          }

          #[test]
          fn test_export_normalized_stroke_data() {
              let mut state = DrawingState::new();
              state.start_stroke(IcedPoint::new(0.0, 0.0));
              state.add_point(IcedPoint::new(200.0, 200.0));
              state.end_stroke();
              
              let normalized = state.export_normalized_strokes(200.0, 200.0);
              assert_eq!(normalized.len(), 1);
              assert_eq!(normalized[0][0].x, 0.0);
              assert_eq!(normalized[0][0].y, 0.0);
              assert_eq!(normalized[0][1].x, 1.0);
              assert_eq!(normalized[0][1].y, 1.0);
          }

          #[test]
          fn test_stroke_timestamps_are_sequential() {
              let mut state = DrawingState::new();
              let start = Instant::now();
              
              state.start_stroke(IcedPoint::new(10.0, 10.0));
              std::thread::sleep(Duration::from_millis(5));
              state.add_point(IcedPoint::new(20.0, 20.0));
              std::thread::sleep(Duration::from_millis(5));
              state.add_point(IcedPoint::new(30.0, 30.0));
              state.end_stroke();
              
              let stroke = &state.completed_strokes[0];
              assert!(stroke.points[0].timestamp >= start);
              assert!(stroke.points[1].timestamp > stroke.points[0].timestamp);
              assert!(stroke.points[2].timestamp > stroke.points[1].timestamp);
          }

          #[test]
          fn test_stroke_velocity_calculation() {
              let stroke = create_stroke(vec![(0.0, 0.0), (100.0, 0.0)]);
              let p1 = &stroke.points[0];
              let p2 = &stroke.points[1];
              
              let distance = ((p2.x - p1.x).powi(2) + (p2.y - p1.y).powi(2)).sqrt();
              let time_diff = p2.timestamp.duration_since(p1.timestamp).as_secs_f32();
              let velocity = distance / time_diff;
              
              assert!(velocity > 0.0);
              assert!(velocity.is_finite());
          }

          #[test]
          fn test_canvas_bounds_clamping() {
              let canvas_width = 200.0;
              let canvas_height = 200.0;
              
              let point = IcedPoint::new(250.0, -10.0);
              let clamped = IcedPoint::new(
                  point.x.max(0.0).min(canvas_width),
                  point.y.max(0.0).min(canvas_height),
              );
              
              assert_eq!(clamped.x, 200.0);
              assert_eq!(clamped.y, 0.0);
          }

          #[test]
          fn test_stroke_rendering_data_generation() {
              let stroke = create_stroke(vec![
                  (10.0, 10.0),
                  (20.0, 20.0),
                  (30.0, 15.0),
              ]);
              
              assert!(stroke.points.len() >= 2);
              
              for i in 0..stroke.points.len() - 1 {
                  let p1 = &stroke.points[i];
                  let p2 = &stroke.points[i + 1];
                  assert!(p1.x != p2.x || p1.y != p2.y);
              }
          }

          #[test]
          fn test_empty_stroke_not_added() {
              let mut state = DrawingState::new();
              state.start_stroke(IcedPoint::new(10.0, 10.0));
              
              state.end_stroke();
              
              assert!(state.completed_strokes.len() <= 1);
          }
      }

      #[cfg(test)]
      mod property_tests {
          use super::*;
          use proptest::prelude::*;

          prop_compose! {
              fn point_strategy()(x in 0.0f32..200.0, y in 0.0f32..200.0) -> (f32, f32) {
                  (x, y)
              }
          }

          prop_compose! {
              fn stroke_strategy()(points in prop::collection::vec(point_strategy(), 2..50)) -> Vec<(f32, f32)> {
                  points
              }
          }

          proptest! {
              #[test]
              fn prop_normalized_coordinates_in_unit_square(
                  points in stroke_strategy(),
                  width in 50.0f32..500.0,
                  height in 50.0f32..500.0
              ) {
                  let stroke = create_stroke(points);
                  let normalized = stroke.normalize(width, height);
                  
                  for point in normalized {
                      prop_assert!(point.x >= 0.0 && point.x <= 1.0);
                      prop_assert!(point.y >= 0.0 && point.y <= 1.0);
                  }
              }

              #[test]
              fn prop_distance_threshold_reduces_points(
                  mut points in prop::collection::vec(point_strategy(), 10..100)
              ) {
                  let original_count = points.len();
                  let mut state = DrawingState::new();
                  
                  if let Some(first) = points.first() {
                      state.start_stroke(IcedPoint::new(first.0, first.1));
                      for (x, y) in points.iter().skip(1) {
                          state.add_point(IcedPoint::new(*x, *y));
                      }
                      state.end_stroke();
                      
                      let filtered_count = state.completed_strokes[0].points.len();
                      prop_assert!(filtered_count <= original_count);
                  }
              }

              #[test]
              fn prop_stroke_sequence_preserved(
                  stroke_count in 1usize..10,
                  points_per_stroke in 2usize..20
              ) {
                  let mut state = DrawingState::new();
                  
                  for _ in 0..stroke_count {
                      state.start_stroke(IcedPoint::new(10.0, 10.0));
                      for i in 1..points_per_stroke {
                          state.add_point(IcedPoint::new(10.0 + i as f32 * 5.0, 10.0));
                      }
                      state.end_stroke();
                  }
                  
                  prop_assert_eq!(state.completed_strokes.len(), stroke_count);
              }

              #[test]
              fn prop_clear_always_empties_state(strokes in 0usize..20) {
                  let mut state = DrawingState::new();
                  
                  for _ in 0..strokes {
                      state.start_stroke(IcedPoint::new(10.0, 10.0));
                      state.add_point(IcedPoint::new(20.0, 20.0));
                      state.end_stroke();
                  }
                  
                  state.clear();
                  
                  prop_assert_eq!(state.completed_strokes.len(), 0);
                  prop_assert!(!state.is_drawing());
              }

              #[test]
              fn prop_undo_decrements_stroke_count(strokes in 1usize..20) {
                  let mut state = DrawingState::new();
                  
                  for _ in 0..strokes {
                      state.start_stroke(IcedPoint::new(10.0, 10.0));
                      state.end_stroke();
                  }
                  
                  let initial_count = state.completed_strokes.len();
                  state.undo();
                  
                  prop_assert_eq!(state.completed_strokes.len(), initial_count - 1);
              }
          }
      }

      #[cfg(test)]
      mod integration_tests {
          use super::*;
          use iced::mouse::{Button, Event as MouseEvent};
          use iced::Point as IcedPoint;

          #[test]
          fn test_mouse_event_sequence_creates_stroke() {
              let mut canvas = HandwritingCanvas::new(200, 200);
              
              canvas.on_event(MouseEvent::ButtonPressed(Button::Left), IcedPoint::new(10.0, 10.0));
              assert!(canvas.state.is_drawing());
              
              canvas.on_event(MouseEvent::CursorMoved, IcedPoint::new(50.0, 50.0));
              canvas.on_event(MouseEvent::CursorMoved, IcedPoint::new(100.0, 100.0));
              
              canvas.on_event(MouseEvent::ButtonReleased(Button::Left), IcedPoint::new(100.0, 100.0));
              
              assert!(!canvas.state.is_drawing());
              assert_eq!(canvas.state.completed_strokes.len(), 1);
              assert!(canvas.state.completed_strokes[0].points.len() >= 2);
          }

          #[test]
          fn test_stroke_completion_triggers_callback() {
              let mut canvas = HandwritingCanvas::new(200, 200);
              let mut callback_invoked = false;
              
              canvas.set_on_stroke_complete(|_strokes| {
                  callback_invoked = true;
              });
              
              canvas.on_event(MouseEvent::ButtonPressed(Button::Left), IcedPoint::new(10.0, 10.0));
              canvas.on_event(MouseEvent::CursorMoved, IcedPoint::new(50.0, 50.0));
              canvas.on_event(MouseEvent::ButtonReleased(Button::Left), IcedPoint::new(50.0, 50.0));
              
              assert!(callback_invoked);
          }

          #[test]
          fn test_visual_feedback_differentiation() {
              let mut canvas = HandwritingCanvas::new(200, 200);
              
              canvas.on_event(MouseEvent::ButtonPressed(Button::Left), IcedPoint::new(10.0, 10.0));
              
              let current_style = canvas.get_current_stroke_style();
              let completed_style = canvas.get_completed_stroke_style();
              
              assert_ne!(current_style.color, completed_style.color);
          }
      }

  coverage:
    - "Stroke data structure creation and manipulation"
    - "Point creation with timestamp recording"
    - "Distance threshold filtering of closely-spaced points"
    - "Distance calculation between points for threshold application"
    - "Coordinate normalization to 0-1 range"
    - "Normalization handles edge cases (zero dimensions, single point)"
    - "Drawing state machine initialization"
    - "Drawing state machine transitions (idle -> drawing -> idle)"
    - "Stroke start event handling"
    - "Stroke continuation with point addition"
    - "Stroke completion and storage"
    - "Multiple sequential strokes maintained in order"
    - "Clear operation removes all strokes and resets state"
    - "Undo operation removes last completed stroke only"
    - "Undo does not affect current in-progress stroke"
    - "Export raw stroke data as Vec<Vec<Point>>"
    - "Export normalized stroke data with canvas dimensions"
    - "Empty state exports empty stroke list"
    - "Timestamp sequential ordering within stroke"
    - "Velocity calculation from timestamps and positions"
    - "Canvas bounds clamping for out-of-range coordinates"
    - "Stroke path data generation for rendering"
    - "Single-point stroke handling (edge case)"
    - "Property: normalized coordinates always in [0,1] range"
    - "Property: distance threshold reduces or maintains point count"
    - "Property: stroke sequence order preserved"
    - "Property: clear always empties all state"
    - "Property: undo decrements completed stroke count"
    - "Integration: mouse press-move-release creates complete stroke"
    - "Integration: stroke completion triggers callback"
    - "Integration: visual differentiation between current and completed strokes"

dependencies:
  depends_on:
    - task_id: 1
      reason: "Requires iced framework foundation including canvas::Program trait and basic widget infrastructure"

  depended_upon_by:
    - task_id: 8
      reason: "Practice mode uses HandwritingCanvas widget for interactive handwriting exercises"
    - task_id: 9
      reason: "Character recognition system consumes normalized stroke data exported from canvas"

  external:
    - name: "iced::canvas::Program"
      type: "trait"
      status: "already exists"
    - name: "iced::canvas::Path"
      type: "struct"
      status: "already exists"
    - name: "iced::Point"
      type: "struct"
      status: "already exists"
    - name: "iced::mouse::Event"
      type: "enum"
      status: "already exists"
    - name: "iced::mouse::Button"
      type: "enum"
      status: "already exists"
    - name: "std::time::Instant"
      type: "struct"
      status: "already exists"
    - name: "proptest"
      type: "crate"
      status: "to be imported"
---
task:
  id: 6
  name: "Application State Management and Navigation"

context:
  description: |
    This task implements the core Elm architecture state management system for the kanji learning
    application. It establishes the foundational control flow that manages all screen transitions,
    user interactions, and application state consistency. The Elm architecture pattern provides a
    unidirectional data flow where all state changes flow through a single update() function,
    ensuring predictable and testable behavior.

    The state management system serves as the central orchestrator coordinating between the UI
    layer (view functions) and business logic (database operations, SRS calculations, stroke
    recognition). It maintains a clear separation between pure state transitions and asynchronous
    side effects through the Command abstraction (Task-based async operations).

    This implementation must support complex workflows including learning sessions with spaced
    repetition scheduling, practice modes with real-time stroke recognition, and statistics
    displays with dynamic filtering. The state structure uses an enum-based screen system where
    each screen variant carries its own isolated state, while shared data (user progress,
    settings) is managed through Arc<RwLock> for thread-safe access.

    The architecture prevents entire classes of bugs by making invalid states unrepresentable
    through Rust's type system and ensuring all state transitions are explicit, auditable, and
    testable without requiring UI or database infrastructure.

  key_points:
    - "Screen enum variants carry screen-specific state, isolating concerns and preventing state pollution"
    - "Message enum provides exhaustive enumeration of all user interactions and system events"
    - "update() function is pure and side-effect-free, returning Command for async operations"
    - "Shared state (progress, settings) uses Arc<RwLock> for thread-safe concurrent access"
    - "Navigation maintains referential transparency - screen transitions are deterministic"
    - "Session state (learning/practice) is owned by Screen variants, ensuring encapsulation"
    - "Command abstraction enables async operations (database, recognition) without breaking purity"
    - "Type system enforces state machine correctness at compile time where possible"

files:
  - path: "src/state/mod.rs"
    description: "Module declaration file exposing Screen, Message, and AppState types"
  
  - path: "src/state/screen.rs"
    description: "Screen enum defining all application screens with associated state (MainMenu, Learning, Practice, Statistics, Settings, etc.)"
  
  - path: "src/state/message.rs"
    description: "Message enum defining all user interactions and system events that trigger state transitions"
  
  - path: "src/state/app_state.rs"
    description: "AppState struct holding current screen, shared progress data, settings, and session state"
  
  - path: "src/state/update.rs"
    description: "Implementation of Application::update() function with main message routing and state transition logic"
  
  - path: "src/state/navigation.rs"
    description: "Helper functions for screen transitions, navigation stack management, and state initialization"
  
  - path: "src/state/session.rs"
    description: "Session state structures for learning and practice modes, including current character, progress tracking, and review queue"
  
  - path: "src/command.rs"
    description: "Command enum and execution logic for async operations that return Messages upon completion"
  
  - path: "tests/state_tests.rs"
    description: "Unit tests for state transitions, navigation flows, and message handling across all screens"

functions:
  - file: "src/state/mod.rs"
    items:
      - type: "module_declaration"
        name: "pub mod app_state"
        description: "Module containing AppState and related structures"
      - type: "module_declaration"
        name: "pub mod screen"
        description: "Module containing Screen enum and screen-specific state"
      - type: "module_declaration"
        name: "pub mod message"
        description: "Module containing Message enum for all user interactions"
      - type: "module_declaration"
        name: "pub mod navigation"
        description: "Module containing navigation helper functions"
      - type: "module_declaration"
        name: "pub mod session"
        description: "Module containing session state structures"

  - file: "src/state/app_state.rs"
    items:
      - type: "struct"
        name: "AppState"
        description: "Root state container holding current screen, shared progress data, settings, and database handle"
        invariants: "Always contains a valid Screen variant; shared data is thread-safe via Arc<RwLock>"
      - type: "struct"
        name: "SharedState"
        description: "Thread-safe shared state container for progress and settings accessible across screens"
        invariants: "Progress data remains consistent with database; settings are valid"
      - type: "method"
        name: "AppState::new"
        description: "Creates new AppState with MainMenu screen and initializes shared state from database"
        preconditions: "Database connection is valid and accessible"
        postconditions: "AppState is initialized with MainMenu screen and loaded shared state"
      - type: "method"
        name: "AppState::current_screen"
        description: "Returns immutable reference to the current Screen"
        postconditions: "Returns valid Screen reference"
      - type: "method"
        name: "AppState::current_screen_mut"
        description: "Returns mutable reference to the current Screen"
        postconditions: "Returns valid mutable Screen reference"
      - type: "method"
        name: "AppState::navigate_to"
        description: "Transitions to a new screen, updating the current screen state"
        preconditions: "New screen state is valid and properly initialized"
        postconditions: "Current screen is updated to the new screen"
      - type: "method"
        name: "SharedState::new"
        description: "Creates new SharedState with progress and settings data"
        postconditions: "SharedState is initialized with valid data"
      - type: "method"
        name: "SharedState::load_from_db"
        description: "Loads progress and settings from database into SharedState"
        preconditions: "Database connection is valid"
        postconditions: "SharedState contains current database values"
      - type: "method"
        name: "SharedState::get_progress"
        description: "Returns clone of current progress data with read lock"
        postconditions: "Returns valid Progress data"
      - type: "method"
        name: "SharedState::update_progress"
        description: "Updates progress data with write lock"
        preconditions: "Progress data is valid"
        postconditions: "Progress is updated in memory"

  - file: "src/state/screen.rs"
    items:
      - type: "enum"
        name: "Screen"
        description: "Represents all application screens with associated state for each screen type"
        invariants: "Each variant contains valid screen-specific state"
      - type: "enum_variant"
        name: "Screen::MainMenu"
        description: "Main menu screen with menu selection state"
      - type: "enum_variant"
        name: "Screen::Learning"
        description: "Learning session screen with current kanji, review queue, and session progress"
      - type: "enum_variant"
        name: "Screen::Practice"
        description: "Practice mode screen with drawing canvas state, current character, and recognition state"
      - type: "enum_variant"
        name: "Screen::Statistics"
        description: "Statistics display screen with current filter and sort options"
      - type: "enum_variant"
        name: "Screen::Settings"
        description: "Settings configuration screen with current settings values"
      - type: "enum_variant"
        name: "Screen::KanjiDetail"
        description: "Detailed kanji information screen with kanji ID and display mode"
      - type: "struct"
        name: "MainMenuState"
        description: "State for main menu screen including selected menu item"
        invariants: "Selected index is within valid menu bounds"
      - type: "struct"
        name: "LearningState"
        description: "State for learning session including current kanji, review queue, and session statistics"
        invariants: "Current kanji matches queue front; session stats are non-negative"
      - type: "struct"
        name: "PracticeState"
        description: "State for practice mode including canvas, current character, strokes, and recognition result"
        invariants: "Canvas dimensions are positive; stroke data is valid"
      - type: "struct"
        name: "StatisticsState"
        description: "State for statistics screen including filters, sort order, and cached statistics data"
        invariants: "Statistics data matches current filter settings"
      - type: "struct"
        name: "SettingsState"
        description: "State for settings screen including editable settings and save state"
        invariants: "Settings values are within valid ranges"
      - type: "struct"
        name: "KanjiDetailState"
        description: "State for kanji detail screen including kanji data and viewing mode"
        preconditions: "Kanji ID exists in database"
        invariants: "Kanji data is loaded and valid"
      - type: "method"
        name: "Screen::is_main_menu"
        description: "Returns true if screen is MainMenu variant"
      - type: "method"
        name: "Screen::is_learning"
        description: "Returns true if screen is Learning variant"
      - type: "method"
        name: "Screen::is_practice"
        description: "Returns true if screen is Practice variant"
      - type: "method"
        name: "LearningState::new"
        description: "Creates new learning session state with kanji queue from database"
        preconditions: "Database contains kanji for review"
        postconditions: "Learning state initialized with valid review queue"
      - type: "method"
        name: "LearningState::current_kanji"
        description: "Returns reference to current kanji being reviewed"
        postconditions: "Returns valid kanji reference if queue not empty"
      - type: "method"
        name: "LearningState::advance_to_next"
        description: "Moves to next kanji in review queue"
        preconditions: "Queue is not empty"
        postconditions: "Current kanji updated or session complete"
      - type: "method"
        name: "PracticeState::new"
        description: "Creates new practice state with empty canvas and selected character"
        postconditions: "Practice state initialized with clean canvas"
      - type: "method"
        name: "PracticeState::add_stroke"
        description: "Adds a new stroke to the canvas"
        postconditions: "Stroke is added to stroke collection"
      - type: "method"
        name: "PracticeState::clear_canvas"
        description: "Removes all strokes from canvas"
        postconditions: "Canvas is empty"

  - file: "src/state/message.rs"
    items:
      - type: "enum"
        name: "Message"
        description: "All possible user interactions and system events in the application"
      - type: "enum_variant"
        name: "Message::NavigateToMainMenu"
        description: "Navigate to main menu screen"
      - type: "enum_variant"
        name: "Message::NavigateToLearning"
        description: "Navigate to learning session screen and initialize session"
      - type: "enum_variant"
        name: "Message::NavigateToPractice"
        description: "Navigate to practice mode screen"
      - type: "enum_variant"
        name: "Message::NavigateToStatistics"
        description: "Navigate to statistics screen"
      - type: "enum_variant"
        name: "Message::NavigateToSettings"
        description: "Navigate to settings screen"
      - type: "enum_variant"
        name: "Message::NavigateToKanjiDetail"
        description: "Navigate to kanji detail screen for specific kanji ID"
      - type: "enum_variant"
        name: "Message::MainMenuItemSelected"
        description: "User selected menu item in main menu (up/down/enter)"
      - type: "enum_variant"
        name: "Message::LearningShowAnswer"
        description: "User requested to show answer in learning session"
      - type: "enum_variant"
        name: "Message::LearningRateRecall"
        description: "User rated their recall of current kanji (Again/Hard/Good/Easy)"
      - type: "enum_variant"
        name: "Message::LearningSessionComplete"
        description: "Learning session finished all reviews"
      - type: "enum_variant"
        name: "Message::PracticeStrokeAdded"
        description: "User drew a stroke on practice canvas with point data"
      - type: "enum_variant"
        name: "Message::PracticeClearCanvas"
        description: "User requested to clear practice canvas"
      - type: "enum_variant"
        name: "Message::PracticeSubmitDrawing"
        description: "User submitted drawing for recognition"
      - type: "enum_variant"
        name: "Message::PracticeRecognitionComplete"
        description: "Recognition task completed with result"
      - type: "enum_variant"
        name: "Message::PracticeSelectNewCharacter"
        description: "User selected new character to practice"
      - type: "enum_variant"
        name: "Message::StatisticsFilterChanged"
        description: "User changed statistics filter settings"
      - type: "enum_variant"
        name: "Message::StatisticsSortChanged"
        description: "User changed statistics sort order"
      - type: "enum_variant"
        name: "Message::SettingsValueChanged"
        description: "User modified a settings value"
      - type: "enum_variant"
        name: "Message::SettingsSave"
        description: "User requested to save settings"
      - type: "enum_variant"
        name: "Message::SettingsSaveComplete"
        description: "Settings save task completed"
      - type: "enum_variant"
        name: "Message::SettingsCancel"
        description: "User cancelled settings changes"
      - type: "enum_variant"
        name: "Message::DatabaseOperationComplete"
        description: "Async database operation completed with result"
      - type: "enum_variant"
        name: "Message::ErrorOccurred"
        description: "Error occurred during operation with error details"
      - type: "enum_variant"
        name: "Message::Quit"
        description: "User requested to quit application"

  - file: "src/state/navigation.rs"
    items:
      - type: "function"
        name: "navigate_to_main_menu"
        description: "Creates MainMenu screen state and returns it"
        postconditions: "Returns initialized MainMenuState"
      - type: "function"
        name: "navigate_to_learning"
        description: "Creates Learning screen state by loading review queue from database"
        preconditions: "Database connection is valid"
        postconditions: "Returns initialized LearningState with review queue"
      - type: "function"
        name: "navigate_to_practice"
        description: "Creates Practice screen state with empty canvas"
        postconditions: "Returns initialized PracticeState"
      - type: "function"
        name: "navigate_to_statistics"
        description: "Creates Statistics screen state with default filters"
        postconditions: "Returns initialized StatisticsState"
      - type: "function"
        name: "navigate_to_settings"
        description: "Creates Settings screen state with current settings loaded"
        preconditions: "Shared state contains current settings"
        postconditions: "Returns initialized SettingsState"
      - type: "function"
        name: "navigate_to_kanji_detail"
        description: "Creates KanjiDetail screen state for specific kanji ID"
        preconditions: "Kanji ID exists in database"
        postconditions: "Returns initialized KanjiDetailState with kanji data"
      - type: "function"
        name: "can_navigate_back"
        description: "Checks if navigation history allows going back"
        postconditions: "Returns true if back navigation is available"
      - type: "function"
        name: "get_previous_screen"
        description: "Returns previous screen from navigation history"
        preconditions: "Navigation history is not empty"
        postconditions: "Returns valid previous Screen"

  - file: "src/application.rs"
    items:
      - type: "method"
        name: "Application::update"
        description: "Main state transition function implementing Elm architecture update logic; routes all messages to appropriate handlers and returns Command for async operations"
        preconditions: "AppState is valid; Message is well-formed"
        postconditions: "AppState is updated according to message; Command is returned for any async operations"
        invariants: "Function is pure with no side effects; all state changes are explicit"
      - type: "method"
        name: "Application::update_main_menu"
        description: "Handles messages specific to main menu screen"
        preconditions: "Current screen is MainMenu"
        postconditions: "MainMenu state updated or navigation triggered"
      - type: "method"
        name: "Application::update_learning"
        description: "Handles messages specific to learning session screen"
        preconditions: "Current screen is Learning"
        postconditions: "Learning state updated with answer shown, kanji advanced, or session completed"
      - type: "method"
        name: "Application::update_practice"
        description: "Handles messages specific to practice mode screen"
        preconditions: "Current screen is Practice"
        postconditions: "Practice state updated with new strokes, cleared canvas, or recognition initiated"
      - type: "method"
        name: "Application::update_statistics"
        description: "Handles messages specific to statistics screen"
        preconditions: "Current screen is Statistics"
        postconditions: "Statistics state updated with new filters or sort order"
      - type: "method"
        name: "Application::update_settings"
        description: "Handles messages specific to settings screen"
        preconditions: "Current screen is Settings"
        postconditions: "Settings state updated or save operation initiated"
      - type: "method"
        name: "Application::handle_navigation"
        description: "Processes navigation messages and transitions between screens"
        postconditions: "Screen transition completed with properly initialized target screen state"
      - type: "method"
        name: "Application::handle_learning_rate_recall"
        description: "Processes user recall rating in learning session and updates SRS data"
        preconditions: "Current screen is Learning with valid current kanji"
        postconditions: "SRS data updated; kanji moved to appropriate queue; database save task created"
      - type: "method"
        name: "Application::handle_practice_recognition"
        description: "Initiates stroke recognition task for submitted drawing"
        preconditions: "Current screen is Practice with strokes on canvas"
        postconditions: "Recognition task Command returned"
      - type: "method"
        name: "Application::handle_database_operation"
        description: "Processes completed database operation results"
        postconditions: "Shared state updated if operation succeeded; error handled if failed"
      - type: "method"
        name: "Application::handle_error"
        description: "Handles error messages and updates UI to show error state"
        postconditions: "Error is logged and/or displayed to user"

  - file: "src/command.rs"
    items:
      - type: "enum"
        name: "Command"
        description: "Represents async operations that return Messages upon completion (Elm architecture Task equivalent)"
      - type: "enum_variant"
        name: "Command::None"
        description: "No async operation needed"
      - type: "enum_variant"
        name: "Command::SaveProgress"
        description: "Save progress data to database asynchronously"
      - type: "enum_variant"
        name: "Command::LoadKanjiQueue"
        description: "Load review queue from database asynchronously"
      - type: "enum_variant"
        name: "Command::RecognizeStrokes"
        description: "Perform stroke recognition asynchronously"
      - type: "enum_variant"
        name: "Command::SaveSettings"
        description: "Save settings to database asynchronously"
      - type: "enum_variant"
        name: "Command::LoadStatistics"
        description: "Load statistics data from database asynchronously"
      - type: "enum_variant"
        name: "Command::Batch"
        description: "Execute multiple commands in sequence"
      - type: "method"
        name: "Command::none"
        description: "Creates a None command"
        postconditions: "Returns Command::None"
      - type: "method"
        name: "Command::batch"
        description: "Combines multiple commands into a single Batch command"
        postconditions: "Returns Command::Batch with all commands"
      - type: "method"
        name: "Command::perform"
        description: "Executes the command asynchronously and returns resulting Message"
        postconditions: "Async task is spawned; Message will be returned upon completion"
      - type: "function"
        name: "perform_save_progress"
        description: "Async function to save progress data to database"
        preconditions: "Database connection is valid; progress data is valid"
        postconditions: "Progress saved to database; returns Message::DatabaseOperationComplete or Message::ErrorOccurred"
      - type: "function"
        name: "perform_load_kanji_queue"
        description: "Async function to load review queue from database"
        preconditions: "Database connection is valid"
        postconditions: "Review queue loaded; returns appropriate Message with queue data"
      - type: "function"
        name: "perform_recognize_strokes"
        description: "Async function to perform stroke recognition"
        preconditions: "Stroke data is valid and non-empty"
        postconditions: "Recognition completed; returns Message::PracticeRecognitionComplete with result"
      - type: "function"
        name: "perform_save_settings"
        description: "Async function to save settings to database"
        preconditions: "Database connection is valid; settings are valid"
        postconditions: "Settings saved; returns Message::SettingsSaveComplete"

  - file: "tests/state_tests.rs"
    items:
      - type: "function"
        name: "test_app_state_initialization"
        description: "Tests that AppState initializes with MainMenu screen"
      - type: "function"
        name: "test_navigate_to_learning"
        description: "Tests navigation from MainMenu to Learning screen"
      - type: "function"
        name: "test_navigate_to_practice"
        description: "Tests navigation from MainMenu to Practice screen"
      - type: "function"
        name: "test_learning_show_answer"
        description: "Tests showing answer in learning session"
      - type: "function"
        name: "test_learning_rate_recall"
        description: "Tests rating recall and advancing to next kanji"
      - type: "function"
        name: "test_learning_session_complete"
        description: "Tests learning session completion when queue is empty"
      - type: "function"
        name: "test_practice_add_stroke"
        description: "Tests adding strokes to practice canvas"
      - type: "function"
        name: "test_practice_clear_canvas"
        description: "Tests clearing practice canvas"
      - type: "function"
        name: "test_practice_submit_drawing"
        description: "Tests submitting drawing for recognition"
      - type: "function"
        name: "test_settings_value_changed"
        description: "Tests changing settings values"
      - type: "function"
        name: "test_settings_save"
        description: "Tests saving settings changes"
      - type: "function"
        name: "test_statistics_filter_changed"
        description: "Tests changing statistics filters"
      - type: "function"
        name: "test_navigation_stack"
        description: "Tests navigation history and back navigation"
      - type: "function"
        name: "test_shared_state_thread_safety"
        description: "Tests concurrent access to SharedState"
      - type: "function"
        name: "test_message_handling_all_variants"
        description: "Tests that all Message variants are handled without panics"

formal_verification:
  needed: true
  level: "Critical"
  explanation: |
    State management in the Elm architecture is the core control mechanism of the
    entire application. The update() function and state transitions must be proven
    correct because:
    
    1. **State Consistency**: Invalid states or inconsistent transitions lead to
       application crashes, data corruption, or loss of user progress. The state
       machine must be proven to have no unreachable or invalid states.
    
    2. **Session Integrity**: Learning and practice sessions involve user progress
       tracking. State transitions during sessions must preserve data integrity -
       no lost reviews, no skipped characters, no duplicate entries.
    
    3. **Concurrency Safety**: Arc<RwLock> shared state access patterns must be
       proven deadlock-free and race-condition-free. The update() function coordinates
       async database operations that could introduce subtle concurrency bugs.
    
    4. **Navigation Soundness**: Screen transitions must be bijective where appropriate
       (e.g., MainMenu -> Learning -> MainMenu preserves menu state). Invalid navigation
       sequences must be impossible by construction.
    
    5. **High Risk Assessment**: The task explicitly flags "complexity_risk: high"
       and "integration_risk: high" with concerns about unwieldy update() functions,
       async error handling, and potential deadlocks. These risks justify formal
       verification.
    
    The pure functional nature of update() makes it ideal for formal verification.
    Property-based testing alone is insufficient for proving the absence of state
    machine errors in safety-critical paths (session progress, data persistence).

  properties:
    - name: "State Machine Completeness"
      formal_statement: |
        ∀s ∈ Screen, ∀m ∈ Message: ∃s' ∈ Screen: update(s, m) = (s', tasks)
        Every screen-message pair produces a valid next state (no panics/unreachable).

    - name: "Navigation Inverse Property"
      formal_statement: |
        ∀s₁: Screen::MainMenu: 
          let (s₂, _) = update(s₁, Message::NavigateTo(Screen::Learning));
          let (s₃, _) = update(s₂, Message::NavigateBack);
          ⟹ s₃ ≡ s₁ (modulo time-dependent state)
        Navigation back from a screen restores previous state.

    - name: "Session State Preservation"
      formal_statement: |
        ∀session_state, ∀msg ∈ {non-session-ending messages}:
          let (Screen::Learning(s), _) = update(Screen::Learning(session_state), msg);
          ⟹ s.current_index ≥ session_state.current_index ∧
             s.reviews_today ≥ session_state.reviews_today ∧
             s.session_start_time = session_state.session_start_time
        Session progress monotonically advances and session metadata is immutable.

    - name: "Database Consistency"
      formal_statement: |
        ∀msg ∈ {CompleteReview, FinishSession, UpdateProgress}:
          let (s', tasks) = update(s, msg);
          ⟹ ∃!db_task ∈ tasks: db_task persists state changes ∧
             db_task.on_completion returns Message::DatabaseUpdated(result)
        All state-mutating messages produce exactly one database persistence task.

    - name: "No Invalid State Construction"
      formal_statement: |
        ∀s: AppState: invariant(s) = true where
          invariant(AppState { screen: Screen::Learning(ls), .. }) ⟹
            ls.characters.len() > 0 ∧
            ls.current_index < ls.characters.len() ∧
            ls.session_start_time ≤ now()
        State invariants hold for all reachable states.

    - name: "Deadlock Freedom"
      formal_statement: |
        ∀execution_path π in update():
          let locks = {l | l ∈ Arc<RwLock<T>> accessed in π};
          ⟹ ∃total_order ≺ on locks: ∀l₁, l₂ ∈ π: acquired(l₁) ≺ acquired(l₂)
        Lock acquisition follows a total order (no circular wait condition).

    - name: "Message Idempotency (where applicable)"
      formal_statement: |
        ∀msg ∈ {RefreshStatistics, LoadSettings, CancelOperation}:
          update(update(s, msg).0, msg).0 ≡ update(s, msg).0
        Certain messages are idempotent (safe to replay without side effects).

  strategy:
    - "State Machine Model Checking: Use TLA+ or Alloy to model the Screen × Message state space. Verify state machine completeness, no deadlocks in navigation graph, and session state preservation properties. Generate counterexamples for any violations."
    - "Type-Level Proofs: Leverage Rust's type system to make invalid states unrepresentable. Use phantom types or session types to enforce screen transition constraints at compile time. Example: LearningSession<Active> vs LearningSession<Completed> to prevent operations on ended sessions."
    - "Lock Order Analysis: Use tools like Shuttle or Loom for exhaustive concurrency testing of Arc<RwLock> access patterns. Statically verify lock acquisition order using annotations or custom lints (e.g., lockbud)."
    - "Property-Based Testing with Prusti: Annotate update() and helper functions with preconditions/postconditions using Prusti contracts. Verify session state preservation and navigation invariants via symbolic execution."
    - "Async Correctness with Miri: Run state transition tests under Miri to detect undefined behavior in Task usage, ensure Task::perform callbacks correctly propagate Messages, and verify no data races in async contexts."
    - "Formal Trace Verification: Log all state transitions during execution. Write a separate verifier that checks execution traces against the formal state machine specification to detect runtime violations of proven properties."

tests:
  strategy:
    approach: "unit tests with property-based testing"
    rationale:
      - "State transitions are pure functions making them ideal for unit testing"
      - "All message handling and navigation flows can be tested without UI or database"
      - "Property-based testing ensures invariants hold across all possible state transitions"
      - "High test coverage is critical as this is the central orchestrator of the application"
      - "Screen transitions must maintain consistency - exhaustive testing prevents invalid states"

  implementation:
    file: "tests/state_tests.rs"
    location: "create new"
    code: |
      #[cfg(test)]
      mod app_state_tests {
          use super::super::*;
          use crate::types::*;
          use std::sync::{Arc, RwLock};

          fn create_test_state() -> AppState {
              AppState {
                  screen: Screen::MainMenu,
                  progress: Arc::new(RwLock::new(ProgressData::default())),
                  settings: Arc::new(RwLock::new(Settings::default())),
                  kanji_data: Arc::new(vec![]),
              }
          }

          #[test]
          fn test_initial_state_is_main_menu() {
              let state = create_test_state();
              assert!(matches!(state.screen, Screen::MainMenu));
          }

          #[test]
          fn test_navigate_to_learning_screen() {
              let mut state = create_test_state();
              let msg = Message::NavigateToLearning;
              
              state = Application::update(state, msg);
              
              assert!(matches!(state.screen, Screen::Learning(_)));
          }

          #[test]
          fn test_navigate_to_practice_screen() {
              let mut state = create_test_state();
              let msg = Message::NavigateToPractice;
              
              state = Application::update(state, msg);
              
              assert!(matches!(state.screen, Screen::Practice(_)));
          }

          #[test]
          fn test_navigate_to_statistics_screen() {
              let mut state = create_test_state();
              let msg = Message::NavigateToStatistics;
              
              state = Application::update(state, msg);
              
              assert!(matches!(state.screen, Screen::Statistics));
          }

          #[test]
          fn test_navigate_back_to_main_menu() {
              let mut state = create_test_state();
              state.screen = Screen::Learning(LearningState::default());
              let msg = Message::NavigateToMainMenu;
              
              state = Application::update(state, msg);
              
              assert!(matches!(state.screen, Screen::MainMenu));
          }

          #[test]
          fn test_learning_session_initialization() {
              let mut state = create_test_state();
              let msg = Message::StartLearningSession { kanji_ids: vec![1, 2, 3] };
              
              state = Application::update(state, msg);
              
              if let Screen::Learning(learning_state) = &state.screen {
                  assert_eq!(learning_state.total_items, 3);
                  assert_eq!(learning_state.current_index, 0);
              } else {
                  panic!("Expected Learning screen");
              }
          }

          #[test]
          fn test_practice_session_initialization() {
              let mut state = create_test_state();
              let msg = Message::StartPracticeSession { 
                  mode: PracticeMode::Review,
                  kanji_ids: vec![1, 2, 3, 4, 5]
              };
              
              state = Application::update(state, msg);
              
              if let Screen::Practice(practice_state) = &state.screen {
                  assert_eq!(practice_state.mode, PracticeMode::Review);
                  assert_eq!(practice_state.remaining_items.len(), 5);
              } else {
                  panic!("Expected Practice screen");
              }
          }

          #[test]
          fn test_learning_next_item() {
              let mut state = create_test_state();
              state.screen = Screen::Learning(LearningState {
                  kanji_ids: vec![1, 2, 3],
                  current_index: 0,
                  total_items: 3,
                  session_type: SessionType::NewItems,
              });
              
              let msg = Message::LearningNextItem;
              state = Application::update(state, msg);
              
              if let Screen::Learning(learning_state) = &state.screen {
                  assert_eq!(learning_state.current_index, 1);
              } else {
                  panic!("Expected Learning screen");
              }
          }

          #[test]
          fn test_learning_previous_item() {
              let mut state = create_test_state();
              state.screen = Screen::Learning(LearningState {
                  kanji_ids: vec![1, 2, 3],
                  current_index: 2,
                  total_items: 3,
                  session_type: SessionType::NewItems,
              });
              
              let msg = Message::LearningPreviousItem;
              state = Application::update(state, msg);
              
              if let Screen::Learning(learning_state) = &state.screen {
                  assert_eq!(learning_state.current_index, 1);
              } else {
                  panic!("Expected Learning screen");
              }
          }

          #[test]
          fn test_learning_previous_item_at_boundary() {
              let mut state = create_test_state();
              state.screen = Screen::Learning(LearningState {
                  kanji_ids: vec![1, 2, 3],
                  current_index: 0,
                  total_items: 3,
                  session_type: SessionType::NewItems,
              });
              
              let msg = Message::LearningPreviousItem;
              state = Application::update(state, msg);
              
              if let Screen::Learning(learning_state) = &state.screen {
                  assert_eq!(learning_state.current_index, 0);
              } else {
                  panic!("Expected Learning screen");
              }
          }

          #[test]
          fn test_learning_complete_session() {
              let mut state = create_test_state();
              state.screen = Screen::Learning(LearningState {
                  kanji_ids: vec![1, 2, 3],
                  current_index: 2,
                  total_items: 3,
                  session_type: SessionType::NewItems,
              });
              
              let msg = Message::LearningComplete;
              state = Application::update(state, msg);
              
              assert!(matches!(state.screen, Screen::MainMenu));
          }

          #[test]
          fn test_practice_submit_answer_correct() {
              let mut state = create_test_state();
              state.screen = Screen::Practice(PracticeState {
                  mode: PracticeMode::Review,
                  current_kanji_id: Some(1),
                  remaining_items: vec![2, 3],
                  correct_count: 0,
                  incorrect_count: 0,
                  drawing_state: DrawingState::default(),
              });
              
              let msg = Message::PracticeSubmitAnswer { 
                  kanji_id: 1,
                  strokes: vec![],
              };
              state = Application::update(state, msg);
              
              if let Screen::Practice(practice_state) = &state.screen {
                  assert!(practice_state.correct_count >= 0);
              } else {
                  panic!("Expected Practice screen");
              }
          }

          #[test]
          fn test_practice_next_item_depletes_queue() {
              let mut state = create_test_state();
              state.screen = Screen::Practice(PracticeState {
                  mode: PracticeMode::Review,
                  current_kanji_id: Some(1),
                  remaining_items: vec![2],
                  correct_count: 5,
                  incorrect_count: 2,
                  drawing_state: DrawingState::default(),
              });
              
              let msg = Message::PracticeNextItem;
              state = Application::update(state, msg);
              
              if let Screen::Practice(practice_state) = &state.screen {
                  assert_eq!(practice_state.current_kanji_id, Some(2));
                  assert_eq!(practice_state.remaining_items.len(), 0);
              } else {
                  panic!("Expected Practice screen");
              }
          }

          #[test]
          fn test_practice_complete_session() {
              let mut state = create_test_state();
              state.screen = Screen::Practice(PracticeState {
                  mode: PracticeMode::Review,
                  current_kanji_id: None,
                  remaining_items: vec![],
                  correct_count: 8,
                  incorrect_count: 2,
                  drawing_state: DrawingState::default(),
              });
              
              let msg = Message::PracticeComplete;
              state = Application::update(state, msg);
              
              assert!(matches!(state.screen, Screen::MainMenu));
          }

          #[test]
          fn test_update_settings() {
              let state = create_test_state();
              let new_settings = Settings {
                  daily_goal: 25,
                  show_hints: false,
                  animation_speed: 1.5,
              };
              
              let msg = Message::UpdateSettings(new_settings.clone());
              let state = Application::update(state, msg);
              
              let settings = state.settings.read().unwrap();
              assert_eq!(settings.daily_goal, 25);
              assert_eq!(settings.show_hints, false);
              assert_eq!(settings.animation_speed, 1.5);
          }

          #[test]
          fn test_screen_state_preservation_during_navigation() {
              let mut state = create_test_state();
              
              let msg = Message::StartLearningSession { kanji_ids: vec![1, 2, 3] };
              state = Application::update(state, msg);
              
              let msg = Message::LearningNextItem;
              state = Application::update(state, msg);
              
              if let Screen::Learning(learning_state) = &state.screen {
                  assert_eq!(learning_state.current_index, 1);
                  assert_eq!(learning_state.total_items, 3);
              } else {
                  panic!("Expected Learning screen");
              }
          }

          #[test]
          fn test_multiple_screen_transitions() {
              let mut state = create_test_state();
              
              state = Application::update(state, Message::NavigateToLearning);
              assert!(matches!(state.screen, Screen::Learning(_)));
              
              state = Application::update(state, Message::NavigateToMainMenu);
              assert!(matches!(state.screen, Screen::MainMenu));
              
              state = Application::update(state, Message::NavigateToPractice);
              assert!(matches!(state.screen, Screen::Practice(_)));
              
              state = Application::update(state, Message::NavigateToStatistics);
              assert!(matches!(state.screen, Screen::Statistics));
              
              state = Application::update(state, Message::NavigateToMainMenu);
              assert!(matches!(state.screen, Screen::MainMenu));
          }

          #[test]
          fn test_shared_state_remains_consistent() {
              let state = create_test_state();
              let progress_ptr = Arc::clone(&state.progress);
              let settings_ptr = Arc::clone(&state.settings);
              
              let state = Application::update(state, Message::NavigateToLearning);
              
              assert!(Arc::ptr_eq(&state.progress, &progress_ptr));
              assert!(Arc::ptr_eq(&state.settings, &settings_ptr));
          }
      }

      #[cfg(test)]
      mod screen_enum_tests {
          use super::super::*;

          #[test]
          fn test_screen_variants_exist() {
              let main_menu = Screen::MainMenu;
              let learning = Screen::Learning(LearningState::default());
              let practice = Screen::Practice(PracticeState::default());
              let statistics = Screen::Statistics;
              
              assert!(matches!(main_menu, Screen::MainMenu));
              assert!(matches!(learning, Screen::Learning(_)));
              assert!(matches!(practice, Screen::Practice(_)));
              assert!(matches!(statistics, Screen::Statistics));
          }

          #[test]
          fn test_learning_state_default() {
              let state = LearningState::default();
              assert_eq!(state.current_index, 0);
              assert_eq!(state.total_items, 0);
              assert!(state.kanji_ids.is_empty());
          }

          #[test]
          fn test_practice_state_default() {
              let state = PracticeState::default();
              assert_eq!(state.current_kanji_id, None);
              assert_eq!(state.correct_count, 0);
              assert_eq!(state.incorrect_count, 0);
              assert!(state.remaining_items.is_empty());
          }
      }

      #[cfg(test)]
      mod message_enum_tests {
          use super::super::*;

          #[test]
          fn test_navigation_messages() {
              let messages = vec![
                  Message::NavigateToMainMenu,
                  Message::NavigateToLearning,
                  Message::NavigateToPractice,
                  Message::NavigateToStatistics,
              ];
              
              assert_eq!(messages.len(), 4);
          }

          #[test]
          fn test_session_messages() {
              let start_learning = Message::StartLearningSession { 
                  kanji_ids: vec![1, 2, 3] 
              };
              let start_practice = Message::StartPracticeSession { 
                  mode: PracticeMode::Review,
                  kanji_ids: vec![4, 5, 6]
              };
              
              match start_learning {
                  Message::StartLearningSession { kanji_ids } => {
                      assert_eq!(kanji_ids.len(), 3);
                  }
                  _ => panic!("Wrong message type"),
              }
          }

          #[test]
          fn test_learning_control_messages() {
              let messages = vec![
                  Message::LearningNextItem,
                  Message::LearningPreviousItem,
                  Message::LearningComplete,
              ];
              
              assert_eq!(messages.len(), 3);
          }

          #[test]
          fn test_practice_control_messages() {
              let submit = Message::PracticeSubmitAnswer {
                  kanji_id: 1,
                  strokes: vec![],
              };
              let next = Message::PracticeNextItem;
              let complete = Message::PracticeComplete;
              
              assert!(matches!(submit, Message::PracticeSubmitAnswer { .. }));
              assert!(matches!(next, Message::PracticeNextItem));
              assert!(matches!(complete, Message::PracticeComplete));
          }
      }

      #[cfg(test)]
      mod property_tests {
          use super::super::*;
          use proptest::prelude::*;

          proptest! {
              #[test]
              fn prop_navigation_never_panics(
                  start_screen in 0u8..4,
                  nav_sequence in prop::collection::vec(0u8..4, 0..20)
              ) {
                  let mut state = create_test_state_for_screen(start_screen);
                  
                  for nav in nav_sequence {
                      let msg = create_navigation_message(nav);
                      state = Application::update(state, msg);
                  }
              }

              #[test]
              fn prop_learning_index_stays_in_bounds(
                  item_count in 1usize..100,
                  operations in prop::collection::vec(prop::bool::ANY, 0..50)
              ) {
                  let kanji_ids: Vec<u32> = (0..item_count as u32).collect();
                  let mut state = create_test_state();
                  state.screen = Screen::Learning(LearningState {
                      kanji_ids: kanji_ids.clone(),
                      current_index: 0,
                      total_items: item_count,
                      session_type: SessionType::NewItems,
                  });

                  for is_next in operations {
                      let msg = if is_next {
                          Message::LearningNextItem
                      } else {
                          Message::LearningPreviousItem
                      };
                      state = Application::update(state, msg);
                      
                      if let Screen::Learning(learning_state) = &state.screen {
                          prop_assert!(learning_state.current_index < item_count);
                      }
                  }
              }

              #[test]
              fn prop_practice_counts_never_negative(
                  correct in 0u32..100,
                  incorrect in 0u32..100,
                  additional_ops in 0u32..50
              ) {
                  let mut state = create_test_state();
                  state.screen = Screen::Practice(PracticeState {
                      mode: PracticeMode::Review,
                      current_kanji_id: Some(1),
                      remaining_items: (0..additional_ops).collect(),
                      correct_count: correct,
                      incorrect_count: incorrect,
                      drawing_state: DrawingState::default(),
                  });

                  for _ in 0..additional_ops {
                      let msg = Message::PracticeNextItem;
                      state = Application::update(state, msg);
                      
                      if let Screen::Practice(practice_state) = &state.screen {
                          prop_assert!(practice_state.correct_count >= 0);
                          prop_assert!(practice_state.incorrect_count >= 0);
                      }
                  }
              }

              #[test]
              fn prop_shared_state_consistency(
                  nav_count in 0usize..30
              ) {
                  let state = create_test_state();
                  let original_progress_ptr = Arc::as_ptr(&state.progress);
                  let original_settings_ptr = Arc::as_ptr(&state.settings);
                  
                  let mut current_state = state;
                  for i in 0..nav_count {
                      let msg = create_navigation_message((i % 4) as u8);
                      current_state = Application::update(current_state, msg);
                  }
                  
                  prop_assert_eq!(Arc::as_ptr(&current_state.progress), original_progress_ptr);
                  prop_assert_eq!(Arc::as_ptr(&current_state.settings), original_settings_ptr);
              }
          }

          fn create_test_state() -> AppState {
              AppState {
                  screen: Screen::MainMenu,
                  progress: Arc::new(RwLock::new(ProgressData::default())),
                  settings: Arc::new(RwLock::new(Settings::default())),
                  kanji_data: Arc::new(vec![]),
              }
          }

          fn create_test_state_for_screen(screen_index: u8) -> AppState {
              let mut state = create_test_state();
              state.screen = match screen_index % 4 {
                  0 => Screen::MainMenu,
                  1 => Screen::Learning(LearningState::default()),
                  2 => Screen::Practice(PracticeState::default()),
                  3 => Screen::Statistics,
                  _ => Screen::MainMenu,
              };
              state
          }

          fn create_navigation_message(index: u8) -> Message {
              match index % 4 {
                  0 => Message::NavigateToMainMenu,
                  1 => Message::NavigateToLearning,
                  2 => Message::NavigateToPractice,
                  3 => Message::NavigateToStatistics,
                  _ => Message::NavigateToMainMenu,
              }
          }
      }

  coverage:
    - "Initial application state defaults to MainMenu screen"
    - "Navigation from MainMenu to Learning screen"
    - "Navigation from MainMenu to Practice screen"
    - "Navigation from MainMenu to Statistics screen"
    - "Navigation back to MainMenu from any screen"
    - "Learning session initialization with kanji IDs"
    - "Practice session initialization with mode and kanji IDs"
    - "Learning session next item increments index"
    - "Learning session previous item decrements index"
    - "Learning session previous at boundary stays at index 0"
    - "Learning session completion returns to MainMenu"
    - "Practice session answer submission"
    - "Practice session next item depletes remaining queue"
    - "Practice session completion returns to MainMenu"
    - "Settings update modifies shared state"
    - "Screen state preservation during navigation operations"
    - "Multiple sequential screen transitions maintain consistency"
    - "Shared state Arc pointers remain consistent across navigation"
    - "All Screen enum variants can be constructed"
    - "LearningState default values are correct"
    - "PracticeState default values are correct"
    - "All navigation Message variants exist"
    - "Session start Message variants carry required data"
    - "Learning control Message variants exist"
    - "Practice control Message variants exist"
    - "Property: Navigation never panics regardless of sequence"
    - "Property: Learning index always stays within bounds"
    - "Property: Practice counts never go negative"
    - "Property: Shared state pointers remain consistent across operations"

dependencies:
  depends_on:
    - task_id: 1
      reason: "Needs application foundation and state/ module structure"

  depended_upon_by:
    - task_id: 7
      reason: "Learning session requires state management framework"
    - task_id: 8
      reason: "Practice session requires state management framework"
    - task_id: 10
      reason: "Statistics screen needs navigation support"

  external:
    - name: "Arc"
      type: "struct"
      status: "already exists"
    - name: "RwLock"
      type: "struct"
      status: "already exists"
    - name: "proptest"
      type: "crate"
      status: "to be imported"
    - name: "ProgressData"
      type: "struct"
      status: "needs implementation"
    - name: "Settings"
      type: "struct"
      status: "needs implementation"
    - name: "SessionType"
      type: "enum"
      status: "needs implementation"
    - name: "PracticeMode"
      type: "enum"
      status: "needs implementation"
    - name: "DrawingState"
      type: "struct"
      status: "needs implementation"
---
task:
  id: 7
  name: "SM-2 Spaced Repetition Algorithm and Review Queue"

context:
  description: |
    This task implements the SM-2 spaced repetition algorithm, the pedagogical engine
    that powers effective long-term vocabulary retention in the learning system. SM-2
    is a battle-tested algorithm originally developed by Piotr Wozniak for SuperMemo,
    widely regarded as one of the most effective spaced repetition systems for educational
    purposes.
    
    The implementation includes the core SM2Card struct that tracks per-card scheduling
    parameters (ease factor, interval, repetition count, next review date) and updates
    them based on user performance ratings (0-5 quality scale). The ReviewQueue manages
    card prioritization according to SRS best practices: learning cards (new or recently
    failed) take priority over due reviews, which take priority over new cards. Daily
    limits prevent overwhelming learners with too many new cards at once.
    
    This task is foundational for the entire learning experience - correct implementation
    ensures optimal review scheduling for maximum retention with minimal review time.
    The algorithm's mathematical properties (ease factor bounds, interval progression,
    state transitions) require careful implementation and comprehensive testing to ensure
    educational effectiveness.

  key_points:
    - "SM-2 algorithm uses ease factor (starting at 2.5, floor at 1.3) to personalize card difficulty"
    - "First two intervals are fixed (1 day, 6 days), subsequent intervals use ease_factor multiplication"
    - "Quality ratings below 3 reset cards to learning state (interval=1, repetitions=0)"
    - "ReviewQueue prioritizes learning > due reviews > new cards for optimal pedagogy"
    - "Daily new card limits prevent learner overwhelm while maintaining engagement"
    - "Floating-point ease factor calculations require careful bounds checking and precision handling"
    - "Quality rating scale maps to user experience: 5=perfect, 4=correct, 3=difficult, 2=incorrect, 1=barely, 0=blackout"
    - "Algorithm is deterministic and mathematical, making it ideal for property-based testing"

files:
  - path: "src/srs/mod.rs"
    description: "Module declaration file for the spaced repetition system, exposing SM2Card and ReviewQueue"
  - path: "src/srs/sm2.rs"
    description: "Implementation of SM-2 algorithm including SM2Card struct and review logic"
  - path: "src/srs/queue.rs"
    description: "ReviewQueue implementation with card prioritization logic and daily limits"
  - path: "tests/srs_tests.rs"
    description: "Comprehensive unit and property-based tests for SM-2 algorithm and review queue"

functions:
  - file: "src/srs/sm2.rs"
    items:
      - type: "struct"
        name: "SM2Card"
        description: "Represents a flashcard with SM-2 scheduling parameters including ease factor, interval, repetition count, and next review date"
        invariants: "ease_factor >= 1.3; interval >= 0; repetitions >= 0; next_review is valid datetime"
      
      - type: "constant"
        name: "DEFAULT_EASE_FACTOR"
        description: "Initial ease factor for new cards (2.5 as per SM-2 specification)"
      
      - type: "constant"
        name: "MIN_EASE_FACTOR"
        description: "Minimum allowed ease factor (1.3) to prevent cards from becoming too difficult"
      
      - type: "constant"
        name: "FIRST_INTERVAL_DAYS"
        description: "Fixed interval for first review (1 day)"
      
      - type: "constant"
        name: "SECOND_INTERVAL_DAYS"
        description: "Fixed interval for second review (6 days)"
      
      - type: "enum"
        name: "ReviewQuality"
        description: "Enum representing quality ratings (0-5) with semantic names: Blackout=0, Incorrect=1, IncorrectEasy=2, CorrectDifficult=3, CorrectHesitant=4, Perfect=5"
      
      - type: "method"
        name: "ReviewQuality::to_u8"
        description: "Converts ReviewQuality enum to numeric value (0-5)"
        postconditions: "Returns value in range [0, 5]"
      
      - type: "method"
        name: "ReviewQuality::from_u8"
        description: "Converts numeric value (0-5) to ReviewQuality enum"
        preconditions: "value in range [0, 5]"
        postconditions: "Returns Some(ReviewQuality) if valid, None otherwise"
      
      - type: "method"
        name: "SM2Card::new"
        description: "Creates a new SM2Card with default SM-2 parameters (ease=2.5, interval=0, reps=0)"
        postconditions: "Card has default ease factor 2.5, interval 0, repetitions 0, next_review set to now"
      
      - type: "method"
        name: "SM2Card::review"
        description: "Updates card state based on quality rating (0-5) according to SM-2 algorithm"
        preconditions: "quality must be in range [0, 5]"
        postconditions: "ease_factor updated per SM-2 formula and >= 1.3; interval and repetitions updated; next_review scheduled; if quality < 3 then repetitions=0 and interval=1"
      
      - type: "method"
        name: "SM2Card::calculate_ease_factor"
        description: "Calculates new ease factor based on quality rating using SM-2 formula: EF' = EF + (0.1 - (5 - q) * (0.08 + (5 - q) * 0.02))"
        preconditions: "quality in range [0, 5]"
        postconditions: "Returns ease factor >= 1.3"
        invariants: "Returned value is always >= MIN_EASE_FACTOR"
      
      - type: "method"
        name: "SM2Card::calculate_interval"
        description: "Calculates next interval based on repetition count and ease factor (1 day for rep=1, 6 days for rep=2, previous_interval * ease_factor for rep>2)"
        preconditions: "repetitions > 0"
        postconditions: "Returns interval in days according to SM-2 specification"
      
      - type: "method"
        name: "SM2Card::is_due"
        description: "Checks if card is due for review based on current time and next_review date"
        postconditions: "Returns true if next_review <= now, false otherwise"
      
      - type: "method"
        name: "SM2Card::is_learning"
        description: "Checks if card is in learning state (repetitions < 2 or recently failed)"
        postconditions: "Returns true if card is being learned, false if in review phase"
      
      - type: "method"
        name: "SM2Card::is_new"
        description: "Checks if card has never been reviewed"
        postconditions: "Returns true if repetitions == 0 and card never reviewed"

  - file: "src/srs/queue.rs"
    items:
      - type: "struct"
        name: "ReviewQueue"
        description: "Manages prioritized queues of cards (new, learning, review) with daily limits"
        invariants: "new_cards_per_day >= 0; review_cards_per_day >= 0; cards_reviewed_today >= 0; new_cards_today >= 0"
      
      - type: "struct"
        name: "QueueConfig"
        description: "Configuration for review queue including daily limits for new and review cards"
      
      - type: "method"
        name: "QueueConfig::default"
        description: "Creates default queue configuration with reasonable daily limits (20 new cards, 100 review cards)"
        postconditions: "Returns config with new_cards_per_day=20, review_cards_per_day=100"
      
      - type: "method"
        name: "ReviewQueue::new"
        description: "Creates a new ReviewQueue with given configuration"
        postconditions: "Queue is empty with counters at 0"
      
      - type: "method"
        name: "ReviewQueue::add_card"
        description: "Adds a card to the appropriate queue (new, learning, or review) based on card state"
        preconditions: "card is valid SM2Card"
        postconditions: "Card added to correct internal queue based on state"
      
      - type: "method"
        name: "ReviewQueue::get_next_card"
        description: "Returns next card to review based on priority: learning > due reviews > new cards, respecting daily limits"
        postconditions: "Returns Some(card) if available and within limits, None otherwise; increments appropriate counter"
        invariants: "Priority order: learning cards first, then due reviews, then new cards up to daily limit"
      
      - type: "method"
        name: "ReviewQueue::return_card"
        description: "Returns a reviewed card to the queue, updating its queue placement based on new state"
        preconditions: "card has been updated via review()"
        postconditions: "Card placed in appropriate queue or removed if not due"
      
      - type: "method"
        name: "ReviewQueue::count_due"
        description: "Returns count of cards due for review (learning + due reviews)"
        postconditions: "Returns accurate count of reviewable cards"
      
      - type: "method"
        name: "ReviewQueue::count_new"
        description: "Returns count of new cards available within daily limit"
        postconditions: "Returns min(new_cards.len(), new_cards_per_day - new_cards_today)"
      
      - type: "method"
        name: "ReviewQueue::reset_daily_counters"
        description: "Resets daily counters (cards_reviewed_today, new_cards_today) for new day"
        postconditions: "new_cards_today = 0; cards_reviewed_today = 0"
      
      - type: "method"
        name: "ReviewQueue::has_cards_available"
        description: "Checks if any cards are available for review within daily limits"
        postconditions: "Returns true if get_next_card() would return Some(_)"

  - file: "src/srs/mod.rs"
    items:
      - type: "module_declaration"
        name: "mod sm2"
        description: "Module declaration for SM-2 algorithm implementation"
      
      - type: "module_declaration"
        name: "mod queue"
        description: "Module declaration for review queue management"
      
      - type: "module_declaration"
        name: "pub use sm2::SM2Card"
        description: "Re-exports SM2Card for public API"
      
      - type: "module_declaration"
        name: "pub use queue::{ReviewQueue, QueueConfig}"
        description: "Re-exports ReviewQueue and QueueConfig for public API"

formal_verification:
  needed: true
  level: "Basic"
  explanation: |
    The SM-2 spaced repetition algorithm involves critical mathematical computations
    that directly impact learning effectiveness. While not safety-critical in the
    traditional sense, incorrect implementation would silently degrade the educational
    value of the entire system. The algorithm has several invariants and mathematical
    properties that must hold to ensure correct scheduling behavior.
    
    Basic formal verification is recommended because:
    1. The ease factor calculation involves floating-point arithmetic that must
       maintain bounds (>= 1.3) to prevent degenerate scheduling
    2. Interval progression must be monotonically increasing for successful reviews
       to avoid premature or delayed scheduling
    3. State transitions (learning → review → relearning) must be deterministic
       and reversible based on quality ratings
    4. The algorithm is well-specified mathematically, making it amenable to
       formal reasoning
    5. Bugs in scheduling logic are difficult to detect through manual testing
       and may only manifest over long time periods
    
    However, this is not "Critical" level because failures do not cause memory
    unsafety, data loss, or system crashes - they only degrade learning efficiency.
    Property-based testing combined with formal invariant specification provides
    adequate assurance.

  properties:
    - name: "Ease Factor Lower Bound"
      formal_statement: "∀ card: SM2Card, ∀ quality ∈ [0,5]: card.review(quality).ease_factor >= 1.3"
    
    - name: "Interval Monotonicity for Success"
      formal_statement: "∀ card: SM2Card, quality >= 3 ∧ repetitions >= 2 ⟹ new_interval >= old_interval"
    
    - name: "Failure Reset Correctness"
      formal_statement: "∀ card: SM2Card, quality < 3 ⟹ (new_repetitions = 0 ∧ new_interval = 1)"
    
    - name: "Fixed Initial Intervals"
      formal_statement: "(repetitions = 1 ⟹ interval = 1) ∧ (repetitions = 2 ∧ quality >= 3 ⟹ interval = 6)"
    
    - name: "Next Review Date Future"
      formal_statement: "∀ card: SM2Card, ∀ quality ∈ [0,5]: card.review(quality).next_review > current_date"
    
    - name: "Queue Priority Ordering"
      formal_statement: "∀ queue: ReviewQueue: learning_cards.is_empty() ⟹ (due_reviews.is_empty() ⟹ return new_cards)"
    
    - name: "Ease Factor Adjustment Consistency"
      formal_statement: "ease_factor' = max(1.3, ease_factor + (0.1 - (5 - quality) * (0.08 + (5 - quality) * 0.02)))"
    
    - name: "Repetition Counter Invariant"
      formal_statement: "∀ card: SM2Card, quality >= 3 ⟹ repetitions' = repetitions + 1"

  strategy:
    - "Implement property-based tests using proptest crate to verify invariants across random inputs"
    - "Use debug assertions in production code to check pre/postconditions at runtime"
    - "Create comprehensive unit tests covering boundary cases (quality=0, quality=5, first review, high repetition counts)"
    - "Document formal properties as doc comments with mathematical notation for maintainability"
    - "Consider using type-level guarantees (e.g., bounded types for quality ratings 0-5)"
    - "Implement quickcheck-style shrinking for property tests to find minimal failing cases"

tests:
  strategy:
    approach: "mixed (unit tests + property-based tests)"
    rationale:
      - "SM-2 algorithm is deterministic and mathematical, ideal for unit testing all quality ratings (0-5)"
      - "Property-based testing verifies critical invariants like ease factor bounds (>= 1.3), interval monotonicity, and state transitions"
      - "Unit tests cover edge cases: first review, consecutive successes/failures, boundary quality ratings"
      - "Queue prioritization logic requires explicit scenario testing to verify learning > review > new ordering"
      - "Daily limits and queue overflow scenarios need deterministic unit tests"
      - "Floating-point precision in ease factor calculations requires tolerance-based assertions"

  implementation:
    file: "src/srs/sm2.rs"
    location: "inline test module in implementation file"
    code: |
      #[cfg(test)]
      mod tests {
          use super::*;
          use chrono::{Duration, Utc};

          // Helper function to create a fresh card
          fn new_test_card(id: u32) -> SM2Card {
              SM2Card {
                  id,
                  ease_factor: 2.5,
                  interval_days: 0,
                  repetitions: 0,
                  next_review: Utc::now(),
              }
          }

          // ===== SM2Card Basic Algorithm Tests =====

          #[test]
          fn test_first_review_quality_5_sets_interval_1() {
              let mut card = new_test_card(1);
              let before = Utc::now();
              card.review(5);
              
              assert_eq!(card.interval_days, 1);
              assert_eq!(card.repetitions, 1);
              assert!(card.ease_factor >= 2.5); // Should increase or stay same
              assert!(card.next_review >= before + Duration::days(1));
}

          #[test]
          fn test_first_review_quality_4_sets_interval_1() {
              let mut card = new_test_card(2);
              card.review(4);
              
              assert_eq!(card.interval_days, 1);
              assert_eq!(card.repetitions, 1);
              assert_eq!(card.ease_factor, 2.5); // Quality 4 maintains ease factor
          }

          #[test]
          fn test_first_review_quality_3_sets_interval_1() {
              let mut card = new_test_card(3);
              card.review(3);
              
              assert_eq!(card.interval_days, 1);
              assert_eq!(card.repetitions, 1);
              assert!(card.ease_factor < 2.5); // Quality 3 decreases ease factor
          }

          #[test]
          fn test_second_review_quality_4_sets_interval_6() {
              let mut card = new_test_card(4);
              card.review(4); // First review
              card.review(4); // Second review
              
              assert_eq!(card.interval_days, 6);
              assert_eq!(card.repetitions, 2);
          }

          #[test]
          fn test_third_review_uses_ease_factor() {
              let mut card = new_test_card(5);
              card.review(4); // interval = 1
              card.review(4); // interval = 6
              card.review(4); // interval = 6 * 2.5 = 15
              
              assert_eq!(card.interval_days, 15);
              assert_eq!(card.repetitions, 3);
          }

          #[test]
          fn test_quality_5_increases_ease_factor() {
              let mut card = new_test_card(6);
              let initial_ease = card.ease_factor;
              card.review(5);
              
              assert!(card.ease_factor > initial_ease);
          }

          #[test]
          fn test_quality_3_decreases_ease_factor() {
              let mut card = new_test_card(7);
              let initial_ease = card.ease_factor;
              card.review(3);
              
              assert!(card.ease_factor < initial_ease);
          }

          #[test]
          fn test_quality_below_3_resets_card() {
              let mut card = new_test_card(8);
              card.review(4);
              card.review(4);
              card.review(4); // Build up interval and repetitions
              
              assert!(card.interval_days > 1);
              assert!(card.repetitions > 1);
              
              card.review(2); // Fail the card
              
              assert_eq!(card.interval_days, 1);
              assert_eq!(card.repetitions, 0);
          }

          #[test]
          fn test_ease_factor_floor_at_1_3() {
              let mut card = new_test_card(9);
              // Repeatedly fail to drive ease factor down
              for _ in 0..20 {
                  card.review(0);
              }
              
              assert!(card.ease_factor >= 1.3);
          }

          #[test]
          fn test_quality_0_blackout_resets_to_learning() {
              let mut card = new_test_card(10);
              card.review(5);
              card.review(5);
              card.review(5);
              
              card.review(0); // Complete blackout
              
              assert_eq!(card.interval_days, 1);
              assert_eq!(card.repetitions, 0);
          }

          #[test]
          fn test_intervals_are_monotonic_increasing() {
              let mut card = new_test_card(11);
              let mut last_interval = 0;
              
              for _ in 0..10 {
                  card.review(4);
                  assert!(card.interval_days >= last_interval);
                  last_interval = card.interval_days;
              }
          }

          #[test]
          fn test_next_review_date_always_in_future() {
              let mut card = new_test_card(12);
              let before = Utc::now();
              
              card.review(4);
              
              assert!(card.next_review > before);
          }

          // ===== ReviewQueue Tests =====

          #[test]
          fn test_new_queue_is_empty() {
              let queue = ReviewQueue::new(20);
              assert_eq!(queue.total_cards(), 0);
          }

          #[test]
          fn test_add_new_card_increases_count() {
              let mut queue = ReviewQueue::new(20);
              let card = new_test_card(1);
              
              queue.add_new_card(card);
              
              assert_eq!(queue.total_cards(), 1);
              assert_eq!(queue.new_cards_count(), 1);
          }

          #[test]
          fn test_learning_cards_have_priority_over_new() {
              let mut queue = ReviewQueue::new(20);
              
              let new_card = new_test_card(1);
              queue.add_new_card(new_card);
              
              let mut learning_card = new_test_card(2);
              learning_card.review(2); // Failed card goes to learning
              queue.add_learning_card(learning_card);
              
              let next = queue.get_next_card().unwrap();
              assert_eq!(next.id, 2); // Learning card comes first
          }

          #[test]
          fn test_due_reviews_have_priority_over_new() {
              let mut queue = ReviewQueue::new(20);
              
              let new_card = new_test_card(1);
              queue.add_new_card(new_card);
              
              let mut due_card = new_test_card(2);
              due_card.review(4);
              due_card.next_review = Utc::now() - Duration::days(1); // Make it overdue
              queue.add_review_card(due_card);
              
              let next = queue.get_next_card().unwrap();
              assert_eq!(next.id, 2); // Due review comes first
          }

          #[test]
          fn test_learning_priority_over_due_reviews() {
              let mut queue = ReviewQueue::new(20);
              
              let mut learning_card = new_test_card(1);
              learning_card.review(2);
              queue.add_learning_card(learning_card);
              
              let mut due_card = new_test_card(2);
              due_card.review(4);
              due_card.next_review = Utc::now() - Duration::days(1);
              queue.add_review_card(due_card);
              
              let next = queue.get_next_card().unwrap();
              assert_eq!(next.id, 1); // Learning card comes first
          }

          #[test]
          fn test_daily_new_card_limit_enforced() {
              let mut queue = ReviewQueue::new(5); // Limit of 5 new cards
              
              for i in 0..10 {
                  queue.add_new_card(new_test_card(i));
              }
              
              let mut seen_count = 0;
              while let Some(_) = queue.get_next_card() {
                  seen_count += 1;
              }
              
              assert_eq!(seen_count, 5); // Should only see 5 cards
          }

          #[test]
          fn test_get_next_card_returns_none_when_empty() {
              let mut queue = ReviewQueue::new(20);
              assert!(queue.get_next_card().is_none());
          }

          #[test]
          fn test_not_due_review_cards_not_returned() {
              let mut queue = ReviewQueue::new(20);
              
              let mut future_card = new_test_card(1);
              future_card.review(4);
              future_card.next_review = Utc::now() + Duration::days(5); // Not due yet
              queue.add_review_card(future_card);
              
              assert!(queue.get_next_card().is_none());
          }

          #[test]
          fn test_queue_respects_priority_order() {
              let mut queue = ReviewQueue::new(20);
              
              // Add cards in reverse priority order
              let new_card = new_test_card(1);
              queue.add_new_card(new_card);
              
              let mut review_card = new_test_card(2);
              review_card.review(4);
              review_card.next_review = Utc::now() - Duration::hours(1);
              queue.add_review_card(review_card);
              
              let mut learning_card = new_test_card(3);
              learning_card.review(2);
              queue.add_learning_card(learning_card);
              
              // Should get learning first, then review, then new
              assert_eq!(queue.get_next_card().unwrap().id, 3);
              assert_eq!(queue.get_next_card().unwrap().id, 2);
              assert_eq!(queue.get_next_card().unwrap().id, 1);
          }
      }

      #[cfg(test)]
      mod property_tests {
          use super::*;
          use proptest::prelude::*;

          // Generate valid quality ratings (0-5)
          fn quality_strategy() -> impl Strategy<Value = u8> {
              0u8..=5u8
          }

          proptest! {
              #[test]
              fn prop_ease_factor_never_below_1_3(
                  qualities in prop::collection::vec(quality_strategy(), 1..50)
              ) {
                  let mut card = SM2Card {
                      id: 1,
                      ease_factor: 2.5,
                      interval_days: 0,
                      repetitions: 0,
                      next_review: Utc::now(),
                  };
                  
                  for quality in qualities {
                      card.review(quality);
                      prop_assert!(card.ease_factor >= 1.3);
                  }
              }

              #[test]
              fn prop_intervals_never_decrease_on_success(
                  count in 3usize..20
              ) {
                  let mut card = SM2Card {
                      id: 1,
                      ease_factor: 2.5,
                      interval_days: 0,
                      repetitions: 0,
                      next_review: Utc::now(),
                  };
                  
                  let mut last_interval = 0;
                  for _ in 0..count {
                      card.review(4); // Always succeed
                      prop_assert!(card.interval_days >= last_interval);
                      last_interval = card.interval_days;
                  }
              }

              #[test]
              fn prop_quality_below_3_always_resets(
                  setup_reviews in prop::collection::vec(4u8..=5u8, 1..10),
                  fail_quality in 0u8..3u8
              ) {
                  let mut card = SM2Card {
                      id: 1,
                      ease_factor: 2.5,
                      interval_days: 0,
                      repetitions: 0,
                      next_review: Utc::now(),
                  };
                  
                  // Build up the card with successful reviews
                  for quality in setup_reviews {
                      card.review(quality);
                  }
                  
                  // Now fail it
                  card.review(fail_quality);
                  
                  prop_assert_eq!(card.repetitions, 0);
                  prop_assert_eq!(card.interval_days, 1);
              }

              #[test]
              fn prop_next_review_always_in_future(quality in quality_strategy()) {
                  let mut card = SM2Card {
                      id: 1,
                      ease_factor: 2.5,
                      interval_days: 0,
                      repetitions: 0,
                      next_review: Utc::now(),
                  };
                  
                  let before = Utc::now();
                  card.review(quality);
                  
                  prop_assert!(card.next_review >= before);
              }

              #[test]
              fn prop_repetitions_increment_on_quality_gte_3(
                  quality in 3u8..=5u8
              ) {
                  let mut card = SM2Card {
                      id: 1,
                      ease_factor: 2.5,
                      interval_days: 0,
                      repetitions: 0,
                      next_review: Utc::now(),
                  };
                  
                  let before_reps = card.repetitions;
                  card.review(quality);
                  
                  prop_assert_eq!(card.repetitions, before_reps + 1);
              }
          }
      }

  coverage:
    - "First review with quality 5 sets interval to 1 day"
    - "First review with quality 4 sets interval to 1 day"
    - "First review with quality 3 sets interval to 1 day and decreases ease factor"
    - "Second successful review sets interval to 6 days"
    - "Third and subsequent reviews use ease factor multiplication"
    - "Quality rating 5 increases ease factor"
    - "Quality rating 3 decreases ease factor"
    - "Quality rating below 3 resets card to learning state (interval=1, repetitions=0)"
    - "Ease factor never falls below 1.3 floor"
    - "Quality 0 (complete blackout) resets card to learning"
    - "Intervals increase monotonically for consecutive successful reviews"
    - "Next review date is always set to future after review"
    - "Empty ReviewQueue returns no cards"
    - "Adding new card increases queue count"
    - "Learning cards have priority over new cards"
    - "Due review cards have priority over new cards"
    - "Learning cards have highest priority over due reviews"
    - "Daily new card limit is enforced"
    - "Empty queue returns None when requesting next card"
    - "Review cards not yet due are not returned by queue"
    - "Queue respects complete priority order: learning > review > new"
    - "Property: ease factor never goes below 1.3 regardless of review sequence"
    - "Property: intervals never decrease for consecutive successful reviews"
    - "Property: any quality rating below 3 always resets repetitions to 0"
    - "Property: next review date is always in future after any review"
    - "Property: repetitions increment for quality >= 3"

dependencies:
  depends_on:
    - task_id: 2
      reason: "Needs character database to create flashcards from character data"

  depended_upon_by:
    - task_id: 8
      reason: "Learning session uses SM-2 algorithm for scheduling card reviews and queue management"
    - task_id: 11
      reason: "Persistence layer stores card state (ease factor, intervals, next review dates) for long-term tracking"

  external:
    - name: "chrono"
      type: "crate"
      status: "to be imported"
    - name: "proptest"
      type: "crate"
      status: "to be imported"
---
task:
  id: 9
  name: "Character Recognition Integration"

context:
  description: |
    This task implements a character recognition engine that analyzes user-drawn strokes
    and returns candidate matches with confidence scores. The recognition system serves as
    the validation mechanism for practice mode, providing objective assessment of whether
    users can accurately reproduce Japanese characters from memory.
    
    The implementation consists of three main components: stroke normalization (preprocessing
    raw canvas coordinates into a resolution-independent format), recognition engine integration
    (interfacing with hanzi_lookup or similar libraries via FFI/WASM), and validation logic
    (determining if the expected character appears in recognition results with sufficient
    confidence). The system must balance accuracy with user experience—overly strict thresholds
    frustrate learners, while overly permissive validation allows incorrect forms to pass.
    
    A key architectural challenge is handling the inherent variability of handwriting while
    maintaining acceptable false positive rates (<5%). The normalization pipeline transforms
    arbitrary screen coordinates into a consistent 0-1 unit square, optionally resampling to
    fixed point counts and applying smoothing to reduce noise. This preprocessed data feeds
    into the recognition engine, which returns ranked candidates. Validation then checks if
    the expected character appears in the top-N results above a confidence threshold.
    
    This task enables the practice mode (Task 8) to provide immediate feedback on drawing
    accuracy, closing the learning loop between instruction and validation. Recognition
    performance must complete within 200ms to maintain responsive user experience.

  key_points:
    - "Resolution-independent normalization ensures recognition works across different screen sizes and canvas dimensions"
    - "Stroke order and direction must be preserved through normalization pipeline as they are semantically significant in Japanese writing"
    - "Recognition threshold tuning (confidence score, top-N ranking) directly impacts UX and requires empirical validation with real handwriting samples"
    - "External library integration (hanzi_lookup via FFI) introduces platform-specific complexity and potential compatibility challenges"
    - "False positive prevention is critical—allowing incorrect forms to pass undermines learning effectiveness"
    - "Performance constraint (<200ms) limits preprocessing complexity and may require caching or optimization"
    - "Stroke count validation provides fast-path rejection for obvious errors before expensive recognition"
    - "Feedback generation transforms recognition failures into actionable learning guidance"

files:
  - path: "src/recognition/mod.rs"
    description: "Module declaration and public API for character recognition functionality, including high-level RecognitionService"
  
  - path: "src/recognition/types.rs"
    description: "Common types and error definitions used throughout recognition subsystem (Point, Stroke, StrokeSequence, RecognitionError)"
  
  - path: "src/recognition/normalizer.rs"
    description: "Stroke normalization functions including coordinate scaling, bounding box calculation, resampling, and smoothing"
  
  - path: "src/recognition/engine.rs"
    description: "Recognition engine interface with FFI/WASM bindings to hanzi_lookup or alternative recognition library"
  
  - path: "src/recognition/validator.rs"
    description: "Validation logic to check if expected character appears in recognition results with sufficient confidence"
  
  - path: "src/recognition/feedback.rs"
    description: "Feedback generation for incorrect recognition attempts, including stroke count hints and common error messages"
  
  - path: "tests/recognition_tests.rs"
    description: "Integration tests for end-to-end recognition pipeline with sample stroke data, property-based tests, and performance benchmarks"

functions:
  - file: "src/recognition/types.rs"
    items:
      - type: "module_declaration"
        name: "types"
        description: "Common types used throughout recognition subsystem"
      
      - type: "struct"
        name: "Point"
        description: "2D coordinate point with x and y values"
      
      - type: "struct"
        name: "Stroke"
        description: "Sequence of points representing a single stroke"
        invariants: "Contains at least one point"
      
      - type: "struct"
        name: "StrokeSequence"
        description: "Ordered collection of strokes forming a complete character"
        invariants: "Contains at least one stroke, preserves stroke order"
      
      - type: "enum"
        name: "RecognitionError"
        description: "Error types for recognition operations"
      
      - type: "enum_variant"
        name: "RecognitionError::EmptyInput"
        description: "No stroke data provided"
      
      - type: "enum_variant"
        name: "RecognitionError::NormalizationFailed"
        description: "Failed to normalize stroke data"
      
      - type: "enum_variant"
        name: "RecognitionError::EngineFailed"
        description: "Recognition engine returned error"
      
      - type: "enum_variant"
        name: "RecognitionError::InvalidFormat"
        description: "Stroke data format is invalid"
      
      - type: "constant"
        name: "DEFAULT_CONFIDENCE_THRESHOLD"
        description: "Default minimum confidence for validation (0.7)"
      
      - type: "constant"
        name: "DEFAULT_TOP_N_CANDIDATES"
        description: "Default number of top candidates to consider (3)"
      
      - type: "constant"
        name: "DEFAULT_RESAMPLE_POINTS"
        description: "Default number of points for resampling (64)"

  - file: "src/recognition/normalizer.rs"
    items:
      - type: "module_declaration"
        name: "normalizer"
        description: "Module containing stroke normalization and preprocessing utilities"
      
      - type: "struct"
        name: "BoundingBox"
        description: "Represents the bounding box of stroke data with min/max coordinates"
        invariants: "max_x >= min_x and max_y >= min_y"
      
      - type: "struct"
        name: "NormalizedStroke"
        description: "Stroke data normalized to 0-1 coordinate range"
        invariants: "All coordinates are in [0.0, 1.0] range"
      
      - type: "function"
        name: "calculate_bounding_box"
        description: "Computes the minimal bounding box containing all stroke points"
        preconditions: "Stroke data contains at least one point"
        postconditions: "Returns BoundingBox encompassing all points"
      
      - type: "function"
        name: "normalize_coordinates"
        description: "Normalizes stroke coordinates to 0-1 range while preserving aspect ratio"
        preconditions: "Bounding box is valid and non-empty"
        postconditions: "All output coordinates are in [0.0, 1.0] range"
        invariants: "Preserves stroke order and relative positions"
      
      - type: "function"
        name: "resample_stroke"
        description: "Resamples stroke to fixed number of evenly-spaced points using linear interpolation"
        preconditions: "Stroke contains at least 2 points, target_points > 1"
        postconditions: "Returns stroke with exactly target_points points"
        invariants: "Preserves stroke direction and general shape"
      
      - type: "function"
        name: "smooth_stroke"
        description: "Applies Gaussian smoothing to reduce noise while preserving overall shape"
        preconditions: "Stroke contains at least 3 points"
        postconditions: "Returns smoothed stroke with same number of points"
        invariants: "Stroke endpoints remain unchanged"
      
      - type: "function"
        name: "normalize_stroke_sequence"
        description: "Normalizes a complete sequence of strokes (multi-stroke character)"
        preconditions: "Sequence contains at least one stroke"
        postconditions: "All strokes normalized to shared coordinate space"
        invariants: "Preserves stroke order and relative timing"

  - file: "src/recognition/engine.rs"
    items:
      - type: "module_declaration"
        name: "engine"
        description: "Recognition engine interface and implementation"
      
      - type: "struct"
        name: "RecognitionCandidate"
        description: "A single recognition result with character and confidence score"
        invariants: "confidence is in [0.0, 1.0] range"
      
      - type: "struct"
        name: "RecognitionResult"
        description: "Complete recognition results with ranked candidates and metadata"
        invariants: "Candidates are sorted by confidence descending"
      
      - type: "trait"
        name: "RecognitionEngine"
        description: "Abstract interface for character recognition backends"
      
      - type: "method"
        name: "RecognitionEngine::recognize"
        description: "Recognizes character from normalized stroke data, returns ranked candidates"
        preconditions: "Stroke data is normalized and valid"
        postconditions: "Returns results sorted by confidence, or error on failure"
      
      - type: "struct"
        name: "HanziLookupEngine"
        description: "Recognition engine implementation using hanzi_lookup library via FFI"
      
      - type: "trait_impl"
        name: "RecognitionEngine for HanziLookupEngine"
        description: "Implements RecognitionEngine trait for hanzi_lookup backend"
      
      - type: "function"
        name: "convert_to_hanzi_lookup_format"
        description: "Converts normalized strokes to format expected by hanzi_lookup library"
        preconditions: "Strokes are normalized"
        postconditions: "Returns format compatible with hanzi_lookup API"
      
      - type: "function"
        name: "parse_hanzi_lookup_results"
        description: "Parses raw hanzi_lookup output into RecognitionResult structure"
        preconditions: "Input is valid hanzi_lookup output format"
        postconditions: "Returns sorted RecognitionResult or error"

  - file: "src/recognition/validator.rs"
    items:
      - type: "module_declaration"
        name: "validator"
        description: "Validation logic for recognition results"
      
      - type: "struct"
        name: "ValidationConfig"
        description: "Configuration for validation thresholds and behavior"
        invariants: "confidence_threshold in [0.0, 1.0], top_n_candidates >= 1"
      
      - type: "struct"
        name: "ValidationResult"
        description: "Result of validating recognition against expected character"
      
      - type: "function"
        name: "validate_recognition"
        description: "Checks if expected character appears in top-N results with sufficient confidence"
        preconditions: "Recognition results are sorted by confidence"
        postconditions: "Returns ValidationResult indicating match or no match"
      
      - type: "function"
        name: "find_matching_candidate"
        description: "Searches recognition results for expected character"
        preconditions: "Candidates list is valid"
        postconditions: "Returns Some(candidate) if found, None otherwise"
      
      - type: "function"
        name: "check_confidence_threshold"
        description: "Validates that candidate confidence meets minimum threshold"
        preconditions: "Candidate confidence is in [0.0, 1.0]"
        postconditions: "Returns true if confidence >= threshold"

  - file: "src/recognition/feedback.rs"
    items:
      - type: "module_declaration"
        name: "feedback"
        description: "Feedback generation for recognition failures"
      
      - type: "enum"
        name: "FeedbackType"
        description: "Categories of feedback messages"
      
      - type: "enum_variant"
        name: "FeedbackType::StrokeCountMismatch"
        description: "User drew wrong number of strokes"
      
      - type: "enum_variant"
        name: "FeedbackType::SimilarCharacter"
        description: "Recognized character is similar to expected"
      
      - type: "enum_variant"
        name: "FeedbackType::LowConfidence"
        description: "Expected character found but with low confidence"
      
      - type: "enum_variant"
        name: "FeedbackType::NoMatch"
        description: "Expected character not in recognition results"
      
      - type: "struct"
        name: "FeedbackMessage"
        description: "User-facing feedback with type and message text"
      
      - type: "function"
        name: "generate_feedback"
        description: "Generates helpful feedback based on validation failure"
        preconditions: "ValidationResult indicates failure"
        postconditions: "Returns FeedbackMessage with actionable guidance"
      
      - type: "function"
        name: "detect_stroke_count_error"
        description: "Checks if stroke count differs from expected character"
        preconditions: "Expected character stroke count is known"
        postconditions: "Returns Some(expected_count) if mismatch detected"
      
      - type: "function"
        name: "find_similar_character"
        description: "Identifies if top candidate is visually similar to expected"
        preconditions: "Recognition results contain at least one candidate"
        postconditions: "Returns Some(similar_char) if similarity detected"

  - file: "src/recognition/mod.rs"
    items:
      - type: "module_declaration"
        name: "recognition"
        description: "Root module for character recognition subsystem"
      
      - type: "struct"
        name: "RecognitionService"
        description: "High-level service coordinating normalization, recognition, and validation"
      
      - type: "function"
        name: "RecognitionService::new"
        description: "Creates new RecognitionService with specified engine and config"
        postconditions: "Returns initialized service ready for recognition"
      
      - type: "method"
        name: "RecognitionService::recognize_and_validate"
        description: "End-to-end pipeline: normalize, recognize, validate against expected character"
        preconditions: "Stroke data is valid and non-empty"
        postconditions: "Returns ValidationResult with feedback on match or failure"
      
      - type: "method"
        name: "RecognitionService::recognize_only"
        description: "Performs recognition without validation, returns all candidates"
        preconditions: "Stroke data is valid and non-empty"
        postconditions: "Returns RecognitionResult with ranked candidates"

  - file: "tests/recognition_tests.rs"
    items:
      - type: "function"
        name: "test_normalize_coordinates_preserves_range"
        description: "Verifies normalized coordinates are in [0, 1] range"
      
      - type: "function"
        name: "test_normalize_preserves_stroke_order"
        description: "Ensures stroke order is maintained after normalization"
      
      - type: "function"
        name: "test_resample_produces_exact_point_count"
        description: "Checks resampling returns exactly the requested number of points"
      
      - type: "function"
        name: "test_smooth_preserves_endpoints"
        description: "Verifies smoothing does not alter stroke start and end points"
      
      - type: "function"
        name: "test_bounding_box_calculation"
        description: "Tests bounding box correctly encompasses all points"
      
      - type: "function"
        name: "test_recognition_returns_sorted_results"
        description: "Confirms recognition results are sorted by confidence descending"
      
      - type: "function"
        name: "test_validation_accepts_correct_match"
        description: "Validates that correct character in top-N passes validation"
      
      - type: "function"
        name: "test_validation_rejects_low_confidence"
        description: "Ensures low confidence matches are rejected"
      
      - type: "function"
        name: "test_validation_rejects_missing_character"
        description: "Confirms validation fails when expected character not in results"
      
      - type: "function"
        name: "test_feedback_detects_stroke_count_error"
        description: "Verifies feedback identifies wrong stroke count"
      
      - type: "function"
        name: "test_end_to_end_recognition_pipeline"
        description: "Integration test of complete recognition flow with sample data"
      
      - type: "function"
        name: "test_recognition_performance_under_200ms"
        description: "Benchmark test ensuring recognition completes within time limit"

formal_verification:
  needed: false
  level: "None"
  explanation: |
    Character recognition integration does not require formal verification for several reasons:
    
    1. Non-critical failure domain: Recognition errors result in user feedback and retry
       opportunities, not system corruption or safety hazards. False positives/negatives
       affect UX but not correctness of the core system.
    
    2. Inherent uncertainty: Recognition operates on probabilistic/heuristic matching
       of imperfect human input against learned patterns. The "correct" result is subjective
       and context-dependent, making formal specification of correctness properties difficult.
    
    3. External dependency: Core recognition logic resides in third-party libraries
       (hanzi_lookup, WASM modules, or ML models) that are not under our control and
       cannot be formally verified within this project scope.
    
    4. Testability through empirical methods: Recognition quality is best validated
       through integration testing with real handwriting samples, measuring metrics like
       accuracy, false positive/negative rates, and latency. Property-based testing of
       normalization functions (coordinate scaling, resampling) provides sufficient
       assurance for preprocessing logic.
    
    5. Tunable thresholds: Validation thresholds (confidence scores, top-N ranking)
       are adjustable parameters that will be empirically tuned based on user testing,
       not formally derived.
    
    The task is better served by comprehensive integration testing with diverse handwriting
    samples, performance benchmarking, and iterative threshold tuning based on observed
    false positive/negative rates. Unit tests will verify normalization preserves relative
    positions and produces consistent output ranges, which is sufficient for deterministic
    preprocessing logic.

tests:
  strategy:
    approach: "mixed (unit + integration + property-based)"
    rationale:
      - "Unit tests verify stroke normalization math and coordinate transformations in isolation"
      - "Integration tests validate end-to-end recognition pipeline with real stroke data samples"
      - "Property-based tests ensure normalization preserves invariants across input ranges"
      - "Performance tests verify recognition completes within 200ms requirement"
      - "Validation tests confirm false positive rate stays below 5% threshold"
      - "Mock-based tests isolate recognition interface from external library dependencies"

  implementation:
    file: "tests/recognition_tests.rs"
    location: "separate test file"
    code: |
      #[cfg(test)]
      mod tests {
          use super::*;
          
          // ==================== Stroke Normalization Tests ====================
          
          #[test]
          fn test_normalize_stroke_to_unit_square() {
              // Test that arbitrary coordinates normalize to 0-1 range
              let strokes = vec![
                  vec![(100.0, 200.0), (300.0, 400.0), (200.0, 300.0)],
              ];
              
              let normalized = normalize_strokes(&strokes);
              
              for stroke in &normalized {
                  for (x, y) in stroke {
                      assert!(*x >= 0.0 && *x <= 1.0, "X coordinate out of range: {}", x);
                      assert!(*y >= 0.0 && *y <= 1.0, "Y coordinate out of range: {}", y);
                  }
              }
          }
          
          #[test]
          fn test_normalization_preserves_relative_positions() {
              // Verify that relative stroke positions are maintained
              let strokes = vec![
                  vec![(0.0, 0.0), (100.0, 0.0)],  // Horizontal line
                  vec![(50.0, 50.0), (50.0, 100.0)], // Vertical line
              ];
              
              let normalized = normalize_strokes(&strokes);
              
              // First stroke should remain horizontal (same y)
              assert_eq!(normalized[0][0].1, normalized[0][1].1);
              
              // Second stroke should remain vertical (same x)
              assert_eq!(normalized[1][0].0, normalized[1][1].0);
          }
          
          #[test]
          fn test_normalization_preserves_stroke_order() {
              // Ensure stroke order is maintained after normalization
              let strokes = vec![
                  vec![(0.0, 0.0), (50.0, 50.0)],
                  vec![(100.0, 100.0), (150.0, 150.0)],
                  vec![(200.0, 0.0), (250.0, 50.0)],
              ];
              
              let normalized = normalize_strokes(&strokes);
              
              assert_eq!(normalized.len(), 3);
              assert_eq!(normalized[0].len(), 2);
              assert_eq!(normalized[1].len(), 2);
              assert_eq!(normalized[2].len(), 2);
          }
          
          #[test]
          fn test_resample_stroke_to_fixed_point_count() {
              // Test resampling produces consistent point count
              let stroke = vec![
                  (0.0, 0.0), (10.0, 10.0), (20.0, 20.0), (30.0, 30.0),
                  (40.0, 40.0), (50.0, 50.0)
              ];
              
              let resampled = resample_stroke(&stroke, 10);
              
              assert_eq!(resampled.len(), 10);
              assert_eq!(resampled[0], (0.0, 0.0));
              assert_eq!(resampled[9], (50.0, 50.0));
          }
          
          #[test]
          fn test_smooth_stroke_reduces_noise() {
              // Verify smoothing reduces jitter while preserving general shape
              let noisy_stroke = vec![
                  (0.0, 0.0), (1.0, 5.0), (2.0, 3.0), (3.0, 7.0),
                  (4.0, 6.0), (5.0, 10.0)
              ];
              
              let smoothed = smooth_stroke(&noisy_stroke, 0.3);
              
              // Smoothed stroke should have same length
              assert_eq!(smoothed.len(), noisy_stroke.len());
              
              // Variance should be reduced
              let original_variance = calculate_variance(&noisy_stroke);
              let smoothed_variance = calculate_variance(&smoothed);
              assert!(smoothed_variance < original_variance);
          }
          
          // ==================== Recognition Interface Tests ====================
          
          #[test]
          fn test_recognition_returns_candidates() {
              // Test that recognition engine returns ranked candidates
              let normalized_strokes = vec![
                  vec![(0.0, 0.0), (1.0, 0.0), (1.0, 1.0)], // Simple L shape
              ];
              
              let result = recognize_character(&normalized_strokes);
              
              assert!(result.is_ok());
              let candidates = result.unwrap();
              assert!(!candidates.is_empty());
              assert!(candidates.len() <= 10); // Should limit results
          }
          
          #[test]
          fn test_recognition_candidates_sorted_by_confidence() {
              // Verify candidates are sorted descending by confidence
              let strokes = create_sample_hiragana_a();
              
              let candidates = recognize_character(&strokes).unwrap();
              
              for i in 0..candidates.len()-1 {
                  assert!(
                      candidates[i].confidence >= candidates[i+1].confidence,
                      "Candidates not sorted by confidence"
                  );
              }
          }
          
          #[test]
          fn test_recognition_confidence_scores_in_valid_range() {
              // Ensure confidence scores are between 0 and 1
              let strokes = create_sample_hiragana_a();
              
              let candidates = recognize_character(&strokes).unwrap();
              
              for candidate in candidates {
                  assert!(
                      candidate.confidence >= 0.0 && candidate.confidence <= 1.0,
                      "Invalid confidence score: {}", candidate.confidence
                  );
              }
          }
          
          // ==================== Validation Tests ====================
          
          #[test]
          fn test_validate_correct_character_match() {
              // Test validation succeeds when expected character is in top results
              let strokes = create_sample_hiragana_a();
              let expected = 'あ';
              
              let is_valid = validate_recognition(&strokes, expected, 3, 0.7).unwrap();
              
              assert!(is_valid, "Should validate correct character");
          }
          
          #[test]
          fn test_validate_rejects_incorrect_character() {
              // Test validation fails when expected character not in top results
              let strokes = create_sample_hiragana_a();
              let expected = 'い'; // Wrong character
              
              let is_valid = validate_recognition(&strokes, expected, 3, 0.7).unwrap();
              
              assert!(!is_valid, "Should reject incorrect character");
          }
          
          #[test]
          fn test_validate_respects_confidence_threshold() {
              // Test that validation fails if confidence below threshold
              let strokes = create_sample_hiragana_a();
              let expected = 'あ';
              
              // Set impossibly high threshold
              let is_valid = validate_recognition(&strokes, expected, 3, 0.99).unwrap();
              
              // May fail if confidence not high enough
              // (behavior depends on recognition quality)
          }
          
          #[test]
          fn test_validate_respects_top_n_limit() {
              // Test that validation only checks top N results
              let strokes = create_sample_hiragana_a();
              let expected = 'あ';
              
              // Check top 1 vs top 5
              let top_1 = validate_recognition(&strokes, expected, 1, 0.5).unwrap();
              let top_5 = validate_recognition(&strokes, expected, 5, 0.5).unwrap();
              
              // Top 5 should be at least as permissive as top 1
              if top_1 {
                  assert!(top_5, "Top 5 should include top 1 match");
              }
          }
          
          // ==================== Feedback Generation Tests ====================
          
          #[test]
          fn test_feedback_for_wrong_stroke_count() {
              // Test feedback when stroke count is incorrect
              let strokes = vec![
                  vec![(0.0, 0.0), (1.0, 1.0)], // Only 1 stroke
              ];
              let expected = 'あ'; // Requires 3 strokes
              
              let feedback = generate_feedback(&strokes, expected, &[]);
              
              assert!(feedback.contains("stroke"));
              assert!(feedback.contains("3")); // Should mention expected count
          }
          
          #[test]
          fn test_feedback_shows_close_matches() {
              // Test feedback suggests similar characters
              let strokes = create_sample_hiragana_a();
              let expected = 'お'; // Similar to あ
              
              let candidates = recognize_character(&strokes).unwrap();
              let feedback = generate_feedback(&strokes, expected, &candidates);
              
              assert!(feedback.contains("similar") || feedback.contains("close"));
              assert!(feedback.contains('あ')); // Should show actual match
          }
          
          // ==================== Performance Tests ====================
          
          #[test]
          fn test_recognition_performance_under_200ms() {
              // Verify recognition completes within performance requirement
              use std::time::Instant;
              
              let strokes = create_sample_hiragana_a();
              
              let start = Instant::now();
              let _result = recognize_character(&strokes);
              let duration = start.elapsed();
              
              assert!(
                  duration.as_millis() < 200,
                  "Recognition took {}ms, expected <200ms",
                  duration.as_millis()
              );
          }
          
          // ==================== Edge Case Tests ====================
          
          #[test]
          fn test_empty_stroke_handling() {
              // Test handling of empty stroke data
              let empty_strokes: Vec<Vec<(f64, f64)>> = vec![];
              
              let result = recognize_character(&empty_strokes);
              
              assert!(result.is_err() || result.unwrap().is_empty());
          }
          
          #[test]
          fn test_single_point_stroke_handling() {
              // Test handling of degenerate single-point strokes
              let single_point = vec![vec![(0.5, 0.5)]];
              
              let result = normalize_strokes(&single_point);
              
              // Should handle gracefully without panic
              assert_eq!(result.len(), 1);
          }
          
          // ==================== Helper Functions ====================
          
          fn create_sample_hiragana_a() -> Vec<Vec<(f64, f64)>> {
              // Sample stroke data for hiragana 'あ' character
              vec![
                  vec![(0.2, 0.1), (0.4, 0.2), (0.5, 0.4)],
                  vec![(0.3, 0.3), (0.6, 0.3), (0.8, 0.5)],
                  vec![(0.5, 0.5), (0.5, 0.8), (0.6, 0.9)],
              ]
          }
          
          fn calculate_variance(stroke: &[(f64, f64)]) -> f64 {
              let y_values: Vec<f64> = stroke.iter().map(|(_, y)| *y).collect();
              let mean = y_values.iter().sum::<f64>() / y_values.len() as f64;
              y_values.iter().map(|y| (y - mean).powi(2)).sum::<f64>() / y_values.len() as f64
          }
      }
      
      // ==================== Property-Based Tests ====================
      
      #[cfg(test)]
      mod property_tests {
          use super::*;
          use proptest::prelude::*;
          
          proptest! {
              #[test]
              fn prop_normalization_always_in_unit_range(
                  strokes in prop::collection::vec(
                      prop::collection::vec(
                          (0.0f64..1000.0, 0.0f64..1000.0),
                          1..20
                      ),
                      1..5
                  )
              ) {
                  let normalized = normalize_strokes(&strokes);
                  
                  for stroke in normalized {
                      for (x, y) in stroke {
                          prop_assert!(x >= 0.0 && x <= 1.0);
                          prop_assert!(y >= 0.0 && y <= 1.0);
                      }
                  }
              }
              
              #[test]
              fn prop_normalization_preserves_stroke_count(
                  strokes in prop::collection::vec(
                      prop::collection::vec(
                          (0.0f64..100.0, 0.0f64..100.0),
                          2..10
                      ),
                      1..5
                  )
              ) {
                  let normalized = normalize_strokes(&strokes);
                  prop_assert_eq!(normalized.len(), strokes.len());
              }
              
              #[test]
              fn prop_resampling_preserves_endpoints(
                  stroke in prop::collection::vec(
                      (0.0f64..100.0, 0.0f64..100.0),
                      3..20
                  ),
                  target_count in 5usize..50
              ) {
                  let first = stroke[0];
                  let last = stroke[stroke.len() - 1];
                  
                  let resampled = resample_stroke(&stroke, target_count);
                  
                  prop_assert_eq!(resampled[0], first);
                  prop_assert_eq!(resampled[target_count - 1], last);
              }
              
              #[test]
              fn prop_confidence_scores_valid_range(
                  strokes in prop::collection::vec(
                      prop::collection::vec(
                          (0.0f64..1.0, 0.0f64..1.0),
                          2..10
                      ),
                      1..4
                  )
              ) {
                  if let Ok(candidates) = recognize_character(&strokes) {
                      for candidate in candidates {
                          prop_assert!(candidate.confidence >= 0.0);
                          prop_assert!(candidate.confidence <= 1.0);
                      }
                  }
              }
          }
      }
      
      // ==================== Integration Tests ====================
      
      #[cfg(test)]
      mod integration_tests {
          use super::*;
          
          #[test]
          fn test_end_to_end_recognition_pipeline() {
              // Test complete flow: raw input -> normalization -> recognition -> validation
              let raw_strokes = vec![
                  vec![(50.0, 20.0), (150.0, 40.0), (200.0, 100.0)],
                  vec![(100.0, 80.0), (250.0, 80.0), (300.0, 150.0)],
                  vec![(180.0, 140.0), (180.0, 280.0), (220.0, 320.0)],
              ];
              
              // Step 1: Normalize
              let normalized = normalize_strokes(&raw_strokes);
              assert!(!normalized.is_empty());
              
              // Step 2: Resample
              let resampled: Vec<Vec<(f64, f64)>> = normalized
                  .iter()
                  .map(|stroke| resample_stroke(stroke, 20))
                  .collect();
              
              // Step 3: Recognize
              let candidates = recognize_character(&resampled).unwrap();
              assert!(!candidates.is_empty());
              
              // Step 4: Validate
              let expected = candidates[0].character;
              let is_valid = validate_recognition(&resampled, expected, 3, 0.5).unwrap();
              assert!(is_valid);
          }
          
          #[test]
          fn test_false_positive_rate_below_threshold() {
              // Test that false positive rate is below 5%
              let test_cases = load_test_dataset(); // Load labeled test data
              let mut false_positives = 0;
              let total = test_cases.len();
              
              for (strokes, expected) in test_cases {
                  let normalized = normalize_strokes(&strokes);
                  let is_valid = validate_recognition(&normalized, expected, 3, 0.7).unwrap();
                  
                  if is_valid {
                      let candidates = recognize_character(&normalized).unwrap();
                      let top_match = candidates[0].character;
                      if top_match != expected {
                          false_positives += 1;
                      }
                  }
              }
              
              let false_positive_rate = false_positives as f64 / total as f64;
              assert!(
                  false_positive_rate < 0.05,
                  "False positive rate {}% exceeds 5% threshold",
                  false_positive_rate * 100.0
              );
          }
          
          fn load_test_dataset() -> Vec<(Vec<Vec<(f64, f64)>>, char)> {
              // Load or generate test dataset
              vec![
                  (create_sample_hiragana_a(), 'あ'),
                  // Add more test cases
              ]
          }
      }

  coverage:
    - "Stroke normalization to 0-1 unit square range"
    - "Normalization preserves relative positions and proportions"
    - "Normalization preserves stroke order and direction"
    - "Stroke resampling to fixed point count"
    - "Resampling preserves start and end points"
    - "Stroke smoothing reduces noise while maintaining shape"
    - "Recognition engine returns non-empty candidate list"
    - "Recognition candidates sorted by descending confidence"
    - "Confidence scores are within valid 0-1 range"
    - "Validation succeeds when expected character in top-N with sufficient confidence"
    - "Validation rejects incorrect characters"
    - "Validation respects confidence threshold parameter"
    - "Validation respects top-N limit parameter"
    - "Feedback generation for incorrect stroke count"
    - "Feedback suggests similar characters for close matches"
    - "Recognition performance under 200ms requirement"
    - "Empty stroke data handled gracefully"
    - "Single-point degenerate strokes handled without panic"
    - "Property: normalization always produces 0-1 range output"
    - "Property: normalization preserves stroke count"
    - "Property: resampling preserves endpoints"
    - "Property: confidence scores always in valid range"
    - "Integration: end-to-end pipeline from raw input to validation"
    - "Integration: false positive rate below 5% threshold on test dataset"

dependencies:
  depends_on:
    - task_id: 5
      reason: "Requires stroke data format (Point, Stroke, StrokeSequence types) from HandwritingCanvas to process user drawings"

  depended_upon_by:
    - task_id: 8
      reason: "PracticeSession uses recognition validation to assess whether user-drawn characters match expected characters, enabling practice mode feedback loop"

  external:
    - name: "hanzi_lookup"
      type: "crate"
      status: "needs implementation"
    - name: "proptest"
      type: "crate"
      status: "to be imported"
---
task:
  id: 10
  name: "Statistics and Progress Visualization"

context:
  description: |
    This task implements comprehensive statistics tracking and visualization for user
    progress in the flashcard application. It aggregates review data into meaningful
    metrics including accuracy rates, study streaks, cards mastered, and time-series
    data for daily and weekly patterns.
    
    The statistics system serves multiple purposes: it motivates learners through
    visible progress indicators, provides insight into learning patterns for future
    optimization, and creates engagement through gamification elements like streaks
    and achievements. Research shows that progress visualization significantly
    improves learner retention and consistency.
    
    The implementation uses efficient data structures (BTreeMap for time-series data,
    HashSet for date tracking) to enable fast queries and aggregations. The achievement
    system unlocks milestones based on review count, accuracy, and streak thresholds,
    providing positive reinforcement for consistent practice.
    
    This task integrates with the LearningSession (Task 8) which updates statistics
    after each review, and with the database layer (Task 11) which persists metrics
    across sessions. The statistics screen provides a dedicated UI for viewing all
    progress visualizations.

  key_points:
    - "Use BTreeMap for daily_stats to enable efficient date range queries for weekly/monthly aggregations"
    - "Calculate streaks from study_days HashSet by checking for consecutive dates ending at today"
    - "Update statistics incrementally during sessions, batch save at end to minimize I/O"
    - "Handle timezone boundaries carefully when converting timestamps to dates for streak calculations"
    - "Achievement unlocks should trigger celebratory animations to reinforce positive behavior"
    - "Card maturity stages: new (never reviewed), learning (interval <21 days), mature (21+ days)"
    - "Property-based testing ensures invariants like accuracy ∈ [0,1] and longest_streak >= current_streak"

files:
  - path: "src/models/statistics.rs"
    description: "Core Statistics struct with metrics aggregation, time-series data structures (DayStats, WeekStats), and calculation methods for accuracy, streaks, and achievements"
  
  - path: "src/models/mod.rs"
    description: "Module declaration file to expose the statistics module"
  
  - path: "src/models/achievement.rs"
    description: "Achievement system types and unlock logic for milestone-based gamification"
  
  - path: "src/ui/statistics_screen.rs"
    description: "Statistics screen UI component rendering progress visualizations, metrics displays, and achievement badges"
  
  - path: "src/ui/mod.rs"
    description: "Module declaration file to expose the statistics_screen module"
  
  - path: "src/ui/components/progress_chart.rs"
    description: "Reusable progress visualization components for displaying accuracy trends and review history"
  
  - path: "src/ui/components/streak_display.rs"
    description: "Streak indicator widget showing current and longest streaks with flame emoji visualization"
  
  - path: "src/ui/components/mod.rs"
    description: "Module declaration file to expose progress_chart and streak_display components"

functions:
  - file: "src/models/statistics.rs"
    items:
      - type: "struct"
        name: "Statistics"
        description: "Aggregates review data into meaningful metrics including accuracy, streaks, time metrics, and card counts"
        invariants: "total_reviews >= correct_reviews, current_streak >= 0, longest_streak >= current_streak, cards_new + cards_learning + cards_mastered == total_cards"
      
      - type: "struct"
        name: "DayStats"
        description: "Time-series data structure for daily review aggregations, tracking reviews and accuracy for a single day"
        invariants: "total_reviews >= correct_reviews, accuracy is in range 0.0..=1.0"
      
      - type: "struct"
        name: "WeekStats"
        description: "Time-series data structure for weekly review aggregations, tracking reviews and accuracy for a week"
        invariants: "total_reviews >= correct_reviews, accuracy is in range 0.0..=1.0"
      
      - type: "method"
        name: "Statistics::new"
        description: "Creates a new Statistics instance with zero values and empty collections"
        postconditions: "Returns Statistics with all counters at 0, empty BTreeMap for daily stats, empty HashSet for study_days"
      
      - type: "method"
        name: "Statistics::update_from_review"
        description: "Updates statistics incrementally based on a single review result"
        preconditions: "Valid review result with card_id, correctness, and timestamp"
        postconditions: "Increments total_reviews, updates correct_reviews if applicable, updates daily stats, adds to study_days set"
      
      - type: "method"
        name: "Statistics::calculate_accuracy"
        description: "Calculates overall accuracy rate as correct/total reviews"
        preconditions: "total_reviews may be 0"
        postconditions: "Returns f64 in range 0.0..=1.0, or 0.0 if no reviews"
      
      - type: "method"
        name: "Statistics::update_streak"
        description: "Recalculates current and longest streak based on study_days set"
        preconditions: "study_days contains valid dates"
        postconditions: "current_streak reflects consecutive days ending today, longest_streak is max of all streaks"
      
      - type: "method"
        name: "Statistics::get_cards_by_status"
        description: "Returns tuple of (new, learning, mastered) card counts based on card intervals"
        postconditions: "Returns (u32, u32, u32) where sum equals total unique cards reviewed"
      
      - type: "method"
        name: "Statistics::get_daily_stats"
        description: "Retrieves DayStats for a specific date from the BTreeMap"
        postconditions: "Returns Option<&DayStats>, None if date not found"
      
      - type: "method"
        name: "Statistics::get_week_stats"
        description: "Aggregates DayStats over a week range into WeekStats"
        preconditions: "Valid date range (start <= end)"
        postconditions: "Returns WeekStats aggregating all daily data in range"
      
      - type: "method"
        name: "Statistics::add_study_day"
        description: "Adds a date to the study_days HashSet and triggers streak update"
        postconditions: "Date is in study_days, streak is recalculated"
      
      - type: "function"
        name: "calculate_streak"
        description: "Helper function to calculate consecutive day streak from a set of dates"
        preconditions: "study_days is a valid HashSet of dates"
        postconditions: "Returns (current_streak, longest_streak) as (u32, u32)"
      
      - type: "function"
        name: "get_date_from_timestamp"
        description: "Converts timestamp to local date, handling timezone correctly"
        preconditions: "Valid timestamp"
        postconditions: "Returns NaiveDate in local timezone"

  - file: "src/models/achievement.rs"
    items:
      - type: "enum"
        name: "Achievement"
        description: "Represents different achievement types with associated milestone values"
      
      - type: "enum_variant"
        name: "Achievement::FirstReview"
        description: "Unlocked after completing first review"
      
      - type: "enum_variant"
        name: "Achievement::Streak7"
        description: "Unlocked after maintaining 7-day study streak"
      
      - type: "enum_variant"
        name: "Achievement::Streak30"
        description: "Unlocked after maintaining 30-day study streak"
      
      - type: "enum_variant"
        name: "Achievement::Streak100"
        description: "Unlocked after maintaining 100-day study streak"
      
      - type: "enum_variant"
        name: "Achievement::Reviews100"
        description: "Unlocked after completing 100 reviews"
      
      - type: "enum_variant"
        name: "Achievement::Reviews1000"
        description: "Unlocked after completing 1000 reviews"
      
      - type: "enum_variant"
        name: "Achievement::Accuracy90"
        description: "Unlocked when achieving 90% accuracy over 50+ reviews"
      
      - type: "enum_variant"
        name: "Achievement::CardsMastered50"
        description: "Unlocked after mastering 50 cards"
      
      - type: "struct"
        name: "AchievementTracker"
        description: "Tracks unlocked achievements and checks for new unlocks"
        invariants: "unlocked contains only valid Achievement variants"
      
      - type: "method"
        name: "AchievementTracker::new"
        description: "Creates a new empty AchievementTracker"
        postconditions: "Returns tracker with empty unlocked HashSet"
      
      - type: "method"
        name: "AchievementTracker::check_and_unlock"
        description: "Checks statistics against achievement conditions and returns newly unlocked achievements"
        preconditions: "Valid Statistics instance"
        postconditions: "Returns Vec<Achievement> of newly unlocked achievements, updates unlocked set"
      
      - type: "method"
        name: "AchievementTracker::is_unlocked"
        description: "Checks if a specific achievement has been unlocked"
        postconditions: "Returns bool indicating unlock status"
      
      - type: "method"
        name: "Achievement::description"
        description: "Returns human-readable description of the achievement"
        postconditions: "Returns &str with achievement description"
      
      - type: "method"
        name: "Achievement::icon"
        description: "Returns emoji or icon representation of the achievement"
        postconditions: "Returns &str with emoji/icon"

  - file: "src/ui/statistics_screen.rs"
    items:
      - type: "function"
        name: "view_statistics"
        description: "Renders the statistics screen UI with all progress visualizations"
        preconditions: "Valid Statistics and AchievementTracker instances"
        postconditions: "Returns Element representing complete statistics screen"
      
      - type: "function"
        name: "render_accuracy_card"
        description: "Renders a card displaying overall accuracy percentage"
        postconditions: "Returns Element with accuracy percentage and visual indicator"
      
      - type: "function"
        name: "render_streak_card"
        description: "Renders a card displaying current and longest streak with flame emoji"
        postconditions: "Returns Element with streak metrics and flame emoji visualization"
      
      - type: "function"
        name: "render_cards_by_status"
        description: "Renders a breakdown of cards by status (new/learning/mastered)"
        postconditions: "Returns Element with card counts in three categories"
      
      - type: "function"
        name: "render_daily_history"
        description: "Renders daily review history for the past N days"
        preconditions: "Valid daily_stats BTreeMap"
        postconditions: "Returns Element with daily review counts, possibly as chart"
      
      - type: "function"
        name: "render_achievements"
        description: "Renders grid of achievements with locked/unlocked status"
        preconditions: "Valid AchievementTracker"
        postconditions: "Returns Element displaying all achievements with unlock status"
      
      - type: "function"
        name: "render_achievement_unlock_animation"
        description: "Renders celebratory animation when achievement is unlocked"
        preconditions: "Valid Achievement that was just unlocked"
        postconditions: "Returns animated Element showing achievement unlock"

  - file: "src/ui/mod.rs"
    items:
      - type: "module_declaration"
        name: "statistics_screen"
        description: "Module declaration for statistics screen UI components"

  - file: "src/lib.rs"
    items:
      - type: "module_declaration"
        name: "statistics"
        description: "Module declaration for statistics data structures and calculations"
      
      - type: "module_declaration"
        name: "achievements"
        description: "Module declaration for achievement system"

  - file: "tests/statistics_tests.rs"
    items:
      - type: "function"
        name: "test_statistics_new"
        description: "Tests that new Statistics instance has correct initial values"
      
      - type: "function"
        name: "test_accuracy_calculation"
        description: "Tests accuracy calculation with various correct/total ratios"
      
      - type: "function"
        name: "test_accuracy_with_no_reviews"
        description: "Tests that accuracy returns 0.0 when total_reviews is 0"
      
      - type: "function"
        name: "test_streak_consecutive_days"
        description: "Tests that streak increments correctly for consecutive study days"
      
      - type: "function"
        name: "test_streak_broken"
        description: "Tests that streak resets when a day is skipped"
      
      - type: "function"
        name: "test_longest_streak_tracking"
        description: "Tests that longest_streak correctly tracks maximum streak"
      
      - type: "function"
        name: "test_daily_stats_aggregation"
        description: "Tests that daily stats correctly aggregate multiple reviews on same day"
      
      - type: "function"
        name: "test_cards_by_status"
        description: "Tests card categorization into new/learning/mastered based on intervals"
      
      - type: "function"
        name: "test_achievement_unlock_conditions"
        description: "Tests that achievements unlock at correct milestones"
      
      - type: "function"
        name: "test_week_stats_aggregation"
        description: "Tests that week stats correctly aggregate daily data over date range"
      
      - type: "function"
        name: "prop_accuracy_range"
        description: "Property test verifying accuracy is always in range 0.0..=1.0"
      
      - type: "function"
        name: "prop_streak_invariants"
        description: "Property test verifying longest_streak >= current_streak"
      
      - type: "function"
        name: "prop_review_counts"
        description: "Property test verifying total_reviews >= correct_reviews"

formal_verification:
  needed: false
  level: "None"
  explanation: |
    Formal verification is not required for this statistics and visualization task
    because the functionality is primarily computational and presentational rather
    than safety-critical or security-sensitive.
    
    The core operations involve:
    1. Statistical aggregations (counting, averaging, ratio calculations)
    2. Date-based streak calculations
    3. Achievement milestone checking
    4. UI rendering of computed metrics
    
    These operations are:
    - Deterministic and mathematically straightforward
    - Well-suited to comprehensive unit and property-based testing
    - Non-critical to system safety (incorrect statistics don't compromise data integrity)
    - Easily verifiable through conventional testing approaches
    
    Property-based testing (as indicated in the task overview) is the appropriate
    verification strategy for this component. Properties like "accuracy always between
    0 and 1", "streak never negative", and "total reviews equals sum of correct and
    incorrect" can be thoroughly validated through proptest without the overhead of
    formal verification tools.
    
    The risk assessment confirms low complexity, integration, and testing risk,
    further supporting that standard testing practices are sufficient.

tests:
  strategy:
    approach: "mixed (unit tests + property-based)"
    rationale:
      - "Statistics calculations are deterministic mathematical operations best verified with unit tests"
      - "Streak calculations have clear edge cases (consecutive days, gaps, resets) suitable for unit testing"
      - "Property-based tests ensure accuracy calculations remain valid across random review distributions"
      - "Achievement unlock conditions are threshold-based and require boundary testing"
      - "Time-series aggregation correctness can be verified with known input/output pairs"
      - "No concurrency or external I/O involved, making unit testing sufficient"

  implementation:
    file: "src/models/statistics.rs"
    location: "in existing test module"
    code: |
      #[cfg(test)]
      mod tests {
          use super::*;
          use chrono::{NaiveDate, Utc, TimeZone};
          use std::collections::{BTreeMap, HashSet};

          #[test]
          fn test_accuracy_calculation_perfect_score() {
              // Verify 100% accuracy when all reviews are correct
              let mut stats = Statistics::new();
              stats.total_reviews = 10;
              stats.correct_reviews = 10;
              
              assert_eq!(stats.accuracy_rate(), 100.0);
          }

          #[test]
          fn test_accuracy_calculation_zero_score() {
              // Verify 0% accuracy when no reviews are correct
              let mut stats = Statistics::new();
              stats.total_reviews = 10;
              stats.correct_reviews = 0;
              
              assert_eq!(stats.accuracy_rate(), 0.0);
          }

          #[test]
          fn test_accuracy_calculation_partial_score() {
              // Verify correct accuracy for partial success
              let mut stats = Statistics::new();
              stats.total_reviews = 20;
              stats.correct_reviews = 15;
              
              assert_eq!(stats.accuracy_rate(), 75.0);
          }

          #[test]
          fn test_accuracy_with_no_reviews() {
              // Verify handling of division by zero case
              let stats = Statistics::new();
              
              assert_eq!(stats.accuracy_rate(), 0.0);
          }

          #[test]
          fn test_streak_increments_consecutive_days() {
              // Verify streak increments when studying consecutive days
              let mut stats = Statistics::new();
              let day1 = NaiveDate::from_ymd_opt(2024, 1, 1).unwrap();
              let day2 = NaiveDate::from_ymd_opt(2024, 1, 2).unwrap();
              let day3 = NaiveDate::from_ymd_opt(2024, 1, 3).unwrap();
              
              stats.record_study_day(day1);
              assert_eq!(stats.current_streak, 1);
              
              stats.record_study_day(day2);
              assert_eq!(stats.current_streak, 2);
              
              stats.record_study_day(day3);
              assert_eq!(stats.current_streak, 3);
          }

          #[test]
          fn test_streak_resets_on_gap() {
              // Verify streak resets when a day is skipped
              let mut stats = Statistics::new();
              let day1 = NaiveDate::from_ymd_opt(2024, 1, 1).unwrap();
              let day2 = NaiveDate::from_ymd_opt(2024, 1, 2).unwrap();
              let day5 = NaiveDate::from_ymd_opt(2024, 1, 5).unwrap();
              
              stats.record_study_day(day1);
              stats.record_study_day(day2);
              assert_eq!(stats.current_streak, 2);
              
              stats.record_study_day(day5);
              assert_eq!(stats.current_streak, 1);
          }

          #[test]
          fn test_longest_streak_tracked() {
              // Verify longest streak is preserved even when current resets
              let mut stats = Statistics::new();
              let day1 = NaiveDate::from_ymd_opt(2024, 1, 1).unwrap();
              let day2 = NaiveDate::from_ymd_opt(2024, 1, 2).unwrap();
              let day3 = NaiveDate::from_ymd_opt(2024, 1, 3).unwrap();
              let day10 = NaiveDate::from_ymd_opt(2024, 1, 10).unwrap();
              
              stats.record_study_day(day1);
              stats.record_study_day(day2);
              stats.record_study_day(day3);
              assert_eq!(stats.longest_streak, 3);
              
              stats.record_study_day(day10);
              assert_eq!(stats.current_streak, 1);
              assert_eq!(stats.longest_streak, 3);
          }

          #[test]
          fn test_same_day_recorded_once() {
              // Verify recording the same day multiple times doesn't inflate streak
              let mut stats = Statistics::new();
              let day1 = NaiveDate::from_ymd_opt(2024, 1, 1).unwrap();
              
              stats.record_study_day(day1);
              stats.record_study_day(day1);
              stats.record_study_day(day1);
              
              assert_eq!(stats.current_streak, 1);
              assert_eq!(stats.study_days.len(), 1);
          }

          #[test]
          fn test_daily_stats_aggregation() {
              // Verify daily statistics aggregate correctly
              let mut stats = Statistics::new();
              let date = NaiveDate::from_ymd_opt(2024, 1, 1).unwrap();
              
              stats.record_review(date, true, 120);
              stats.record_review(date, false, 180);
              stats.record_review(date, true, 60);
              
              let day_stats = stats.daily_stats.get(&date).unwrap();
              assert_eq!(day_stats.reviews_count, 3);
              assert_eq!(day_stats.correct_count, 2);
              assert_eq!(day_stats.total_time_seconds, 360);
              assert_eq!(day_stats.accuracy_rate(), 66.66667);
          }

          #[test]
          fn test_cards_by_status_counts() {
              // Verify card status categorization
              let mut stats = Statistics::new();
              
              stats.cards_new = 50;
              stats.cards_learning = 30;
              stats.cards_mature = 20;
              
              assert_eq!(stats.total_cards(), 100);
              assert_eq!(stats.mastery_percentage(), 20.0);
          }

          #[test]
          fn test_achievement_unlock_first_review() {
              // Verify achievement unlocks at correct milestone
              let mut achievements = AchievementTracker::new();
              
              assert!(!achievements.is_unlocked("first_review"));
              
              achievements.check_and_unlock("first_review", 1, 1);
              assert!(achievements.is_unlocked("first_review"));
          }

          #[test]
          fn test_achievement_unlock_streak_milestone() {
              // Verify streak-based achievement unlocks
              let mut achievements = AchievementTracker::new();
              
              assert!(!achievements.is_unlocked("week_streak"));
              
              achievements.check_and_unlock("week_streak", 7, 7);
              assert!(achievements.is_unlocked("week_streak"));
          }

          #[test]
          fn test_achievement_unlock_review_count_milestone() {
              // Verify review count milestones unlock achievements
              let mut achievements = AchievementTracker::new();
              
              achievements.check_and_unlock("hundred_reviews", 100, 100);
              assert!(achievements.is_unlocked("hundred_reviews"));
              
              achievements.check_and_unlock("thousand_reviews", 1000, 1000);
              assert!(achievements.is_unlocked("thousand_reviews"));
          }

          #[test]
          fn test_weekly_stats_aggregation() {
              // Verify weekly aggregations sum daily stats correctly
              let mut stats = Statistics::new();
              let week_start = NaiveDate::from_ymd_opt(2024, 1, 1).unwrap();
              
              for day_offset in 0..7 {
                  let date = week_start + chrono::Duration::days(day_offset);
                  stats.record_review(date, true, 100);
                  stats.record_review(date, false, 100);
              }
              
              let week_stats = stats.get_week_stats(week_start);
              assert_eq!(week_stats.total_reviews, 14);
              assert_eq!(week_stats.correct_reviews, 7);
              assert_eq!(week_stats.total_time_seconds, 1400);
          }

          #[test]
          fn test_time_series_date_range_query() {
              // Verify BTreeMap enables efficient date range queries
              let mut stats = Statistics::new();
              let start = NaiveDate::from_ymd_opt(2024, 1, 1).unwrap();
              
              for day in 0..30 {
                  let date = start + chrono::Duration::days(day);
                  stats.record_review(date, true, 60);
              }
              
              let range_start = NaiveDate::from_ymd_opt(2024, 1, 10).unwrap();
              let range_end = NaiveDate::from_ymd_opt(2024, 1, 15).unwrap();
              
              let range_stats: Vec<_> = stats.daily_stats
                  .range(range_start..=range_end)
                  .collect();
              
              assert_eq!(range_stats.len(), 6);
          }

          #[test]
          fn test_update_statistics_from_review() {
              // Verify statistics update correctly after a review
              let mut stats = Statistics::new();
              let date = Utc::now().date_naive();
              
              stats.update_from_review(date, true, 150);
              
              assert_eq!(stats.total_reviews, 1);
              assert_eq!(stats.correct_reviews, 1);
              assert_eq!(stats.current_streak, 1);
              assert!(stats.study_days.contains(&date));
              assert!(stats.daily_stats.contains_key(&date));
          }

          #[test]
          fn test_maturity_classification() {
              // Verify cards are correctly classified as new/learning/mature
              let mut stats = Statistics::new();
              
              assert!(stats.is_new_card(0));
              assert!(stats.is_learning_card(10));
              assert!(stats.is_mature_card(21));
              assert!(stats.is_mature_card(100));
          }

          #[test]
          fn test_study_time_accumulation() {
              // Verify total study time accumulates correctly
              let mut stats = Statistics::new();
              let date = NaiveDate::from_ymd_opt(2024, 1, 1).unwrap();
              
              stats.record_review(date, true, 120);
              stats.record_review(date, true, 180);
              stats.record_review(date, false, 90);
              
              assert_eq!(stats.total_study_time_seconds, 390);
          }

          #[test]
          fn test_empty_statistics_defaults() {
              // Verify new Statistics struct has correct default values
              let stats = Statistics::new();
              
              assert_eq!(stats.total_reviews, 0);
              assert_eq!(stats.correct_reviews, 0);
              assert_eq!(stats.current_streak, 0);
              assert_eq!(stats.longest_streak, 0);
              assert_eq!(stats.cards_new, 0);
              assert_eq!(stats.cards_learning, 0);
              assert_eq!(stats.cards_mature, 0);
              assert_eq!(stats.total_study_time_seconds, 0);
              assert!(stats.study_days.is_empty());
              assert!(stats.daily_stats.is_empty());
          }
      }

      #[cfg(test)]
      mod property_tests {
          use super::*;
          use proptest::prelude::*;

          proptest! {
              #[test]
              fn prop_accuracy_always_between_0_and_100(
                  total in 1u32..10000,
                  correct in 0u32..10000
              ) {
                  let correct = correct.min(total);
                  let mut stats = Statistics::new();
                  stats.total_reviews = total;
                  stats.correct_reviews = correct;
                  
                  let accuracy = stats.accuracy_rate();
                  prop_assert!(accuracy >= 0.0 && accuracy <= 100.0);
              }

              #[test]
              fn prop_streak_never_exceeds_study_days(
                  days in prop::collection::vec(0i64..365, 1..100)
              ) {
                  let mut stats = Statistics::new();
                  let base = NaiveDate::from_ymd_opt(2024, 1, 1).unwrap();
                  
                  for day_offset in days {
                      let date = base + chrono::Duration::days(day_offset);
                      stats.record_study_day(date);
                  }
                  
                  prop_assert!(stats.current_streak as usize <= stats.study_days.len());
                  prop_assert!(stats.longest_streak as usize <= stats.study_days.len());
              }

              #[test]
              fn prop_longest_streak_never_less_than_current(
                  days in prop::collection::vec(0i64..100, 1..50)
              ) {
                  let mut stats = Statistics::new();
                  let base = NaiveDate::from_ymd_opt(2024, 1, 1).unwrap();
                  
                  for day_offset in days {
                      let date = base + chrono::Duration::days(day_offset);
                      stats.record_study_day(date);
                      prop_assert!(stats.longest_streak >= stats.current_streak);
                  }
              }

              #[test]
              fn prop_daily_stats_sum_equals_total(
                  review_counts in prop::collection::vec(1usize..50, 1..10)
              ) {
                  let mut stats = Statistics::new();
                  let base = NaiveDate::from_ymd_opt(2024, 1, 1).unwrap();
                  
                  let mut expected_total = 0;
                  for (day, count) in review_counts.iter().enumerate() {
                      let date = base + chrono::Duration::days(day as i64);
                      for _ in 0..*count {
                          stats.record_review(date, true, 60);
                          expected_total += 1;
                      }
                  }
                  
                  let daily_sum: u32 = stats.daily_stats
                      .values()
                      .map(|d| d.reviews_count)
                      .sum();
                  
                  prop_assert_eq!(daily_sum, expected_total);
              }

              #[test]
              fn prop_total_cards_equals_sum_of_categories(
                  new in 0u32..1000,
                  learning in 0u32..1000,
                  mature in 0u32..1000
              ) {
                  let mut stats = Statistics::new();
                  stats.cards_new = new;
                  stats.cards_learning = learning;
                  stats.cards_mature = mature;
                  
                  prop_assert_eq!(stats.total_cards(), new + learning + mature);
              }
          }
      }

  coverage:
    - "Accuracy calculation returns 100% for perfect scores"
    - "Accuracy calculation returns 0% for zero correct reviews"
    - "Accuracy calculation computes correct percentage for partial scores"
    - "Accuracy calculation handles zero total reviews without division errors"
    - "Streak increments correctly for consecutive study days"
    - "Streak resets to 1 when study days are non-consecutive"
    - "Longest streak is preserved when current streak resets"
    - "Recording same day multiple times doesn't inflate streak count"
    - "Daily statistics aggregate review count, correct count, and time correctly"
    - "Cards categorized correctly by status (new/learning/mature)"
    - "Achievement unlocks trigger at first review milestone"
    - "Achievement unlocks trigger at streak milestones"
    - "Achievement unlocks trigger at review count milestones"
    - "Weekly statistics correctly aggregate daily statistics over 7-day periods"
    - "BTreeMap enables efficient date range queries for time-series data"
    - "Statistics update correctly from individual review results"
    - "Cards classified correctly by interval (new: 0, learning: <21, mature: >=21)"
    - "Total study time accumulates across multiple reviews"
    - "New Statistics struct initializes with correct default values"
    - "Accuracy percentage always falls between 0 and 100 (property)"
    - "Current and longest streaks never exceed total study days (property)"
    - "Longest streak is never less than current streak (property)"
    - "Sum of daily review counts equals total reviews (property)"
    - "Total cards equals sum of new, learning, and mature cards (property)"

dependencies:
  depends_on:
    - task_id: 6
      reason: "Requires navigation framework to integrate statistics screen into application navigation flow"

  depended_upon_by:
    - task_id: 8
      reason: "LearningSession updates statistics after each review using update_from_review method"
    - task_id: 11
      reason: "Database layer persists Statistics struct and loads it on application startup"

  external:
    - name: "chrono"
      type: "crate"
      status: "to be imported"
    - name: "proptest"
      type: "crate"
      status: "to be imported"
    - name: "BTreeMap"
      type: "struct"
      status: "already exists"
    - name: "HashSet"
      type: "struct"
      status: "already exists"
    - name: "iced"
      type: "crate"
      status: "already exists"
---
task:
  id: 11
  name: "Local Persistence and Database Layer"

context:
  description: |
    This task implements a robust local data persistence layer using the redb embedded
    database to store all application data including user progress, flashcard state,
    review history, application settings, and statistics. The persistence layer is
    critical infrastructure that ensures data integrity and user trust.
    
    The implementation provides a type-safe wrapper (AppDatabase) around redb that
    handles serialization, transactions, and error handling. It uses bincode for
    efficient binary serialization during normal operations and JSON for human-readable
    backups. The database file is stored in platform-appropriate locations using the
    directories crate (XDG on Linux, AppData on Windows, Application Support on macOS).
    
    Key architectural decisions include:
    - Batch operations to minimize write transaction overhead
    - Separation of concerns: schema definitions, operations, and backup in distinct modules
    - ACID transaction guarantees delegated to redb with wrapper ensuring type safety
    - Export/import functionality for backup, restore, and data portability
    - Automatic metadata tracking for versioning and migration support
    
    This layer serves as the foundation for all persistent state in the application.
    Without it, no learning progress can be saved, making it a critical dependency
    for the learning session, statistics, and settings components.

  key_points:
    - "redb provides ACID guarantees without external dependencies (no separate database server)"
    - "Bincode serialization for performance, JSON for portability and human readability"
    - "Batch write operations critical for performance - single transaction for multiple cards"
    - "Read transactions are cheap and non-blocking, write transactions serialize"
    - "Platform-specific paths ensure proper integration with OS conventions"
    - "Backup/restore enables data portability and disaster recovery"
    - "Database corruption is rare but catastrophic - robust backup strategy essential"
    - "Future schema changes require migration strategy (tracked via metadata table)"

files:
  - path: "src/persistence/mod.rs"
    description: "Module declaration and re-exports for persistence layer"
  
  - path: "src/persistence/error.rs"
    description: "Persistence-specific error types wrapping redb, bincode, and IO errors"
  
  - path: "src/persistence/database.rs"
    description: "AppDatabase wrapper around redb with initialization and transaction handling"
  
  - path: "src/persistence/tables.rs"
    description: "redb table definitions for cards, reviews, settings, and statistics with serializable record types"
  
  - path: "src/persistence/backup.rs"
    description: "Export/import functionality for database backup and restore with compression support"
  
  - path: "src/persistence/paths.rs"
    description: "Platform-appropriate database file path resolution using directories crate"

functions:
  - file: "src/persistence/mod.rs"
    items:
      - type: "module_declaration"
        name: "pub mod database"
        description: "Database wrapper and operations module"
      - type: "module_declaration"
        name: "pub mod tables"
        description: "Table definitions and schema module"
      - type: "module_declaration"
        name: "pub mod backup"
        description: "Backup and restore functionality module"
      - type: "module_declaration"
        name: "mod error"
        description: "Persistence-specific error types"
      - type: "module_declaration"
        name: "mod paths"
        description: "Platform-specific path resolution"
      - type: "function"
        name: "pub use database::AppDatabase"
        description: "Re-export main database struct"
      - type: "function"
        name: "pub use error::PersistenceError"
        description: "Re-export persistence error type"

  - file: "src/persistence/error.rs"
    items:
      - type: "enum"
        name: "PersistenceError"
        description: "Error type for all persistence operations"
      - type: "enum_variant"
        name: "PersistenceError::DatabaseError"
        description: "Wrapper for redb errors"
      - type: "enum_variant"
        name: "PersistenceError::SerializationError"
        description: "Serialization/deserialization failures"
      - type: "enum_variant"
        name: "PersistenceError::IoError"
        description: "File system I/O errors"
      - type: "enum_variant"
        name: "PersistenceError::CorruptedData"
        description: "Data integrity check failures"
      - type: "enum_variant"
        name: "PersistenceError::NotFound"
        description: "Requested data not found in database"
      - type: "trait_impl"
        name: "impl From<redb::Error> for PersistenceError"
        description: "Convert redb errors to PersistenceError"
      - type: "trait_impl"
        name: "impl From<bincode::Error> for PersistenceError"
        description: "Convert bincode errors to PersistenceError"
      - type: "trait_impl"
        name: "impl From<std::io::Error> for PersistenceError"
        description: "Convert IO errors to PersistenceError"
      - type: "trait_impl"
        name: "impl Display for PersistenceError"
        description: "Human-readable error messages"
      - type: "trait_impl"
        name: "impl Error for PersistenceError"
        description: "Standard error trait implementation"

  - file: "src/persistence/tables.rs"
    items:
      - type: "constant"
        name: "CARDS_TABLE: TableDefinition<&str, &[u8]>"
        description: "Table for flashcard data, keyed by card ID"
      - type: "constant"
        name: "REVIEWS_TABLE: TableDefinition<u64, &[u8]>"
        description: "Table for review history, keyed by timestamp"
      - type: "constant"
        name: "SETTINGS_TABLE: TableDefinition<&str, &[u8]>"
        description: "Table for application settings, keyed by setting name"
      - type: "constant"
        name: "STATISTICS_TABLE: TableDefinition<&str, &[u8]>"
        description: "Table for aggregated statistics, keyed by stat type"
      - type: "constant"
        name: "METADATA_TABLE: TableDefinition<&str, &str>"
        description: "Table for database metadata (version, timestamps)"
      - type: "struct"
        name: "CardRecord"
        description: "Serializable card data for persistence"
      - type: "struct"
        name: "ReviewRecord"
        description: "Serializable review history entry"
      - type: "struct"
        name: "SettingsRecord"
        description: "Serializable application settings"
      - type: "struct"
        name: "StatisticsRecord"
        description: "Serializable statistics data"
      - type: "trait_impl"
        name: "impl Serialize for CardRecord"
        description: "Serialize card data using bincode"
      - type: "trait_impl"
        name: "impl Deserialize for CardRecord"
        description: "Deserialize card data using bincode"
      - type: "trait_impl"
        name: "impl From<SM2Card> for CardRecord"
        description: "Convert SM2Card to persistable record"
      - type: "trait_impl"
        name: "impl From<CardRecord> for SM2Card"
        description: "Convert record back to SM2Card"

  - file: "src/persistence/database.rs"
    items:
      - type: "struct"
        name: "AppDatabase"
        description: "Main database wrapper providing typed operations over redb"
        invariants: "Database file is always in valid redb format; all operations are ACID-compliant"
      - type: "method"
        name: "AppDatabase::new(path: PathBuf) -> Result<Self, PersistenceError>"
        description: "Open or create database at specified path"
        preconditions: "Path parent directory must exist or be creatable"
        postconditions: "Database is initialized with all required tables; metadata is set"
      - type: "method"
        name: "AppDatabase::default_path() -> Result<PathBuf, PersistenceError>"
        description: "Get platform-appropriate default database path using directories crate"
        postconditions: "Returns XDG data dir on Linux, AppData on Windows, Application Support on macOS"
      - type: "method"
        name: "AppDatabase::initialize_schema(&self) -> Result<(), PersistenceError>"
        description: "Ensure all required tables exist in the database"
        postconditions: "All table definitions are created if not present"
      - type: "method"
        name: "AppDatabase::save_card(&self, card: &SM2Card) -> Result<(), PersistenceError>"
        description: "Save or update a single card in the database"
        preconditions: "Card has valid ID"
        postconditions: "Card data persisted atomically; previous version overwritten if exists"
      - type: "method"
        name: "AppDatabase::load_card(&self, card_id: &str) -> Result<Option<SM2Card>, PersistenceError>"
        description: "Load a card by ID from the database"
        preconditions: "Card ID is non-empty"
        postconditions: "Returns Some(card) if found, None otherwise"
      - type: "method"
        name: "AppDatabase::delete_card(&self, card_id: &str) -> Result<(), PersistenceError>"
        description: "Remove a card from the database"
        postconditions: "Card is removed atomically; no-op if card doesn't exist"
      - type: "method"
        name: "AppDatabase::batch_save_cards(&self, cards: &[SM2Card]) -> Result<(), PersistenceError>"
        description: "Save multiple cards in a single transaction for efficiency"
        postconditions: "All cards saved atomically or none on error; single write transaction; completes in <100ms for 50 cards"
      - type: "method"
        name: "AppDatabase::load_all_cards(&self) -> Result<Vec<SM2Card>, PersistenceError>"
        description: "Load all cards from the database"
        postconditions: "Returns all valid cards; skips corrupted entries with warning"
      - type: "method"
        name: "AppDatabase::save_review(&self, review: &ReviewRecord) -> Result<(), PersistenceError>"
        description: "Save a review history entry"
        preconditions: "Review has valid timestamp"
        postconditions: "Review persisted with timestamp as key"
      - type: "method"
        name: "AppDatabase::load_review_history(&self, card_id: &str) -> Result<Vec<ReviewRecord>, PersistenceError>"
        description: "Load review history for a specific card"
        postconditions: "Returns reviews in timestamp order"
      - type: "method"
        name: "AppDatabase::save_settings(&self, settings: &SettingsRecord) -> Result<(), PersistenceError>"
        description: "Save application settings"
        postconditions: "Settings persisted atomically"
      - type: "method"
        name: "AppDatabase::load_settings(&self) -> Result<SettingsRecord, PersistenceError>"
        description: "Load application settings"
        postconditions: "Returns settings or default if not found"
      - type: "method"
        name: "AppDatabase::save_statistics(&self, stats: &StatisticsRecord) -> Result<(), PersistenceError>"
        description: "Save statistics data"
        postconditions: "Statistics persisted atomically"
      - type: "method"
        name: "AppDatabase::load_statistics(&self) -> Result<StatisticsRecord, PersistenceError>"
        description: "Load current statistics data"
        postconditions: "Returns statistics or default if not found"
      - type: "method"
        name: "AppDatabase::compact(&self) -> Result<(), PersistenceError>"
        description: "Compact database file to reclaim space"
        postconditions: "Database file is optimized; data integrity maintained"
      - type: "method"
        name: "AppDatabase::get_metadata(&self, key: &str) -> Result<String, PersistenceError>"
        description: "Retrieve metadata value by key"
      - type: "method"
        name: "AppDatabase::set_metadata(&self, key: &str, value: &str) -> Result<(), PersistenceError>"
        description: "Store metadata value by key"
      - type: "function"
        name: "fn serialize_record<T: Serialize>(record: &T) -> Result<Vec<u8>, PersistenceError>"
        description: "Helper to serialize any record type to bytes using bincode"
      - type: "function"
        name: "fn deserialize_record<T: DeserializeOwned>(bytes: &[u8]) -> Result<T, PersistenceError>"
        description: "Helper to deserialize bytes to any record type using bincode"

  - file: "src/persistence/backup.rs"
    items:
      - type: "struct"
        name: "BackupData"
        description: "Complete database snapshot for export/import"
      - type: "trait_impl"
        name: "impl Serialize for BackupData"
        description: "Serialize backup data to JSON"
      - type: "trait_impl"
        name: "impl Deserialize for BackupData"
        description: "Deserialize backup data from JSON"
      - type: "function"
        name: "pub fn export_database(db: &AppDatabase, output_path: &Path) -> Result<(), PersistenceError>"
        description: "Export entire database to JSON file"
        preconditions: "Database is open; output path is writable"
        postconditions: "JSON file created with all database contents; formatted for human readability"
      - type: "function"
        name: "pub fn export_database_compressed(db: &AppDatabase, output_path: &Path) -> Result<(), PersistenceError>"
        description: "Export database to gzip-compressed JSON"
        postconditions: "Compressed backup file created; significantly smaller than uncompressed"
      - type: "function"
        name: "pub fn import_database(db: &AppDatabase, input_path: &Path, overwrite: bool) -> Result<(), PersistenceError>"
        description: "Import database from JSON backup file"
        preconditions: "Input file exists and is valid JSON backup format"
        postconditions: "Database populated with backup data; existing data cleared if overwrite=true, merged otherwise"
      - type: "function"
        name: "pub fn verify_backup(input_path: &Path) -> Result<BackupData, PersistenceError>"
        description: "Validate backup file without importing"
        postconditions: "Returns parsed backup if valid, error with details otherwise"
      - type: "function"
        name: "pub fn create_automatic_backup(db: &AppDatabase) -> Result<PathBuf, PersistenceError>"
        description: "Create timestamped backup in default backup directory"
        postconditions: "Backup created with filename containing timestamp; old backups not touched"
      - type: "function"
        name: "pub fn cleanup_old_backups(backup_dir: &Path, keep_count: usize) -> Result<(), PersistenceError>"
        description: "Remove old backups keeping only most recent N"
        preconditions: "keep_count > 0"
        postconditions: "Only keep_count most recent backups remain; older ones deleted"

  - file: "src/persistence/paths.rs"
    items:
      - type: "function"
        name: "pub fn get_default_database_path() -> Result<PathBuf, PersistenceError>"
        description: "Get platform-appropriate path for main database file"
        postconditions: "Returns path in XDG data dir (Linux), AppData (Windows), or Application Support (macOS)"
      - type: "function"
        name: "pub fn get_backup_directory() -> Result<PathBuf, PersistenceError>"
        description: "Get platform-appropriate directory for backup files"
        postconditions: "Returns path in appropriate user data directory; creates if not exists"
      - type: "function"
        name: "pub fn ensure_parent_directory(path: &Path) -> Result<(), PersistenceError>"
        description: "Ensure parent directory exists for given path"
        postconditions: "Parent directory exists and is writable"

formal_verification:
  needed: false
  level: "None"
  explanation: |
    Formal verification is not necessary for this database persistence layer for several reasons:
    
    1. **Correctness delegation to redb**: The core ACID properties (Atomicity, Consistency, 
       Isolation, Durability) are provided by the underlying redb library, which has its own 
       testing and correctness guarantees. We are building a wrapper layer, not implementing 
       database semantics from scratch.
    
    2. **Serialization verification is impractical**: The primary risk area is 
       serialization/deserialization correctness using bincode. However, formal verification 
       of serialization is typically not cost-effective - property-based testing with 
       round-trip checks (serialize then deserialize equals original) provides better 
       return on investment.
    
    3. **Integration testing sufficient**: The critical properties (data survives restart, 
       transactions are atomic, concurrent access is safe) are effectively verified through 
       integration tests with actual database operations. These tests can directly observe 
       the behaviors that matter to users.
    
    4. **File I/O and platform paths**: Platform-specific path handling (via directories 
       crate) and file I/O are inherently difficult to formally verify and are better 
       tested through integration tests on actual filesystems.
    
    5. **Moderate complexity risk**: The task assessment indicates "medium" complexity risk, 
       not critical. The wrapper pattern is straightforward - translate domain operations 
       to redb calls with serialization. This is well-understood infrastructure code.
    
    6. **Backup/restore verification**: While data integrity is critical, backup/restore 
       correctness is best verified by round-trip testing (export then import equals 
       original), which is a standard integration test pattern.
    
    The recommended approach is comprehensive integration testing with actual redb instances, 
    property-based testing for serialization round-trips, and concurrency testing for 
    multi-threaded access patterns. This provides better coverage of real-world failure 
    modes than formal verification would achieve for this infrastructure layer.

tests:
  strategy:
    approach: "integration and unit mixed"
    rationale:
      - "Database operations require integration tests with actual redb instance to verify ACID properties and data persistence across restarts"
      - "Unit tests validate serialization/deserialization independently of database layer"
      - "Concurrency tests verify thread-safe operations and transaction isolation"
      - "Property-based tests ensure batch operations maintain consistency regardless of data size"
      - "Integration tests validate platform-specific path resolution and backup/restore workflows"
      - "Performance benchmarks verify batch operations meet <100ms requirement for 50 cards"

  implementation:
    file: "src/persistence/database.rs"
    location: "in existing test module"
    code: |
      #[cfg(test)]
      mod tests {
          use super::*;
          use crate::card::Card;
          use crate::spaced_repetition::sm2::SM2Card;
          use std::fs;
          use std::path::PathBuf;
          use std::sync::Arc;
          use std::thread;
          use tempfile::TempDir;

          // Helper to create temporary database for testing
          fn create_test_db() -> (AppDatabase, TempDir) {
              let temp_dir = TempDir::new().unwrap();
              let db_path = temp_dir.path().join("test.db");
              let db = AppDatabase::new(&db_path).unwrap();
              (db, temp_dir)
          }

          // Helper to create sample card data
          fn create_sample_card(id: &str) -> Card {
              Card::new(
                  id.to_string(),
                  format!("Front {}", id),
                  format!("Back {}", id),
              )
          }

          fn create_sample_sm2_card(id: &str) -> SM2Card {
              SM2Card::new(create_sample_card(id))
          }

          #[test]
          fn test_database_initializes_on_first_run() {
              let temp_dir = TempDir::new().unwrap();
              let db_path = temp_dir.path().join("new.db");
              
              assert!(!db_path.exists());
              let db = AppDatabase::new(&db_path).unwrap();
              assert!(db_path.exists());
          }

          #[test]
          fn test_card_save_and_load() {
              let (db, _temp) = create_test_db();
              let card = create_sample_sm2_card("card1");
              
              db.save_card(&card).unwrap();
              let loaded = db.load_card("card1").unwrap();
              
              assert!(loaded.is_some());
              let loaded_card = loaded.unwrap();
              assert_eq!(loaded_card.card().id(), card.card().id());
              assert_eq!(loaded_card.card().front(), card.card().front());
              assert_eq!(loaded_card.card().back(), card.card().back());
          }

          #[test]
          fn test_card_update() {
              let (db, _temp) = create_test_db();
              let mut card = create_sample_sm2_card("card1");
              
              db.save_card(&card).unwrap();
              
              // Simulate review that modifies card state
              card.review(4); // Quality rating 4
              db.save_card(&card).unwrap();
              
              let loaded = db.load_card("card1").unwrap().unwrap();
              assert_eq!(loaded.repetitions(), card.repetitions());
              assert_eq!(loaded.easiness_factor(), card.easiness_factor());
          }

          #[test]
          fn test_card_delete() {
              let (db, _temp) = create_test_db();
              let card = create_sample_sm2_card("card1");
              
              db.save_card(&card).unwrap();
              assert!(db.load_card("card1").unwrap().is_some());
              
              db.delete_card("card1").unwrap();
              assert!(db.load_card("card1").unwrap().is_none());
          }

          #[test]
          fn test_load_all_cards() {
              let (db, _temp) = create_test_db();
              
              let cards: Vec<SM2Card> = (0..10)
                  .map(|i| create_sample_sm2_card(&format!("card{}", i)))
                  .collect();
              
              for card in &cards {
                  db.save_card(card).unwrap();
              }
              
              let loaded = db.load_all_cards().unwrap();
              assert_eq!(loaded.len(), 10);
          }

          #[test]
          fn test_batch_save_cards() {
              let (db, _temp) = create_test_db();
              
              let cards: Vec<SM2Card> = (0..50)
                  .map(|i| create_sample_sm2_card(&format!("card{}", i)))
                  .collect();
              
              let start = std::time::Instant::now();
              db.batch_save_cards(&cards).unwrap();
              let duration = start.elapsed();
              
              // Verify performance requirement: <100ms for 50 cards
              assert!(duration.as_millis() < 100, 
                  "Batch save took {}ms, expected <100ms", duration.as_millis());
              
              let loaded = db.load_all_cards().unwrap();
              assert_eq!(loaded.len(), 50);
          }

          #[test]
          fn test_batch_save_atomicity() {
              let (db, _temp) = create_test_db();
              
              // Save some valid cards in batch
              let valid_cards: Vec<SM2Card> = (0..5)
                  .map(|i| create_sample_sm2_card(&format!("card{}", i)))
                  .collect();
              
              db.batch_save_cards(&valid_cards).unwrap();
              
              // Verify all saved
              let loaded = db.load_all_cards().unwrap();
              assert_eq!(loaded.len(), 5);
          }

          #[test]
          fn test_review_history_persistence() {
              let (db, _temp) = create_test_db();
              
              let review = ReviewRecord {
                  card_id: "card1".to_string(),
                  timestamp: chrono::Utc::now(),
                  quality: 4,
                  interval_days: 1,
              };
              
              db.save_review(&review).unwrap();
              let history = db.load_review_history("card1").unwrap();
              
              assert_eq!(history.len(), 1);
              assert_eq!(history[0].card_id, "card1");
              assert_eq!(history[0].quality, 4);
          }

          #[test]
          fn test_settings_persistence() {
              let (db, _temp) = create_test_db();
              
              let mut settings = AppSettings::default();
              settings.daily_new_cards = 30;
              settings.daily_reviews = 150;
              
              db.save_settings(&settings).unwrap();
              let loaded = db.load_settings().unwrap();
              
              assert_eq!(loaded.daily_new_cards, 30);
              assert_eq!(loaded.daily_reviews, 150);
          }

          #[test]
          fn test_statistics_persistence() {
              let (db, _temp) = create_test_db();
              
              let stats = Statistics {
                  total_cards: 100,
                  total_reviews: 500,
                  retention_rate: 0.85,
                  average_ease: 2.5,
              };
              
              db.save_statistics(&stats).unwrap();
              let loaded = db.load_statistics().unwrap();
              
              assert_eq!(loaded.total_cards, 100);
              assert_eq!(loaded.total_reviews, 500);
              assert_eq!(loaded.retention_rate, 0.85);
          }

          #[test]
          fn test_data_survives_restart() {
              let temp_dir = TempDir::new().unwrap();
              let db_path = temp_dir.path().join("persist.db");
              
              // First session: save data
              {
                  let db = AppDatabase::new(&db_path).unwrap();
                  let card = create_sample_sm2_card("persistent");
                  db.save_card(&card).unwrap();
              } // db drops here
              
              // Second session: load data
              {
                  let db = AppDatabase::new(&db_path).unwrap();
                  let loaded = db.load_card("persistent").unwrap();
                  assert!(loaded.is_some());
                  assert_eq!(loaded.unwrap().card().id(), "persistent");
              }
          }

          #[test]
          fn test_concurrent_reads() {
              let (db, _temp) = create_test_db();
              let db = Arc::new(db);
              
              // Save initial data
              for i in 0..10 {
                  db.save_card(&create_sample_sm2_card(&format!("card{}", i))).unwrap();
              }
              
              // Spawn multiple readers
              let mut handles = vec![];
              for i in 0..5 {
                  let db_clone = Arc::clone(&db);
                  let handle = thread::spawn(move || {
                      for j in 0..10 {
                          let card_id = format!("card{}", j);
                          let card = db_clone.load_card(&card_id).unwrap();
                          assert!(card.is_some());
                      }
                  });
                  handles.push(handle);
              }
              
              // All readers should complete successfully
              for handle in handles {
                  handle.join().unwrap();
              }
          }

          #[test]
          fn test_sequential_writes() {
              let (db, _temp) = create_test_db();
              let db = Arc::new(db);
              
              // Spawn multiple writers sequentially
              let mut handles = vec![];
              for i in 0..5 {
                  let db_clone = Arc::clone(&db);
                  let handle = thread::spawn(move || {
                      let card = create_sample_sm2_card(&format!("thread_card_{}", i));
                      db_clone.save_card(&card).unwrap();
                  });
                  handles.push(handle);
              }
              
              for handle in handles {
                  handle.join().unwrap();
              }
              
              let all_cards = db.load_all_cards().unwrap();
              assert_eq!(all_cards.len(), 5);
          }

          #[test]
          fn test_export_to_json() {
              let (db, _temp) = create_test_db();
              
              // Save test data
              for i in 0..5 {
                  db.save_card(&create_sample_sm2_card(&format!("card{}", i))).unwrap();
              }
              
              let export_path = _temp.path().join("export.json");
              db.export_to_json(&export_path).unwrap();
              
              assert!(export_path.exists());
              
              // Verify JSON is valid and contains data
              let json_content = fs::read_to_string(&export_path).unwrap();
              let parsed: serde_json::Value = serde_json::from_str(&json_content).unwrap();
              assert!(parsed.get("cards").is_some());
          }

          #[test]
          fn test_import_from_json() {
              let (db, _temp) = create_test_db();
              
              // Create and export data
              for i in 0..5 {
                  db.save_card(&create_sample_sm2_card(&format!("card{}", i))).unwrap();
              }
              
              let export_path = _temp.path().join("export.json");
              db.export_to_json(&export_path).unwrap();
              
              // Create new database and import
              let (new_db, _new_temp) = create_test_db();
              new_db.import_from_json(&export_path).unwrap();
              
              let imported_cards = new_db.load_all_cards().unwrap();
              assert_eq!(imported_cards.len(), 5);
          }

          #[test]
          fn test_backup_restore_produces_identical_data() {
              let (db, _temp) = create_test_db();
              
              // Save comprehensive test data
              let cards: Vec<SM2Card> = (0..10)
                  .map(|i| create_sample_sm2_card(&format!("card{}", i)))
                  .collect();
              db.batch_save_cards(&cards).unwrap();
              
              let settings = AppSettings::default();
              db.save_settings(&settings).unwrap();
              
              let stats = Statistics {
                  total_cards: 10,
                  total_reviews: 50,
                  retention_rate: 0.9,
                  average_ease: 2.5,
              };
              db.save_statistics(&stats).unwrap();
              
              // Export
              let backup_path = _temp.path().join("backup.json");
              db.export_to_json(&backup_path).unwrap();
              
              // Create new database and restore
              let (restored_db, _restored_temp) = create_test_db();
              restored_db.import_from_json(&backup_path).unwrap();
              
              // Verify identical data
              let restored_cards = restored_db.load_all_cards().unwrap();
              assert_eq!(restored_cards.len(), 10);
              
              let restored_settings = restored_db.load_settings().unwrap();
              assert_eq!(restored_settings.daily_new_cards, settings.daily_new_cards);
              
              let restored_stats = restored_db.load_statistics().unwrap();
              assert_eq!(restored_stats.total_cards, 10);
          }

          #[test]
          fn test_platform_appropriate_database_path() {
              let db_path = AppDatabase::get_default_path();
              
              // Verify path exists and is absolute
              assert!(db_path.is_absolute());
              
              #[cfg(target_os = "linux")]
              {
                  assert!(db_path.to_str().unwrap().contains(".local/share") ||
                          db_path.to_str().unwrap().contains(".config"));
              }
              
              #[cfg(target_os = "windows")]
              {
                  assert!(db_path.to_str().unwrap().contains("AppData"));
              }
              
              #[cfg(target_os = "macos")]
              {
                  assert!(db_path.to_str().unwrap().contains("Application Support"));
              }
          }

          #[test]
          fn test_empty_database_operations() {
              let (db, _temp) = create_test_db();
              
              // Operations on empty database should not fail
              let cards = db.load_all_cards().unwrap();
              assert_eq!(cards.len(), 0);
              
              let card = db.load_card("nonexistent").unwrap();
              assert!(card.is_none());
              
              let history = db.load_review_history("nonexistent").unwrap();
              assert_eq!(history.len(), 0);
          }

          #[test]
          fn test_large_batch_operations() {
              let (db, _temp) = create_test_db();
              
              // Test with 1000 cards to verify scalability
              let cards: Vec<SM2Card> = (0..1000)
                  .map(|i| create_sample_sm2_card(&format!("card{}", i)))
                  .collect();
              
              db.batch_save_cards(&cards).unwrap();
              
              let loaded = db.load_all_cards().unwrap();
              assert_eq!(loaded.len(), 1000);
          }

          #[test]
          fn test_special_characters_in_card_content() {
              let (db, _temp) = create_test_db();
              
              let mut card = create_sample_card("special");
              card.set_front("Front with 日本語 and émojis 🎌");
              card.set_back("Back with \"quotes\" and <html> & symbols");
              
              let sm2_card = SM2Card::new(card);
              db.save_card(&sm2_card).unwrap();
              
              let loaded = db.load_card("special").unwrap().unwrap();
              assert_eq!(loaded.card().front(), "Front with 日本語 and émojis 🎌");
              assert_eq!(loaded.card().back(), "Back with \"quotes\" and <html> & symbols");
          }
      }

      #[cfg(test)]
      mod property_tests {
          use super::*;
          use proptest::prelude::*;
          use tempfile::TempDir;

          fn create_test_db() -> (AppDatabase, TempDir) {
              let temp_dir = TempDir::new().unwrap();
              let db_path = temp_dir.path().join("test.db");
              let db = AppDatabase::new(&db_path).unwrap();
              (db, temp_dir)
          }

          proptest! {
              #[test]
              fn prop_card_roundtrip(
                  id in "[a-z0-9]{1,20}",
                  front in "\\PC{1,100}",
                  back in "\\PC{1,100}"
              ) {
                  let (db, _temp) = create_test_db();
                  
                  let card = Card::new(id.clone(), front.clone(), back.clone());
                  let sm2_card = SM2Card::new(card);
                  
                  db.save_card(&sm2_card).unwrap();
                  let loaded = db.load_card(&id).unwrap().unwrap();
                  
                  prop_assert_eq!(loaded.card().id(), &id);
                  prop_assert_eq!(loaded.card().front(), &front);
                  prop_assert_eq!(loaded.card().back(), &back);
              }

              #[test]
              fn prop_batch_save_preserves_count(
                  count in 1usize..100
              ) {
                  let (db, _temp) = create_test_db();
                  
                  let cards: Vec<SM2Card> = (0..count)
                      .map(|i| {
                          let card = Card::new(
                              format!("card{}", i),
                              format!("front{}", i),
                              format!("back{}", i)
                          );
                          SM2Card::new(card)
                      })
                      .collect();
                  
                  db.batch_save_cards(&cards).unwrap();
                  let loaded = db.load_all_cards().unwrap();
                  
                  prop_assert_eq!(loaded.len(), count);
              }

              #[test]
              fn prop_export_import_preserves_data(
                  card_count in 1usize..50
              ) {
                  let (db, temp) = create_test_db();
                  
                  let cards: Vec<SM2Card> = (0..card_count)
                      .map(|i| {
                          let card = Card::new(
                              format!("card{}", i),
                              format!("front{}", i),
                              format!("back{}", i)
                          );
                          SM2Card::new(card)
                      })
                      .collect();
                  
                  db.batch_save_cards(&cards).unwrap();
                  
                  let export_path = temp.path().join("export.json");
                  db.export_to_json(&export_path).unwrap();
                  
                  let (new_db, _new_temp) = create_test_db();
                  new_db.import_from_json(&export_path).unwrap();
                  
                  let imported = new_db.load_all_cards().unwrap();
                  prop_assert_eq!(imported.len(), card_count);
              }
          }
      }

  coverage:
    - "Database initializes correctly on first run"
    - "Database file created at correct path"
    - "Card state saves correctly"
    - "Card state loads correctly after save"
    - "Card update persists changes"
    - "Card deletion removes data"
    - "Load all cards retrieves complete set"
    - "Batch save completes in <100ms for 50 cards"
    - "Batch save is atomic (all-or-nothing)"
    - "Review history persists accurately"
    - "Settings data survives restart"
    - "Statistics data persists correctly"
    - "Data survives application restart"
    - "Concurrent reads don't block each other"
    - "Sequential writes complete successfully"
    - "Export produces valid JSON file"
    - "Import correctly restores all data"
    - "Backup/restore produces identical data"
    - "Database path is platform-appropriate (Linux/Windows/macOS)"
    - "Operations on empty database handle gracefully"
    - "Large batch operations (1000 cards) scale correctly"
    - "Special characters and Unicode persist correctly"
    - "Property: Card roundtrip preserves all fields"
    - "Property: Batch save preserves exact count"
    - "Property: Export/import cycle preserves data integrity"

dependencies:
  depends_on:
    - task_id: 2
      reason: "Needs Card data structure to persist flashcard data"
    - task_id: 7
      reason: "Needs SM2Card structure to persist spaced repetition state"

  depended_upon_by:
    - task_id: 8
      reason: "Learning session requires persistence to save progress and card state"
    - task_id: 12
      reason: "Statistics component needs to persist aggregated data"
    - task_id: 13
      reason: "Settings need to be loaded and saved to database"

  external:
    - name: "redb"
      type: "crate"
      status: "to be imported"
    - name: "bincode"
      type: "crate"
      status: "to be imported"
    - name: "serde"
      type: "crate"
      status: "already exists"
    - name: "serde_json"
      type: "crate"
      status: "to be imported"
    - name: "directories"
      type: "crate"
      status: "to be imported"
    - name: "chrono"
      type: "crate"
      status: "to be imported"
    - name: "tempfile"
      type: "crate"
      status: "to be imported"
    - name: "proptest"
      type: "crate"
      status: "to be imported"
---
task:
  id: 8
  name: "Learning Session and Practice Modes"

context:
  description: |
    This task implements the core learning experience workflows that tie together all
    previously built systems into cohesive, interactive learning sessions. The learning
    session presents flashcards from review queues, collects user quality ratings, and
    updates spaced repetition state. The practice mode provides four progressive difficulty
    levels (watch animation, trace with guide, trace without guide, free drawing) that
    guide users from passive observation to active recall.
    
    These systems represent the convergence point where character data, stroke animation,
    handwriting recognition, SM-2 scheduling, and UI components combine to create actual
    learning experiences. The quality of these implementations directly determines user
    engagement and learning effectiveness.
    
    The learning session acts as a state machine managing review queue progression, card
    presentation, quality rating collection, and database persistence with batched saves
    for performance. The practice session implements a separate state machine that enforces
    sequential progression through difficulty levels, only advancing when handwriting
    recognition validates successful mastery at each stage.

  key_points:
    - "LearningSession orchestrates ReviewQueue, SM2Card updates, and persistence layer with batched saves every 5-10 cards"
    - "PracticeSession enforces progressive difficulty requiring successful recognition before advancement"
    - "Session statistics track comprehensive metrics including accuracy rates, time per card, and quality distributions"
    - "Both sessions support interruption/resume through state serialization for long-term learning continuity"
    - "Visual feedback systems (green checkmarks, red X marks) provide immediate reinforcement"
    - "Keyboard shortcuts (1-5 for quality, space for next) optimize review flow efficiency"
    - "Integration testing strategy essential due to complex state machines and multi-system dependencies"

files:
  - path: "src/learning/session.rs"
    description: "Core LearningSession struct and state machine for managing review queue progression, quality ratings, and session flow"
  
  - path: "src/learning/practice.rs"
    description: "PracticeSession struct and PracticeMode enum for managing four-stage practice progression with stroke animation and drawing validation"
  
  - path: "src/learning/session_stats.rs"
    description: "SessionStatistics struct for tracking session progress, accuracy rates, time per card, and review counts"
  
  - path: "src/learning/mod.rs"
    description: "Module declaration file exposing session, practice, and statistics modules"
  
  - path: "src/ui/views/learning_session_view.rs"
    description: "UI view for learning session displaying flashcards, character details, and quality rating buttons (0-5)"
  
  - path: "src/ui/views/practice_session_view.rs"
    description: "UI view for practice mode with animation player, drawing canvas, tracing guides, and mode progression controls"
  
  - path: "src/ui/views/session_summary_view.rs"
    description: "Session summary screen showing statistics, accuracy, time spent, cards reviewed, and session completion feedback"
  
  - path: "src/ui/views/mod.rs"
    description: "Updated module declaration to expose learning_session_view, practice_session_view, and session_summary_view"
  
  - path: "src/ui/components/quality_buttons.rs"
    description: "Reusable quality rating button component (0-5 ratings) with keyboard shortcut support and visual feedback"
  
  - path: "src/ui/components/progress_indicator.rs"
    description: "Progress bar component showing cards remaining, cards completed, and session advancement"
  
  - path: "src/ui/components/mod.rs"
    description: "Updated module declaration to expose quality_buttons and progress_indicator components"
  
  - path: "tests/integration/learning_session_test.rs"
    description: "Integration tests for complete learning session workflows including queue progression, rating submission, and state persistence"
  
  - path: "tests/integration/practice_session_test.rs"
    description: "Integration tests for practice mode progression through all four stages with recognition validation"
  
  - path: "tests/unit/session_stats_test.rs"
    description: "Unit tests for session statistics calculation, accuracy tracking, and time measurement"

functions:
  - file: "src/session/mod.rs"
    items:
      - type: "module_declaration"
        name: "learning"
        description: "Module containing learning session implementation"
      - type: "module_declaration"
        name: "practice"
        description: "Module containing practice session implementation"
      - type: "module_declaration"
        name: "statistics"
        description: "Module containing session statistics tracking"

  - file: "src/session/learning.rs"
    items:
      - type: "struct"
        name: "LearningSession"
        description: "Manages the learning session state machine, review queue progression, and card presentation workflow"
        invariants: "current_index <= cards.len(); batch_save_counter >= 0"
      - type: "struct"
        name: "SessionConfig"
        description: "Configuration for learning sessions including batch save interval and daily limits"
      - type: "enum"
        name: "SessionState"
        description: "Current state of learning session: NotStarted, ShowingCard, WaitingForRating, ShowingFeedback, Complete"
      - type: "struct"
        name: "ReviewResult"
        description: "Result of a single card review containing card_id, quality rating, and timestamp"
      - type: "method"
        name: "LearningSession::new"
        description: "Creates new learning session from review queue with optional configuration"
        preconditions: "queue is not empty"
        postconditions: "Session initialized in NotStarted state with cards loaded"
      - type: "method"
        name: "LearningSession::start"
        description: "Starts the session and presents first card"
        preconditions: "Session in NotStarted state"
        postconditions: "Session in ShowingCard state with current_index = 0"
      - type: "method"
        name: "LearningSession::submit_rating"
        description: "Submits quality rating for current card and updates SM-2 state"
        preconditions: "Session in WaitingForRating state; rating in 0..=5"
        postconditions: "Card state updated; feedback shown; batch_save_counter incremented"
      - type: "method"
        name: "LearningSession::next_card"
        description: "Advances to next card in queue or completes session"
        preconditions: "Session in ShowingFeedback state"
        postconditions: "current_index incremented or session Complete"
      - type: "method"
        name: "LearningSession::current_card"
        description: "Returns reference to current card being reviewed"
        preconditions: "current_index < cards.len()"
      - type: "method"
        name: "LearningSession::progress"
        description: "Returns session progress as (cards_completed, total_cards)"
      - type: "method"
        name: "LearningSession::is_complete"
        description: "Returns true if all cards have been reviewed"
      - type: "method"
        name: "LearningSession::save_progress"
        description: "Persists current session progress and review results to database"
        postconditions: "All pending results written to database; batch_save_counter reset"
      - type: "method"
        name: "LearningSession::get_statistics"
        description: "Returns SessionStatistics for current session"

  - file: "src/session/practice.rs"
    items:
      - type: "enum"
        name: "PracticeMode"
        description: "Practice difficulty levels: WatchAnimation, TraceWithGuide, TraceWithoutGuide, FreeDrawing"
      - type: "struct"
        name: "PracticeSession"
        description: "Manages practice session state machine through progressive difficulty levels"
        invariants: "current_mode ordinal <= FreeDrawing ordinal; attempt_count >= 0"
      - type: "struct"
        name: "PracticeConfig"
        description: "Configuration for practice sessions including recognition threshold and max attempts per mode"
      - type: "enum"
        name: "PracticeState"
        description: "Current state: WatchingAnimation, DrawingWithGuide, DrawingFreehand, ShowingFeedback, ModeComplete"
      - type: "struct"
        name: "DrawingResult"
        description: "Result of handwriting recognition attempt with score and matched character"
      - type: "method"
        name: "PracticeSession::new"
        description: "Creates new practice session for a character with starting mode"
        preconditions: "character exists in database"
        postconditions: "Session initialized at WatchAnimation mode"
      - type: "method"
        name: "PracticeSession::start_mode"
        description: "Starts current practice mode (animation or drawing canvas)"
        postconditions: "Session transitions to appropriate drawing/watching state"
      - type: "method"
        name: "PracticeSession::submit_drawing"
        description: "Submits user drawing for recognition and validation"
        preconditions: "Session in drawing state; strokes non-empty"
        postconditions: "Recognition performed; feedback shown; mode advances on success"
      - type: "method"
        name: "PracticeSession::advance_mode"
        description: "Advances to next difficulty level after successful recognition"
        preconditions: "current_mode != FreeDrawing; last recognition successful"
        postconditions: "current_mode advanced by one level; attempt_count reset"
      - type: "method"
        name: "PracticeSession::retry_current_mode"
        description: "Allows retry of current mode after failed recognition"
        postconditions: "attempt_count incremented; canvas cleared"
      - type: "method"
        name: "PracticeSession::current_mode"
        description: "Returns current PracticeMode"
      - type: "method"
        name: "PracticeSession::show_hint"
        description: "Displays hint by animating one stroke"
        postconditions: "hint_used flag set; single stroke animated"
      - type: "method"
        name: "PracticeSession::skip_mode"
        description: "Allows user to skip current mode and advance (with penalty)"
        postconditions: "Mode advanced; skip recorded in statistics"
      - type: "method"
        name: "PracticeSession::is_complete"
        description: "Returns true if all practice modes completed successfully"
      - type: "method"
        name: "PracticeSession::get_statistics"
        description: "Returns practice statistics including accuracy per mode"
      - type: "function"
        name: "validate_drawing"
        description: "Validates user drawing against target character using recognition threshold"
        preconditions: "strokes non-empty; character valid"
        postconditions: "Returns DrawingResult with similarity score 0.0..=1.0"
      - type: "function"
        name: "should_advance_mode"
        description: "Determines if recognition score meets threshold to advance mode"
        preconditions: "score in 0.0..=1.0"

  - file: "src/session/statistics.rs"
    items:
      - type: "struct"
        name: "SessionStatistics"
        description: "Tracks comprehensive statistics for learning or practice session"
        invariants: "cards_reviewed >= 0; total_time_ms >= 0; accuracy in 0.0..=1.0"
      - type: "struct"
        name: "CardTiming"
        description: "Records timing information for individual card review"
      - type: "enum"
        name: "SessionType"
        description: "Type of session: Learning or Practice"
      - type: "method"
        name: "SessionStatistics::new"
        description: "Creates new statistics tracker for session type"
        postconditions: "All counters initialized to zero"
      - type: "method"
        name: "SessionStatistics::record_review"
        description: "Records a completed card review with quality and duration"
        preconditions: "duration_ms > 0"
        postconditions: "cards_reviewed incremented; timing recorded; accuracy updated"
      - type: "method"
        name: "SessionStatistics::record_practice_attempt"
        description: "Records practice attempt with mode, success, and score"
        postconditions: "attempt count incremented; mode-specific stats updated"
      - type: "method"
        name: "SessionStatistics::average_time_per_card"
        description: "Returns average review time in milliseconds"
        preconditions: "cards_reviewed > 0"
      - type: "method"
        name: "SessionStatistics::accuracy_rate"
        description: "Returns accuracy as percentage 0.0..=100.0"
      - type: "method"
        name: "SessionStatistics::quality_distribution"
        description: "Returns histogram of quality ratings (learning mode)"
      - type: "method"
        name: "SessionStatistics::mode_accuracy"
        description: "Returns accuracy breakdown by practice mode"
      - type: "method"
        name: "SessionStatistics::total_duration"
        description: "Returns total session duration in milliseconds"

  - file: "src/ui/session_view.rs"
    items:
      - type: "struct"
        name: "SessionView"
        description: "Main view component for learning session UI"
      - type: "struct"
        name: "SessionViewModel"
        description: "View model holding session state and UI-specific data"
      - type: "enum"
        name: "SessionMessage"
        description: "Messages for session view: RatingSelected, NextCard, PauseSession, ResumeSession, EndSession"
      - type: "function"
        name: "view"
        description: "Renders complete session view with card, controls, and progress"
      - type: "function"
        name: "render_flashcard"
        description: "Renders current flashcard with character and metadata"
      - type: "function"
        name: "render_quality_buttons"
        description: "Renders quality rating buttons 0-5 with keyboard shortcuts"
      - type: "function"
        name: "render_feedback_overlay"
        description: "Renders visual feedback (checkmark/X) after rating submission"
      - type: "function"
        name: "render_progress_bar"
        description: "Renders progress bar showing cards completed and remaining"
      - type: "function"
        name: "render_session_summary"
        description: "Renders session completion summary with statistics"
      - type: "method"
        name: "SessionView::update"
        description: "Handles session messages and updates view model"
        postconditions: "View model reflects new session state"

  - file: "src/ui/practice_view.rs"
    items:
      - type: "struct"
        name: "PracticeView"
        description: "Main view component for practice session UI"
      - type: "struct"
        name: "PracticeViewModel"
        description: "View model holding practice state and canvas data"
      - type: "enum"
        name: "PracticeMessage"
        description: "Messages: ModeStarted, StrokeDrawn, DrawingSubmitted, HintRequested, ModeSkipped, RetryMode"
      - type: "function"
        name: "view"
        description: "Renders practice view with appropriate mode-specific UI"
      - type: "function"
        name: "render_animation_mode"
        description: "Renders watch mode with stroke order animation"
      - type: "function"
        name: "render_trace_mode"
        description: "Renders tracing mode with guide overlay (with or without strokes)"
      - type: "function"
        name: "render_freehand_mode"
        description: "Renders free drawing mode without guides"
      - type: "function"
        name: "render_guide_overlay"
        description: "Renders semi-transparent ghost overlay of target character"
      - type: "function"
        name: "render_mode_indicator"
        description: "Renders current practice mode badge and progress"
      - type: "function"
        name: "render_drawing_controls"
        description: "Renders undo, clear, hint, and submit buttons"
      - type: "function"
        name: "render_practice_feedback"
        description: "Renders recognition feedback with score and next steps"
      - type: "method"
        name: "PracticeView::update"
        description: "Handles practice messages and updates view model"
        postconditions: "Canvas and practice session state synchronized"

  - file: "src/ui/keyboard_shortcuts.rs"
    items:
      - type: "struct"
        name: "KeyboardHandler"
        description: "Handles keyboard shortcuts for session and practice views"
      - type: "function"
        name: "handle_session_key"
        description: "Maps keyboard input to session messages (1-5 for ratings, space for next)"
        preconditions: "Valid key event"
        postconditions: "Returns appropriate SessionMessage or None"
      - type: "function"
        name: "handle_practice_key"
        description: "Maps keyboard input to practice messages (h for hint, r for retry, etc)"
        preconditions: "Valid key event"
        postconditions: "Returns appropriate PracticeMessage or None"

  - file: "tests/session/learning_tests.rs"
    items:
      - type: "function"
        name: "test_learning_session_initialization"
        description: "Tests session creation from review queue"
      - type: "function"
        name: "test_session_progression"
        description: "Tests advancing through multiple cards"
      - type: "function"
        name: "test_quality_rating_updates_sm2"
        description: "Tests that rating submission correctly updates SM-2 state"
      - type: "function"
        name: "test_batch_save_interval"
        description: "Tests that saves occur at configured intervals"
      - type: "function"
        name: "test_session_completion"
        description: "Tests session completes after all cards reviewed"
      - type: "function"
        name: "test_session_statistics_accuracy"
        description: "Tests statistics accurately reflect review history"
      - type: "function"
        name: "test_session_interrupt_and_resume"
        description: "Tests session can be paused and resumed with state preserved"

  - file: "tests/session/practice_tests.rs"
    items:
      - type: "function"
        name: "test_practice_session_initialization"
        description: "Tests practice session creation with character"
      - type: "function"
        name: "test_mode_progression"
        description: "Tests progression through all four practice modes"
      - type: "function"
        name: "test_successful_recognition_advances_mode"
        description: "Tests that meeting threshold advances to next mode"
      - type: "function"
        name: "test_failed_recognition_allows_retry"
        description: "Tests that failed recognition keeps user in current mode"
      - type: "function"
        name: "test_hint_system"
        description: "Tests hint shows single stroke animation"
      - type: "function"
        name: "test_skip_mode_with_penalty"
        description: "Tests skip functionality and penalty recording"
      - type: "function"
        name: "test_practice_statistics_per_mode"
        description: "Tests statistics track accuracy per practice mode"
      - type: "function"
        name: "test_recognition_threshold_tuning"
        description: "Tests various threshold values for recognition validation"

  - file: "tests/session/statistics_tests.rs"
    items:
      - type: "function"
        name: "test_statistics_initialization"
        description: "Tests statistics start with zero values"
      - type: "function"
        name: "test_record_review_updates_stats"
        description: "Tests recording reviews updates counters correctly"
      - type: "function"
        name: "test_average_time_calculation"
        description: "Tests average time per card calculation"
      - type: "function"
        name: "test_accuracy_rate_calculation"
        description: "Tests accuracy percentage calculation"
      - type: "function"
        name: "test_quality_distribution"
        description: "Tests quality rating histogram generation"

  - file: "tests/session/integration_tests.rs"
    items:
      - type: "function"
        name: "test_end_to_end_learning_session"
        description: "Integration test of complete learning session workflow"
      - type: "function"
        name: "test_end_to_end_practice_session"
        description: "Integration test of complete practice session through all modes"
      - type: "function"
        name: "test_session_persistence_roundtrip"
        description: "Tests session save and load preserves all state"

formal_verification:
  needed: false
  level: "None"
  explanation: |
    Formal verification is not needed for the learning session and practice modes because:
    
    1. State Machine Correctness: While the session and practice mode state machines are 
       complex, their correctness can be adequately verified through comprehensive integration 
       testing. The state transitions (e.g., advancing from WatchAnimation → TraceWithGuide → 
       TraceWithoutGuide → FreeDrawing) are deterministic and can be exhaustively tested with 
       standard test cases covering all transition paths.
    
    2. No Critical Safety Properties: Unlike systems where bugs could cause data loss, safety 
       hazards, or financial consequences, errors in session management result in poor UX 
       (incorrect card progression, statistics inaccuracy) but not catastrophic failure. These 
       issues are discoverable through manual testing and user feedback.
    
    3. UI-Heavy Logic: Much of this task involves UI rendering, user interaction handling, 
       and visual feedback—domains where formal verification provides limited value compared 
       to integration and manual testing. The correctness of "does the green check appear" or 
       "does the animation play smoothly" cannot be meaningfully captured in formal properties.
    
    4. Dependent System Correctness: The critical algorithmic correctness (SM-2 scheduling, 
       handwriting recognition) is handled by Tasks 7 and 5 respectively. This task primarily 
       orchestrates those systems. If verification were needed, it would be at those lower 
       levels, not at the orchestration layer.
    
    5. Cost-Benefit Analysis: The complexity risk is high due to numerous state transitions 
       and integration points, but this complexity is manageable through the recommended 
       integration testing strategy. The estimated 18 tests should provide adequate coverage 
       of state machine paths, edge cases (interruption/resume), and data persistence. Formal 
       verification would require significant effort to model UI interactions and async state 
       transitions without proportional benefit.
    
    6. Practical Validation: Session statistics accuracy and review queue progression can be 
       validated through property-based testing (e.g., "cards reviewed count equals quality 
       ratings recorded") without full formal verification. Integration tests can verify the 
       critical property that "all queued cards are eventually presented" and "quality ratings 
       persist correctly."
    
    The recommended testing strategy (integration tests with property-based checks for 
    statistics) provides sufficient confidence in correctness for this user-facing, 
    UI-heavy component.

tests:
  strategy:
    approach: "mixed (unit + integration)"
    rationale:
      - "Learning session logic requires unit tests for state transitions, queue progression, and quality rating handling in isolation"
      - "Practice mode state machine needs unit tests for mode progression logic, threshold validation, and edge cases"
      - "Integration tests verify end-to-end workflows spanning ReviewQueue → LearningSession → SM2Card updates → persistence"
      - "Session statistics calculation and batched database saves require integration testing to ensure correctness"
      - "Session interruption/resume scenarios need integration tests to verify state persistence and recovery"
      - "Property-based tests for session state invariants (e.g., cards reviewed count never exceeds queue size)"

  implementation:
    file: "tests/learning_session_tests.rs"
    location: "create new"
    code: |
      #[cfg(test)]
      mod learning_session_tests {
          use super::*;
          use crate::spaced_repetition::{SM2Card, ReviewQueue, Quality};
          use crate::models::CharacterCard;
          use crate::session::{LearningSession, SessionStatistics};
          use std::time::Duration;

          // ============= Unit Tests: LearningSession Core Logic =============

          #[test]
          fn test_learning_session_initialization() {
              // Verify session initializes with correct queue state
              let mut queue = ReviewQueue::new();
              queue.add_card(create_test_card(1));
              queue.add_card(create_test_card(2));
              
              let session = LearningSession::new(queue);
              
              assert_eq!(session.total_cards(), 2);
              assert_eq!(session.cards_reviewed(), 0);
              assert!(!session.is_complete());
              assert!(session.current_card().is_some());
          }

          #[test]
          fn test_session_progresses_through_queue() {
              // Verify session moves through all cards in order
              let mut queue = ReviewQueue::new();
              let card1 = create_test_card(1);
              let card2 = create_test_card(2);
              queue.add_card(card1.clone());
              queue.add_card(card2.clone());
              
              let mut session = LearningSession::new(queue);
              
              assert_eq!(session.current_card().unwrap().id(), card1.id());
              session.submit_rating(Quality::Good);
              
              assert_eq!(session.current_card().unwrap().id(), card2.id());
              session.submit_rating(Quality::Good);
              
              assert!(session.current_card().is_none());
              assert!(session.is_complete());
              assert_eq!(session.cards_reviewed(), 2);
          }

          #[test]
          fn test_quality_rating_updates_card_state() {
              // Verify quality ratings correctly update SM-2 state
              let mut queue = ReviewQueue::new();
              let card = create_test_card(1);
              let original_interval = card.interval();
              queue.add_card(card);
              
              let mut session = LearningSession::new(queue);
              session.submit_rating(Quality::Good);
              
              let reviewed_card = session.get_reviewed_card(0).unwrap();
              assert!(reviewed_card.interval() >= original_interval);
              assert_eq!(reviewed_card.repetitions(), 1);
          }

          #[test]
          fn test_session_statistics_accuracy() {
              // Verify statistics correctly track session metrics
              let mut queue = ReviewQueue::new();
              queue.add_card(create_test_card(1));
              queue.add_card(create_test_card(2));
              queue.add_card(create_test_card(3));
              
              let mut session = LearningSession::new(queue);
              
              session.submit_rating(Quality::Perfect);
              std::thread::sleep(Duration::from_millis(100));
              session.submit_rating(Quality::Hard);
              std::thread::sleep(Duration::from_millis(100));
              session.submit_rating(Quality::Good);
              
              let stats = session.statistics();
              assert_eq!(stats.cards_reviewed, 3);
              assert_eq!(stats.quality_ratings.get(&Quality::Perfect), Some(&1));
              assert_eq!(stats.quality_ratings.get(&Quality::Hard), Some(&1));
              assert_eq!(stats.quality_ratings.get(&Quality::Good), Some(&1));
              assert!(stats.total_time > Duration::from_millis(200));
              assert!(stats.average_time_per_card() > Duration::from_millis(50));
          }

          #[test]
          fn test_session_handles_empty_queue() {
              // Verify session handles empty queue gracefully
              let queue = ReviewQueue::new();
              let session = LearningSession::new(queue);
              
              assert_eq!(session.total_cards(), 0);
              assert!(session.is_complete());
              assert!(session.current_card().is_none());
          }

          #[test]
          fn test_session_skip_card_functionality() {
              // Verify skip moves to next card without recording review
              let mut queue = ReviewQueue::new();
              queue.add_card(create_test_card(1));
              queue.add_card(create_test_card(2));
              
              let mut session = LearningSession::new(queue);
              let first_card_id = session.current_card().unwrap().id();
              
              session.skip_current_card();
              
              assert_ne!(session.current_card().unwrap().id(), first_card_id);
              assert_eq!(session.cards_reviewed(), 0);
              assert_eq!(session.cards_skipped(), 1);
          }

          #[test]
          fn test_session_progress_percentage() {
              // Verify progress calculation is accurate
              let mut queue = ReviewQueue::new();
              for i in 0..10 {
                  queue.add_card(create_test_card(i));
              }
              
              let mut session = LearningSession::new(queue);
              assert_eq!(session.progress_percentage(), 0.0);
              
              for _ in 0..5 {
                  session.submit_rating(Quality::Good);
              }
              
              assert!((session.progress_percentage() - 50.0).abs() < 0.01);
              
              for _ in 0..5 {
                  session.submit_rating(Quality::Good);
              }
              
              assert!((session.progress_percentage() - 100.0).abs() < 0.01);
          }

          // ============= Unit Tests: PracticeSession Core Logic =============

          #[test]
          fn test_practice_session_initialization() {
              // Verify practice session starts in WatchAnimation mode
              let card = create_test_card(1);
              let session = PracticeSession::new(card);
              
              assert_eq!(session.current_mode(), PracticeMode::WatchAnimation);
              assert_eq!(session.mode_index(), 0);
              assert!(!session.is_complete());
          }

          #[test]
          fn test_practice_mode_progression() {
              // Verify practice progresses through all modes on success
              let card = create_test_card(1);
              let mut session = PracticeSession::new(card);
              
              assert_eq!(session.current_mode(), PracticeMode::WatchAnimation);
              session.advance_on_success();
              
              assert_eq!(session.current_mode(), PracticeMode::TraceWithGuide);
              session.advance_on_success();
              
              assert_eq!(session.current_mode(), PracticeMode::TraceWithoutGuide);
              session.advance_on_success();
              
              assert_eq!(session.current_mode(), PracticeMode::FreeDrawing);
              session.advance_on_success();
              
              assert!(session.is_complete());
          }

          #[test]
          fn test_practice_mode_stays_on_failure() {
              // Verify practice mode doesn't advance on recognition failure
              let card = create_test_card(1);
              let mut session = PracticeSession::new(card);
              
              session.advance_on_success(); // Move to TraceWithGuide
              let current_mode = session.current_mode();
              
              session.record_failure();
              
              assert_eq!(session.current_mode(), current_mode);
              assert_eq!(session.failure_count(), 1);
          }

          #[test]
          fn test_practice_session_can_restart_mode() {
              // Verify ability to restart current practice mode
              let card = create_test_card(1);
              let mut session = PracticeSession::new(card);
              
              session.advance_on_success(); // TraceWithGuide
              session.advance_on_success(); // TraceWithoutGuide
              
              session.restart_current_mode();
              
              assert_eq!(session.current_mode(), PracticeMode::TraceWithoutGuide);
              assert_eq!(session.attempt_count_for_current_mode(), 0);
          }

          #[test]
          fn test_practice_session_skip_to_mode() {
              // Verify ability to skip directly to specific mode
              let card = create_test_card(1);
              let mut session = PracticeSession::new(card);
              
              session.skip_to_mode(PracticeMode::FreeDrawing);
              
              assert_eq!(session.current_mode(), PracticeMode::FreeDrawing);
          }

          #[test]
          fn test_practice_session_tracks_attempts() {
              // Verify attempt tracking per mode
              let card = create_test_card(1);
              let mut session = PracticeSession::new(card);
              
              session.advance_on_success(); // TraceWithGuide
              
              session.record_failure();
              session.record_failure();
              session.advance_on_success();
              
              let stats = session.mode_statistics(PracticeMode::TraceWithGuide);
              assert_eq!(stats.attempts, 3);
              assert_eq!(stats.failures, 2);
              assert_eq!(stats.successes, 1);
          }

          // ============= Integration Tests: End-to-End Workflows =============

          #[test]
          fn test_complete_learning_session_workflow() {
              // Integration: Full session from queue creation to completion
              let mut queue = ReviewQueue::new();
              for i in 0..5 {
                  queue.add_card(create_test_card(i));
              }
              
              let mut session = LearningSession::new(queue);
              let qualities = vec![
                  Quality::Perfect,
                  Quality::Good,
                  Quality::Good,
                  Quality::Hard,
                  Quality::Easy,
              ];
              
              for quality in qualities.iter() {
                  assert!(!session.is_complete());
                  session.submit_rating(*quality);
              }
              
              assert!(session.is_complete());
              assert_eq!(session.cards_reviewed(), 5);
              
              let stats = session.statistics();
              assert_eq!(stats.cards_reviewed, 5);
              assert_eq!(stats.quality_ratings.values().sum::<usize>(), 5);
          }

          #[test]
          fn test_session_interruption_and_resume() {
              // Integration: Verify session can be interrupted and resumed
              let mut queue = ReviewQueue::new();
              for i in 0..5 {
                  queue.add_card(create_test_card(i));
              }
              
              let mut session = LearningSession::new(queue);
              session.submit_rating(Quality::Good);
              session.submit_rating(Quality::Good);
              
              // Simulate interruption - serialize state
              let serialized = session.serialize_state();
              
              // Resume from serialized state
              let mut resumed_session = LearningSession::from_serialized_state(serialized);
              
              assert_eq!(resumed_session.cards_reviewed(), 2);
              assert_eq!(resumed_session.total_cards(), 5);
              assert!(!resumed_session.is_complete());
              
              // Continue session
              resumed_session.submit_rating(Quality::Good);
              assert_eq!(resumed_session.cards_reviewed(), 3);
          }

          #[test]
          fn test_batched_database_saves() {
              // Integration: Verify database saves occur at batch intervals
              let mut queue = ReviewQueue::new();
              for i in 0..15 {
                  queue.add_card(create_test_card(i));
              }
              
              let mut session = LearningSession::with_batch_size(queue, 5);
              let mut save_count = 0;
              
              session.on_batch_save(|| save_count += 1);
              
              for _ in 0..4 {
                  session.submit_rating(Quality::Good);
              }
              assert_eq!(save_count, 0); // No save yet
              
              session.submit_rating(Quality::Good);
              assert_eq!(save_count, 1); // First batch saved
              
              for _ in 0..5 {
                  session.submit_rating(Quality::Good);
              }
              assert_eq!(save_count, 2); // Second batch saved
          }

          #[test]
          fn test_practice_session_with_recognition_validation() {
              // Integration: Practice session with handwriting validation
              let card = create_test_card_with_strokes(1);
              let mut session = PracticeSession::new(card.clone());
              
              // WatchAnimation - no validation needed
              session.advance_on_success();
              
              // TraceWithGuide - validate with guide
              let strokes = simulate_correct_drawing(&card);
              let is_valid = session.validate_drawing(strokes, 0.8);
              assert!(is_valid);
              session.advance_on_success();
              
              // TraceWithoutGuide - validate without guide
              let strokes = simulate_correct_drawing(&card);
              let is_valid = session.validate_drawing(strokes, 0.7);
              assert!(is_valid);
              session.advance_on_success();
              
              // FreeDrawing - validate freely drawn
              let strokes = simulate_correct_drawing(&card);
              let is_valid = session.validate_drawing(strokes, 0.6);
              assert!(is_valid);
              session.advance_on_success();
              
              assert!(session.is_complete());
          }

          #[test]
          fn test_session_with_all_quality_ratings() {
              // Integration: Verify all quality ratings work correctly
              let mut queue = ReviewQueue::new();
              for i in 0..6 {
                  queue.add_card(create_test_card(i));
              }
              
              let mut session = LearningSession::new(queue);
              
              session.submit_rating(Quality::Again);
              session.submit_rating(Quality::Hard);
              session.submit_rating(Quality::Good);
              session.submit_rating(Quality::Easy);
              session.submit_rating(Quality::Perfect);
              session.submit_rating(Quality::Good);
              
              let stats = session.statistics();
              assert_eq!(stats.quality_ratings.get(&Quality::Again), Some(&1));
              assert_eq!(stats.quality_ratings.get(&Quality::Hard), Some(&1));
              assert_eq!(stats.quality_ratings.get(&Quality::Good), Some(&2));
              assert_eq!(stats.quality_ratings.get(&Quality::Easy), Some(&1));
              assert_eq!(stats.quality_ratings.get(&Quality::Perfect), Some(&1));
          }

          // ============= Property-Based Tests =============

          #[cfg(test)]
          mod property_tests {
              use super::*;
              use proptest::prelude::*;

              proptest! {
                  #[test]
                  fn prop_cards_reviewed_never_exceeds_total(
                      card_count in 1usize..50,
                      ratings in prop::collection::vec(quality_strategy(), 1..100)
                  ) {
                      let mut queue = ReviewQueue::new();
                      for i in 0..card_count {
                          queue.add_card(create_test_card(i));
                      }
                      
                      let mut session = LearningSession::new(queue);
                      
                      for rating in ratings.iter().take(card_count * 2) {
                          if !session.is_complete() {
                              session.submit_rating(*rating);
                          }
                      }
                      
                      prop_assert!(session.cards_reviewed() <= session.total_cards());
                      prop_assert_eq!(session.is_complete(), session.cards_reviewed() == session.total_cards());
                  }

                  #[test]
                  fn prop_progress_percentage_in_valid_range(
                      card_count in 1usize..50,
                      review_count in 0usize..100
                  ) {
                      let mut queue = ReviewQueue::new();
                      for i in 0..card_count {
                          queue.add_card(create_test_card(i));
                      }
                      
                      let mut session = LearningSession::new(queue);
                      
                      for _ in 0..review_count.min(card_count) {
                          session.submit_rating(Quality::Good);
                      }
                      
                      let progress = session.progress_percentage();
                      prop_assert!(progress >= 0.0 && progress <= 100.0);
                  }

                  #[test]
                  fn prop_practice_mode_never_skips_stages(
                      advancement_count in 0usize..10
                  ) {
                      let card = create_test_card(1);
                      let mut session = PracticeSession::new(card);
                      
                      let mut last_index = session.mode_index();
                      
                      for _ in 0..advancement_count {
                          if !session.is_complete() {
                              session.advance_on_success();
                              let current_index = session.mode_index();
                              prop_assert!(current_index <= last_index + 1);
                              last_index = current_index;
                          }
                      }
                  }

                  #[test]
                  fn prop_session_statistics_time_is_monotonic(
                      card_count in 1usize..20
                  ) {
                      let mut queue = ReviewQueue::new();
                      for i in 0..card_count {
                          queue.add_card(create_test_card(i));
                      }
                      
                      let mut session = LearningSession::new(queue);
                      let mut last_time = Duration::from_secs(0);
                      
                      for _ in 0..card_count {
                          std::thread::sleep(Duration::from_millis(10));
                          session.submit_rating(Quality::Good);
                          let current_time = session.statistics().total_time;
                          prop_assert!(current_time >= last_time);
                          last_time = current_time;
                      }
                  }
              }

              fn quality_strategy() -> impl Strategy<Value = Quality> {
                  prop_oneof![
                      Just(Quality::Again),
                      Just(Quality::Hard),
                      Just(Quality::Good),
                      Just(Quality::Easy),
                      Just(Quality::Perfect),
                  ]
              }
          }

          // ============= Helper Functions =============

          fn create_test_card(id: usize) -> CharacterCard {
              CharacterCard::new(
                  id,
                  format!("char_{}", id),
                  vec!["meaning".to_string()],
                  vec!["reading".to_string()],
                  vec![],
              )
          }

          fn create_test_card_with_strokes(id: usize) -> CharacterCard {
              let strokes = vec![
                  vec![(0.0, 0.0), (1.0, 1.0)],
                  vec![(0.0, 1.0), (1.0, 0.0)],
              ];
              CharacterCard::new(
                  id,
                  format!("char_{}", id),
                  vec!["meaning".to_string()],
                  vec!["reading".to_string()],
                  strokes,
              )
          }

          fn simulate_correct_drawing(card: &CharacterCard) -> Vec<Vec<(f32, f32)>> {
              // Simulate drawing that matches card strokes with minor variation
              card.strokes()
                  .iter()
                  .map(|stroke| {
                      stroke
                          .iter()
                          .map(|(x, y)| (x + 0.01, y + 0.01))
                          .collect()
                  })
                  .collect()
          }
      }

      #[cfg(test)]
      mod session_ui_tests {
          use super::*;
          use crate::ui::session::{SessionView, PracticeView};

          #[test]
          fn test_session_view_renders_current_card() {
              // Verify SessionView displays correct card
              let mut queue = ReviewQueue::new();
              queue.add_card(create_test_card(1));
              let session = LearningSession::new(queue);
              
              let view = SessionView::new(&session);
              let rendered = view.render();
              
              assert!(rendered.contains("char_1"));
          }

          #[test]
          fn test_session_view_shows_quality_buttons() {
              // Verify all quality rating buttons are present
              let mut queue = ReviewQueue::new();
              queue.add_card(create_test_card(1));
              let session = LearningSession::new(queue);
              
              let view = SessionView::new(&session);
              let rendered = view.render();
              
              assert!(rendered.contains("Again"));
              assert!(rendered.contains("Hard"));
              assert!(rendered.contains("Good"));
              assert!(rendered.contains("Easy"));
              assert!(rendered.contains("Perfect"));
          }

          #[test]
          fn test_practice_view_shows_correct_mode_ui() {
              // Verify PracticeView adapts UI to current mode
              let card = create_test_card_with_strokes(1);
              let session = PracticeSession::new(card);
              
              let view = PracticeView::new(&session);
              
              // WatchAnimation mode should show animation controls
              assert!(view.has_animation_controls());
              assert!(!view.has_drawing_canvas());
          }

          #[test]
          fn test_session_summary_displays_statistics() {
              // Verify session summary shows accurate stats
              let mut queue = ReviewQueue::new();
              for i in 0..3 {
                  queue.add_card(create_test_card(i));
              }
              
              let mut session = LearningSession::new(queue);
              session.submit_rating(Quality::Perfect);
              session.submit_rating(Quality::Good);
              session.submit_rating(Quality::Hard);
              
              let summary = session.generate_summary();
              
              assert_eq!(summary.total_reviewed, 3);
              assert!(summary.accuracy_score > 0.0);
              assert!(summary.total_time > Duration::from_secs(0));
          }

          fn create_test_card(id: usize) -> CharacterCard {
              CharacterCard::new(
                  id,
                  format!("char_{}", id),
                  vec!["meaning".to_string()],
                  vec!["reading".to_string()],
                  vec![],
              )
          }

          fn create_test_card_with_strokes(id: usize) -> CharacterCard {
              let strokes = vec![
                  vec![(0.0, 0.0), (1.0, 1.0)],
                  vec![(0.0, 1.0), (1.0, 0.0)],
              ];
              CharacterCard::new(
                  id,
                  format!("char_{}", id),
                  vec!["meaning".to_string()],
                  vec!["reading".to_string()],
                  strokes,
              )
          }
      }

  coverage:
    - "LearningSession initialization with queue state"
    - "Session progression through all queued cards"
    - "Quality rating submission updates SM-2 card state"
    - "Session statistics track accurate review metrics"
    - "Empty queue handling"
    - "Skip card functionality without recording review"
    - "Progress percentage calculation accuracy"
    - "PracticeSession initialization in WatchAnimation mode"
    - "Practice mode progression through all four stages"
    - "Practice mode retention on recognition failure"
    - "Practice session mode restart capability"
    - "Practice session skip to specific mode"
    - "Practice session attempt tracking per mode"
    - "Complete end-to-end learning session workflow"
    - "Session interruption and resume from serialized state"
    - "Batched database saves at configured intervals"
    - "Practice session with handwriting recognition validation"
    - "Session handling of all quality rating types (Again through Perfect)"
    - "Property: cards reviewed never exceeds total cards"
    - "Property: progress percentage stays within 0-100% range"
    - "Property: practice mode advances sequentially without skipping"
    - "Property: session time statistics are monotonically increasing"
    - "SessionView renders current card correctly"
    - "SessionView displays all quality rating buttons"
    - "PracticeView adapts UI to current practice mode"
    - "Session summary displays accurate statistics"

dependencies:
  depends_on:
    - task_id: 2
      reason: "Needs character data structures and models for card content"
    - task_id: 3
      reason: "Needs CharacterCard widget for flashcard presentation"
    - task_id: 4
      reason: "Needs stroke animation system for watch mode practice"
    - task_id: 5
      reason: "Needs drawing canvas and handwriting recognition for practice modes"
    - task_id: 6
      reason: "Needs state management framework for session orchestration"
    - task_id: 7
      reason: "Needs SM-2 algorithm implementation and review queue system"

  depended_upon_by:
    - task_id: 10
      reason: "Statistics dashboard aggregates session data and metrics"
    - task_id: 11
      reason: "Persistence layer saves session state and review history"

  external:
    - name: "Duration"
      type: "struct"
      status: "already exists"
    - name: "Instant"
      type: "struct"
      status: "already exists"
    - name: "HashMap"
      type: "struct"
      status: "already exists"
    - name: "proptest"
      type: "crate"
      status: "to be imported"
---
task:
  id: 12
  name: "Visual Feedback and Animation Polish"

context:
  description: |
    This task implements a comprehensive visual feedback system that provides immediate,
    clear, and delightful responses to user interactions throughout the language learning
    application. The system includes feedback animations for correct/incorrect answers,
    shake effects for errors, circular progress indicators for session tracking, and
    celebratory popups for achievement unlocks.
    
    Visual feedback is critical for effective learning applications as it reinforces
    correct behaviors and gently corrects mistakes in real-time. Research shows that
    immediate visual feedback significantly improves learning retention and user
    engagement. The animations make the application feel responsive and polished,
    transforming what could be a dry educational tool into an engaging experience.
    
    The implementation uses the iced framework's animation capabilities built in Task 1,
    and integrates with the message system from Task 6 to trigger appropriate feedback
    based on user actions. All animations are designed with accessibility in mind,
    including WCAG AA compliant colors, reduced motion support, and icon+color feedback
    to avoid relying on color alone.
    
    The architecture separates animation logic (timing, easing, state management) from
    rendering, making components reusable and testable. Each animation type is
    self-contained with clear lifecycle phases (start, update, complete). The system
    supports multiple concurrent animations and automatically cleans up completed ones.

  key_points:
    - "All feedback colors meet WCAG AA contrast requirements for accessibility"
    - "Animations respect prefers-reduced-motion system preference"
    - "Feedback combines visual (color) and iconic (checkmark/X) elements for accessibility"
    - "Shake effect uses exponential decay to prevent motion sickness"
    - "Progress indicators use smooth easing (EaseOutCubic) for natural feel"
    - "Achievement animations use playful EaseOutElastic for celebratory effect"
    - "All animations target 60fps performance with sub-500ms feedback timing"
    - "Animation components are stateful and self-managing with clear lifecycle"
    - "System supports concurrent animations without interference"
    - "Easing functions maintain mathematical invariants (monotonic, bounded 0-1)"

files:
  - path: "src/ui/animations/mod.rs"
    description: "Module declaration for animation components, exports all animation types"
  
  - path: "src/ui/animations/feedback.rs"
    description: "FeedbackAnimation enum and logic for correct/incorrect/partial feedback animations"
  
  - path: "src/ui/animations/effects.rs"
    description: "ShakeEffect implementation with sine wave oscillation and decay"
  
  - path: "src/ui/animations/progress.rs"
    description: "ProgressCircle component for circular progress indicators"
  
  - path: "src/ui/animations/achievement.rs"
    description: "AchievementPopup struct for celebration animations when unlocking achievements"
  
  - path: "src/ui/theme/colors.rs"
    description: "Color palette constants for feedback states (success, error, warning, neutral)"
  
  - path: "src/ui/animations/easing.rs"
    description: "Easing function implementations (EaseOutElastic, EaseOutCubic, etc.) for smooth animations"
  
  - path: "src/ui/components/session_view.rs"
    description: "Session view integration for triggering and rendering feedback animations"
  
  - path: "src/ui/components/achievement_display.rs"
    description: "Achievement display component for managing and rendering achievement popups"
  
  - path: "tests/visual_feedback_tests.rs"
    description: "Comprehensive tests for animation timing, state transitions, and accessibility"

functions:
  - file: "src/ui/animations/mod.rs"
    items:
      - type: "module_declaration"
        name: "feedback"
        description: "Module containing feedback animation components"
      - type: "module_declaration"
        name: "progress"
        description: "Module containing progress indicator components"
      - type: "module_declaration"
        name: "achievement"
        description: "Module containing achievement animation components"
      - type: "module_declaration"
        name: "effects"
        description: "Module containing visual effects like shake"
      - type: "module_declaration"
        name: "easing"
        description: "Module containing easing function implementations"

  - file: "src/ui/animations/feedback.rs"
    items:
      - type: "enum"
        name: "FeedbackType"
        description: "Represents the type of feedback to display (Correct, Incorrect, Partial)"
      - type: "enum"
        name: "AnimationState"
        description: "Represents the current state of an animation (NotStarted, Running, Completed)"
      - type: "struct"
        name: "FeedbackAnimation"
        description: "Manages state and rendering of success/error/partial feedback animations"
      - type: "method"
        name: "FeedbackAnimation::new"
        description: "Creates a new feedback animation of the specified type"
        preconditions: "Valid FeedbackType provided"
        postconditions: "Animation initialized with start time and type-specific parameters"
      - type: "method"
        name: "FeedbackAnimation::update"
        description: "Updates animation state based on elapsed time"
        postconditions: "Animation progress updated, returns true if animation is complete"
        invariants: "Progress value remains in range 0.0-1.0"
      - type: "method"
        name: "FeedbackAnimation::view"
        description: "Renders the feedback animation as an iced Element"
      - type: "method"
        name: "FeedbackAnimation::is_complete"
        description: "Returns whether the animation has finished"
      - type: "method"
        name: "FeedbackAnimation::state"
        description: "Returns the current animation state"
      - type: "method"
        name: "FeedbackAnimation::progress"
        description: "Returns the current animation progress (0.0-1.0)"
      - type: "method"
        name: "FeedbackAnimation::elapsed"
        description: "Returns the elapsed time since animation started"
      - type: "method"
        name: "FeedbackAnimation::color"
        description: "Returns the color for the current feedback type"
      - type: "function"
        name: "feedback_color"
        description: "Returns the color associated with a feedback type"
        postconditions: "Returns WCAG AA compliant color"
      - type: "function"
        name: "feedback_icon"
        description: "Returns the icon character or path for a feedback type"
      - type: "constant"
        name: "FEEDBACK_DURATION_MS"
        description: "Duration of feedback animation in milliseconds (300ms)"
      - type: "constant"
        name: "FLASH_INTENSITY"
        description: "Intensity of flash effect for feedback (0.0-1.0)"

  - file: "src/ui/animations/effects.rs"
    items:
      - type: "struct"
        name: "ShakeEffect"
        description: "Implements oscillating shake animation with decay for error feedback"
      - type: "struct"
        name: "ShakeConfig"
        description: "Configuration for shake effect (amplitude, frequency, duration)"
      - type: "struct"
        name: "AccessibilitySettings"
        description: "Accessibility settings including prefers_reduced_motion flag"
      - type: "method"
        name: "ShakeEffect::new"
        description: "Creates a new shake effect with specified config"
        preconditions: "Amplitude > 0, frequency > 0"
        postconditions: "Shake effect initialized with start time and parameters"
      - type: "method"
        name: "ShakeEffect::with_accessibility_settings"
        description: "Creates a new shake effect respecting accessibility preferences"
        postconditions: "Shake disabled if prefers_reduced_motion is true"
      - type: "method"
        name: "ShakeEffect::update"
        description: "Updates shake position based on elapsed time with decay"
        postconditions: "Returns current offset position, decreases with time"
        invariants: "Final position converges to (0, 0)"
      - type: "method"
        name: "ShakeEffect::offset_x"
        description: "Returns current horizontal offset for shake effect"
        postconditions: "Returns value with decaying amplitude"
      - type: "method"
        name: "ShakeEffect::offset_y"
        description: "Returns current vertical offset for shake effect"
        postconditions: "Returns value with decaying amplitude"
      - type: "method"
        name: "ShakeEffect::is_complete"
        description: "Returns whether shake has decayed to negligible amplitude"
      - type: "function"
        name: "calculate_shake_offset"
        description: "Calculates shake offset using sine wave with exponential decay"
        preconditions: "time >= 0, amplitude > 0"
        postconditions: "Returns offset that decays to 0 over time"
        invariants: "Offset magnitude never exceeds initial amplitude"
      - type: "constant"
        name: "SHAKE_DURATION_MS"
        description: "Duration of shake animation in milliseconds (500ms)"
      - type: "constant"
        name: "SHAKE_AMPLITUDE"
        description: "Initial amplitude of shake in pixels (10.0)"
      - type: "constant"
        name: "SHAKE_FREQUENCY"
        description: "Oscillation frequency of shake in Hz (15.0)"
      - type: "constant"
        name: "SHAKE_DECAY_RATE"
        description: "Exponential decay rate for shake amplitude (5.0)"

  - file: "src/ui/animations/progress.rs"
    items:
      - type: "struct"
        name: "ProgressCircle"
        description: "Renders a circular progress indicator with smooth transitions"
      - type: "struct"
        name: "ProgressConfig"
        description: "Configuration for progress circle (smooth transitions, duration, etc.)"
      - type: "method"
        name: "ProgressCircle::new"
        description: "Creates a new progress circle with config"
        preconditions: "Valid ProgressConfig provided"
        postconditions: "Circle initialized with current and target progress at 0.0"
      - type: "method"
        name: "ProgressCircle::set_progress"
        description: "Sets current progress directly without transition"
        preconditions: "progress in range 0.0-1.0"
        postconditions: "Current progress set, clamped to valid range"
      - type: "method"
        name: "ProgressCircle::set_target_progress"
        description: "Sets target progress and initiates smooth transition"
        preconditions: "progress in range 0.0-1.0"
        postconditions: "Target progress updated, transition animation started"
      - type: "method"
        name: "ProgressCircle::update"
        description: "Updates current progress toward target with smooth easing"
        postconditions: "Current progress interpolated toward target"
        invariants: "Current progress remains in range 0.0-1.0"
      - type: "method"
        name: "ProgressCircle::view"
        description: "Renders the progress circle as an iced Canvas element"
      - type: "method"
        name: "ProgressCircle::progress"
        description: "Returns the current progress value"
      - type: "method"
        name: "ProgressCircle::arc_angle"
        description: "Returns the current arc angle in radians for rendering"
      - type: "function"
        name: "draw_progress_arc"
        description: "Draws partial arc on canvas based on progress value"
        preconditions: "progress in range 0.0-1.0, radius > 0"
        postconditions: "Arc drawn from 12 o'clock position clockwise"
      - type: "constant"
        name: "PROGRESS_TRANSITION_MS"
        description: "Duration of progress transition animation (400ms)"
      - type: "constant"
        name: "CIRCLE_RADIUS"
        description: "Default radius of progress circle in pixels (40.0)"
      - type: "constant"
        name: "CIRCLE_STROKE_WIDTH"
        description: "Stroke width of progress circle in pixels (4.0)"

  - file: "src/ui/animations/easing.rs"
    items:
      - type: "function"
        name: "ease_out_cubic"
        description: "Cubic easing function for smooth progress transitions"
        preconditions: "t in range 0.0-1.0"
        postconditions: "Returns eased value in range 0.0-1.0"
        invariants: "Monotonically increasing, f(0)=0, f(1)=1"
      - type: "function"
        name: "ease_out_elastic"
        description: "Elastic easing function for playful slide-in effect"
        preconditions: "t in range 0.0-1.0"
        postconditions: "Returns eased value with overshoot and bounce"
        invariants: "Final value converges to 1.0"

  - file: "src/ui/animations/achievement.rs"
    items:
      - type: "struct"
        name: "AchievementPopup"
        description: "Displays celebratory animation for unlocked achievements with auto-dismiss"
      - type: "struct"
        name: "Achievement"
        description: "Data structure containing achievement title, description, and icon"
      - type: "enum"
        name: "AnimationPhase"
        description: "Represents current phase of achievement animation (SlideIn, Display, FadeOut, Complete)"
      - type: "method"
        name: "AchievementPopup::new"
        description: "Creates a new achievement popup with achievement data"
        preconditions: "Valid Achievement provided"
        postconditions: "Popup initialized in hidden state"
      - type: "method"
        name: "AchievementPopup::show"
        description: "Begins the slide-in animation to show the popup"
        postconditions: "Animation phase set to SlideIn, popup becomes visible"
      - type: "method"
        name: "AchievementPopup::update"
        description: "Updates popup animation state including slide-in, display, and fade-out"
        postconditions: "Animation phase updated, returns true if popup should be dismissed"
        invariants: "Transitions through phases: SlideIn -> Display -> FadeOut -> Complete"
      - type: "method"
        name: "AchievementPopup::view"
        description: "Renders the achievement popup with current animation state"
      - type: "method"
        name: "AchievementPopup::dismiss"
        description: "Manually triggers fade-out animation"
        postconditions: "Animation transitions to FadeOut phase"
      - type: "method"
        name: "AchievementPopup::is_visible"
        description: "Returns whether the popup is currently visible"
      - type: "method"
        name: "AchievementPopup::opacity"
        description: "Returns the current opacity value (0.0-1.0)"
      - type: "method"
        name: "AchievementPopup::position_y"
        description: "Returns the current vertical position for rendering"
      - type: "function"
        name: "calculate_slide_offset"
        description: "Calculates vertical offset for slide-in animation"
        preconditions: "progress in range 0.0-1.0"
        postconditions: "Returns offset from -100% to 0% with elastic easing"
      - type: "constant"
        name: "SLIDE_IN_DURATION_MS"
        description: "Duration of slide-in animation (600ms)"
      - type: "constant"
        name: "DISPLAY_DURATION_MS"
        description: "Duration to display achievement before fade-out (3000ms)"
      - type: "constant"
        name: "FADE_OUT_DURATION_MS"
        description: "Duration of fade-out animation (400ms)"

  - file: "src/ui/theme/colors.rs"
    items:
      - type: "constant"
        name: "FEEDBACK_SUCCESS"
        description: "WCAG AA compliant green for correct answers (#2ECC71)"
      - type: "constant"
        name: "FEEDBACK_ERROR"
        description: "WCAG AA compliant red for incorrect answers (#E74C3C)"
      - type: "constant"
        name: "FEEDBACK_PARTIAL"
        description: "WCAG AA compliant yellow/orange for partial credit (#F39C12)"
      - type: "constant"
        name: "PROGRESS_FOREGROUND"
        description: "Color for progress indicator foreground (#3498DB)"
      - type: "constant"
        name: "PROGRESS_BACKGROUND"
        description: "Color for progress indicator background (#ECF0F1)"
      - type: "constant"
        name: "ACHIEVEMENT_BACKGROUND"
        description: "Background color for achievement popups (#9B59B6)"
      - type: "constant"
        name: "ACHIEVEMENT_TEXT"
        description: "Text color for achievement popups (#FFFFFF)"

  - file: "src/ui/components/session_view.rs"
    items:
      - type: "method"
        name: "SessionView::trigger_feedback"
        description: "Triggers appropriate feedback animation based on answer correctness"
        preconditions: "Valid feedback type and session state"
        postconditions: "FeedbackAnimation created and added to active animations"
      - type: "method"
        name: "SessionView::update_animations"
        description: "Updates all active animations and removes completed ones"
        postconditions: "Animation states updated, completed animations removed"
      - type: "method"
        name: "SessionView::render_with_effects"
        description: "Renders session view with active shake effects and feedback animations"

  - file: "src/ui/components/achievement_display.rs"
    items:
      - type: "struct"
        name: "AchievementDisplay"
        description: "Component for displaying achievement popups in the UI hierarchy"
      - type: "struct"
        name: "FeedbackSystem"
        description: "Central system managing all feedback animations and events"
      - type: "enum"
        name: "FeedbackEvent"
        description: "Events that trigger feedback animations (ReviewCompleted, AchievementUnlocked, etc.)"
      - type: "method"
        name: "AchievementDisplay::new"
        description: "Creates a new achievement display component"
        postconditions: "Display initialized with empty popup queue"
      - type: "method"
        name: "AchievementDisplay::show_achievement"
        description: "Displays a new achievement popup with animation"
        preconditions: "Valid achievement data"
        postconditions: "AchievementPopup added to queue"
      - type: "method"
        name: "AchievementDisplay::update"
        description: "Updates all active achievement popups"
        postconditions: "Popup animations updated, completed popups removed"
      - type: "method"
        name: "AchievementDisplay::view"
        description: "Renders all active achievement popups"
      - type: "method"
        name: "FeedbackSystem::new"
        description: "Creates a new feedback system"
        postconditions: "System initialized with no active animations"
      - type: "method"
        name: "FeedbackSystem::handle_event"
        description: "Handles a feedback event and triggers appropriate animations"
        postconditions: "Appropriate animation created and started based on event type"
      - type: "method"
        name: "FeedbackSystem::has_active_animation"
        description: "Returns whether any animations are currently active"
      - type: "method"
        name: "FeedbackSystem::current_animation_type"
        description: "Returns the type of the current active animation if any"
      - type: "method"
        name: "FeedbackSystem::has_active_popup"
        description: "Returns whether any achievement popups are currently active"
      - type: "method"
        name: "FeedbackSystem::start_session"
        description: "Starts tracking progress for a new session"
        preconditions: "total_items > 0"
        postconditions: "Progress tracking initialized"
      - type: "method"
        name: "FeedbackSystem::update_progress"
        description: "Updates session progress"
        preconditions: "Session has been started"
        postconditions: "Progress circle updated with new completion ratio"
      - type: "method"
        name: "FeedbackSystem::session_progress"
        description: "Returns the current session progress (0.0-1.0)"

  - file: "tests/visual_feedback_tests.rs"
    items:
      - type: "function"
        name: "test_correct_feedback_uses_green_color"
        description: "Verifies correct answer feedback uses accessible green color"
      - type: "function"
        name: "test_incorrect_feedback_uses_red_color"
        description: "Verifies incorrect answer feedback uses accessible red color"
      - type: "function"
        name: "test_partial_feedback_uses_yellow_color"
        description: "Verifies partial answer feedback uses accessible yellow/orange color"
      - type: "function"
        name: "test_feedback_animation_completes_in_expected_time"
        description: "Verifies feedback animations complete within 200-500ms window"
      - type: "function"
        name: "test_feedback_animation_progress_increases_monotonically"
        description: "Verifies animation progress increases smoothly from 0 to 1"
      - type: "function"
        name: "test_feedback_animation_initial_state"
        description: "Verifies animation starts in correct initial state"
      - type: "function"
        name: "test_shake_starts_at_zero_offset"
        description: "Verifies shake effect starts at center position"
      - type: "function"
        name: "test_shake_returns_to_center"
        description: "Verifies shake effect returns to zero offset after completion"
      - type: "function"
        name: "test_shake_amplitude_decays"
        description: "Verifies shake amplitude decreases over time"
      - type: "function"
        name: "test_shake_oscillates"
        description: "Verifies shake effect oscillates left and right"
      - type: "function"
        name: "test_shake_respects_custom_amplitude"
        description: "Verifies shake effect respects configured amplitude limits"
      - type: "function"
        name: "test_progress_circle_at_zero_percent"
        description: "Verifies progress circle renders correctly at 0% completion"
      - type: "function"
        name: "test_progress_circle_at_fifty_percent"
        description: "Verifies progress circle renders correctly at 50% completion"
      - type: "function"
        name: "test_progress_circle_at_hundred_percent"
        description: "Verifies progress circle renders correctly at 100% completion"
      - type: "function"
        name: "test_progress_circle_clamps_values"
        description: "Verifies progress values are clamped to valid 0-1 range"
      - type: "function"
        name: "test_progress_circle_smooth_updates"
        description: "Verifies progress updates interpolate smoothly"
      - type: "function"
        name: "test_achievement_popup_initial_state"
        description: "Verifies popup starts in hidden state"
      - type: "function"
        name: "test_achievement_popup_fade_in"
        description: "Verifies popup fades in smoothly when shown"
      - type: "function"
        name: "test_achievement_popup_auto_dismiss"
        description: "Verifies popup auto-dismisses after configured duration"
      - type: "function"
        name: "test_achievement_popup_slide_animation"
        description: "Verifies popup slides down from top"
      - type: "function"
        name: "calculate_contrast_ratio"
        description: "Helper function to calculate WCAG contrast ratios"
      - type: "function"
        name: "test_correct_feedback_meets_wcag_aa_contrast"
        description: "Verifies correct feedback meets WCAG AA contrast (4.5:1)"
      - type: "function"
        name: "test_incorrect_feedback_meets_wcag_aa_contrast"
        description: "Verifies incorrect feedback meets WCAG AA contrast (4.5:1)"
      - type: "function"
        name: "test_prefers_reduced_motion_disables_shake"
        description: "Verifies shake effect respects prefers-reduced-motion"
      - type: "function"
        name: "test_feedback_system_triggers_correct_animation"
        description: "Verifies correct animation triggers on success event"
      - type: "function"
        name: "test_feedback_system_triggers_incorrect_animation"
        description: "Verifies incorrect animation triggers on failure event"
      - type: "function"
        name: "test_achievement_unlocked_triggers_popup"
        description: "Verifies achievement unlock triggers celebration popup"
      - type: "function"
        name: "test_progress_updates_during_session"
        description: "Verifies progress circle updates as session progresses"

formal_verification:
  needed: false
  level: "None"
  explanation: |
    Formal verification is not needed for this task because:
    
    1. Visual feedback and animations are inherently subjective and perceptual in nature.
       Their correctness cannot be meaningfully captured in formal mathematical properties.
       Success is determined by human perception (smoothness, timing, aesthetics) rather
       than logical invariants.
    
    2. Animation systems involve continuous time-based transformations and rendering
       effects that are difficult to formally specify. Properties like "smooth at 60fps"
       or "visually pleasing easing curve" are not amenable to formal verification.
    
    3. The risk profile is low - animation bugs result in poor UX or visual glitches,
       not data corruption, security vulnerabilities, or system crashes. Failed animations
       don't compromise system integrity.
    
    4. The task complexity is rated as "moderate" with "low" complexity, integration,
       and testing risks. This indicates straightforward implementation without subtle
       edge cases that would benefit from formal methods.
    
    5. Integration testing and visual inspection are more appropriate verification methods
       for this domain. Tests can verify that animations trigger correctly, complete
       within expected timeframes, and transition through expected states, which is
       sufficient assurance for UI feedback.
    
    6. The only testable invariants (like "shake effect returns to center" or "progress
       circle renders at correct percentages") are simple enough to verify through
       conventional unit and integration tests without formal methods.
    
    Standard testing practices including timing verification, state transition checks,
    accessibility compliance tests (WCAG contrast), and frame rate monitoring provide
    adequate quality assurance for this animation-focused task.

tests:
  strategy:
    approach: "mixed (unit + integration + visual regression)"
    rationale:
      - "Animation timing and state transitions require unit tests for deterministic verification"
      - "Integration tests verify animations trigger correctly in response to application events"
      - "Visual properties (colors, positions, completion states) need concrete value assertions"
      - "Accessibility requirements (contrast ratios, motion preferences) demand specific checks"
      - "Performance characteristics (60fps, no frame drops) require timing-based validation"
      - "Cannot fully test visual quality programmatically - manual visual inspection still needed"

  implementation:
    file: "tests/visual_feedback_tests.rs"
    location: "create new"
    code: |
      #[cfg(test)]
      mod feedback_animation_tests {
          use super::*;
          use crate::ui::animations::feedback::{FeedbackAnimation, FeedbackType, AnimationState};
          use std::time::Duration;

          #[test]
          fn test_correct_feedback_uses_green_color() {
              let feedback = FeedbackAnimation::new(FeedbackType::Correct);
              let color = feedback.color();
              
              assert_eq!(color.r, 0.0, "Green should have no red component");
              assert!(color.g >= 0.5, "Green component should be at least 0.5");
              assert_eq!(color.b, 0.0, "Green should have no blue component");
          }

          #[test]
          fn test_incorrect_feedback_uses_red_color() {
              let feedback = FeedbackAnimation::new(FeedbackType::Incorrect);
              let color = feedback.color();
              
              assert!(color.r >= 0.7, "Red component should be at least 0.7");
              assert_eq!(color.g, 0.0, "Red should have no green component");
              assert_eq!(color.b, 0.0, "Red should have no blue component");
          }

          #[test]
          fn test_partial_feedback_uses_yellow_color() {
              let feedback = FeedbackAnimation::new(FeedbackType::Partial);
              let color = feedback.color();
              
              assert!(color.r >= 0.8, "Yellow needs high red");
              assert!(color.g >= 0.5, "Yellow needs medium-high green");
              assert_eq!(color.b, 0.0, "Yellow should have no blue");
          }

          #[test]
          fn test_feedback_animation_completes_in_expected_time() {
              let mut feedback = FeedbackAnimation::new(FeedbackType::Correct);
              let duration = Duration::from_millis(500);
              
              feedback.update(duration);
              
              assert_eq!(feedback.state(), AnimationState::Completed);
              assert!(feedback.elapsed() <= Duration::from_millis(500));
          }

          #[test]
          fn test_feedback_animation_progress_increases_monotonically() {
              let mut feedback = FeedbackAnimation::new(FeedbackType::Correct);
              let mut last_progress = 0.0;
              
              for frame in 0..30 {
                  let delta = Duration::from_millis(16);
                  feedback.update(delta);
                  let progress = feedback.progress();
                  
                  assert!(progress >= last_progress, "Progress should never decrease");
                  assert!(progress <= 1.0, "Progress should not exceed 1.0");
                  last_progress = progress;
              }
          }

          #[test]
          fn test_feedback_animation_initial_state() {
              let feedback = FeedbackAnimation::new(FeedbackType::Correct);
              
              assert_eq!(feedback.state(), AnimationState::NotStarted);
              assert_eq!(feedback.progress(), 0.0);
              assert_eq!(feedback.elapsed(), Duration::ZERO);
          }
      }

      #[cfg(test)]
      mod shake_effect_tests {
          use super::*;
          use crate::ui::animations::effects::{ShakeEffect, ShakeConfig, AccessibilitySettings};
          use std::time::Duration;

          #[test]
          fn test_shake_starts_at_zero_offset() {
              let shake = ShakeEffect::new(ShakeConfig::default());
              
              assert_eq!(shake.offset_x(), 0.0);
              assert_eq!(shake.offset_y(), 0.0);
          }

          #[test]
          fn test_shake_returns_to_center() {
              let mut shake = ShakeEffect::new(ShakeConfig::default());
              let total_duration = Duration::from_millis(400);
              
              shake.update(total_duration);
              
              assert!(shake.offset_x().abs() < 0.01, "Should return to center X");
              assert!(shake.offset_y().abs() < 0.01, "Should return to center Y");
              assert!(shake.is_complete());
          }

          #[test]
          fn test_shake_amplitude_decays() {
              let mut shake = ShakeEffect::new(ShakeConfig::default());
              
              shake.update(Duration::from_millis(50));
              let early_offset = shake.offset_x().abs();
              
              shake.update(Duration::from_millis(150));
              let late_offset = shake.offset_x().abs();
              
              assert!(late_offset < early_offset, "Amplitude should decay");
          }

          #[test]
          fn test_shake_oscillates() {
              let mut shake = ShakeEffect::new(ShakeConfig::default());
              let mut direction_changes = 0;
              let mut last_offset = 0.0;
              
              for frame in 0..20 {
                  shake.update(Duration::from_millis(16));
                  let current_offset = shake.offset_x();
                  
                  if (current_offset > 0.0 && last_offset < 0.0) ||
                     (current_offset < 0.0 && last_offset > 0.0) {
                      direction_changes += 1;
                  }
                  
                  last_offset = current_offset;
              }
              
              assert!(direction_changes >= 2, "Should oscillate multiple times");
          }

          #[test]
          fn test_shake_respects_custom_amplitude() {
              let config = ShakeConfig {
                  amplitude: 5.0,
                  frequency: 15.0,
                  duration_ms: 400,
              };
              let mut shake = ShakeEffect::new(config);
              
              let mut max_offset = 0.0;
              for _ in 0..30 {
                  shake.update(Duration::from_millis(16));
                  max_offset = max_offset.max(shake.offset_x().abs());
              }
              
              assert!(max_offset <= 5.5, "Should not exceed configured amplitude significantly");
          }

          #[test]
          fn test_prefers_reduced_motion_disables_shake() {
              let mut shake = ShakeEffect::with_accessibility_settings(
                  ShakeConfig::default(),
                  AccessibilitySettings { prefers_reduced_motion: true }
              );
              
              shake.update(Duration::from_millis(200));
              
              assert_eq!(shake.offset_x(), 0.0, "Should not shake with reduced motion");
              assert_eq!(shake.offset_y(), 0.0, "Should not shake with reduced motion");
          }
      }

      #[cfg(test)]
      mod progress_circle_tests {
          use super::*;
          use crate::ui::animations::progress::{ProgressCircle, ProgressConfig};
          use std::time::Duration;

          #[test]
          fn test_progress_circle_at_zero_percent() {
              let mut circle = ProgressCircle::new(ProgressConfig::default());
              circle.set_progress(0.0);
              
              let arc_angle = circle.arc_angle();
              assert_eq!(arc_angle, 0.0);
          }

          #[test]
          fn test_progress_circle_at_fifty_percent() {
              let mut circle = ProgressCircle::new(ProgressConfig::default());
              circle.set_progress(0.5);
              
              let arc_angle = circle.arc_angle();
              assert!((arc_angle - std::f32::consts::PI).abs() < 0.01);
          }

          #[test]
          fn test_progress_circle_at_hundred_percent() {
              let mut circle = ProgressCircle::new(ProgressConfig::default());
              circle.set_progress(1.0);
              
              let arc_angle = circle.arc_angle();
              assert!((arc_angle - 2.0 * std::f32::consts::PI).abs() < 0.01);
          }

          #[test]
          fn test_progress_circle_clamps_values() {
              let mut circle = ProgressCircle::new(ProgressConfig::default());
              
              circle.set_progress(-0.5);
              assert_eq!(circle.progress(), 0.0);
              
              circle.set_progress(1.5);
              assert_eq!(circle.progress(), 1.0);
          }

          #[test]
          fn test_progress_circle_smooth_updates() {
              let mut circle = ProgressCircle::new(ProgressConfig {
                  smooth_transition: true,
                  transition_duration_ms: 300,
                  ..Default::default()
              });
              
              circle.set_target_progress(1.0);
              circle.update(Duration::from_millis(150));
              
              let progress = circle.progress();
              assert!(progress > 0.3 && progress < 0.7, "Should be near middle");
          }
      }

      #[cfg(test)]
      mod achievement_popup_tests {
          use super::*;
          use crate::ui::animations::achievement::{AchievementPopup, Achievement};
          use std::time::Duration;

          #[test]
          fn test_achievement_popup_initial_state() {
              let achievement = Achievement {
                  title: "First Step".to_string(),
                  description: "Complete your first review".to_string(),
                  icon: "trophy".to_string(),
              };
              let popup = AchievementPopup::new(achievement);
              
              assert!(!popup.is_visible());
              assert_eq!(popup.opacity(), 0.0);
          }

          #[test]
          fn test_achievement_popup_fade_in() {
              let achievement = Achievement {
                  title: "First Step".to_string(),
                  description: "Complete your first review".to_string(),
                  icon: "trophy".to_string(),
              };
              let mut popup = AchievementPopup::new(achievement);
              popup.show();
              
              popup.update(Duration::from_millis(250));
              
              assert!(popup.is_visible());
              assert!(popup.opacity() > 0.3 && popup.opacity() < 0.9);
          }

          #[test]
          fn test_achievement_popup_auto_dismiss() {
              let achievement = Achievement {
                  title: "First Step".to_string(),
                  description: "Complete your first review".to_string(),
                  icon: "trophy".to_string(),
              };
              let mut popup = AchievementPopup::new(achievement);
              popup.show();
              
              popup.update(Duration::from_millis(3500));
              
              assert!(!popup.is_visible());
          }

          #[test]
          fn test_achievement_popup_slide_animation() {
              let achievement = Achievement {
                  title: "First Step".to_string(),
                  description: "Complete your first review".to_string(),
                  icon: "trophy".to_string(),
              };
              let mut popup = AchievementPopup::new(achievement);
              popup.show();
              
              let initial_y = popup.position_y();
              assert!(initial_y < 0.0, "Should start above viewport");
              
              popup.update(Duration::from_millis(500));
              
              let final_y = popup.position_y();
              assert!(final_y >= 0.0, "Should slide into viewport");
          }
      }

      #[cfg(test)]
      mod accessibility_tests {
          use super::*;
          use crate::ui::animations::feedback::{FeedbackAnimation, FeedbackType};

          fn calculate_contrast_ratio(fg: (f32, f32, f32), bg: (f32, f32, f32)) -> f32 {
              let luminance = |rgb: (f32, f32, f32)| -> f32 {
                  let to_linear = |c: f32| {
                      if c <= 0.03928 {
                          c / 12.92
                      } else {
                          ((c + 0.055) / 1.055).powf(2.4)
                      }
                  };
                  0.2126 * to_linear(rgb.0) + 
                  0.7152 * to_linear(rgb.1) + 
                  0.0722 * to_linear(rgb.2)
              };
              
              let l1 = luminance(fg);
              let l2 = luminance(bg);
              let lighter = l1.max(l2);
              let darker = l1.min(l2);
              
              (lighter + 0.05) / (darker + 0.05)
          }

          #[test]
          fn test_correct_feedback_meets_wcag_aa_contrast() {
              let feedback = FeedbackAnimation::new(FeedbackType::Correct);
              let fg_color = feedback.color();
              let bg_color = (1.0, 1.0, 1.0);
              
              let contrast = calculate_contrast_ratio(
                  (fg_color.r, fg_color.g, fg_color.b),
                  bg_color
              );
              
              assert!(contrast >= 4.5, "Contrast ratio {} below WCAG AA", contrast);
          }

          #[test]
          fn test_incorrect_feedback_meets_wcag_aa_contrast() {
              let feedback = FeedbackAnimation::new(FeedbackType::Incorrect);
              let fg_color = feedback.color();
              let bg_color = (1.0, 1.0, 1.0);
              
              let contrast = calculate_contrast_ratio(
                  (fg_color.r, fg_color.g, fg_color.b),
                  bg_color
              );
              
              assert!(contrast >= 4.5, "Contrast ratio {} below WCAG AA", contrast);
          }
      }

      #[cfg(test)]
      mod integration_tests {
          use super::*;
          use crate::ui::components::achievement_display::{FeedbackSystem, FeedbackEvent};
          use crate::ui::animations::feedback::FeedbackType;
          use crate::ui::animations::achievement::Achievement;

          #[test]
          fn test_feedback_system_triggers_correct_animation() {
              let mut system = FeedbackSystem::new();
              let event = FeedbackEvent::ReviewCompleted(ReviewResult::Correct);
              
              system.handle_event(event);
              
              assert!(system.has_active_animation());
              assert_eq!(system.current_animation_type(), Some(FeedbackType::Correct));
          }

          #[test]
          fn test_feedback_system_triggers_incorrect_animation() {
              let mut system = FeedbackSystem::new();
              let event = FeedbackEvent::ReviewCompleted(ReviewResult::Incorrect);
              
              system.handle_event(event);
              
              assert!(system.has_active_animation());
              assert_eq!(system.current_animation_type(), Some(FeedbackType::Incorrect));
          }

          #[test]
          fn test_achievement_unlocked_triggers_popup() {
              let mut system = FeedbackSystem::new();
              let achievement = Achievement {
                  title: "Scholar".to_string(),
                  description: "Review 100 items".to_string(),
                  icon: "star".to_string(),
              };
              let event = FeedbackEvent::AchievementUnlocked(achievement);
              
              system.handle_event(event);
              
              assert!(system.has_active_popup());
          }

          #[test]
          fn test_progress_updates_during_session() {
              let mut system = FeedbackSystem::new();
              system.start_session(10);
              
              for completed in 1..=5 {
                  system.update_progress(completed, 10);
              }
              
              let progress = system.session_progress();
              assert_eq!(progress, 0.5);
          }
      }

  coverage:
    - "Correct feedback uses accessible green color"
    - "Incorrect feedback uses accessible red color"
    - "Partial feedback uses accessible yellow/orange color"
    - "Feedback animations complete within 200-500ms window"
    - "Animation progress increases monotonically from 0 to 1"
    - "Feedback animation starts in correct initial state"
    - "Shake effect starts at center position (0,0)"
    - "Shake effect returns to center after completion"
    - "Shake amplitude decays over time"
    - "Shake effect oscillates multiple times"
    - "Shake respects custom amplitude configuration"
    - "Progress circle renders correctly at 0% completion"
    - "Progress circle renders correctly at 50% completion"
    - "Progress circle renders correctly at 100% completion"
    - "Progress values are clamped to valid 0-1 range"
    - "Progress updates interpolate smoothly with transitions enabled"
    - "Achievement popup starts in hidden state"
    - "Achievement popup fades in smoothly when shown"
    - "Achievement popup auto-dismisses after 3 seconds"
    - "Achievement popup slides down from top of viewport"
    - "Correct feedback meets WCAG AA contrast requirements (4.5:1)"
    - "Incorrect feedback meets WCAG AA contrast requirements (4.5:1)"
    - "Shake effect respects prefers-reduced-motion setting"
    - "Feedback system triggers correct animation on success"
    - "Feedback system triggers incorrect animation on failure"
    - "Achievement unlock triggers celebration popup"
    - "Progress circle updates correctly during session"

dependencies:
  depends_on:
    - task_id: 1
      reason: "Needs animation API and rendering capabilities from iced framework foundation"
    - task_id: 6
      reason: "Needs message/event system to trigger feedback animations in response to user actions"

  depended_upon_by:
    - task_id: 8
      reason: "Progress tracking may use progress circle component for visual display"
    - task_id: 10
      reason: "Statistics view may use achievement popup for displaying unlocked achievements"

  external:
    - name: "iced::widget::Canvas"
      type: "struct"
      status: "already exists"
    - name: "iced::Color"
      type: "struct"
      status: "already exists"
    - name: "iced::Element"
      type: "type"
      status: "already exists"
    - name: "std::time::Duration"
      type: "struct"
      status: "already exists"
    - name: "std::time::Instant"
      type: "struct"
      status: "already exists"
---
task:
  id: 13
  name: "UI/UX Polish and Accessibility"

context:
  description: |
    This task implements comprehensive UI/UX polish and accessibility features to ensure
    the flashcard application meets WCAG 2.1 Level AA standards and provides a professional,
    polished user experience. The implementation focuses on four key areas:
    
    1. **WCAG-Compliant Color System**: Establishes a color palette where all text/background
       combinations meet the 4.5:1 contrast ratio requirement for normal text and 3:1 for
       large text. This ensures readability for users with low vision or color blindness.
    
    2. **Keyboard Navigation and Shortcuts**: Implements comprehensive keyboard-only operation
       with shortcuts for quality rating (1-5 keys), navigation (Space, Enter, Escape), and
       help access. This serves power users and those who cannot use pointing devices.
    
    3. **Touch Target Sizing**: Ensures all interactive elements meet or exceed the 48x48px
       minimum touch target size required by WCAG, making the application usable on touch
       devices and by users with motor impairments.
    
    4. **Responsive Typography and Layout**: Establishes a consistent typography scale with
       minimum 14px body text and responsive layouts that adapt gracefully to different
       window sizes while maintaining accessibility.
    
    This task builds upon the complete UI structure from Task 6 and all implemented screens
    from Task 8, applying consistent styling, accessibility features, and polish across the
    entire application. The result is an application that is not only functional but also
    accessible to users with disabilities, legally compliant in many jurisdictions, and
    provides a professional user experience that builds trust and encourages continued use.

  key_points:
    - "Accessibility is both an ethical imperative and legal requirement in many jurisdictions (ADA, Section 508)"
    - "WCAG 2.1 Level AA compliance requires 4.5:1 contrast for normal text, 3:1 for large text, and 48x48px minimum touch targets"
    - "Keyboard navigation must provide equivalent functionality to mouse/touch interaction for all features"
    - "Consistent design system with 8px spacing unit and defined typography scale improves cognitive load and learning effectiveness"
    - "Responsive layouts ensure usability across different window sizes and display configurations"
    - "Focus indicators with 2px minimum border width provide visible feedback for keyboard navigation"
    - "Screen reader support through semantic structure and accessible labels ensures equivalent experience for blind users"
    - "Property-based testing validates mathematical correctness of contrast ratio calculations"

files:
  - path: "src/ui/theme.rs"
    description: "WCAG-compliant color palette and typography scale definitions"
  
  - path: "src/ui/styles.rs"
    description: "Consistent styling utilities and component style constants"
  
  - path: "src/ui/keyboard.rs"
    description: "Keyboard shortcut definitions and event handling logic"
  
  - path: "src/ui/accessibility.rs"
    description: "Accessibility utilities including focus management and ARIA-like helpers"
  
  - path: "src/ui/layout.rs"
    description: "Responsive layout utilities and spacing constants"
  
  - path: "src/ui/components/button.rs"
    description: "Accessible button component with proper touch target sizing"
  
  - path: "src/ui/components/card.rs"
    description: "Enhanced flashcard display component with accessibility features"
  
  - path: "src/ui/components/input.rs"
    description: "Accessible text input component with focus indicators"
  
  - path: "src/ui/screens/study.rs"
    description: "Study screen with keyboard shortcuts and responsive layout"
  
  - path: "src/ui/screens/review.rs"
    description: "Review screen with accessible controls and keyboard navigation"
  
  - path: "src/ui/screens/deck_list.rs"
    description: "Deck list screen with keyboard navigation and proper spacing"
  
  - path: "src/ui/screens/settings.rs"
    description: "Settings screen with accessible form controls"
  
  - path: "src/ui/screens/help.rs"
    description: "Help screen documenting keyboard shortcuts and accessibility features"
  
  - path: "src/ui/mod.rs"
    description: "Updated UI module declarations including new accessibility modules"
  
  - path: "tests/accessibility_tests.rs"
    description: "Integration tests for accessibility features and keyboard navigation"

functions:
  - file: "src/ui/theme.rs"
    items:
      - type: "module_declaration"
        name: "theme"
        description: "Centralized theme and design system module for consistent styling"
      - type: "struct"
        name: "ColorPalette"
        description: "WCAG-compliant color palette with documented contrast ratios"
      - type: "constant"
        name: "PRIMARY_COLOR"
        description: "Primary brand color (meets WCAG AA contrast)"
      - type: "constant"
        name: "SECONDARY_COLOR"
        description: "Secondary accent color (meets WCAG AA contrast)"
      - type: "constant"
        name: "BACKGROUND_COLOR"
        description: "Main background color"
      - type: "constant"
        name: "SURFACE_COLOR"
        description: "Surface/card background color"
      - type: "constant"
        name: "TEXT_PRIMARY"
        description: "Primary text color with 4.5:1 contrast on backgrounds"
      - type: "constant"
        name: "TEXT_SECONDARY"
        description: "Secondary text color with minimum 4.5:1 contrast"
      - type: "constant"
        name: "ERROR_COLOR"
        description: "Error state color (meets WCAG AA contrast)"
      - type: "constant"
        name: "SUCCESS_COLOR"
        description: "Success state color (meets WCAG AA contrast)"
      - type: "constant"
        name: "WARNING_COLOR"
        description: "Warning state color (meets WCAG AA contrast)"
      - type: "constant"
        name: "FOCUS_INDICATOR_COLOR"
        description: "Keyboard focus indicator color with visible contrast"
      - type: "struct"
        name: "Typography"
        description: "Typography scale with consistent font sizes and weights"
      - type: "constant"
        name: "FONT_SIZE_LARGE"
        description: "Large text size (18-20px for headings)"
      - type: "constant"
        name: "FONT_SIZE_BODY"
        description: "Body text size (16-18px)"
      - type: "constant"
        name: "FONT_SIZE_SECONDARY"
        description: "Secondary text size (14px)"
      - type: "constant"
        name: "FONT_SIZE_SMALL"
        description: "Small text size (12px minimum)"
      - type: "struct"
        name: "Spacing"
        description: "Consistent spacing scale using 8px base unit"
      - type: "constant"
        name: "SPACING_XS"
        description: "Extra small spacing (4px)"
      - type: "constant"
        name: "SPACING_SM"
        description: "Small spacing (8px)"
      - type: "constant"
        name: "SPACING_MD"
        description: "Medium spacing (16px)"
      - type: "constant"
        name: "SPACING_LG"
        description: "Large spacing (24px)"
      - type: "constant"
        name: "SPACING_XL"
        description: "Extra large spacing (32px)"
      - type: "constant"
        name: "MIN_TOUCH_TARGET_SIZE"
        description: "Minimum touch target size (48px for WCAG compliance)"
      - type: "function"
        name: "verify_contrast_ratio"
        description: "Utility to verify color contrast ratios meet WCAG standards"
        preconditions: "Valid RGB color values provided"
        postconditions: "Returns contrast ratio as f32"

  - file: "src/ui/keyboard.rs"
    items:
      - type: "module_declaration"
        name: "keyboard"
        description: "Keyboard navigation and shortcut handling"
      - type: "enum"
        name: "KeyboardShortcut"
        description: "Enumeration of all keyboard shortcuts in the application"
      - type: "enum_variant"
        name: "KeyboardShortcut::RateQuality1"
        description: "Rate question quality as 1 (key: 1)"
      - type: "enum_variant"
        name: "KeyboardShortcut::RateQuality2"
        description: "Rate question quality as 2 (key: 2)"
      - type: "enum_variant"
        name: "KeyboardShortcut::RateQuality3"
        description: "Rate question quality as 3 (key: 3)"
      - type: "enum_variant"
        name: "KeyboardShortcut::RateQuality4"
        description: "Rate question quality as 4 (key: 4)"
      - type: "enum_variant"
        name: "KeyboardShortcut::RateQuality5"
        description: "Rate question quality as 5 (key: 5)"
      - type: "enum_variant"
        name: "KeyboardShortcut::NextQuestion"
        description: "Move to next question (key: Space or Enter)"
      - type: "enum_variant"
        name: "KeyboardShortcut::PreviousQuestion"
        description: "Move to previous question (key: Backspace)"
      - type: "enum_variant"
        name: "KeyboardShortcut::ShowAnswer"
        description: "Reveal answer (key: Space)"
      - type: "enum_variant"
        name: "KeyboardShortcut::Cancel"
        description: "Cancel current action or go back (key: Escape)"
      - type: "enum_variant"
        name: "KeyboardShortcut::ShowHelp"
        description: "Show help/shortcuts screen (key: ?)"
      - type: "function"
        name: "handle_keyboard_event"
        description: "Maps keyboard events to actions/messages"
        preconditions: "Valid keyboard event from iced"
        postconditions: "Returns Option<Message> for matched shortcuts"
      - type: "function"
        name: "get_shortcut_description"
        description: "Returns human-readable description of shortcut for help screen"

  - file: "src/ui/accessibility.rs"
    items:
      - type: "module_declaration"
        name: "accessibility"
        description: "Accessibility utilities and screen reader support"
      - type: "function"
        name: "create_accessible_button"
        description: "Creates button with proper touch target size and ARIA labels"
        preconditions: "Button content and label provided"
        postconditions: "Returns iced Button with minimum 48x48px size"
        invariants: "All buttons meet minimum touch target requirements"
      - type: "function"
        name: "add_focus_indicator"
        description: "Adds visible focus indicator to widget for keyboard navigation"
        preconditions: "Valid widget provided"
        postconditions: "Widget has 2px visible focus border"
      - type: "function"
        name: "create_screen_reader_text"
        description: "Creates screen reader only text for context"
        preconditions: "Text content provided"
        postconditions: "Returns accessible text element"
      - type: "function"
        name: "ensure_minimum_target_size"
        description: "Ensures widget meets minimum 48x48px touch target"
        preconditions: "Widget dimensions available"
        postconditions: "Widget meets or exceeds minimum size with padding if needed"
      - type: "function"
        name: "create_skip_link"
        description: "Creates skip navigation link for keyboard users"
        preconditions: "Target section ID provided"
        postconditions: "Returns skip link that becomes visible on focus"

  - file: "src/ui/responsive.rs"
    items:
      - type: "module_declaration"
        name: "responsive"
        description: "Responsive layout utilities that adapt to window size"
      - type: "enum"
        name: "BreakPoint"
        description: "Responsive breakpoints for different screen sizes"
      - type: "enum_variant"
        name: "BreakPoint::Mobile"
        description: "Mobile screens (<600px)"
      - type: "enum_variant"
        name: "BreakPoint::Tablet"
        description: "Tablet screens (600-1024px)"
      - type: "enum_variant"
        name: "BreakPoint::Desktop"
        description: "Desktop screens (>1024px)"
      - type: "function"
        name: "get_breakpoint"
        description: "Determines current breakpoint based on window width"
        preconditions: "Valid window width provided"
        postconditions: "Returns appropriate BreakPoint variant"
      - type: "function"
        name: "responsive_padding"
        description: "Returns appropriate padding for current screen size"
        preconditions: "BreakPoint determined"
        postconditions: "Returns padding value scaled to screen size"
      - type: "function"
        name: "responsive_font_size"
        description: "Returns font size scaled for screen size and accessibility"
        preconditions: "Base font size and breakpoint provided"
        postconditions: "Returns font size >= 12px"
        invariants: "Never returns font size below minimum"
      - type: "function"
        name: "create_responsive_layout"
        description: "Creates layout that adapts columns/rows to screen size"
        preconditions: "Content widgets and breakpoint provided"
        postconditions: "Returns optimal layout for screen size"

  - file: "src/ui/components/button.rs"
    items:
      - type: "function"
        name: "styled_button"
        description: "Creates consistently styled button with proper sizing and accessibility"
        preconditions: "Label text and optional icon provided"
        postconditions: "Returns Button with minimum 48x48px size, proper contrast, and focus indicator"
        invariants: "Always meets WCAG touch target and contrast requirements"
      - type: "function"
        name: "primary_button"
        description: "Primary action button with brand styling"
      - type: "function"
        name: "secondary_button"
        description: "Secondary action button with subtle styling"
      - type: "function"
        name: "icon_button"
        description: "Icon-only button with text label for screen readers"
        preconditions: "Icon and accessible label provided"
        postconditions: "Returns 48x48px button with hidden text label"

  - file: "src/ui/components/text.rs"
    items:
      - type: "function"
        name: "heading_text"
        description: "Creates heading text with proper hierarchy and sizing"
        preconditions: "Text content and level (1-6) provided"
        postconditions: "Returns Text widget with semantic heading level"
      - type: "function"
        name: "body_text"
        description: "Creates body text with standard sizing and contrast"
      - type: "function"
        name: "secondary_text"
        description: "Creates secondary/caption text with proper minimum size"
        invariants: "Font size never below 12px"
      - type: "function"
        name: "error_text"
        description: "Creates error message text with icon and proper contrast"
      - type: "function"
        name: "success_text"
        description: "Creates success message text with icon and proper contrast"

  - file: "src/ui/components/card.rs"
    items:
      - type: "function"
        name: "create_card"
        description: "Creates card container with consistent styling and proper contrast"
        preconditions: "Card content provided"
        postconditions: "Returns Container with surface color, proper spacing, and shadows"
      - type: "function"
        name: "create_interactive_card"
        description: "Creates card that responds to hover and focus states"
        preconditions: "Card content and click handler provided"
        postconditions: "Returns interactive card with visible focus indicator"

  - file: "src/ui/screens/help_screen.rs"
    items:
      - type: "function"
        name: "view"
        description: "Renders help screen showing keyboard shortcuts"
        postconditions: "Displays all keyboard shortcuts with descriptions"
      - type: "function"
        name: "render_shortcut_list"
        description: "Renders formatted list of keyboard shortcuts"
      - type: "function"
        name: "render_accessibility_info"
        description: "Renders accessibility features information"

  - file: "src/ui/mod.rs"
    items:
      - type: "trait_impl"
        name: "Application::subscription for FlashcardApp"
        description: "Add keyboard event subscription for global shortcuts"
        postconditions: "Application receives keyboard events for shortcut handling"

  - file: "tests/accessibility_tests.rs"
    items:
      - type: "function"
        name: "test_color_contrast_ratios"
        description: "Verifies all color combinations meet WCAG AA standards"
        postconditions: "All text/background pairs have >= 4.5:1 contrast"
      - type: "function"
        name: "test_minimum_touch_targets"
        description: "Verifies all interactive elements meet 48x48px minimum"
        postconditions: "All buttons and interactive widgets are properly sized"
      - type: "function"
        name: "test_keyboard_shortcuts"
        description: "Verifies all keyboard shortcuts map correctly"
        postconditions: "All shortcut keys produce expected messages"
      - type: "function"
        name: "test_focus_indicators"
        description: "Verifies focus indicators are visible"
        postconditions: "All interactive elements have visible focus state"
      - type: "function"
        name: "test_font_sizes"
        description: "Verifies all font sizes meet minimum requirements"
        postconditions: "No font size below 12px"
      - type: "function"
        name: "test_responsive_breakpoints"
        description: "Verifies breakpoint calculations work correctly"
      - type: "function"
        name: "test_screen_reader_labels"
        description: "Verifies all interactive elements have accessible labels"
      - type: "function"
        name: "test_keyboard_navigation_order"
        description: "Verifies tab order is logical and complete"

formal_verification:
  needed: false
  level: "None"
  explanation: |
    UI/UX polish and accessibility features do not require formal verification for several reasons:
    
    1. **Subjective and Perceptual Properties**: Many accessibility and UX requirements (color
       contrast ratios, touch target sizes, visual hierarchy) are measured against external
       standards (WCAG 2.1 AA) rather than mathematical invariants. These are better validated
       through compliance testing and manual verification with assistive technologies.
    
    2. **Human-Centered Validation**: The effectiveness of keyboard navigation, screen reader
       announcements, and visual polish must be validated through actual human interaction and
       user testing, not formal proofs. A mathematically correct keyboard handler may still
       provide poor UX.
    
    3. **Integration Testing Sufficiency**: The critical properties (contrast ratios meet 4.5:1,
       targets are ≥48x48px, keyboard handlers respond correctly) are straightforward to verify
       through integration tests and automated accessibility checkers. These are assertions about
       concrete values, not complex logical properties requiring proof.
    
    4. **Framework Delegation**: The underlying iced framework handles event routing, focus
       management, and rendering. The application layer primarily configures colors, sizes, and
       handlers—configuration-level concerns rather than algorithmic correctness.
    
    5. **Low Complexity Risk**: The task is marked as having low complexity and integration risk.
       The implementation involves applying constants, sizing constraints, and event handlers
       rather than complex state machines or concurrent operations that benefit from verification.
    
    Standard integration testing with accessibility validation tools (contrast checkers, screen
    readers, keyboard-only testing) provides adequate assurance for this task.

tests:
  strategy:
    approach: "integration"
    rationale:
      - "Accessibility and UX polish require integration testing across components to verify system-wide consistency"
      - "Contrast ratio validation can be automated by testing color constant values against WCAG formulas"
      - "Keyboard navigation requires testing actual widget event handlers and focus flow between components"
      - "Touch target sizing validation can be automated by checking minimum dimensions in layout components"
      - "Typography consistency verified through constant validation and applied styles"
      - "Screen reader support requires manual testing but can be partially validated through semantic structure checks"
      - "Responsive layout behavior tested through simulated window size changes"
      - "Property-based testing used for contrast ratio calculations to ensure mathematical correctness"

  implementation:
    file: "tests/ui_ux_accessibility_tests.rs"
    location: "create new"
    code: |
      #[cfg(test)]
      mod ui_ux_accessibility_tests {
          use super::*;
          
          // Test color contrast ratios meet WCAG AA standards
          #[test]
          fn test_color_contrast_ratios_meet_wcag_aa() {
              // WCAG AA requires 4.5:1 for normal text, 3:1 for large text
              let foreground = Color::from_rgb(0.0, 0.0, 0.0); // Black
              let background = Color::from_rgb(1.0, 1.0, 1.0); // White
              
              let contrast_ratio = calculate_contrast_ratio(foreground, background);
              assert!(contrast_ratio >= 4.5, 
                  "Normal text contrast ratio {} does not meet WCAG AA requirement of 4.5:1", 
                  contrast_ratio);
              
              // Test all defined color pairs in palette
              let color_pairs = get_all_color_pairs();
              for (name, fg, bg) in color_pairs {
                  let ratio = calculate_contrast_ratio(fg, bg);
                  assert!(ratio >= 4.5, 
                      "Color pair '{}' has contrast ratio {} which fails WCAG AA", 
                      name, ratio);
              }
          }
          
          #[test]
          fn test_primary_button_meets_minimum_touch_target() {
              // WCAG requires minimum 48x48px touch targets
              let button = create_primary_button("Test", ButtonMessage::Submit);
              let size = button.size();
              
              assert!(size.width >= 48.0, 
                  "Button width {} is less than minimum 48px", size.width);
              assert!(size.height >= 48.0, 
                  "Button height {} is less than minimum 48px", size.height);
          }
          
          #[test]
          fn test_all_interactive_elements_meet_touch_target_minimum() {
              // Test all button types and interactive elements
              let elements = vec![
                  create_primary_button("Primary", ButtonMessage::Submit),
                  create_secondary_button("Secondary", ButtonMessage::Cancel),
                  create_quality_rating_button(5),
                  create_navigation_button("Next"),
                  create_checkbox("Checkbox"),
                  create_text_input("Input"),
              ];
              
              for (idx, element) in elements.iter().enumerate() {
                  let size = element.size();
                  assert!(size.width >= 48.0 && size.height >= 48.0,
                      "Interactive element {} has size {}x{} below 48x48px minimum",
                      idx, size.width, size.height);
              }
          }
          
          #[test]
          fn test_keyboard_shortcuts_registered() {
              // Verify all required keyboard shortcuts are registered
              let keyboard_map = get_keyboard_shortcuts();
              
              // Quality rating shortcuts (1-5)
              for rating in 1..=5 {
                  let key = format!("{}", rating);
                  assert!(keyboard_map.contains_key(&key),
                      "Quality rating shortcut '{}' not registered", key);
              }
              
              // Navigation shortcuts
              assert!(keyboard_map.contains_key("Space"), 
                  "Space key for 'next' not registered");
              assert!(keyboard_map.contains_key("Escape"), 
                  "Escape key for 'cancel' not registered");
              assert!(keyboard_map.contains_key("Enter"), 
                  "Enter key for 'submit' not registered");
              assert!(keyboard_map.contains_key("Tab"), 
                  "Tab key for navigation not registered");
          }
          
          #[test]
          fn test_focus_indicator_visibility() {
              // Focus indicators must be at least 2px and clearly visible
              let focused_button = create_primary_button("Test", ButtonMessage::Submit)
                  .with_focus(true);
              
              let focus_style = focused_button.get_focus_style();
              assert!(focus_style.border_width >= 2.0,
                  "Focus border width {} is less than 2px minimum", 
                  focus_style.border_width);
              
              // Verify focus color contrasts with background
              let contrast = calculate_contrast_ratio(
                  focus_style.border_color, 
                  focus_style.background_color
              );
              assert!(contrast >= 3.0,
                  "Focus indicator contrast ratio {} insufficient", contrast);
          }
          
          #[test]
          fn test_typography_scale_consistency() {
              // Verify font sizes meet minimum requirements
              let typography = get_typography_scale();
              
              assert!(typography.body >= 14.0,
                  "Body text size {} below recommended 14px minimum", 
                  typography.body);
              assert!(typography.secondary >= 12.0,
                  "Secondary text size {} below absolute 12px minimum", 
                  typography.secondary);
              assert!(typography.heading >= typography.body,
                  "Heading size must be larger than body text");
              
              // Verify consistent scale ratios
              let ratio = typography.heading / typography.body;
              assert!(ratio >= 1.25 && ratio <= 2.0,
                  "Heading to body ratio {} outside recommended range 1.25-2.0", 
                  ratio);
          }
          
          #[test]
          fn test_responsive_layout_adapts_to_window_sizes() {
              // Test layout behavior at different breakpoints
              let layouts = vec![
                  (800, 600, "desktop"),
                  (1920, 1080, "large_desktop"),
                  (600, 800, "small_window"),
                  (400, 600, "minimum_size"),
              ];
              
              for (width, height, name) in layouts {
                  let layout = create_main_layout(width, height);
                  
                  // Verify layout doesn't cause overflow
                  assert!(layout.width() <= width as f32,
                      "Layout width exceeds window width at {}", name);
                  assert!(layout.height() <= height as f32,
                      "Layout height exceeds window height at {}", name);
                  
                  // Verify all content is accessible
                  assert!(layout.has_scrolling() || layout.fits_content(),
                      "Layout at {} doesn't fit content and lacks scrolling", name);
              }
          }
          
          #[test]
          fn test_spacing_consistency() {
              // Verify 8px base spacing unit is used consistently
              let spacing = get_spacing_constants();
              
              assert_eq!(spacing.base % 8, 0,
                  "Base spacing {} is not multiple of 8px", spacing.base);
              assert_eq!(spacing.small % 8, 0,
                  "Small spacing {} is not multiple of 8px", spacing.small);
              assert_eq!(spacing.medium % 8, 0,
                  "Medium spacing {} is not multiple of 8px", spacing.medium);
              assert_eq!(spacing.large % 8, 0,
                  "Large spacing {} is not multiple of 8px", spacing.large);
              
              // Verify spacing scale progression
              assert!(spacing.small < spacing.base);
              assert!(spacing.base < spacing.medium);
              assert!(spacing.medium < spacing.large);
          }
      }
      
      // Property-based testing for contrast ratio calculations
      #[cfg(test)]
      mod contrast_ratio_properties {
          use proptest::prelude::*;
          
          proptest! {
              #[test]
              fn prop_contrast_ratio_is_commutative(
                  r1 in 0.0f32..1.0,
                  g1 in 0.0f32..1.0,
                  b1 in 0.0f32..1.0,
                  r2 in 0.0f32..1.0,
                  g2 in 0.0f32..1.0,
                  b2 in 0.0f32..1.0,
              ) {
                  let color1 = Color::from_rgb(r1, g1, b1);
                  let color2 = Color::from_rgb(r2, g2, b2);
                  
                  let ratio1 = calculate_contrast_ratio(color1, color2);
                  let ratio2 = calculate_contrast_ratio(color2, color1);
                  
                  // Contrast ratio should be same regardless of order
                  prop_assert!((ratio1 - ratio2).abs() < 0.01);
              }
              
              #[test]
              fn prop_contrast_ratio_always_positive(
                  r1 in 0.0f32..1.0,
                  g1 in 0.0f32..1.0,
                  b1 in 0.0f32..1.0,
                  r2 in 0.0f32..1.0,
                  g2 in 0.0f32..1.0,
                  b2 in 0.0f32..1.0,
              ) {
                  let color1 = Color::from_rgb(r1, g1, b1);
                  let color2 = Color::from_rgb(r2, g2, b2);
                  
                  let ratio = calculate_contrast_ratio(color1, color2);
                  
                  // Contrast ratio must be positive and at least 1.0
                  prop_assert!(ratio >= 1.0);
              }
              
              #[test]
              fn prop_black_white_has_maximum_contrast(
                  r in 0.0f32..1.0,
                  g in 0.0f32..1.0,
                  b in 0.0f32..1.0,
              ) {
                  let black = Color::from_rgb(0.0, 0.0, 0.0);
                  let white = Color::from_rgb(1.0, 1.0, 1.0);
                  let other = Color::from_rgb(r, g, b);
                  
                  let max_contrast = calculate_contrast_ratio(black, white);
                  let other_contrast = calculate_contrast_ratio(black, other);
                  
                  // Black-white should have highest possible contrast (21:1)
                  prop_assert!(max_contrast >= other_contrast);
                  prop_assert!((max_contrast - 21.0).abs() < 0.1);
              }
          }
      }
      
      // Helper functions for tests
      fn calculate_contrast_ratio(fg: Color, bg: Color) -> f32 {
          // Convert RGB to relative luminance (WCAG formula)
          fn relative_luminance(c: f32) -> f32 {
              if c <= 0.03928 {
                  c / 12.92
              } else {
                  ((c + 0.055) / 1.055).powf(2.4)
              }
          }
          
          let l1 = 0.2126 * relative_luminance(fg.r) 
                 + 0.7152 * relative_luminance(fg.g) 
                 + 0.0722 * relative_luminance(fg.b);
          let l2 = 0.2126 * relative_luminance(bg.r) 
                 + 0.7152 * relative_luminance(bg.g) 
                 + 0.0722 * relative_luminance(bg.b);
          
          let lighter = l1.max(l2);
          let darker = l1.min(l2);
          
          (lighter + 0.05) / (darker + 0.05)
      }

  coverage:
    - "WCAG AA contrast ratio validation for all color pairs (4.5:1 minimum)"
    - "Large text contrast ratio validation (3.0:1 minimum)"
    - "Primary button meets 48x48px minimum touch target size"
    - "Secondary button meets 48x48px minimum touch target size"
    - "Quality rating buttons meet touch target minimums"
    - "All interactive elements (buttons, checkboxes, inputs) meet 48x48px minimum"
    - "Quality rating keyboard shortcuts (1-5) are registered"
    - "Navigation keyboard shortcuts (Space, Escape, Enter, Tab) are registered"
    - "Focus indicator border meets 2px minimum width"
    - "Focus indicator has sufficient contrast with background (3:1 minimum)"
    - "Body text meets 14px recommended minimum font size"
    - "Secondary text meets 12px absolute minimum font size"
    - "Heading text is appropriately larger than body text"
    - "Typography scale maintains consistent ratios (1.25-2.0)"
    - "Responsive layout adapts to desktop resolution (800x600)"
    - "Responsive layout adapts to large desktop (1920x1080)"
    - "Responsive layout adapts to small windows (600x800)"
    - "Responsive layout handles minimum window size (400x600)"
    - "Layout content doesn't overflow window boundaries"
    - "Layout provides scrolling when content exceeds viewport"
    - "Spacing constants use 8px base unit system"
    - "All spacing values are multiples of 8px"
    - "Spacing scale progresses logically (small < base < medium < large)"
    - "Contrast ratio calculation is commutative (order-independent)"
    - "Contrast ratio is always positive and at least 1.0"
    - "Black-white contrast achieves maximum ratio (21:1)"
    - "Tab navigation includes all interactive elements"
    - "Keyboard-only operation is fully functional"

dependencies:
  depends_on:
    - task_id: 6
      reason: "Needs complete UI structure to polish"
    - task_id: 8
      reason: "Needs all screens implemented to apply consistency"

  depended_upon_by: []

  external:
    - name: "iced::Color"
      type: "struct"
      status: "already exists"
    - name: "iced::widget::Button"
      type: "struct"
      status: "already exists"
    - name: "iced::widget::Container"
      type: "struct"
      status: "already exists"
    - name: "iced::widget::Text"
      type: "struct"
      status: "already exists"
    - name: "iced::keyboard::Event"
      type: "enum"
      status: "already exists"
    - name: "iced::Subscription"
      type: "trait"
      status: "already exists"
    - name: "proptest"
      type: "crate"
      status: "to be imported"
---
task:
  id: 14
  name: "Testing, Documentation, and Release Preparation"

context:
  description: |
    This task implements comprehensive test coverage, user-facing documentation,
    release build configurations, and platform-specific distribution packages to
    transform the working prototype into a production-ready application. It includes
    integration tests that verify end-to-end workflows, property-based tests that
    ensure algorithmic correctness, performance benchmarks that establish baseline
    metrics, and a complete user manual with screenshots.
    
    The testing infrastructure provides quality assurance through multiple layers:
    unit tests for individual components, integration tests for complete workflows,
    property-based tests for mathematical invariants, and benchmarks for performance
    regression detection. The target of >80% code coverage ensures all critical
    paths are validated.
    
    Documentation makes the application accessible to end users by providing clear
    installation instructions, feature explanations with screenshots, keyboard
    shortcut references, and troubleshooting guidance. This reduces support burden
    and enables users to maximize the application's value.
    
    Release preparation includes optimized build configurations with LTO and
    aggressive optimization levels, platform-specific packaging (AppImage/deb for
    Linux, .app bundle for macOS, MSI installer for Windows), and automated CI/CD
    pipelines for consistent builds and testing across all platforms.

  key_points:
    - "Integration tests use temporary databases to avoid corrupting production data"
    - "Property-based tests verify SM-2 algorithm correctness across all valid inputs"
    - "Benchmarks establish performance baselines: 60fps animation, <100ms DB operations, <50ms recognition"
    - "Release profile optimizations: opt-level=3, lto=true, strip=true, codegen-units=1"
    - "Cross-platform testing on clean VMs catches dependency and packaging issues"
    - "Documentation is user-focused (not technical) with Getting Started, Features, and Troubleshooting sections"
    - "CI/CD pipeline automates testing, builds, and release artifact creation"
    - "Code signing certificates required for macOS and Windows distribution"

files:
  - path: "tests/integration_tests.rs"
    description: "Integration tests for complete user workflows and learning sessions"
  
  - path: "tests/animation_tests.rs"
    description: "Integration tests for animation system and visual effects"
  
  - path: "tests/database_tests.rs"
    description: "Integration tests for database operations and data persistence"
  
  - path: "tests/recognition_tests.rs"
    description: "Integration tests for character recognition and input handling"
  
  - path: "tests/common/mod.rs"
    description: "Shared test utilities, fixtures, and helper functions"
  
  - path: "benches/animation_benchmark.rs"
    description: "Performance benchmarks for animation rendering and frame rates"
  
  - path: "benches/database_benchmark.rs"
    description: "Performance benchmarks for database operations and batch saves"
  
  - path: "benches/recognition_benchmark.rs"
    description: "Performance benchmarks for character recognition latency"
  
  - path: "benches/sm2_benchmark.rs"
    description: "Performance benchmarks for SM-2 algorithm calculations"
  
  - path: "tests/property_tests.rs"
    description: "Property-based tests for SM-2 algorithm and statistics"
  
  - path: "Cargo.toml"
    description: "Updated with release profile, benchmark configurations, and test dependencies"
  
  - path: "docs/user_manual.md"
    description: "Comprehensive user manual with Getting Started, Features, and Troubleshooting"
  
  - path: "docs/installation.md"
    description: "Installation instructions for Linux, macOS, and Windows"
  
  - path: "docs/screenshots/README.md"
    description: "Directory for user manual screenshots and images"
  
  - path: ".github/workflows/ci.yml"
    description: "GitHub Actions workflow for automated testing and builds"
  
  - path: ".github/workflows/release.yml"
    description: "GitHub Actions workflow for automated release builds and packaging"
  
  - path: "build/linux/appimage.yml"
    description: "AppImage build configuration for Linux distribution"
  
  - path: "build/macos/bundle.toml"
    description: "Configuration for macOS app bundle creation"
  
  - path: "build/windows/wix.wxs"
    description: "WiX toolset configuration for Windows MSI installer"
  
  - path: "build/common/release.sh"
    description: "Shell script for cross-platform release build automation"

functions:
  - file: "tests/integration_tests.rs"
    items:
      - type: "module_declaration"
        name: "integration_tests"
        description: "Integration test module for end-to-end workflow testing"
      
      - type: "function"
        name: "setup_test_environment"
        description: "Creates a temporary test environment with isolated database and configuration"
        postconditions: "Returns a TestEnvironment with temporary paths and initialized database"
      
      - type: "function"
        name: "teardown_test_environment"
        description: "Cleans up temporary files and databases after tests complete"
        preconditions: "TestEnvironment exists"
        postconditions: "All temporary resources are removed"
      
      - type: "function"
        name: "test_complete_learning_session"
        description: "Tests a full learning session from start to review completion"
        postconditions: "Cards are learned, statistics updated, database persisted"
      
      - type: "function"
        name: "test_practice_mode_workflow"
        description: "Tests practice mode with multiple card reviews and animations"
        postconditions: "Practice session completes with correct statistics"
      
      - type: "function"
        name: "test_statistics_tracking"
        description: "Verifies statistics are correctly tracked across multiple sessions"
        postconditions: "All statistics match expected values after simulated sessions"
      
      - type: "function"
        name: "test_database_persistence"
        description: "Tests that card states persist correctly across application restarts"
        postconditions: "Card data matches before and after restart"
      
      - type: "function"
        name: "test_animation_rendering_cycle"
        description: "Tests complete animation rendering cycle with user input"
        postconditions: "Animation completes within expected timeframe"
      
      - type: "function"
        name: "test_handwriting_recognition_integration"
        description: "Tests handwriting recognition from stroke input to character match"
        postconditions: "Recognition produces correct character matches"
      
      - type: "function"
        name: "test_settings_persistence"
        description: "Verifies settings are saved and loaded correctly"
        postconditions: "Settings match after save/load cycle"
      
      - type: "function"
        name: "test_concurrent_database_access"
        description: "Tests database handles concurrent read/write operations safely"
        postconditions: "No data corruption or panics under concurrent access"
      
      - type: "function"
        name: "test_card_import_export"
        description: "Tests importing and exporting card data"
        postconditions: "Exported data can be re-imported without loss"
      
      - type: "function"
        name: "test_error_recovery"
        description: "Tests application recovers gracefully from common error conditions"
        postconditions: "Application continues functioning after errors"

  - file: "tests/property_tests.rs"
    items:
      - type: "module_declaration"
        name: "property_tests"
        description: "Property-based tests for algorithmic correctness"
      
      - type: "function"
        name: "prop_sm2_intervals_increase"
        description: "Property test: SM-2 intervals increase with correct answers"
        invariants: "Interval(n+1) >= Interval(n) for quality >= 3"
      
      - type: "function"
        name: "prop_sm2_easiness_factor_bounds"
        description: "Property test: Easiness factor stays within valid bounds"
        invariants: "1.3 <= easiness_factor <= 2.5"
      
      - type: "function"
        name: "prop_sm2_deterministic"
        description: "Property test: Same inputs produce same outputs in SM-2"
        invariants: "SM2(card, quality) is deterministic"
      
      - type: "function"
        name: "prop_statistics_consistency"
        description: "Property test: Statistics remain mathematically consistent"
        invariants: "total_reviews = correct + incorrect, percentages sum to 100"
      
      - type: "function"
        name: "prop_card_state_transitions_valid"
        description: "Property test: Card state transitions are always valid"
        invariants: "All state transitions follow defined FSM rules"
      
      - type: "function"
        name: "prop_database_roundtrip"
        description: "Property test: Data survives database save/load cycle"
        invariants: "save(load(data)) == data"
      
      - type: "function"
        name: "prop_animation_timing_monotonic"
        description: "Property test: Animation timestamps are monotonically increasing"
        invariants: "timestamp(frame_n+1) > timestamp(frame_n)"
      
      - type: "function"
        name: "prop_stroke_order_preserved"
        description: "Property test: Stroke order is preserved through processing"
        invariants: "Input stroke order matches processed stroke order"

  - file: "benches/performance_benchmarks.rs"
    items:
      - type: "module_declaration"
        name: "performance_benchmarks"
        description: "Performance benchmarks for critical paths"
      
      - type: "function"
        name: "bench_animation_frame_rate"
        description: "Benchmarks animation rendering to ensure 60fps capability"
        postconditions: "Frame time < 16.67ms (60fps target)"
      
      - type: "function"
        name: "bench_database_batch_save"
        description: "Benchmarks batch saving card states to database"
        postconditions: "Batch save time < 100ms for 1000 cards"
      
      - type: "function"
        name: "bench_database_query_performance"
        description: "Benchmarks common database queries"
        postconditions: "Query time < 10ms for typical operations"
      
      - type: "function"
        name: "bench_handwriting_recognition"
        description: "Benchmarks handwriting recognition latency"
        postconditions: "Recognition time < 200ms per character"
      
      - type: "function"
        name: "bench_sm2_calculation"
        description: "Benchmarks SM-2 algorithm computation"
        postconditions: "Computation time < 1ms per card"
      
      - type: "function"
        name: "bench_statistics_aggregation"
        description: "Benchmarks statistics calculation and aggregation"
        postconditions: "Aggregation time < 50ms for full history"
      
      - type: "function"
        name: "bench_stroke_processing"
        description: "Benchmarks stroke data processing and normalization"
        postconditions: "Processing time < 5ms per stroke"
      
      - type: "function"
        name: "bench_tui_rendering"
        description: "Benchmarks TUI terminal rendering performance"
        postconditions: "Full screen render < 10ms"

  - file: "src/test_utils.rs"
    items:
      - type: "module_declaration"
        name: "test_utils"
        description: "Shared test utilities and fixtures"
      
      - type: "struct"
        name: "TestEnvironment"
        description: "Test environment with temporary database and configuration"
      
      - type: "struct"
        name: "MockStrokeInput"
        description: "Mock implementation for testing stroke input without actual drawing"
      
      - type: "struct"
        name: "TestCardBuilder"
        description: "Builder pattern for creating test card data"
      
      - type: "function"
        name: "create_test_cards"
        description: "Creates a set of test cards with various states"
        postconditions: "Returns vector of cards in different review states"
      
      - type: "function"
        name: "simulate_user_input"
        description: "Simulates user input events for testing"
        postconditions: "Returns sequence of input events"
      
      - type: "function"
        name: "create_mock_strokes"
        description: "Creates mock stroke data for testing recognition"
        postconditions: "Returns valid stroke data matching expected format"
      
      - type: "function"
        name: "assert_card_state"
        description: "Custom assertion for verifying card state properties"
        preconditions: "Card exists in valid state"
      
      - type: "function"
        name: "assert_statistics_valid"
        description: "Custom assertion for validating statistics consistency"
        preconditions: "Statistics struct exists"
        invariants: "Statistics are mathematically consistent"

  - file: "Cargo.toml"
    items:
      - type: "constant"
        name: "[profile.release]"
        description: "Release build profile with optimizations"
        invariants: "opt-level=3, lto=true, strip=true, codegen-units=1"
      
      - type: "constant"
        name: "[profile.bench]"
        description: "Benchmark build profile"
        invariants: "Inherits from release profile"
      
      - type: "constant"
        name: "[dev-dependencies]"
        description: "Test and benchmark dependencies"

  - file: "scripts/build_release.sh"
    items:
      - type: "function"
        name: "build_linux_appimage"
        description: "Builds AppImage package for Linux distribution"
        postconditions: "Produces .AppImage file in dist/ directory"
      
      - type: "function"
        name: "build_linux_deb"
        description: "Builds Debian package for Linux distribution"
        postconditions: "Produces .deb file in dist/ directory"
      
      - type: "function"
        name: "build_macos_bundle"
        description: "Builds .app bundle for macOS distribution"
        postconditions: "Produces .app bundle in dist/ directory"
      
      - type: "function"
        name: "build_windows_msi"
        description: "Builds MSI installer for Windows distribution"
        postconditions: "Produces .msi file in dist/ directory"
      
      - type: "function"
        name: "verify_build_artifacts"
        description: "Verifies all build artifacts are correctly created"
        postconditions: "All platform builds exist and pass basic checks"

  - file: "scripts/package_release.sh"
    items:
      - type: "function"
        name: "package_for_distribution"
        description: "Creates distribution packages for all platforms"
        postconditions: "All platform packages created and checksummed"
      
      - type: "function"
        name: "sign_packages"
        description: "Code signs packages for macOS and Windows"
        preconditions: "Signing certificates available"
        postconditions: "Packages are signed and verifiable"
      
      - type: "function"
        name: "generate_checksums"
        description: "Generates SHA256 checksums for all packages"
        postconditions: "Checksum file created with all package hashes"

  - file: ".github/workflows/ci.yml"
    items:
      - type: "constant"
        name: "test_job"
        description: "CI job for running tests on all platforms"
        postconditions: "All tests pass on Linux, macOS, Windows"
      
      - type: "constant"
        name: "benchmark_job"
        description: "CI job for running performance benchmarks"
        postconditions: "Benchmarks complete and results archived"
      
      - type: "constant"
        name: "build_job"
        description: "CI job for building release artifacts"
        postconditions: "Release builds succeed for all platforms"
      
      - type: "constant"
        name: "coverage_job"
        description: "CI job for measuring test coverage"
        postconditions: "Coverage report generated and uploaded"

  - file: "docs/user_manual.md"
    items:
      - type: "constant"
        name: "getting_started_section"
        description: "Documentation section for initial setup and first use"
      
      - type: "constant"
        name: "features_section"
        description: "Documentation section covering all application features"
      
      - type: "constant"
        name: "troubleshooting_section"
        description: "Documentation section for common issues and solutions"
      
      - type: "constant"
        name: "keyboard_shortcuts_section"
        description: "Documentation section listing all keyboard shortcuts"
      
      - type: "constant"
        name: "settings_reference_section"
        description: "Documentation section describing all configuration options"

  - file: "docs/screenshots/.gitkeep"
    items:
      - type: "constant"
        name: "screenshots_directory"
        description: "Directory for storing documentation screenshots"

  - file: "tests/ui_tests.rs"
    items:
      - type: "module_declaration"
        name: "ui_tests"
        description: "User interface behavior tests"
      
      - type: "function"
        name: "test_navigation_between_screens"
        description: "Tests navigation flow between different UI screens"
        postconditions: "All screen transitions work correctly"
      
      - type: "function"
        name: "test_keyboard_shortcuts"
        description: "Tests all keyboard shortcuts perform expected actions"
        postconditions: "All shortcuts trigger correct behavior"
      
      - type: "function"
        name: "test_error_messages_display"
        description: "Tests error messages are displayed correctly to user"
        postconditions: "Error messages are clear and actionable"
      
      - type: "function"
        name: "test_progress_indicators"
        description: "Tests progress indicators update correctly during operations"
        postconditions: "Progress accurately reflects operation status"

  - file: "tests/data_integrity_tests.rs"
    items:
      - type: "module_declaration"
        name: "data_integrity_tests"
        description: "Tests for data consistency and integrity"
      
      - type: "function"
        name: "test_database_corruption_recovery"
        description: "Tests database can recover from corruption"
        postconditions: "Application handles corrupted database gracefully"
      
      - type: "function"
        name: "test_concurrent_writes"
        description: "Tests database handles concurrent write operations"
        postconditions: "No data loss or corruption under concurrent access"
      
      - type: "function"
        name: "test_transaction_atomicity"
        description: "Tests database transactions are atomic"
        invariants: "Either all changes commit or none do"
      
      - type: "function"
        name: "test_backup_and_restore"
        description: "Tests database backup and restore functionality"
        postconditions: "Restored data matches original exactly"

  - file: "tests/performance_tests.rs"
    items:
      - type: "module_declaration"
        name: "performance_tests"
        description: "Performance regression tests"
      
      - type: "function"
        name: "test_startup_time"
        description: "Tests application startup time is within acceptable limits"
        postconditions: "Application starts in < 2 seconds"
      
      - type: "function"
        name: "test_memory_usage"
        description: "Tests memory usage stays within bounds during operation"
        postconditions: "Memory usage < 100MB during normal operation"
      
      - type: "function"
        name: "test_large_deck_performance"
        description: "Tests performance with large card decks (10000+ cards)"
        postconditions: "Operations remain responsive with large datasets"

  - file: "src/coverage.rs"
    items:
      - type: "module_declaration"
        name: "coverage"
        description: "Code coverage tracking and reporting"
      
      - type: "function"
        name: "generate_coverage_report"
        description: "Generates coverage report from test runs"
        postconditions: "HTML and text coverage reports created"
      
      - type: "function"
        name: "check_coverage_threshold"
        description: "Verifies coverage meets minimum threshold"
        postconditions: "Returns error if coverage < 80%"

formal_verification:
  needed: false
  level: "None"
  explanation: |
    This task focuses on testing infrastructure, documentation, and build/release
    automation, which are not suitable candidates for formal verification. The
    components involved include:
    
    1. Integration tests - These are verification artifacts themselves, not
       production code requiring verification
    2. Benchmark suites - Performance measurement code that validates behavior
       empirically rather than formally
    3. User documentation - Human-readable content with no formal semantics
    4. Build configurations - Declarative TOML/packaging metadata without
       complex logic
    5. CI/CD pipeline definitions - Workflow orchestration without critical
       algorithmic properties
    
    None of these components exhibit the characteristics that benefit from formal
    verification (complex algorithms, safety-critical logic, intricate state
    machines, concurrent operations with subtle invariants). The SM-2 algorithm
    and statistics calculations that could benefit from property-based testing
    were already addressed in previous tasks (Tasks 2-4).
    
    Quality assurance for this task is better achieved through:
    - Running the test suite itself and measuring coverage
    - Manual review of documentation for completeness and accuracy
    - Testing release builds on target platforms
    - CI/CD validation that builds succeed and artifacts are produced
    
    The property-based tests mentioned in the task are for testing other
    components (SM-2 algorithm, statistics), not for verifying the test
    infrastructure itself. These are testing tools, not critical production
    logic requiring formal guarantees.

tests:
  strategy:
    approach: "mixed"
    rationale:
      - "Integration tests verify end-to-end workflows including complete learning sessions, practice modes, and data persistence"
      - "Property-based tests ensure SM-2 algorithm correctness across all valid inputs and verify statistical invariants"
      - "Unit tests cover individual components like database operations, animation rendering, and UI state management"
      - "Benchmark tests establish performance baselines for critical paths (60fps animation, <100ms DB operations)"
      - "Manual testing on clean VMs validates platform-specific installers and distribution packages"
      - "Comprehensive coverage (>80%) ensures production readiness and catches regressions"

  implementation:
    file: "tests/integration_tests.rs"
    location: "create new"
    code: |
      #[cfg(test)]
      mod integration_tests {
          use tempfile::TempDir;
          use std::path::PathBuf;
          use std::time::Duration;
          
          // Helper to create temporary test database
          fn setup_test_db() -> (TempDir, PathBuf) {
              let temp_dir = TempDir::new().unwrap();
              let db_path = temp_dir.path().join("test.db");
              (temp_dir, db_path)
          }

          #[test]
          fn test_complete_learning_session_workflow() {
              // Test full learning session: load character, draw, recognize, grade, save
              let (_temp, db_path) = setup_test_db();
              
              // Initialize database with test data
              // Create learning session
              // Simulate character drawing
              // Trigger recognition
              // Grade response (correct/incorrect)
              // Verify SM-2 scheduling updated
              // Verify statistics recorded
              // Verify data persisted to database
              
              assert!(db_path.exists());
              // Additional assertions for session state
          }

          #[test]
          fn test_practice_mode_workflow() {
              // Test practice mode: select characters, practice without grading, track attempts
              let (_temp, db_path) = setup_test_db();
              
              // Initialize practice mode
              // Simulate multiple character drawings
              // Verify no SM-2 updates (practice doesn't affect scheduling)
              // Verify practice statistics tracked separately
              // Verify session summary accurate
          }

          #[test]
          fn test_review_queue_scheduling() {
              // Test SM-2 review queue: characters appear at correct intervals
              let (_temp, db_path) = setup_test_db();
              
              // Create characters with known review dates (past, today, future)
              // Query review queue for today
              // Verify only due characters returned
              // Verify correct ordering (by priority/due date)
              // Simulate time passage and verify queue updates
          }

          #[test]
          fn test_animation_playback_sequence() {
              // Test stroke animation: correct order, timing, rendering
              
              // Load character with known stroke order
              // Start animation playback
              // Verify strokes animate in correct sequence
              // Verify timing between strokes
              // Verify pause/resume/reset functionality
              // Verify animation completion event
          }

          #[test]
          fn test_progress_statistics_aggregation() {
              // Test statistics: daily progress, success rates, streak tracking
              let (_temp, db_path) = setup_test_db();
              
              // Create test data: multiple sessions over several days
              // Query daily progress
              // Verify counts accurate (characters learned, reviewed, mastered)
              // Verify success rate calculations correct
              // Verify streak detection (consecutive days studied)
              // Test edge cases (gaps in study, perfect/zero success rates)
          }

          #[test]
          fn test_search_and_filter_characters() {
              // Test search: by reading, meaning, radical, HSK level
              let (_temp, db_path) = setup_test_db();
              
              // Populate database with diverse characters
              // Search by pinyin reading
              // Search by English meaning
              // Filter by HSK level
              // Filter by radical
              // Combine multiple filters
              // Verify result sets correct and complete
          }

          #[test]
          fn test_batch_import_export() {
              // Test data portability: export study data, import to new database
              let (_temp, db_path) = setup_test_db();
              let export_path = db_path.parent().unwrap().join("export.json");
              
              // Create study data (characters with SM-2 state, statistics)
              // Export to JSON file
              // Verify export file format valid
              // Create new empty database
              // Import from JSON file
              // Verify all data restored correctly
              // Verify SM-2 state preserved
          }

          #[test]
          fn test_concurrent_database_access() {
              // Test thread safety: multiple readers, write serialization
              let (_temp, db_path) = setup_test_db();
              
              use std::thread;
              use std::sync::Arc;
              
              // Create shared database connection pool
              // Spawn multiple reader threads
              // Spawn writer thread
              // Verify reads succeed concurrently
              // Verify writes don't corrupt data
              // Verify no deadlocks or race conditions
          }

          #[test]
          fn test_error_recovery_and_validation() {
              // Test error handling: corrupted data, missing files, invalid input
              let (_temp, db_path) = setup_test_db();
              
              // Test missing database file
              // Test corrupted database (invalid SQL)
              // Test invalid character data (malformed JSON)
              // Test out-of-bounds input (invalid HSK level)
              // Verify graceful error messages
              // Verify no data loss on recoverable errors
          }

          #[test]
          fn test_ui_state_persistence() {
              // Test UI state: window size, selected mode, filters persist across sessions
              let (_temp, db_path) = setup_test_db();
              
              // Set UI preferences (window size, theme, sort order)
              // Simulate application close
              // Reload application
              // Verify UI state restored correctly
              // Test default state for first launch
          }
      }

      #[cfg(test)]
      mod property_tests {
          use proptest::prelude::*;
          
          // SM-2 algorithm property tests
          proptest! {
              #[test]
              fn prop_sm2_interval_monotonically_increases_on_success(
                  easiness in 1.3f64..2.5f64,
                  interval in 1u32..365u32,
                  quality in 3u8..5u8
              ) {
                  // Property: Successful reviews (quality >= 3) never decrease interval
                  let new_interval = calculate_sm2_interval(easiness, interval, quality);
                  prop_assert!(new_interval >= interval);
              }

              #[test]
              fn prop_sm2_easiness_bounded(
                  initial_easiness in 1.3f64..2.5f64,
                  quality in 0u8..5u8
              ) {
                  // Property: Easiness factor stays within valid bounds [1.3, 2.5]
                  let new_easiness = update_sm2_easiness(initial_easiness, quality);
                  prop_assert!(new_easiness >= 1.3 && new_easiness <= 2.5);
              }

              #[test]
              fn prop_sm2_quality_zero_resets_interval(
                  easiness in 1.3f64..2.5f64,
                  interval in 1u32..365u32
              ) {
                  // Property: Quality 0-2 resets interval to 1
                  for quality in 0..3 {
                      let new_interval = calculate_sm2_interval(easiness, interval, quality);
                      prop_assert_eq!(new_interval, 1);
                  }
              }

              #[test]
              fn prop_statistics_percentage_valid(
                  correct in 0u32..1000u32,
                  total in 0u32..1000u32
              ) {
                  // Property: Success rate always between 0-100%
                  let total = total.max(correct); // Ensure total >= correct
                  let percentage = calculate_success_rate(correct, total);
                  prop_assert!(percentage >= 0.0 && percentage <= 100.0);
              }

              #[test]
              fn prop_stroke_recognition_invariant(
                  strokes in prop::collection::vec(any::<(f32, f32)>(), 2..100)
              ) {
                  // Property: Recognition confidence bounded [0.0, 1.0]
                  let confidence = recognize_stroke_sequence(&strokes);
                  prop_assert!(confidence >= 0.0 && confidence <= 1.0);
              }

              #[test]
              fn prop_animation_timing_consistent(
                  stroke_count in 1usize..20usize,
                  speed_multiplier in 0.5f32..2.0f32
              ) {
                  // Property: Total animation time = stroke_count * base_time / speed
                  let base_time = Duration::from_millis(500);
                  let total_time = calculate_animation_duration(stroke_count, speed_multiplier);
                  let expected = base_time.mul_f32(stroke_count as f32 / speed_multiplier);
                  let diff = if total_time > expected {
                      total_time - expected
                  } else {
                      expected - total_time
                  };
                  prop_assert!(diff < Duration::from_millis(10)); // Allow 10ms tolerance
              }

              #[test]
              fn prop_database_query_result_count(
                  hsk_level in 1u8..6u8
              ) {
                  // Property: Filtered results subset of total results
                  let all_chars = query_all_characters();
                  let filtered = query_by_hsk_level(hsk_level);
                  prop_assert!(filtered.len() <= all_chars.len());
              }
          }
      }

      #[cfg(test)]
      mod benchmark_tests {
          use criterion::{black_box, criterion_group, criterion_main, Criterion};
          use std::time::Duration;

          fn bench_animation_frame_rate(c: &mut Criterion) {
              // Benchmark: Animation rendering maintains 60fps (16.67ms per frame)
              c.bench_function("animation_render_frame", |b| {
                  let character = load_test_character();
                  b.iter(|| {
                      render_animation_frame(black_box(&character), black_box(0.5));
                  });
              });
              
              // Assert frame time < 16.67ms for 60fps
          }

          fn bench_database_batch_save(c: &mut Criterion) {
              // Benchmark: Batch database saves complete in <100ms
              c.bench_function("db_batch_save_100_chars", |b| {
                  let characters = generate_test_characters(100);
                  b.iter(|| {
                      batch_save_characters(black_box(&characters));
});
              });
          }

          fn bench_stroke_recognition_latency(c: &mut Criterion) {
              // Benchmark: Stroke recognition completes in <50ms for responsive UI
              c.bench_function("stroke_recognition", |b| {
                  let strokes = generate_test_strokes(8); // Average character has ~8 strokes
                  b.iter(|| {
                      recognize_character(black_box(&strokes));
                  });
              });
          }

          fn bench_search_query_performance(c: &mut Criterion) {
              // Benchmark: Search across 5000 characters in <20ms
              c.bench_function("search_5000_characters", |b| {
                  let query = "水"; // Common search term
                  b.iter(|| {
                      search_characters(black_box(query));
                  });
              });
          }

          fn bench_statistics_aggregation(c: &mut Criterion) {
              // Benchmark: Aggregate statistics for 30 days in <10ms
              c.bench_function("aggregate_30_day_stats", |b| {
                  let sessions = generate_test_sessions(30);
                  b.iter(|| {
                      aggregate_statistics(black_box(&sessions));
                  });
              });
          }

          criterion_group!(
              benches,
              bench_animation_frame_rate,
              bench_database_batch_save,
              bench_stroke_recognition_latency,
              bench_search_query_performance,
              bench_statistics_aggregation
          );
          criterion_main!(benches);
      }

      #[cfg(test)]
      mod unit_tests {
          use super::*;

          #[test]
          fn test_sm2_initial_scheduling() {
              // Unit: First review scheduled correctly (1 day, then 6 days)
              let card = create_new_card();
              assert_eq!(card.interval, 0);
              
              let card = grade_card(card, 4); // Good
              assert_eq!(card.interval, 1);
              
              let card = grade_card(card, 4); // Good again
              assert_eq!(card.interval, 6);
          }

          #[test]
          fn test_sm2_easiness_adjustment() {
              // Unit: Easiness factor adjusts based on quality
              let mut easiness = 2.5;
              
              easiness = update_easiness(easiness, 5); // Perfect
              assert!(easiness > 2.5);
              
              easiness = update_easiness(easiness, 0); // Total failure
              assert!(easiness < 2.5);
              assert!(easiness >= 1.3); // Lower bound
          }

          #[test]
          fn test_stroke_order_validation() {
              // Unit: Stroke order validation detects correct/incorrect sequences
              let correct_order = vec![1, 2, 3, 4];
              let incorrect_order = vec![1, 3, 2, 4];
              
              assert!(validate_stroke_order(&correct_order));
              assert!(!validate_stroke_order(&incorrect_order));
          }

          #[test]
          fn test_canvas_coordinate_normalization() {
              // Unit: Canvas coordinates normalized to [0.0, 1.0]
              let pixel_x = 400.0;
              let pixel_y = 300.0;
              let canvas_width = 800.0;
              let canvas_height = 600.0;
              
              let (norm_x, norm_y) = normalize_coordinates(pixel_x, pixel_y, canvas_width, canvas_height);
              
              assert_eq!(norm_x, 0.5);
              assert_eq!(norm_y, 0.5);
              assert!(norm_x >= 0.0 && norm_x <= 1.0);
              assert!(norm_y >= 0.0 && norm_y <= 1.0);
          }

          #[test]
          fn test_hsk_level_filtering() {
              // Unit: HSK level filter returns correct subset
              let all_chars = vec![
                  create_char("一", 1),
                  create_char("的", 1),
                  create_char("学", 2),
                  create_char("习", 2),
                  create_char("中", 1),
              ];
              
              let hsk1 = filter_by_hsk(&all_chars, 1);
              assert_eq!(hsk1.len(), 3);
              
              let hsk2 = filter_by_hsk(&all_chars, 2);
              assert_eq!(hsk2.len(), 2);
          }

          #[test]
          fn test_streak_calculation() {
              // Unit: Consecutive study day streak calculated correctly
              use chrono::NaiveDate;
              
              let dates = vec![
                  NaiveDate::from_ymd(2024, 1, 1),
                  NaiveDate::from_ymd(2024, 1, 2),
                  NaiveDate::from_ymd(2024, 1, 3),
                  // Gap on 1/4
                  NaiveDate::from_ymd(2024, 1, 5),
                  NaiveDate::from_ymd(2024, 1, 6),
              ];
              
              let streak = calculate_streak(&dates);
              assert_eq!(streak, 2); // Only last 2 consecutive days
          }

          #[test]
          fn test_success_rate_calculation() {
              // Unit: Success rate percentage calculated correctly
              assert_eq!(calculate_success_rate(0, 0), 0.0);
              assert_eq!(calculate_success_rate(10, 10), 100.0);
              assert_eq!(calculate_success_rate(7, 10), 70.0);
              assert_eq!(calculate_success_rate(1, 3), 33.33);
          }

          #[test]
          fn test_radical_decomposition() {
              // Unit: Character decomposed into correct radicals
              let char = "语"; // Language
              let radicals = decompose_to_radicals(char);
              
              assert!(radicals.contains(&"讠")); // Speech radical
              assert!(radicals.contains(&"五")); // Five component
              assert!(radicals.contains(&"口")); // Mouth component
          }

          #[test]
          fn test_json_serialization() {
              // Unit: Character data serializes/deserializes correctly
              let char = create_test_character("学", "study", "xué", 1);
              
              let json = serialize_character(&char).unwrap();
              let deserialized = deserialize_character(&json).unwrap();
              
              assert_eq!(char, deserialized);
          }

          #[test]
          fn test_database_transaction_rollback() {
              // Unit: Failed transactions rollback without data corruption
              let (_temp, db_path) = setup_test_db();
              
              let initial_count = count_characters(&db_path);
              
              // Attempt transaction that will fail
              let result = execute_failing_transaction(&db_path);
              assert!(result.is_err());
              
              // Verify count unchanged (rollback successful)
              let final_count = count_characters(&db_path);
              assert_eq!(initial_count, final_count);
          }

          #[test]
          fn test_animation_interpolation() {
              // Unit: Bezier curve interpolation smooth and accurate
              let p0 = Point { x: 0.0, y: 0.0 };
              let p1 = Point { x: 1.0, y: 1.0 };
              
              let mid = interpolate_bezier(p0, p1, 0.5);
              assert!((mid.x - 0.5).abs() < 0.01);
              assert!((mid.y - 0.5).abs() < 0.01);
              
              let start = interpolate_bezier(p0, p1, 0.0);
              assert_eq!(start, p0);
              
              let end = interpolate_bezier(p0, p1, 1.0);
              assert_eq!(end, p1);
          }

          #[test]
          fn test_config_file_parsing() {
              // Unit: Configuration file parsed correctly with defaults
              let config_str = r#"
                  theme = "dark"
                  animation_speed = 1.5
              "#;
              
              let config = parse_config(config_str).unwrap();
              assert_eq!(config.theme, "dark");
              assert_eq!(config.animation_speed, 1.5);
              assert_eq!(config.window_width, 800); // Default value
          }

          #[test]
          fn test_input_sanitization() {
              // Unit: User input sanitized to prevent injection
              let malicious = "'; DROP TABLE characters; --";
              let sanitized = sanitize_input(malicious);
              
              assert!(!sanitized.contains("DROP"));
              assert!(!sanitized.contains(";"));
              assert!(!sanitized.contains("--"));
          }
      }

      #[cfg(test)]
      mod release_validation_tests {
          // Tests specific to release build validation
          
          #[test]
          fn test_release_build_optimizations() {
              // Verify release profile settings applied correctly
              #[cfg(not(debug_assertions))]
              {
                  // This test only runs in release mode
                  // Verify LTO enabled, optimization level 3, debug symbols stripped
                  assert!(cfg!(not(debug_assertions)));
              }
          }

          #[test]
          fn test_default_database_creation() {
              // Verify fresh installation creates database correctly
              let home_dir = std::env::temp_dir();
              let app_dir = home_dir.join(".hanzi_learner");
              
              // Simulate first launch
              initialize_application(&app_dir).unwrap();
              
              assert!(app_dir.exists());
              assert!(app_dir.join("characters.db").exists());
              assert!(app_dir.join("config.toml").exists());
          }

          #[test]
          fn test_dependency_versions() {
              // Verify all dependencies compatible (no version conflicts)
              // This would typically be checked by CI/CD
              // Include runtime checks for critical dependencies
          }

          #[test]
          fn test_platform_specific_paths() {
              // Verify paths use platform-appropriate separators
              #[cfg(target_os = "windows")]
              {
                  let path = get_default_data_dir();
                  assert!(path.to_str().unwrap().contains("\\"));
              }
              
              #[cfg(not(target_os = "windows"))]
              {
                  let path = get_default_data_dir();
                  assert!(path.to_str().unwrap().contains("/"));
              }
          }
      }

  coverage:
    - "Complete learning session workflow (load, draw, recognize, grade, save)"
    - "Practice mode workflow without SM-2 scheduling updates"
    - "Review queue scheduling with SM-2 algorithm"
    - "Stroke animation playback sequence and timing"
    - "Progress statistics aggregation and calculations"
    - "Character search and filtering (reading, meaning, radical, HSK)"
    - "Batch import/export data portability"
    - "Concurrent database access and thread safety"
    - "Error recovery and input validation"
    - "UI state persistence across sessions"
    - "SM-2 interval monotonically increases on successful reviews"
    - "SM-2 easiness factor bounded within valid range [1.3, 2.5]"
    - "SM-2 interval resets to 1 on failed reviews (quality 0-2)"
    - "Statistics percentage always valid (0-100%)"
    - "Stroke recognition confidence bounded [0.0, 1.0]"
    - "Animation timing consistency with speed multipliers"
    - "Database query result count invariants"
    - "Animation rendering maintains 60fps (16.67ms per frame)"
    - "Database batch saves complete in <100ms"
    - "Stroke recognition latency <50ms for responsive UI"
    - "Search query across 5000 characters in <20ms"
    - "Statistics aggregation for 30 days in <10ms"
    - "SM-2 initial scheduling (1 day, then 6 days)"
    - "SM-2 easiness factor adjustment based on quality"
    - "Stroke order validation (correct/incorrect sequences)"
    - "Canvas coordinate normalization to [0.0, 1.0]"
    - "HSK level filtering returns correct subset"
    - "Consecutive study day streak calculation"
    - "Success rate percentage calculation with edge cases"
    - "Radical decomposition accuracy"
    - "JSON serialization/deserialization round-trip"
    - "Database transaction rollback on failure"
    - "Bezier curve interpolation smoothness"
    - "Configuration file parsing with defaults"
    - "User input sanitization prevents injection"
    - "Release build optimization settings"
    - "Fresh installation database creation"
    - "Dependency version compatibility"
    - "Platform-specific path handling (Windows/Unix)"
    - "Empty database initialization"
    - "Corrupted data handling"
    - "Missing file error recovery"
    - "Invalid character data validation"
    - "Out-of-bounds input handling"
    - "Window size persistence"
    - "Theme selection persistence"
    - "Sort order preservation"
    - "Filter state preservation"
    - "Multiple simultaneous readers"
    - "Write serialization without deadlocks"
    - "Race condition prevention"
    - "Animation pause/resume/reset functionality"
    - "Animation completion event triggering"
    - "Daily progress count accuracy"
    - "Success rate edge cases (0%, 100%, empty data)"
    - "Study streak with gaps detection"
    - "Export file format validation"
    - "Import data restoration completeness"
    - "SM-2 state preservation across export/import"
    - "Practice statistics tracked separately from learning"
    - "Review queue ordering by priority and due date"
    - "Time simulation for scheduled reviews"

dependencies:
  depends_on:
    - task_id: 1
      reason: "All features must be implemented before final testing"
    - task_id: 2
      reason: "All features must be implemented before final testing"
    - task_id: 3
      reason: "All features must be implemented before final testing"
    - task_id: 4
      reason: "All features must be implemented before final testing"
    - task_id: 5
      reason: "All features must be implemented before final testing"
    - task_id: 6
      reason: "All features must be implemented before final testing"
    - task_id: 7
      reason: "All features must be implemented before final testing"
    - task_id: 8
      reason: "All features must be implemented before final testing"
    - task_id: 9
      reason: "All features must be implemented before final testing"
    - task_id: 10
      reason: "All features must be implemented before final testing"
    - task_id: 11
      reason: "All features must be implemented before final testing"
    - task_id: 12
      reason: "All features must be implemented before final testing"
    - task_id: 13
      reason: "All features must be implemented before final testing"

  depended_upon_by: []

  external:
    - name: "tempfile"
      type: "crate"
      status: "to be imported"
    - name: "proptest"
      type: "crate"
      status: "to be imported"
    - name: "criterion"
      type: "crate"
      status: "to be imported"
    - name: "chrono"
      type: "crate"
      status: "already exists"
    - name: "serde_json"
      type: "crate"
      status: "already exists"
    - name: "cargo-bundle"
      type: "crate"
      status: "to be imported"
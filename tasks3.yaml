# Tasks Overview - Phase 4: Polish & Advanced Features
# Additional enhancement tasks beyond core MVP functionality
# Strategic roadmap for post-launch improvements

# =============================================================================
# PHASE 4: Polish, Export, and Advanced Learning Features
# =============================================================================

task:
  id: 13
  name: "Audio Pronunciation Integration"

  overview:
    purpose: |
      Add native Japanese pronunciation audio for each character, enabling users
      to hear correct pronunciation during flashcard reviews and practice sessions.
      Supports both passive listening and active pronunciation practice.

    motivation: |
      Proper pronunciation is essential for speaking Japanese correctly. Audio
      reinforcement helps build correct pronunciation habits from the beginning
      and provides multi-sensory learning that improves retention. Many learners
      struggle with pronunciation when relying on romanization alone.

    outcome: |
      Users can play audio pronunciation for any character, hear pronunciation
      automatically during reviews (optional), practice listening comprehension,
      and build correct pronunciation habits through repetition.

  scope_summary:
    description: "Integrates audio playback, manages audio assets, adds UI controls, implements auto-play settings"
    files_affected: 4
    functions_added: 10
    tests_required: 5
    complexity: "moderate"
    estimated_effort: "2 days"

  key_components:
    - component: "AudioPlayer"
      type: "struct"
      purpose: "Manages audio playback using rodio or similar"

    - component: "Audio asset loading"
      type: "function"
      purpose: "Loads embedded or external audio files"

    - component: "play_pronunciation"
      type: "function"
      purpose: "Plays audio for specific character"

    - component: "Auto-play settings"
      type: "struct"
      purpose: "User preferences for automatic pronunciation"

    - component: "Audio UI controls"
      type: "widget"
      purpose: "Speaker icon button on flashcards"

  implementation_hints:
    approach: |
      Use rodio crate for cross-platform audio playback. Embed pronunciation
      audio files (MP3/OGG) in binary using include_bytes!() for each character.
      Add speaker icon button to flashcard display. Implement optional auto-play
      on card reveal. Cache decoded audio to reduce latency on repeated plays.

    key_considerations:
      - "Audio files should be normalized to consistent volume"
      - "Support mute/unmute preference that persists"
      - "Auto-play should be optional and toggleable"
      - "Audio playback must not block UI thread"
      - "Consider female/male voice options if available"

    integration_points:
      - "Extends flashcard display (Task 2)"
      - "Integrates with learning session (Task 3)"
      - "Settings persist via database (Task 5)"

  testing_overview:
    strategy: "integration"

    rationale: |
      Audio playback requires integration testing to verify correct file loading,
      playback triggering, and settings persistence across platforms.

    critical_properties:
      - "Audio plays without blocking UI"
      - "Correct audio file matches displayed character"
      - "Settings persist across sessions"

    verification_needs:
      formal_verification: false
      property_testing: false
      concurrency_testing: false
      integration_testing: true

    estimated_test_count: 5

  dependencies:
    requires_completion_of:
      - task_id: 2
        reason: "Extends flashcard display"
      - task_id: 5
        reason: "Needs settings persistence"

    enables_start_of:
      - task_id: 14
        reason: "Audio quiz mode builds on pronunciation"

    parallel_with:
      - 15
      - 16

  acceptance_criteria:
    - "Audio plays correctly for all hiragana and katakana characters"
    - "Speaker button visible and functional on flashcards"
    - "Auto-play setting works and persists"
    - "No audio lag or UI blocking during playback"
    - "Volume normalization consistent across all audio files"

  risk_assessment:
    complexity_risk: "low"
    integration_risk: "low"
    testing_risk: "low"

    concerns:
      - "Audio file licensing must be verified (use free resources)"
      - "File size considerations for embedded audio"

  notes:
    - "Consider using Forvo API or similar for audio sources"
    - "OGG format provides good compression for embedded audio"

# =============================================================================

task:
  id: 14
  name: "Audio Quiz Mode"

  overview:
    purpose: |
      Create a listening comprehension quiz mode where users hear pronunciation
      and must identify the correct character from multiple choices. Develops
      listening skills and reinforces sound-character associations.

    motivation: |
      Listening comprehension is a distinct skill from reading recognition.
      Audio quizzes force users to rely on sound alone, building stronger
      pronunciation memory and preparing for real conversation scenarios where
      visual context may be limited.

    outcome: |
      Users can take audio-based quizzes, practice listening comprehension,
      strengthen sound-character associations, and track listening accuracy
      separately from reading accuracy.

  scope_summary:
    description: "Implements audio quiz mode, multiple-choice UI, distractor generation, listening-specific statistics"
    files_affected: 3
    functions_added: 12
    tests_required: 6
    complexity: "moderate"
    estimated_effort: "2 days"

  key_components:
    - component: "AudioQuizSession"
      type: "struct"
      purpose: "Manages audio quiz flow and state"

    - component: "generate_distractors"
      type: "function"
      purpose: "Creates similar-sounding wrong answers"

    - component: "Multiple choice UI"
      type: "module"
      purpose: "Displays 4 character options"

    - component: "Listening statistics"
      type: "struct"
      purpose: "Tracks audio quiz performance separately"

  implementation_hints:
    approach: |
      Select target character from due cards. Generate 3 phonetically similar
      distractors (e.g., for さ: ざ, た, ち). Play audio automatically on
      question load. Display 4 character options in randomized positions.
      Track listening accuracy separately from reading accuracy.

    key_considerations:
      - "Distractors should be phonetically similar (same vowel or consonant)"
      - "Randomize answer positions to prevent pattern recognition"
      - "Allow replay of audio without penalty"
      - "Visual feedback only after answer selection"
      - "Integrate with SRS but track separately"

    integration_points:
      - "Uses audio from Task 13"
      - "Uses SRS queue from Task 3"
      - "Statistics tracked separately (Task 6)"

  testing_overview:
    strategy: "unit"

    rationale: |
      Distractor generation and quiz logic are deterministic functions that
      can be thoroughly unit tested. UI flow requires manual verification.

    critical_properties:
      - "Distractors always phonetically similar to target"
      - "Correct answer always present in options"
      - "Answer positions randomized"

    verification_needs:
      formal_verification: false
      property_testing: true
      concurrency_testing: false
      integration_testing: false

    estimated_test_count: 6

  dependencies:
    requires_completion_of:
      - task_id: 13
        reason: "Requires audio pronunciation"
      - task_id: 3
        reason: "Uses SRS queue"

    enables_start_of: []

    parallel_with:
      - 15
      - 16

  acceptance_criteria:
    - "Audio plays automatically when quiz question loads"
    - "Four options display with randomized positions"
    - "Distractors are phonetically similar to target"
    - "Users can replay audio without penalty"
    - "Listening accuracy tracked separately from reading"

  risk_assessment:
    complexity_risk: "low"
    integration_risk: "low"
    testing_risk: "low"

    concerns:
      - "Distractor generation quality affects learning effectiveness"

  notes:
    - "Consider adding speed control for audio (0.75x, 1x, 1.25x)"
    - "Track attempts before correct answer for difficulty adjustment"

# =============================================================================

task:
  id: 15
  name: "Data Export and Backup System"

  overview:
    purpose: |
      Implement comprehensive data export functionality allowing users to backup
      their progress, export to CSV/JSON formats for external analysis, and
      import data from backups or other sources. Ensures data portability and
      user ownership.

    motivation: |
      Users invest significant time building their progress data. Export
      functionality provides peace of mind through backups, enables external
      analysis in spreadsheets, and supports data portability if users switch
      devices or want to share progress.

    outcome: |
      Users can export complete progress data, create backups for safekeeping,
      restore from previous backups, export statistics for external analysis,
      and migrate data between devices.

  scope_summary:
    description: "Implements export to multiple formats, backup/restore, import validation, file handling"
    files_affected: 4
    functions_added: 15
    tests_required: 10
    complexity: "moderate"
    estimated_effort: "2-3 days"

  key_components:
    - component: "export_to_csv"
      type: "function"
      purpose: "Exports card progress and review logs to CSV"

    - component: "export_to_json"
      type: "function"
      purpose: "Exports all data in structured JSON format"

    - component: "create_backup"
      type: "function"
      purpose: "Creates compressed backup archive"

    - component: "restore_from_backup"
      type: "function"
      purpose: "Validates and restores backup data"

    - component: "import_validation"
      type: "function"
      purpose: "Validates imported data integrity"

    - component: "Export UI screen"
      type: "module"
      purpose: "User interface for export/import operations"

  implementation_hints:
    approach: |
      Use serde for JSON serialization with schema versioning. Generate CSV
      using csv crate with headers. Create backups as gzipped tar archives
      (.tar.gz) containing database and settings. Use native file dialogs
      (rfd crate) for save/open operations. Implement validation to prevent
      corrupted imports.

    key_considerations:
      - "Include schema version in exports for future compatibility"
      - "Validate all imported data before applying"
      - "Provide option to merge or replace on import"
      - "Backup should include all settings and preferences"
      - "Compress backups to reduce file size"

    integration_points:
      - "Accesses database from Task 5"
      - "Exports statistics from Task 6"
      - "Backs up all user preferences and settings"

  testing_overview:
    strategy: "integration"

    rationale: |
      Export/import requires integration testing to verify round-trip data
      integrity, format correctness, and validation logic.

    critical_properties:
      - "Export → Import roundtrip preserves all data"
      - "CSV format valid and parseable by spreadsheet software"
      - "JSON schema versioning works correctly"
      - "Backup archives extract successfully"

    verification_needs:
      formal_verification: false
      property_testing: true
      concurrency_testing: false
      integration_testing: true

    estimated_test_count: 10

  dependencies:
    requires_completion_of:
      - task_id: 5
        reason: "Needs database access"
      - task_id: 6
        reason: "Exports statistics"

    enables_start_of: []

    parallel_with:
      - 13
      - 14
      - 16

  acceptance_criteria:
    - "CSV export opens correctly in Excel/Google Sheets"
    - "JSON export contains all progress data with schema version"
    - "Backup creates valid .tar.gz archive"
    - "Restore validates and applies backup data correctly"
    - "Import rejects invalid or corrupted data"
    - "File dialogs work on all platforms (Linux, macOS, Windows)"

  risk_assessment:
    complexity_risk: "low"
    integration_risk: "medium"
    testing_risk: "medium"

    concerns:
      - "Schema evolution requires migration logic for old exports"
      - "File dialog integration varies by platform"

  notes:
    - "Consider automatic backup scheduling (daily/weekly)"
    - "Cloud sync could be future enhancement"

# =============================================================================

task:
  id: 16
  name: "Customizable Themes and Accessibility"

  overview:
    purpose: |
      Implement theme system with light/dark modes, customizable color schemes,
      and accessibility features including font size controls, high contrast
      modes, and keyboard navigation. Ensures app is usable and comfortable
      for diverse users.

    motivation: |
      Accessibility is essential for inclusive design. Different users have
      different visual preferences and needs. Theme customization improves
      comfort during long study sessions, and accessibility features ensure
      the app is usable by people with visual impairments or motor limitations.

    outcome: |
      Users can choose light or dark themes, customize color schemes, adjust
      font sizes for readability, use high contrast modes for better visibility,
      and navigate entirely via keyboard without mouse.

  scope_summary:
    description: "Implements theme system, color scheme customization, font scaling, keyboard navigation, accessibility features"
    files_affected: 5
    functions_added: 18
    tests_required: 6
    complexity: "moderate"
    estimated_effort: "3 days"

  key_components:
    - component: "Theme"
      type: "struct"
      purpose: "Defines complete color scheme and styling"

    - component: "ThemeManager"
      type: "struct"
      purpose: "Manages theme switching and persistence"

    - component: "AccessibilitySettings"
      type: "struct"
      purpose: "Font size, contrast, animation preferences"

    - component: "Keyboard navigation"
      type: "module"
      purpose: "Hotkeys and focus management"

    - component: "Settings UI screen"
      type: "module"
      purpose: "User interface for customization"

  implementation_hints:
    approach: |
      Use iced's Theme trait to define custom themes. Create light/dark base
      themes plus high contrast variants. Implement font size multiplier that
      scales all text. Add keyboard shortcuts for common actions (space = flip
      card, 1-5 = ratings, n = next). Persist all preferences in database.
      Follow WCAG 2.1 AA standards for contrast ratios.

    key_considerations:
      - "Contrast ratios must meet WCAG AA (4.5:1 for text)"
      - "Keyboard navigation must reach all interactive elements"
      - "Font scaling should apply globally, not per-widget"
      - "Theme preview in settings before applying"
      - "Reduce motion option disables non-essential animations"

    integration_points:
      - "Themes apply to all UI screens"
      - "Settings persist via Task 5"
      - "Affects all visual components throughout app"

  testing_overview:
    strategy: "integration"

    rationale: |
      Theme and accessibility features require integration testing to verify
      consistent application across all screens and proper keyboard navigation.

    critical_properties:
      - "All text meets WCAG AA contrast requirements"
      - "Keyboard navigation reaches all interactive elements"
      - "Font scaling applies consistently"

    verification_needs:
      formal_verification: false
      property_testing: false
      concurrency_testing: false
      integration_testing: true

    estimated_test_count: 6

  dependencies:
    requires_completion_of:
      - task_id: 5
        reason: "Needs settings persistence"

    enables_start_of: []

    parallel_with:
      - 13
      - 14
      - 15

  acceptance_criteria:
    - "Light and dark themes work on all screens"
    - "High contrast mode meets WCAG AA standards"
    - "Font size adjustable from 80% to 150%"
    - "All interactive elements reachable via keyboard"
    - "Tab order logical and consistent"
    - "Reduce motion setting disables decorative animations"
    - "Theme preferences persist across sessions"

  risk_assessment:
    complexity_risk: "medium"
    integration_risk: "medium"
    testing_risk: "low"

    concerns:
      - "Ensuring contrast compliance across all themes requires testing"
      - "Keyboard navigation can be complex with custom widgets"

  notes:
    - "Consider color-blind friendly palettes"
    - "Screen reader support could be future enhancement"

# =============================================================================

task:
  id: 17
  name: "Study Session History and Analytics Dashboard"

  overview:
    purpose: |
      Create comprehensive analytics dashboard showing detailed study session
      history, time-series progress charts, heatmap calendar views, character-
      specific accuracy breakdowns, and predictive retention forecasts.

    motivation: |
      Detailed analytics help users understand their learning patterns, identify
      problem areas, and stay motivated through visible progress. Historical
      views enable reflection on improvement over time. Predictive analytics
      help users understand future review burden.

    outcome: |
      Users can view detailed session history, analyze learning trends over time,
      identify weak characters requiring more practice, see retention forecasts,
      and track improvement through visual charts.

  scope_summary:
    description: "Implements analytics dashboard, time-series charts, heatmap calendar, character breakdowns, retention predictions"
    files_affected: 4
    functions_added: 22
    tests_required: 8
    complexity: "complex"
    estimated_effort: "4 days"

  key_components:
    - component: "AnalyticsDashboard"
      type: "module"
      purpose: "Main analytics screen with multiple views"

    - component: "SessionHistory"
      type: "struct"
      purpose: "Historical session data aggregation"

    - component: "TimeSeriesChart"
      type: "widget"
      purpose: "Line/bar charts using plotters or similar"

    - component: "HeatmapCalendar"
      type: "widget"
      purpose: "GitHub-style contribution heatmap"

    - component: "CharacterBreakdown"
      type: "widget"
      purpose: "Per-character accuracy and interval data"

    - component: "RetentionPredictor"
      type: "function"
      purpose: "Forecasts future review burden"

  implementation_hints:
    approach: |
      Use plotters crate for charts (accuracy over time, reviews per day).
      Create custom Canvas widget for heatmap calendar showing study activity.
      Query database for aggregated statistics. Calculate per-character metrics
      from review logs. Use SRS intervals to predict upcoming review counts.
      Implement date range filters for historical analysis.

    key_considerations:
      - "Charts must be responsive and readable at different sizes"
      - "Aggregation queries should be efficient (use indexes)"
      - "Heatmap color scale should clearly show activity levels"
      - "Character breakdown should sort by weakest first"
      - "Retention forecast based on current SRS intervals"

    integration_points:
      - "Queries database from Task 5"
      - "Extends statistics from Task 6"
      - "Uses review history for predictions"

  testing_overview:
    strategy: "integration"

    rationale: |
      Analytics require integration with real data to verify correct
      aggregations, chart rendering, and prediction accuracy.

    critical_properties:
      - "Aggregations match raw review data"
      - "Charts render correctly with edge cases (no data, single point)"
      - "Retention predictions within reasonable error margin"

    verification_needs:
      formal_verification: false
      property_testing: false
      concurrency_testing: false
      integration_testing: true

    estimated_test_count: 8

  dependencies:
    requires_completion_of:
      - task_id: 5
        reason: "Needs review history database"
      - task_id: 6
        reason: "Extends statistics system"

    enables_start_of: []

    parallel_with:
      - 18

  acceptance_criteria:
    - "Dashboard displays all key metrics clearly"
    - "Time-series charts show accurate historical trends"
    - "Heatmap calendar displays study activity by day"
    - "Character breakdown shows weakest characters first"
    - "Retention forecast predicts review counts accurately"
    - "Date range filters work correctly"
    - "Charts responsive to window resizing"

  risk_assessment:
    complexity_risk: "high"
    integration_risk: "medium"
    testing_risk: "medium"

    concerns:
      - "Chart rendering performance with large datasets"
      - "plotters integration with iced may be complex"

  notes:
    - "Consider using plotters-iced integration if available"
    - "Export charts as images could be useful feature"

# =============================================================================

task:
  id: 18
  name: "Daily Goals and Gamification System"

  overview:
    purpose: |
      Implement daily study goals, achievement badges, XP/level system, and
      motivational notifications to increase user engagement and build
      consistent study habits through gamification psychology.

    motivation: |
      Gamification dramatically increases user engagement and habit formation.
      Daily goals create structure, achievements provide milestones, and
      leveling systems create sense of progression. These elements transform
      studying from obligation to rewarding activity.

    outcome: |
      Users set and track daily study goals, earn achievements for milestones,
      gain XP and levels through practice, receive motivational notifications,
      and feel rewarded for consistent study habits.

  scope_summary:
    description: "Implements goal system, achievements, XP/levels, badges, notifications, gamification UI"
    files_affected: 5
    functions_added: 25
    tests_required: 12
    complexity: "moderate"
    estimated_effort: "3-4 days"

  key_components:
    - component: "DailyGoal"
      type: "struct"
      purpose: "User-configurable daily review target"

    - component: "Achievement"
      type: "struct"
      purpose: "Unlockable badges with conditions"

    - component: "XPSystem"
      type: "module"
      purpose: "Experience points and leveling logic"

    - component: "NotificationSystem"
      type: "module"
      purpose: "Study reminders and achievement unlocks"

    - component: "BadgeDisplay"
      type: "widget"
      purpose: "Visual badge showcase"

  implementation_hints:
    approach: |
      Allow users to set daily goals (reviews/day, new cards/day, time/day).
      Track progress throughout day with visual indicators. Define achievement
      tree (first review, 7-day streak, 100 reviews, all hiragana mastered).
      Award XP for reviews (scaled by difficulty), level up every 1000 XP.
      Use OS notifications for reminders if enabled.

    key_considerations:
      - "Goals should be realistic and user-adjustable"
      - "XP rewards should scale: harder = more XP"
      - "Achievements unlock in logical progression"
      - "Notifications respect user preferences (opt-in)"
      - "Badge display encourages collection behavior"

    integration_points:
      - "Integrates with learning session (Task 3)"
      - "Uses statistics (Task 6)"
      - "Notifications via OS integration"

  testing_overview:
    strategy: "unit"

    rationale: |
      Goal tracking, XP calculation, and achievement conditions are
      deterministic logic that can be thoroughly unit tested.

    critical_properties:
      - "XP totals always increase (never decrease)"
      - "Achievement unlock conditions evaluate correctly"
      - "Daily goals reset at midnight local time"
      - "Level calculation consistent with XP formula"

    verification_needs:
      formal_verification: false
      property_testing: true
      concurrency_testing: false
      integration_testing: false

    estimated_test_count: 12

  dependencies:
    requires_completion_of:
      - task_id: 3
        reason: "Integrates with learning session"
      - task_id: 6
        reason: "Uses statistics for achievements"

    enables_start_of: []

    parallel_with:
      - 17

  acceptance_criteria:
    - "Daily goals configurable and track progress visually"
    - "Achievements unlock at correct milestones"
    - "XP system awards points for reviews accurately"
    - "Level increases at correct XP thresholds"
    - "Notifications trigger at appropriate times (if enabled)"
    - "Badge display shows earned and locked achievements"
    - "Goal progress resets daily at midnight"

  risk_assessment:
    complexity_risk: "low"
    integration_risk: "low"
    testing_risk: "low"

    concerns:
      - "Over-gamification could feel manipulative; balance is key"

  notes:
    - "Achievement ideas: 'First Steps', 'Week Warrior', 'Century Club', 'Perfect Week'"
    - "Consider social features (leaderboards) in future"

# =============================================================================

task:
  id: 19
  name: "Multiple Profile Support"

  overview:
    purpose: |
      Enable multiple user profiles within single application instance, allowing
      families or shared devices to maintain separate progress, settings, and
      statistics. Supports profile switching without data interference.

    motivation: |
      Multiple people may use the same device for learning. Separate profiles
      prevent progress mixing, maintain personalized settings, and enable
      fair comparison between learners. Essential for educational settings
      and family use.

    outcome: |
      Users can create multiple profiles, switch between profiles easily,
      maintain completely separate progress per profile, and customize settings
      independently for each profile.

  scope_summary:
    description: "Implements profile management, profile switcher, isolated data storage, profile-specific settings"
    files_affected: 5
    functions_added: 15
    tests_required: 10
    complexity: "moderate"
    estimated_effort: "3 days"

  key_components:
    - component: "UserProfile"
      type: "struct"
      purpose: "Profile metadata (name, avatar, created date)"

    - component: "ProfileManager"
      type: "struct"
      purpose: "Profile creation, deletion, switching"

    - component: "Profile selector UI"
      type: "module"
      purpose: "Profile selection screen at startup"

    - component: "Profile-scoped database"
      type: "function"
      purpose: "Isolates data per profile"

  implementation_hints:
    approach: |
      Store profiles in profiles.db with metadata. Use separate database
      files or namespaced tables per profile for isolation. Show profile
      selector at startup with create/select/delete options. Allow profile
      switching from settings without restarting app. Support profile avatars
      (emoji or initials).

    key_considerations:
      - "Complete data isolation between profiles critical"
      - "Profile switching must clear all session state"
      - "Profile deletion requires confirmation and cleanup"
      - "Active profile persists as last-used preference"
      - "Profile names must be unique"

    integration_points:
      - "Extends database from Task 5 with profile scoping"
      - "All features work per-profile"
      - "Settings isolated per profile"

  testing_overview:
    strategy: "integration"

    rationale: |
      Profile isolation requires integration testing to verify complete
      data separation and correct switching behavior.

    critical_properties:
      - "No data leakage between profiles"
      - "Profile switching clears all state"
      - "Profile deletion removes all associated data"

    verification_needs:
      formal_verification: false
      property_testing: false
      concurrency_testing: false
      integration_testing: true

    estimated_test_count: 10

  dependencies:
    requires_completion_of:
      - task_id: 5
        reason: "Extends database architecture"

    enables_start_of: []

    parallel_with:
      - 20

  acceptance_criteria:
    - "Users can create profiles with unique names"
    - "Profile selector appears at startup"
    - "Switching profiles completely isolates data"
    - "Profile deletion removes all associated progress"
    - "Last-used profile loads by default"
    - "Profile avatars display correctly"

  risk_assessment:
    complexity_risk: "medium"
    integration_risk: "high"
    testing_risk: "high"

    concerns:
      - "Data isolation bugs could corrupt or mix progress"
      - "Profile switching must handle edge cases cleanly"

  notes:
    - "Consider profile lock/password in future for privacy"
    - "Profile comparison/competition features possible"

# =============================================================================

task:
  id: 20
  name: "Comprehensive Settings and Preferences System"

  overview:
    purpose: |
      Create unified settings screen managing all user preferences including
      SRS parameters, daily limits, UI customization, audio settings, notification
      preferences, and advanced options. Provides centralized configuration.

    motivation: |
      As features accumulate, settings become fragmented without unified management.
      A comprehensive settings system gives users control over their experience,
      enables power users to fine-tune parameters, and makes preferences
      discoverable and manageable.

    outcome: |
      Users can configure all app behavior from centralized settings, customize
      SRS algorithm parameters, adjust UI and accessibility options, manage
      notifications and audio, and save presets for different study styles.

  scope_summary:
    description: "Implements settings UI, preference management, validation, presets, import/export settings"
    files_affected: 4
    functions_added: 20
    tests_required: 8
    complexity: "moderate"
    estimated_effort: "2-3 days"

  key_components:
    - component: "AppSettings"
      type: "struct"
      purpose: "Comprehensive settings model"

    - component: "SettingsScreen"
      type: "module"
      purpose: "Organized settings UI with categories"

    - component: "validate_settings"
      type: "function"
      purpose: "Ensures settings within valid ranges"

    - component: "SettingsPreset"
      type: "struct"
      purpose: "Predefined setting configurations"

    - component: "export_settings / import_settings"
      type: "functions"
      purpose: "Settings backup and sharing"

  implementation_hints:
    approach: |
      Organize settings into categories: Learning (SRS params, daily limits),
      UI (theme, font, animations), Audio (volume, auto-play), Notifications
      (reminders, achievements), Advanced (database location, debug). Validate
      all inputs (e.g., ease factor 1.3-2.5). Provide presets: "Conservative",
      "Balanced", "Aggressive" SRS settings. Export as JSON for sharing.

    key_considerations:
      - "Settings validation prevents invalid configurations"
      - "Changes apply immediately or on restart (clearly indicated)"
      - "Reset to defaults option for each category"
      - "Settings export enables sharing optimal configurations"
      - "Tooltips explain advanced parameters"

    integration_points:
      - "Affects all application modules"
      - "Persists via Task 5"
      - "Applies per-profile (Task 19)"

  testing_overview:
    strategy: "unit"

    rationale: |
      Settings validation and persistence are deterministic functions
      that can be thoroughly unit tested.

    critical_properties:
      - "Invalid settings rejected with clear errors"
      - "Settings persist and load correctly"
      - "Presets contain valid configurations"

    verification_needs:
      formal_verification: false
      property_testing: true
      concurrency_testing: false
      integration_testing: false

    estimated_test_count: 8

  dependencies:
    requires_completion_of:
      - task_id: 5
        reason: "Uses persistence layer"

    enables_start_of: []

    parallel_with:
      - 19

  acceptance_criteria:
    - "All settings accessible from unified screen"
    - "Settings organized logically by category"
    - "Input validation prevents invalid configurations"
    - "Presets apply correctly"
    - "Settings export/import works without data loss"
    - "Tooltips explain advanced options"
    - "Changes apply immediately or indicate restart needed"

  risk_assessment:
    complexity_risk: "low"
    integration_risk: "medium"
    testing_risk: "low"

    concerns:
      - "Settings sprawl can overwhelm users; good organization critical"

  notes:
    - "Consider search functionality for settings"
    - "Import settings from Anki decks could be future feature"

# =============================================================================
# END OF PHASE 4 TASKS
# =============================================================================

# =============================================================================
# SUMMARY
# =============================================================================

summary:
  total_tasks: 20
  total_estimated_days: "45-60 days"

  phases:
    phase_1_mvp:
      tasks: [1, 2, 3]
      description: "Foundation and core SRS functionality"
      estimated_days: "5-7 days"

    phase_2_core:
      tasks: [4, 5, 6, 7]
      description: "Essential features for complete learning experience"
      estimated_days: "9-12 days"

    phase_3_advanced:
      tasks: [8, 9, 10, 11, 12]
      description: "Advanced practice modes and algorithm optimization"
      estimated_days: "12-16 days"

    phase_4_polish:
      tasks: [13, 14, 15, 16, 17, 18, 19, 20]
      description: "Polish, accessibility, and engagement features"
      estimated_days: "19-25 days"

  critical_path:
    - "Task 1 → Task 2 → Task 3 (MVP foundation)"
    - "Task 3 → Task 5 (Persistence)"
    - "Task 4 → Task 8 → Task 9 → Task 10 (Practice progression)"
    - "Task 5 → Task 6 (Statistics)"

  parallel_opportunities:
    - "Tasks 4, 5, 6, 7 can be developed in parallel after Task 3"
    - "Tasks 13, 14, 15, 16 can be developed in parallel"
    - "Tasks 17, 18 can be developed in parallel"
    - "Tasks 19, 20 can be developed in parallel"

  risk_areas:
    high_risk:
      - "Task 9: Character recognition accuracy"
      - "Task 12: FSRS algorithm complexity"
      - "Task 17: Chart rendering performance"

    medium_risk:
      - "Task 4: Animation performance"
      - "Task 10: Practice mode integration"
      - "Task 19: Profile data isolation"

  optional_tasks:
    - task_id: 12
      reason: "FSRS migration only beneficial with large user base"

    - task_id: 14
      reason: "Audio quiz mode nice-to-have, not essential"

    - task_id: 17
      reason: "Advanced analytics can wait for v2.0"

  recommended_mvp:
    tasks: [1, 2, 3, 5, 6, 7]
    description: "Minimal viable product with SRS, both character sets, and persistence"
    estimated_days: "8-11 days"

  recommended_v1:
    tasks: [1, 2, 3, 4, 5, 6, 7, 8, 10, 11]
    description: "Full-featured v1.0 with practice modes and polish"
    estimated_days: "22-30 days"

# =============================================================================
# END OF FILE
# =============================================================================
